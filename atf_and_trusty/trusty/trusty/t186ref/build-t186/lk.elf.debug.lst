
t186ref/build-t186/lk.elf:     file format elf64-littleaarch64


Disassembly of section .text:

ffffffffea800000 <_start>:

.section .text.boot
FUNCTION(_start)
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    mrs     tmp, sctlr_el1
ffffffffea800000:	d5381009 	mrs	x9, sctlr_el1
    orr     tmp, tmp, #(1<<12) /* Enable icache */
ffffffffea800004:	b2740129 	orr	x9, x9, #0x1000
    orr     tmp, tmp, #(1<<2)  /* Enable dcache/ucache */
ffffffffea800008:	b27e0129 	orr	x9, x9, #0x4
    bic     tmp, tmp, #(1<<3)  /* Disable Stack Alignment Check */ /* TODO: don't use unaligned stacks */
ffffffffea80000c:	927cf929 	and	x9, x9, #0xfffffffffffffff7
    msr     sctlr_el1, tmp
ffffffffea800010:	d5181009 	msr	sctlr_el1, x9

    /* set up the mmu according to mmu_initial_mappings */

    /* load the base of the translation table and clear the table */
    adrp    page_table1, arm64_kernel_translation_table
ffffffffea800014:	f0000315 	adrp	x21, ffffffffea863000 <arm64_kernel_translation_table>
    add     page_table1, page_table1, #:lo12:arm64_kernel_translation_table
ffffffffea800018:	910002b5 	add	x21, x21, #0x0

    /* Prepare tt_trampoline page table */
    /* Calculate pagetable physical addresses */
    adrp    page_table0, tt_trampoline
ffffffffea80001c:	90000334 	adrp	x20, ffffffffea864000 <tt_trampoline>
    add     page_table0, page_table0, #:lo12:tt_trampoline
ffffffffea800020:	91000294 	add	x20, x20, #0x0

#if WITH_SMP
    mov     tmp, x0
ffffffffea800024:	aa0003e9 	mov	x9, x0
    mov     tmp2,x1
ffffffffea800028:	aa0103ea 	mov	x10, x1
    mov     tmp3,x2
ffffffffea80002c:	aa0203f0 	mov	x16, x2
    mov     tmp4,x3
ffffffffea800030:	aa0303f1 	mov	x17, x3
    /* NV: read cpuid by arch_curr_cpu_num */
    bl      arch_curr_cpu_num
ffffffffea800034:	94000aa7 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
    mov     cpuid, x0
ffffffffea800038:	aa0003f3 	mov	x19, x0
    mov     x3, tmp4
ffffffffea80003c:	aa1103e3 	mov	x3, x17
    mov     x2, tmp3
ffffffffea800040:	aa1003e2 	mov	x2, x16
    mov     x1, tmp2
ffffffffea800044:	aa0a03e1 	mov	x1, x10
    mov     x0, tmp
ffffffffea800048:	aa0903e0 	mov	x0, x9
    cbnz    cpuid, .Lmmu_enable_secondary
ffffffffea80004c:	b5000eb3 	cbnz	x19, ffffffffea800220 <_start+0x220>
#endif

    mov     tmp, #0
ffffffffea800050:	d2800009 	mov	x9, #0x0                   	// #0

    /* walk through all the entries in the translation table, setting them up */
.Lclear_top_page_table_loop:
    str     xzr, [page_table1, tmp, lsl #3]
ffffffffea800054:	f8297abf 	str	xzr, [x21, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea800058:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_KERNEL_PAGE_TABLE_ENTRIES_TOP
ffffffffea80005c:	f104013f 	cmp	x9, #0x100
    bne     .Lclear_top_page_table_loop
ffffffffea800060:	54ffffa1 	b.ne	ffffffffea800054 <_start+0x54>  // b.any

    /* load the address of the mmu_initial_mappings table and start processing */
    adrp    mmu_initial_mapping, mmu_initial_mappings
ffffffffea800064:	b00000d6 	adrp	x22, ffffffffea819000 <_mem_phys_base>
    add     mmu_initial_mapping, mmu_initial_mapping, #:lo12:mmu_initial_mappings
ffffffffea800068:	910062d6 	add	x22, x22, #0x18

.Linitial_mapping_loop:
    ldp     paddr, vaddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea80006c:	a9405ed8 	ldp	x24, x23, [x22]
    ldp     size, tmp, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800070:	a94126da 	ldp	x26, x9, [x22, #16]

    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DYNAMIC, .Lnot_dynamic
ffffffffea800074:	361800a9 	tbz	w9, #3, ffffffffea800088 <_start+0x88>
    adr     paddr, _start
ffffffffea800078:	10fffc58 	adr	x24, ffffffffea800000 <_start>
    mov     size, x0
ffffffffea80007c:	aa0003fa 	mov	x26, x0
    str     paddr, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_PHYS_OFFSET]
ffffffffea800080:	f90002d8 	str	x24, [x22]
    str     size, [mmu_initial_mapping, #__MMU_INITIAL_MAPPING_SIZE_OFFSET]
ffffffffea800084:	f9000ada 	str	x26, [x22, #16]

.Lnot_dynamic:
    /* if size == 0, end of list */
    cbz     size, .Linitial_mapping_done
ffffffffea800088:	b4000b3a 	cbz	x26, ffffffffea8001ec <_start+0x1ec>
    mov     mapping_size, size
ffffffffea80008c:	aa1a03f9 	mov	x25, x26

    /* set up the flags */
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_UNCACHED, .Lnot_uncached
ffffffffea800090:	36080069 	tbz	w9, #1, ffffffffea80009c <_start+0x9c>
    ldr     attr, =MMU_INITIAL_MAP_STRONGLY_ORDERED
ffffffffea800094:	580012fb 	ldr	x27, ffffffffea8002f0 <_start+0x2f0>
    b       .Lmem_type_done
ffffffffea800098:	14000013 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_uncached:
    tbzmask tmp, MMU_INITIAL_MAPPING_FLAG_DEVICE, .Lnot_device
ffffffffea80009c:	36100069 	tbz	w9, #2, ffffffffea8000a8 <_start+0xa8>
    ldr     attr, =MMU_INITIAL_MAP_DEVICE
ffffffffea8000a0:	580012db 	ldr	x27, ffffffffea8002f8 <_start+0x2f8>
    b       .Lmem_type_done
ffffffffea8000a4:	14000010 	b	ffffffffea8000e4 <_start+0xe4>
.Lnot_device:

.Lmapping_size_loop:
    ldr     attr, =MMU_PTE_KERNEL_RO_FLAGS
ffffffffea8000a8:	580012db 	ldr	x27, ffffffffea800300 <_start+0x300>
    ldr     tmp, =__rodata_start
ffffffffea8000ac:	580012e9 	ldr	x9, ffffffffea800308 <_start+0x308>
    subs    size, tmp, vaddr
ffffffffea8000b0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000b4:	54000188 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    orr     attr, attr, #MMU_PTE_ATTR_PXN
ffffffffea8000b8:	b24b037b 	orr	x27, x27, #0x20000000000000
    ldr     tmp, =__data_start
ffffffffea8000bc:	580012a9 	ldr	x9, ffffffffea800310 <_start+0x310>
    subs    size, tmp, vaddr
ffffffffea8000c0:	eb17013a 	subs	x26, x9, x23
    b.hi    .Lmem_type_done
ffffffffea8000c4:	54000108 	b.hi	ffffffffea8000e4 <_start+0xe4>  // b.pmore
    ldr     attr, =MMU_PTE_KERNEL_DATA_FLAGS
ffffffffea8000c8:	5800129b 	ldr	x27, ffffffffea800318 <_start+0x318>
    ldr     tmp, =_end
ffffffffea8000cc:	580012a9 	ldr	x9, ffffffffea800320 <_start+0x320>
    subs    size, tmp, vaddr
ffffffffea8000d0:	eb17013a 	subs	x26, x9, x23
    b.lo    . /* Error: _end < vaddr */
ffffffffea8000d4:	54000003 	b.cc	ffffffffea8000d4 <_start+0xd4>  // b.lo, b.ul, b.last
    cmp     mapping_size, size
ffffffffea8000d8:	eb1a033f 	cmp	x25, x26
    b.lo    . /* Error: mapping_size < size => RAM size too small for data/bss */
ffffffffea8000dc:	54000003 	b.cc	ffffffffea8000dc <_start+0xdc>  // b.lo, b.ul, b.last
    mov     size, mapping_size
ffffffffea8000e0:	aa1903fa 	mov	x26, x25

.Lmem_type_done:
    subs    mapping_size, mapping_size, size
ffffffffea8000e4:	eb1a0339 	subs	x25, x25, x26
    b.lo    . /* Error: mapping_size < size (RAM size too small for code/rodata?) */
ffffffffea8000e8:	54000003 	b.cc	ffffffffea8000e8 <_start+0xe8>  // b.lo, b.ul, b.last

    /* Check that paddr, vaddr and size are page aligned */
    orr     tmp, vaddr, paddr
ffffffffea8000ec:	aa1802e9 	orr	x9, x23, x24
    orr     tmp, tmp, size
ffffffffea8000f0:	aa1a0129 	orr	x9, x9, x26
    tst     tmp, #(1 << MMU_KERNEL_PAGE_SIZE_SHIFT) - 1
ffffffffea8000f4:	f2402d3f 	tst	x9, #0xfff
    bne     . /* Error: not page aligned */
ffffffffea8000f8:	54000001 	b.ne	ffffffffea8000f8 <_start+0xf8>  // b.any

    /* Clear top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea8000fc:	d2638af7 	eor	x23, x23, #0xffffffffe0000000

    /* Check that top bits were all set */
    tst     vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800100:	f2638aff 	tst	x23, #0xffffffffe0000000
    bne     . /* Error: vaddr out of range */
ffffffffea800104:	54000001 	b.ne	ffffffffea800104 <_start+0x104>  // b.any

.Lmap_range_top_loop:
    /* Select top level page table */
    mov     page_table, page_table1
ffffffffea800108:	aa1503ed 	mov	x13, x21
    mov     idx_shift, #MMU_KERNEL_TOP_SHIFT
ffffffffea80010c:	d28002ac 	mov	x12, #0x15                  	// #21

    lsr     idx, vaddr, idx_shift
ffffffffea800110:	9acc26eb 	lsr	x11, x23, x12

.Lmap_range_one_table_loop:
    /* Check if current level allow block descriptors */
    cmp     idx_shift, #MMU_PTE_DESCRIPTOR_BLOCK_MAX_SHIFT
ffffffffea800114:	f100799f 	cmp	x12, #0x1e
    b.hi    .Lmap_range_need_page_table
ffffffffea800118:	54000308 	b.hi	ffffffffea800178 <_start+0x178>  // b.pmore

    /* Check if paddr and vaddr alignment allows a block descriptor */
    orr     tmp2, vaddr, paddr
ffffffffea80011c:	aa1802ea 	orr	x10, x23, x24
    lsr     tmp, tmp2, idx_shift
ffffffffea800120:	9acc2549 	lsr	x9, x10, x12
    lsl     tmp, tmp, idx_shift
ffffffffea800124:	9acc2129 	lsl	x9, x9, x12
    cmp     tmp, tmp2
ffffffffea800128:	eb0a013f 	cmp	x9, x10
    b.ne    .Lmap_range_need_page_table
ffffffffea80012c:	54000261 	b.ne	ffffffffea800178 <_start+0x178>  // b.any

    /* Check if size is large enough for a block mapping */
    lsr     tmp, size, idx_shift
ffffffffea800130:	9acc2749 	lsr	x9, x26, x12
    cbz     tmp, .Lmap_range_need_page_table
ffffffffea800134:	b4000229 	cbz	x9, ffffffffea800178 <_start+0x178>

    /* Select descriptor type, page for level 3, block for level 0-2 */
    orr     tmp, attr, #MMU_PTE_L3_DESCRIPTOR_PAGE
ffffffffea800138:	b2400769 	orr	x9, x27, #0x3
    cmp     idx_shift, MMU_KERNEL_PAGE_SIZE_SHIFT
ffffffffea80013c:	f100319f 	cmp	x12, #0xc
    beq     .Lmap_range_l3
ffffffffea800140:	54000040 	b.eq	ffffffffea800148 <_start+0x148>  // b.none
    orr     tmp, attr, #MMU_PTE_L012_DESCRIPTOR_BLOCK
ffffffffea800144:	b2400369 	orr	x9, x27, #0x1
.Lmap_range_l3:

    /* Write page table entry */
    orr     tmp, tmp, paddr
ffffffffea800148:	aa180129 	orr	x9, x9, x24
    str     tmp, [page_table, idx, lsl #3]
ffffffffea80014c:	f82b79a9 	str	x9, [x13, x11, lsl #3]

    /* Move to next page table entry */
    mov     tmp, #1
ffffffffea800150:	d2800029 	mov	x9, #0x1                   	// #1
    lsl     tmp, tmp, idx_shift
ffffffffea800154:	9acc2129 	lsl	x9, x9, x12
    add     vaddr, vaddr, tmp
ffffffffea800158:	8b0902f7 	add	x23, x23, x9
    add     paddr, paddr, tmp
ffffffffea80015c:	8b090318 	add	x24, x24, x9
    subs    size, size, tmp
ffffffffea800160:	eb09035a 	subs	x26, x26, x9
    /* TODO: add local loop if next entry is in the same page table */
    b.ne    .Lmap_range_top_loop /* size != 0 */
ffffffffea800164:	54fffd21 	b.ne	ffffffffea800108 <_start+0x108>  // b.any

    /* Restore top bits of virtual address (should be all set) */
    eor     vaddr, vaddr, #(~0 << MMU_KERNEL_SIZE_SHIFT)
ffffffffea800168:	d2638af7 	eor	x23, x23, #0xffffffffe0000000
    /* Move to next subtype of ram mmu_initial_mappings entry */
    cbnz     mapping_size, .Lmapping_size_loop
ffffffffea80016c:	b5fff9f9 	cbnz	x25, ffffffffea8000a8 <_start+0xa8>

    /* Move to next mmu_initial_mappings entry */
    add     mmu_initial_mapping, mmu_initial_mapping, __MMU_INITIAL_MAPPING_SIZE
ffffffffea800170:	9100a2d6 	add	x22, x22, #0x28
    b       .Linitial_mapping_loop
ffffffffea800174:	17ffffbe 	b	ffffffffea80006c <_start+0x6c>

.Lmap_range_need_page_table:
    /* Check if page table entry is unused */
    ldr     new_page_table, [page_table, idx, lsl #3]
ffffffffea800178:	f86b79ae 	ldr	x14, [x13, x11, lsl #3]
    cbnz    new_page_table, .Lmap_range_has_page_table
ffffffffea80017c:	b500024e 	cbnz	x14, ffffffffea8001c4 <_start+0x1c4>

    /* Calculate phys offset (needed for memory allocation) */
.Lphys_offset:
    adr     phys_offset, .Lphys_offset /* phys */
ffffffffea800180:	1000000f 	adr	x15, ffffffffea800180 <_start+0x180>
    ldr     tmp, =.Lphys_offset /* virt */
ffffffffea800184:	58000d29 	ldr	x9, ffffffffea800328 <_start+0x328>
    sub     phys_offset, tmp, phys_offset
ffffffffea800188:	cb0f012f 	sub	x15, x9, x15

    /* Allocate new page table */
    calloc_bootmem_aligned new_page_table, tmp, tmp2, MMU_KERNEL_PAGE_SIZE_SHIFT, phys_offset
ffffffffea80018c:	b00000ca 	adrp	x10, ffffffffea819000 <_mem_phys_base>
ffffffffea800190:	f947814e 	ldr	x14, [x10, #3840]
ffffffffea800194:	913ffdce 	add	x14, x14, #0xfff
ffffffffea800198:	9274cdce 	and	x14, x14, #0xfffffffffffff000
ffffffffea80019c:	914005c9 	add	x9, x14, #0x1, lsl #12
ffffffffea8001a0:	f9078149 	str	x9, [x10, #3840]
ffffffffea8001a4:	cb0f01ce 	sub	x14, x14, x15
ffffffffea8001a8:	cb0f0129 	sub	x9, x9, x15
ffffffffea8001ac:	aa0e03ea 	mov	x10, x14
ffffffffea8001b0:	a8817d5f 	stp	xzr, xzr, [x10], #16
ffffffffea8001b4:	eb09015f 	cmp	x10, x9
ffffffffea8001b8:	54ffffc3 	b.cc	ffffffffea8001b0 <_start+0x1b0>  // b.lo, b.ul, b.last

    /* Write page table entry (with allocated page table) */
    orr     new_page_table, new_page_table, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001bc:	b24005ce 	orr	x14, x14, #0x3
    str     new_page_table, [page_table, idx, lsl #3]
ffffffffea8001c0:	f82b79ae 	str	x14, [x13, x11, lsl #3]

.Lmap_range_has_page_table:
    /* Check descriptor type */
    and     tmp, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001c4:	924005c9 	and	x9, x14, #0x3
    cmp     tmp, #MMU_PTE_L012_DESCRIPTOR_TABLE
ffffffffea8001c8:	f1000d3f 	cmp	x9, #0x3
    b.ne    . /* Error: entry already in use (as a block entry) */
ffffffffea8001cc:	54000001 	b.ne	ffffffffea8001cc <_start+0x1cc>  // b.any

    /* switch to next page table level */
    bic     page_table, new_page_table, #MMU_PTE_DESCRIPTOR_MASK
ffffffffea8001d0:	927ef5cd 	and	x13, x14, #0xfffffffffffffffc
    mov     tmp, #~0
ffffffffea8001d4:	92800009 	mov	x9, #0xffffffffffffffff    	// #-1
    lsl     tmp, tmp, idx_shift
ffffffffea8001d8:	9acc2129 	lsl	x9, x9, x12
    bic     tmp, vaddr, tmp
ffffffffea8001dc:	8a2902e9 	bic	x9, x23, x9
    sub     idx_shift, idx_shift, #(MMU_KERNEL_PAGE_SIZE_SHIFT - 3)
ffffffffea8001e0:	d100258c 	sub	x12, x12, #0x9
    lsr     idx, tmp, idx_shift
ffffffffea8001e4:	9acc252b 	lsr	x11, x9, x12

    b       .Lmap_range_one_table_loop
ffffffffea8001e8:	17ffffcb 	b	ffffffffea800114 <_start+0x114>
.Linitial_mapping_done:

    /* Prepare tt_trampoline page table */

    /* Zero tt_trampoline translation tables */
    mov     tmp, #0
ffffffffea8001ec:	d2800009 	mov	x9, #0x0                   	// #0
.Lclear_tt_trampoline:
    str     xzr, [page_table0, tmp, lsl#3]
ffffffffea8001f0:	f8297a9f 	str	xzr, [x20, x9, lsl #3]
    add     tmp, tmp, #1
ffffffffea8001f4:	91000529 	add	x9, x9, #0x1
    cmp     tmp, #MMU_PAGE_TABLE_ENTRIES_IDENT
ffffffffea8001f8:	f108013f 	cmp	x9, #0x200
    blt     .Lclear_tt_trampoline
ffffffffea8001fc:	54ffffab 	b.lt	ffffffffea8001f0 <_start+0x1f0>  // b.tstop

    /* Setup mapping at phys -> phys */
    adr     tmp, .Lmmu_on_pc
ffffffffea800200:	10000329 	adr	x9, ffffffffea800264 <_start+0x264>
    lsr     tmp, tmp, #MMU_IDENT_TOP_SHIFT    /* tmp = paddr index */
ffffffffea800204:	d35efd29 	lsr	x9, x9, #30
    ldr     tmp2, =MMU_PTE_IDENT_FLAGS
ffffffffea800208:	5800094a 	ldr	x10, ffffffffea800330 <_start+0x330>
    add     tmp2, tmp2, tmp, lsl #MMU_IDENT_TOP_SHIFT  /* tmp2 = pt entry */
ffffffffea80020c:	8b09794a 	add	x10, x10, x9, lsl #30

    str     tmp2, [page_table0, tmp, lsl #3]     /* tt_trampoline[paddr index] = pt entry */
ffffffffea800210:	f8297a8a 	str	x10, [x20, x9, lsl #3]

#if WITH_SMP
    adr     tmp, page_tables_not_ready
ffffffffea800214:	100c7c69 	adr	x9, ffffffffea8191a0 <page_tables_not_ready>
    str     wzr, [tmp]
ffffffffea800218:	b900013f 	str	wzr, [x9]
    b       .Lpage_tables_ready
ffffffffea80021c:	14000004 	b	ffffffffea80022c <_start+0x22c>

.Lmmu_enable_secondary:
    adr     tmp, page_tables_not_ready
ffffffffea800220:	100c7c09 	adr	x9, ffffffffea8191a0 <page_tables_not_ready>
.Lpage_tables_not_ready:
    ldr     wtmp2, [tmp]
ffffffffea800224:	b940012a 	ldr	w10, [x9]
    cbnz    wtmp2, .Lpage_tables_not_ready
ffffffffea800228:	35ffffea 	cbnz	w10, ffffffffea800224 <_start+0x224>
#endif

    /* set up the mmu */

    /* Invalidate TLB */
    tlbi    vmalle1is
ffffffffea80022c:	d508831f 	tlbi	vmalle1is
    isb
ffffffffea800230:	d5033fdf 	isb
    dsb     sy
ffffffffea800234:	d5033f9f 	dsb	sy

    /* Initialize Memory Attribute Indirection Register */
    ldr     tmp, =MMU_MAIR_VAL
ffffffffea800238:	58000809 	ldr	x9, ffffffffea800338 <_start+0x338>
    msr     mair_el1, tmp
ffffffffea80023c:	d518a209 	msr	mair_el1, x9

    /* Initialize TCR_EL1 */
    /* set cacheable attributes on translation walk */
    /* (SMP extensions) non-shareable, inner write-back write-allocate */
    ldr     tmp, =MMU_TCR_FLAGS_IDENT
ffffffffea800240:	58000809 	ldr	x9, ffffffffea800340 <_start+0x340>
    msr     tcr_el1, tmp
ffffffffea800244:	d5182049 	msr	tcr_el1, x9

    isb
ffffffffea800248:	d5033fdf 	isb

    /* Write ttbr with phys addr of the translation table */
    msr     ttbr0_el1, page_table0
ffffffffea80024c:	d5182014 	msr	ttbr0_el1, x20
    msr     ttbr1_el1, page_table1
ffffffffea800250:	d5182035 	msr	ttbr1_el1, x21
    isb
ffffffffea800254:	d5033fdf 	isb

    /* Read SCTLR */
    mrs     tmp, sctlr_el1
ffffffffea800258:	d5381009 	mrs	x9, sctlr_el1

    /* Turn on the MMU */
    orr     tmp, tmp, #0x1
ffffffffea80025c:	b2400129 	orr	x9, x9, #0x1

    /* Write back SCTLR */
    msr     sctlr_el1, tmp
ffffffffea800260:	d5181009 	msr	sctlr_el1, x9
.Lmmu_on_pc:
    isb
ffffffffea800264:	d5033fdf 	isb

    /* Jump to virtual code address */
    ldr     tmp, =.Lmmu_on_vaddr
ffffffffea800268:	58000709 	ldr	x9, ffffffffea800348 <_start+0x348>
    br      tmp
ffffffffea80026c:	d61f0120 	br	x9

.Lmmu_on_vaddr:

    /* Disable trampoline page-table in ttbr0 */
    ldr     tmp, =MMU_TCR_FLAGS_KERNEL
ffffffffea800270:	58000709 	ldr	x9, ffffffffea800350 <_start+0x350>
    msr     tcr_el1, tmp
ffffffffea800274:	d5182049 	msr	tcr_el1, x9
    isb
ffffffffea800278:	d5033fdf 	isb


    /* Invalidate TLB */
    tlbi    vmalle1
ffffffffea80027c:	d508871f 	tlbi	vmalle1
    isb
ffffffffea800280:	d5033fdf 	isb

#if WITH_SMP
    cbnz    cpuid, .Lsecondary_boot
ffffffffea800284:	b5000193 	cbnz	x19, ffffffffea8002b4 <_start+0x2b4>
#endif
#endif /* WITH_KERNEL_VM */

    ldr tmp, =__stack_end
ffffffffea800288:	58000689 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov sp, tmp
ffffffffea80028c:	9100013f 	mov	sp, x9

    /* clear bss */
.L__do_bss:
    /* clear out the bss */
    /* NOTE: relies on __bss_start and __bss_end being 8 byte aligned */
    ldr     tmp, =__bss_start
ffffffffea800290:	58000689 	ldr	x9, ffffffffea800360 <_start+0x360>
    ldr     tmp2, =__bss_end
ffffffffea800294:	580006aa 	ldr	x10, ffffffffea800368 <_start+0x368>
    sub     tmp2, tmp2, tmp
ffffffffea800298:	cb09014a 	sub	x10, x10, x9
    cbz     tmp2, .L__bss_loop_done
ffffffffea80029c:	b400008a 	cbz	x10, ffffffffea8002ac <_start+0x2ac>
.L__bss_loop:
    sub     tmp2, tmp2, #8
ffffffffea8002a0:	d100214a 	sub	x10, x10, #0x8
    str     xzr, [tmp], #8
ffffffffea8002a4:	f800853f 	str	xzr, [x9], #8
    cbnz    tmp2, .L__bss_loop
ffffffffea8002a8:	b5ffffca 	cbnz	x10, ffffffffea8002a0 <_start+0x2a0>
.L__bss_loop_done:

    bl  lk_main
ffffffffea8002ac:	94000efb 	bl	ffffffffea803e98 <lk_main>
    b   .
ffffffffea8002b0:	14000000 	b	ffffffffea8002b0 <_start+0x2b0>

#if WITH_SMP
.Lsecondary_boot:
    and     tmp, cpuid, #0xff
ffffffffea8002b4:	92401e69 	and	x9, x19, #0xff
    cmp     tmp, #(1 << SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002b8:	f104013f 	cmp	x9, #0x100
    bge     .Lunsupported_cpu_trap
ffffffffea8002bc:	5400016a 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont
    bic     cpuid, cpuid, #0xff
ffffffffea8002c0:	9278de73 	and	x19, x19, #0xffffffffffffff00
    orr     cpuid, tmp, cpuid, LSR #(8 - SMP_CPU_CLUSTER_SHIFT)
ffffffffea8002c4:	aa530133 	orr	x19, x9, x19, lsr #0

    cmp     cpuid, #SMP_MAX_CPUS
ffffffffea8002c8:	f100227f 	cmp	x19, #0x8
    bge     .Lunsupported_cpu_trap
ffffffffea8002cc:	540000ea 	b.ge	ffffffffea8002e8 <_start+0x2e8>  // b.tcont

    /* Set up the stack */
    ldr     tmp, =__stack_end
ffffffffea8002d0:	58000449 	ldr	x9, ffffffffea800358 <_start+0x358>
    mov     tmp2, #ARCH_DEFAULT_STACK_SIZE
ffffffffea8002d4:	d282000a 	mov	x10, #0x1000                	// #4096
    mul     tmp2, tmp2, cpuid
ffffffffea8002d8:	9b137d4a 	mul	x10, x10, x19
    sub     sp, tmp, tmp2
ffffffffea8002dc:	cb2a613f 	sub	sp, x9, x10

    mov     x0, cpuid
ffffffffea8002e0:	aa1303e0 	mov	x0, x19
    bl      arm64_secondary_entry
ffffffffea8002e4:	94000a21 	bl	ffffffffea802b68 <arm64_secondary_entry>

.Lunsupported_cpu_trap:
    wfe
ffffffffea8002e8:	d503205f 	wfe
    b       .Lunsupported_cpu_trap
ffffffffea8002ec:	17ffffff 	b	ffffffffea8002e8 <_start+0x2e8>
ffffffffea8002f0:	00000400 	.word	0x00000400
ffffffffea8002f4:	00600000 	.word	0x00600000
ffffffffea8002f8:	00000404 	.word	0x00000404
ffffffffea8002fc:	00600000 	.word	0x00600000
ffffffffea800300:	00000788 	.word	0x00000788
ffffffffea800304:	00400000 	.word	0x00400000
ffffffffea800308:	ea816000 	.word	0xea816000
ffffffffea80030c:	ffffffff 	.word	0xffffffff
ffffffffea800310:	ea819000 	.word	0xea819000
ffffffffea800314:	ffffffff 	.word	0xffffffff
ffffffffea800318:	00000708 	.word	0x00000708
ffffffffea80031c:	00600000 	.word	0x00600000
ffffffffea800320:	ea873128 	.word	0xea873128
ffffffffea800324:	ffffffff 	.word	0xffffffff
ffffffffea800328:	ea800180 	.word	0xea800180
ffffffffea80032c:	ffffffff 	.word	0xffffffff
ffffffffea800330:	00000709 	.word	0x00000709
ffffffffea800334:	00000000 	.word	0x00000000
ffffffffea800338:	00ff0400 	.word	0x00ff0400
ffffffffea80033c:	00000000 	.word	0x00000000
ffffffffea800340:	b5233519 	.word	0xb5233519
ffffffffea800344:	00000002 	.word	0x00000002
ffffffffea800348:	ea800270 	.word	0xea800270
ffffffffea80034c:	ffffffff 	.word	0xffffffff
ffffffffea800350:	b52335a7 	.word	0xb52335a7
ffffffffea800354:	00000002 	.word	0x00000002
ffffffffea800358:	ea86d000 	.word	0xea86d000
ffffffffea80035c:	ffffffff 	.word	0xffffffff
ffffffffea800360:	ea86d000 	.word	0xea86d000
ffffffffea800364:	ffffffff 	.word	0xffffffff
ffffffffea800368:	ea873128 	.word	0xea873128
ffffffffea80036c:	ffffffff 	.word	0xffffffff
	...

ffffffffea801000 <arm64_exception_base>:

FUNCTION(arm64_exception_base)

/* exceptions from current EL, using SP0 */
LOCAL_FUNCTION(arm64_sync_exc_current_el_SP0)
    invalid_exception 0
ffffffffea801000:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801004:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801008:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80100c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801010:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801014:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801018:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80101c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801020:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801024:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801028:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80102c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801030:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801034:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801038:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80103c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801040:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801044:	d5384021 	mrs	x1, elr_el1
ffffffffea801048:	d5384002 	mrs	x2, spsr_el1
ffffffffea80104c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801050:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801054:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea801058:	910003e0 	mov	x0, sp
ffffffffea80105c:	94000781 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea801060:	14000000 	b	ffffffffea801060 <arm64_exception_base+0x60>
	...

ffffffffea801080 <arm64_irq_current_el_SP0>:

.org 0x080
LOCAL_FUNCTION(arm64_irq_current_el_SP0)
    invalid_exception 1
ffffffffea801080:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801084:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801088:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80108c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801090:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801094:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801098:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80109c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8010a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8010a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8010a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8010ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8010b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8010b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8010b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8010bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8010c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8010c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8010c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8010cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8010d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8010d4:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8010d8:	910003e0 	mov	x0, sp
ffffffffea8010dc:	94000761 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8010e0:	14000000 	b	ffffffffea8010e0 <arm64_irq_current_el_SP0+0x60>
	...

ffffffffea801100 <arm64_fiq_current_el_SP0>:

.org 0x100
LOCAL_FUNCTION(arm64_fiq_current_el_SP0)
    invalid_exception 2
ffffffffea801100:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801104:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801108:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80110c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801110:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801114:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801118:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80111c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801120:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801124:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801128:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80112c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801130:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801134:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801138:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80113c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801140:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801144:	d5384021 	mrs	x1, elr_el1
ffffffffea801148:	d5384002 	mrs	x2, spsr_el1
ffffffffea80114c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801150:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801154:	d2800041 	mov	x1, #0x2                   	// #2
ffffffffea801158:	910003e0 	mov	x0, sp
ffffffffea80115c:	94000741 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea801160:	14000000 	b	ffffffffea801160 <arm64_fiq_current_el_SP0+0x60>
	...

ffffffffea801180 <arm64_err_exc_current_el_SP0>:

.org 0x180
LOCAL_FUNCTION(arm64_err_exc_current_el_SP0)
    invalid_exception 3
ffffffffea801180:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801184:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801188:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80118c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801190:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801194:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801198:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80119c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8011a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8011a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8011a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8011ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8011b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8011b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8011b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8011bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8011c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8011c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8011c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8011cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8011d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8011d4:	d2800061 	mov	x1, #0x3                   	// #3
ffffffffea8011d8:	910003e0 	mov	x0, sp
ffffffffea8011dc:	94000721 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8011e0:	14000000 	b	ffffffffea8011e0 <arm64_err_exc_current_el_SP0+0x60>
	...

ffffffffea801200 <arm64_sync_exc_current_el_SPx>:

/* exceptions from current EL, using SPx */
.org 0x200
LOCAL_FUNCTION(arm64_sync_exc_current_el_SPx)
    regsave_long
ffffffffea801200:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801204:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801208:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80120c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801210:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801214:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801218:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80121c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801220:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801224:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801228:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80122c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801230:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801234:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801238:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80123c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801240:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801244:	d5384021 	mrs	x1, elr_el1
ffffffffea801248:	d5384002 	mrs	x2, spsr_el1
ffffffffea80124c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801250:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801254:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801258:	940006a8 	bl	ffffffffea802cf8 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80125c:	14000162 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801280 <arm64_irq_current_el_SPx>:

.org 0x280
LOCAL_FUNCTION(arm64_irq_current_el_SPx)
    irq_exception
ffffffffea801280:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801284:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801288:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80128c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801290:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801294:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801298:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80129c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8012a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8012a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8012a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8012ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8012b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8012b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8012b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8012bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8012c0:	910003e0 	mov	x0, sp
ffffffffea8012c4:	94000d5f 	bl	ffffffffea804840 <platform_irq>
ffffffffea8012c8:	b4000040 	cbz	x0, ffffffffea8012d0 <arm64_irq_current_el_SPx+0x50>
ffffffffea8012cc:	9400141b 	bl	ffffffffea806338 <thread_preempt>
ffffffffea8012d0:	d50341df 	msr	daifset, #0x1
ffffffffea8012d4:	1400015b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801300 <arm64_fiq_current_el_SPx>:

.org 0x300
LOCAL_FUNCTION(arm64_fiq_current_el_SPx)
    regsave_short
ffffffffea801300:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801304:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801308:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80130c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801310:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801314:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801318:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80131c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801320:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801324:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801328:	910243e0 	add	x0, sp, #0x90
ffffffffea80132c:	d5384021 	mrs	x1, elr_el1
ffffffffea801330:	d5384002 	mrs	x2, spsr_el1
ffffffffea801334:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801338:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80133c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801340:	94000da6 	bl	ffffffffea8049d8 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801344:	1400013f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801380 <arm64_err_exc_current_el_SPx>:

.org 0x380
LOCAL_FUNCTION(arm64_err_exc_current_el_SPx)
    invalid_exception 0x13
ffffffffea801380:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801384:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801388:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80138c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801390:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801394:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801398:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80139c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8013a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8013a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8013a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8013ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8013b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8013b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8013b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8013bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8013c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8013c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8013c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8013cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8013d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8013d4:	d2800261 	mov	x1, #0x13                  	// #19
ffffffffea8013d8:	910003e0 	mov	x0, sp
ffffffffea8013dc:	940006a1 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8013e0:	14000000 	b	ffffffffea8013e0 <arm64_err_exc_current_el_SPx+0x60>
	...

ffffffffea801400 <arm64_sync_exc_lower_el_64>:

/* exceptions from lower EL, running arm64 */
.org 0x400
LOCAL_FUNCTION(arm64_sync_exc_lower_el_64)
    invalid_exception 0x20
ffffffffea801400:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801404:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801408:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80140c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801410:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801414:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801418:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80141c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801420:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801424:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801428:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80142c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801430:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801434:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801438:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80143c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801440:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801444:	d5384021 	mrs	x1, elr_el1
ffffffffea801448:	d5384002 	mrs	x2, spsr_el1
ffffffffea80144c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801450:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801454:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea801458:	910003e0 	mov	x0, sp
ffffffffea80145c:	94000681 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea801460:	14000000 	b	ffffffffea801460 <arm64_sync_exc_lower_el_64+0x60>
	...

ffffffffea801480 <arm64_irq_lower_el_64>:

.org 0x480
LOCAL_FUNCTION(arm64_irq_lower_el_64)
    invalid_exception 0x21
ffffffffea801480:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801484:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801488:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80148c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801490:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801494:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801498:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80149c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8014a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8014a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8014a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8014ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8014b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8014b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8014b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8014bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8014c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8014c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8014c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8014cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8014d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8014d4:	d2800421 	mov	x1, #0x21                  	// #33
ffffffffea8014d8:	910003e0 	mov	x0, sp
ffffffffea8014dc:	94000661 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8014e0:	14000000 	b	ffffffffea8014e0 <arm64_irq_lower_el_64+0x60>
	...

ffffffffea801500 <arm64_fiq_lower_el_64>:

.org 0x500
LOCAL_FUNCTION(arm64_fiq_lower_el_64)
    invalid_exception 0x22
ffffffffea801500:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801504:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801508:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80150c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801510:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801514:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801518:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80151c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801520:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801524:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801528:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80152c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801530:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801534:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801538:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80153c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801540:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801544:	d5384021 	mrs	x1, elr_el1
ffffffffea801548:	d5384002 	mrs	x2, spsr_el1
ffffffffea80154c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801550:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea801554:	d2800441 	mov	x1, #0x22                  	// #34
ffffffffea801558:	910003e0 	mov	x0, sp
ffffffffea80155c:	94000641 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea801560:	14000000 	b	ffffffffea801560 <arm64_fiq_lower_el_64+0x60>
	...

ffffffffea801580 <arm64_err_exc_lower_el_64>:

.org 0x580
LOCAL_FUNCTION(arm64_err_exc_lower_el_64)
    invalid_exception 0x23
ffffffffea801580:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801584:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801588:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80158c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801590:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801594:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801598:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80159c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8015a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8015a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8015a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8015ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8015b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8015b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8015b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8015bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8015c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8015c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8015c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8015cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8015d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8015d4:	d2800461 	mov	x1, #0x23                  	// #35
ffffffffea8015d8:	910003e0 	mov	x0, sp
ffffffffea8015dc:	94000621 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8015e0:	14000000 	b	ffffffffea8015e0 <arm64_err_exc_lower_el_64+0x60>
	...

ffffffffea801600 <arm64_sync_exc_lower_el_32>:

/* exceptions from lower EL, running arm32 */
.org 0x600
LOCAL_FUNCTION(arm64_sync_exc_lower_el_32)
    regsave_long
ffffffffea801600:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801604:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801608:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80160c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801610:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801614:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801618:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80161c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801620:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea801624:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801628:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea80162c:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801630:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea801634:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801638:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea80163c:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801640:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea801644:	d5384021 	mrs	x1, elr_el1
ffffffffea801648:	d5384002 	mrs	x2, spsr_el1
ffffffffea80164c:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea801650:	a9100be1 	stp	x1, x2, [sp, #256]
    mov x0, sp
ffffffffea801654:	910003e0 	mov	x0, sp
    bl  arm64_sync_exception
ffffffffea801658:	940005a8 	bl	ffffffffea802cf8 <arm64_sync_exception>
    b  arm64_exc_shared_restore_long
ffffffffea80165c:	14000062 	b	ffffffffea8017e4 <arm64_exc_shared_restore_long>
	...

ffffffffea801680 <arm64_irq_lower_el_32>:

.org 0x680
LOCAL_FUNCTION(arm64_irq_lower_el_32)
    irq_exception
ffffffffea801680:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801684:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801688:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80168c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801690:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801694:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801698:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80169c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8016a0:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8016a4:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8016a8:	910243e0 	add	x0, sp, #0x90
ffffffffea8016ac:	d5384021 	mrs	x1, elr_el1
ffffffffea8016b0:	d5384002 	mrs	x2, spsr_el1
ffffffffea8016b4:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea8016b8:	a90a0be1 	stp	x1, x2, [sp, #160]
ffffffffea8016bc:	d50341ff 	msr	daifclr, #0x1
ffffffffea8016c0:	910003e0 	mov	x0, sp
ffffffffea8016c4:	94000c5f 	bl	ffffffffea804840 <platform_irq>
ffffffffea8016c8:	b4000040 	cbz	x0, ffffffffea8016d0 <arm64_irq_lower_el_32+0x50>
ffffffffea8016cc:	9400131b 	bl	ffffffffea806338 <thread_preempt>
ffffffffea8016d0:	d50341df 	msr	daifset, #0x1
ffffffffea8016d4:	1400005b 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801700 <arm64_fiq_lower_el_32>:

.org 0x700
LOCAL_FUNCTION(arm64_fiq_lower_el_32)
    regsave_short
ffffffffea801700:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801704:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea801708:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea80170c:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea801710:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea801714:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea801718:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea80171c:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea801720:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea801724:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea801728:	910243e0 	add	x0, sp, #0x90
ffffffffea80172c:	d5384021 	mrs	x1, elr_el1
ffffffffea801730:	d5384002 	mrs	x2, spsr_el1
ffffffffea801734:	a90903fe 	stp	x30, x0, [sp, #144]
ffffffffea801738:	a90a0be1 	stp	x1, x2, [sp, #160]
    mov x0, sp
ffffffffea80173c:	910003e0 	mov	x0, sp
    bl  platform_fiq
ffffffffea801740:	94000ca6 	bl	ffffffffea8049d8 <platform_fiq>
    b  arm64_exc_shared_restore_short
ffffffffea801744:	1400003f 	b	ffffffffea801840 <arm64_exc_shared_restore_short>
	...

ffffffffea801780 <arm64_err_exc_lower_el_32>:

.org 0x780
LOCAL_FUNCTION(arm64_err_exc_lower_el_32)
    invalid_exception 0x33
ffffffffea801780:	d10083ff 	sub	sp, sp, #0x20
ffffffffea801784:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
ffffffffea801788:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
ffffffffea80178c:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
ffffffffea801790:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
ffffffffea801794:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
ffffffffea801798:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
ffffffffea80179c:	a9bf47f0 	stp	x16, x17, [sp, #-16]!
ffffffffea8017a0:	a9bf3fee 	stp	x14, x15, [sp, #-16]!
ffffffffea8017a4:	a9bf37ec 	stp	x12, x13, [sp, #-16]!
ffffffffea8017a8:	a9bf2fea 	stp	x10, x11, [sp, #-16]!
ffffffffea8017ac:	a9bf27e8 	stp	x8, x9, [sp, #-16]!
ffffffffea8017b0:	a9bf1fe6 	stp	x6, x7, [sp, #-16]!
ffffffffea8017b4:	a9bf17e4 	stp	x4, x5, [sp, #-16]!
ffffffffea8017b8:	a9bf0fe2 	stp	x2, x3, [sp, #-16]!
ffffffffea8017bc:	a9bf07e0 	stp	x0, x1, [sp, #-16]!
ffffffffea8017c0:	9103c3e0 	add	x0, sp, #0xf0
ffffffffea8017c4:	d5384021 	mrs	x1, elr_el1
ffffffffea8017c8:	d5384002 	mrs	x2, spsr_el1
ffffffffea8017cc:	a90f03fe 	stp	x30, x0, [sp, #240]
ffffffffea8017d0:	a9100be1 	stp	x1, x2, [sp, #256]
ffffffffea8017d4:	d2800661 	mov	x1, #0x33                  	// #51
ffffffffea8017d8:	910003e0 	mov	x0, sp
ffffffffea8017dc:	940005a1 	bl	ffffffffea802e60 <arm64_invalid_exception>
ffffffffea8017e0:	14000000 	b	ffffffffea8017e0 <arm64_err_exc_lower_el_32+0x60>

ffffffffea8017e4 <arm64_exc_shared_restore_long>:

LOCAL_FUNCTION(arm64_exc_shared_restore_long)
    regrestore_long
ffffffffea8017e4:	f9407bfe 	ldr	x30, [sp, #240]
ffffffffea8017e8:	a9500be1 	ldp	x1, x2, [sp, #256]
ffffffffea8017ec:	d5184021 	msr	elr_el1, x1
ffffffffea8017f0:	d5184002 	msr	spsr_el1, x2
ffffffffea8017f4:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea8017f8:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea8017fc:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea801800:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801804:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801808:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea80180c:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea801810:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801814:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801818:	a8c14ff2 	ldp	x18, x19, [sp], #16
ffffffffea80181c:	a8c157f4 	ldp	x20, x21, [sp], #16
ffffffffea801820:	a8c15ff6 	ldp	x22, x23, [sp], #16
ffffffffea801824:	a8c167f8 	ldp	x24, x25, [sp], #16
ffffffffea801828:	a8c16ffa 	ldp	x26, x27, [sp], #16
ffffffffea80182c:	a8c177fc 	ldp	x28, x29, [sp], #16
ffffffffea801830:	910083ff 	add	sp, sp, #0x20
    exception_return
ffffffffea801834:	d69f03e0 	eret
ffffffffea801838:	d503379f 	dsb	nsh
ffffffffea80183c:	d5033fdf 	isb

ffffffffea801840 <arm64_exc_shared_restore_short>:

LOCAL_FUNCTION(arm64_exc_shared_restore_short)
       regrestore_short
ffffffffea801840:	f9404bfe 	ldr	x30, [sp, #144]
ffffffffea801844:	a94a0be1 	ldp	x1, x2, [sp, #160]
ffffffffea801848:	d5184021 	msr	elr_el1, x1
ffffffffea80184c:	d5184002 	msr	spsr_el1, x2
ffffffffea801850:	a8c107e0 	ldp	x0, x1, [sp], #16
ffffffffea801854:	a8c10fe2 	ldp	x2, x3, [sp], #16
ffffffffea801858:	a8c117e4 	ldp	x4, x5, [sp], #16
ffffffffea80185c:	a8c11fe6 	ldp	x6, x7, [sp], #16
ffffffffea801860:	a8c127e8 	ldp	x8, x9, [sp], #16
ffffffffea801864:	a8c12fea 	ldp	x10, x11, [sp], #16
ffffffffea801868:	a8c137ec 	ldp	x12, x13, [sp], #16
ffffffffea80186c:	a8c13fee 	ldp	x14, x15, [sp], #16
ffffffffea801870:	a8c147f0 	ldp	x16, x17, [sp], #16
ffffffffea801874:	910083ff 	add	sp, sp, #0x20
       exception_return
ffffffffea801878:	d69f03e0 	eret
ffffffffea80187c:	d503379f 	dsb	nsh
ffffffffea801880:	d5033fdf 	isb
ffffffffea801884:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801888 <platform_secondary_init>:
#if WITH_SMP

static void platform_secondary_init(uint level)
{
	dprintf(SPEW, "%s: cpu_id 0x%x\n", __func__, plat_arch_curr_cpu_num());
}
ffffffffea801888:	d65f03c0 	ret
ffffffffea80188c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801890 <platform_prevent_ssb>:
 * by disabling memory disambiguation and speculative store buffering in
 * S-EL1 and S-EL0.
 *
 * This mitigation is only ran on Denver and Carmel (DENVER_PN4) cpus.
 */
static void platform_prevent_ssb(uint level) {
ffffffffea801890:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801894:	910003fd 	mov	x29, sp
ffffffffea801898:	f9000bf3 	str	x19, [sp, #16]
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea80189c:	d5380013 	mrs	x19, midr_el1
	uint64_t actlr = 0;
	uint64_t mask = 0;

	/* Only apply workaround on Denver cores */
	if (!platform_is_denver_cpu())
ffffffffea8018a0:	940002fe 	bl	ffffffffea802498 <platform_is_denver_cpu>
ffffffffea8018a4:	72001c1f 	tst	w0, #0xff
ffffffffea8018a8:	54000260 	b.eq	ffffffffea8018f4 <platform_prevent_ssb+0x64>  // b.none
	/*
	 * Denver CPUs with DENVER_MIDR_PN3 or earlier, use different
	 * bits in the ACTLR_EL1/ACTLR_EL0 registers to disable
	 * speculative store buffer and memory disambiguation.
	 */
	switch(midr) {
ffffffffea8018ac:	d2800400 	mov	x0, #0x20                  	// #32
ffffffffea8018b0:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea8018b4:	eb00027f 	cmp	x19, x0
ffffffffea8018b8:	54000680 	b.eq	ffffffffea801988 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea8018bc:	54000229 	b.ls	ffffffffea801900 <platform_prevent_ssb+0x70>  // b.plast
ffffffffea8018c0:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea8018c4:	f2a9c1e0 	movk	x0, #0x4e0f, lsl #16
ffffffffea8018c8:	eb00027f 	cmp	x19, x0
ffffffffea8018cc:	540005e0 	b.eq	ffffffffea801988 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea8018d0:	d2800801 	mov	x1, #0x40                  	// #64
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
			| DENVER_CPU_DIS_SSB_EL0 | DENVER_CPU_DIS_SSB_EL1;
		break;

	case DENVER_MIDR_PN4:
		mask = DENVER_PN4_CPU_DIS_MD_EL0 | DENVER_PN4_CPU_DIS_MD_EL1
ffffffffea8018d4:	d2807800 	mov	x0, #0x3c0                 	// #960
	switch(midr) {
ffffffffea8018d8:	f2a9c1e1 	movk	x1, #0x4e0f, lsl #16
ffffffffea8018dc:	eb01027f 	cmp	x19, x1
ffffffffea8018e0:	540001c1 	b.ne	ffffffffea801918 <platform_prevent_ssb+0x88>  // b.any
			__func__, plat_arch_curr_cpu_num(), midr);
		break;
	}

	/* update actlr_el1 */
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea8018e4:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea8018e8:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea8018ec:	d5181020 	msr	actlr_el1, x0
ffffffffea8018f0:	d5033fdf 	isb
}
ffffffffea8018f4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8018f8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8018fc:	d65f03c0 	ret
	switch(midr) {
ffffffffea801900:	d2a9c1e0 	mov	x0, #0x4e0f0000            	// #1309605888
ffffffffea801904:	eb00027f 	cmp	x19, x0
ffffffffea801908:	54000400 	b.eq	ffffffffea801988 <platform_prevent_ssb+0xf8>  // b.none
ffffffffea80190c:	91004000 	add	x0, x0, #0x10
ffffffffea801910:	eb00027f 	cmp	x19, x0
ffffffffea801914:	540003a0 	b.eq	ffffffffea801988 <platform_prevent_ssb+0xf8>  // b.none
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801918:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea80191c:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801920:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801924:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801928:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea80192c:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801930:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea801934:	7103fc5f 	cmp	w2, #0xff
ffffffffea801938:	54000061 	b.ne	ffffffffea801944 <platform_prevent_ssb+0xb4>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea80193c:	2a0003e2 	mov	w2, w0
ffffffffea801940:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea801944:	7100105f 	cmp	w2, #0x4
ffffffffea801948:	540002c0 	b.eq	ffffffffea8019a0 <platform_prevent_ssb+0x110>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea80194c:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801950:	9101a021 	add	x1, x1, #0x68
ffffffffea801954:	b8607822 	ldr	w2, [x1, x0, lsl #2]
		dprintf(CRITICAL, "%s: unable to apply cve_2018_3639 TZ"
ffffffffea801958:	aa1303e3 	mov	x3, x19
ffffffffea80195c:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801960:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801964:	9100c021 	add	x1, x1, #0x30
ffffffffea801968:	9102e000 	add	x0, x0, #0xb8
ffffffffea80196c:	9400427d 	bl	ffffffffea812360 <_dprintf>
	uint64_t mask = 0;
ffffffffea801970:	d2800000 	mov	x0, #0x0                   	// #0
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea801974:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801978:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea80197c:	d5181020 	msr	actlr_el1, x0
ffffffffea801980:	d5033fdf 	isb
ffffffffea801984:	17ffffdc 	b	ffffffffea8018f4 <platform_prevent_ssb+0x64>
		mask = DENVER_CPU_DIS_MD_EL0 | DENVER_CPU_DIS_MD_EL1
ffffffffea801988:	d283c000 	mov	x0, #0x1e00                	// #7680
	actlr = ARM64_READ_SYSREG(actlr_el1);
ffffffffea80198c:	d5381021 	mrs	x1, actlr_el1
	actlr |= mask;
ffffffffea801990:	aa010000 	orr	x0, x0, x1
	ARM64_WRITE_SYSREG(actlr_el1, actlr);
ffffffffea801994:	d5181020 	msr	actlr_el1, x0
ffffffffea801998:	d5033fdf 	isb
ffffffffea80199c:	17ffffd6 	b	ffffffffea8018f4 <platform_prevent_ssb+0x64>
		return a57_boot_map[curr_cpu_num];
ffffffffea8019a0:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8019a4:	91012021 	add	x1, x1, #0x48
ffffffffea8019a8:	b8607822 	ldr	w2, [x1, x0, lsl #2]
ffffffffea8019ac:	17ffffeb 	b	ffffffffea801958 <platform_prevent_ssb+0xc8>

ffffffffea8019b0 <plat_arch_curr_cpu_num>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea8019b0:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea8019b4:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea8019b8:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea8019bc:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea8019c0:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea8019c4:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea8019c8:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea8019cc:	7103fc5f 	cmp	w2, #0xff
ffffffffea8019d0:	54000061 	b.ne	ffffffffea8019dc <plat_arch_curr_cpu_num+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea8019d4:	2a0003e2 	mov	w2, w0
ffffffffea8019d8:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea8019dc:	7100105f 	cmp	w2, #0x4
ffffffffea8019e0:	540000a0 	b.eq	ffffffffea8019f4 <plat_arch_curr_cpu_num+0x44>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea8019e4:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8019e8:	9101a021 	add	x1, x1, #0x68
ffffffffea8019ec:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea8019f0:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea8019f4:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8019f8:	91012021 	add	x1, x1, #0x48
ffffffffea8019fc:	b8607820 	ldr	w0, [x1, x0, lsl #2]
}
ffffffffea801a00:	d65f03c0 	ret
ffffffffea801a04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a08 <arch_sync_cache_range>:
}
ffffffffea801a08:	d65f03c0 	ret
ffffffffea801a0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a10 <platform_app_bootloader_epilog>:
{
ffffffffea801a10:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea801a14:	b0000312 	adrp	x18, ffffffffea862000 <__ctor_list>
	asm volatile (
ffffffffea801a18:	529fe17e 	mov	w30, #0xff0b                	// #65291
{
ffffffffea801a1c:	910003fd 	mov	x29, sp
ffffffffea801a20:	f9402a52 	ldr	x18, [x18, #80]
	asm volatile (
ffffffffea801a24:	72b05ffe 	movk	w30, #0x82ff, lsl #16
{
ffffffffea801a28:	f9400240 	ldr	x0, [x18]
ffffffffea801a2c:	f9002fa0 	str	x0, [x29, #88]
ffffffffea801a30:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea801a34:	f9000bf3 	str	x19, [sp, #16]
	asm volatile (
ffffffffea801a38:	9100a3b3 	add	x19, x29, #0x28
ffffffffea801a3c:	aa1e03e0 	mov	x0, x30
ffffffffea801a40:	a9400a61 	ldp	x1, x2, [x19]
ffffffffea801a44:	a9411263 	ldp	x3, x4, [x19, #16]
ffffffffea801a48:	a9421a65 	ldp	x5, x6, [x19, #32]
ffffffffea801a4c:	d5033fdf 	isb
ffffffffea801a50:	d4000003 	smc	#0x0
ffffffffea801a54:	aa0003fe 	mov	x30, x0
ffffffffea801a58:	a9000660 	stp	x0, x1, [x19]
ffffffffea801a5c:	a9010e62 	stp	x2, x3, [x19, #16]
}
ffffffffea801a60:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea801a64:	f9400240 	ldr	x0, [x18]
ffffffffea801a68:	ca000020 	eor	x0, x1, x0
ffffffffea801a6c:	b5000080 	cbnz	x0, ffffffffea801a7c <platform_app_bootloader_epilog+0x6c>
ffffffffea801a70:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801a74:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea801a78:	d65f03c0 	ret
ffffffffea801a7c:	940048ab 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea801a80 <platform_early_init>:
	arm_generic_timer_init(ARM_GENERIC_TIMER_INT, 0);
ffffffffea801a80:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea801a84:	528003a0 	mov	w0, #0x1d                  	// #29
ffffffffea801a88:	14000e42 	b	ffffffffea805390 <arm_generic_timer_init>
ffffffffea801a8c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801a90 <platform_init>:
{
ffffffffea801a90:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801a94:	910003fd 	mov	x29, sp
ffffffffea801a98:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801a9c:	aa1e03f3 	mov	x19, x30
	if ((err = process_boot_params()) != NO_ERROR) {
ffffffffea801aa0:	940000b2 	bl	ffffffffea801d68 <process_boot_params>
ffffffffea801aa4:	350000c0 	cbnz	w0, ffffffffea801abc <platform_init+0x2c>
	platform_init_debug_port(debug_uart_id);
ffffffffea801aa8:	900000c0 	adrp	x0, ffffffffea819000 <_mem_phys_base>
}
ffffffffea801aac:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801ab0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	platform_init_debug_port(debug_uart_id);
ffffffffea801ab4:	b9401000 	ldr	w0, [x0, #16]
ffffffffea801ab8:	140001be 	b	ffffffffea8021b0 <platform_init_debug_port>
		panic("Fatal error: Failed to process boot params\n");
ffffffffea801abc:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801ac0:	aa1303e0 	mov	x0, x19
ffffffffea801ac4:	91022021 	add	x1, x1, #0x88
ffffffffea801ac8:	940042ae 	bl	ffffffffea812580 <_panic>
ffffffffea801acc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801ad0 <platform_init_mmu_mappings>:
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801ad0:	d53800a1 	mrs	x1, mpidr_el1
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801ad4:	d53800a0 	mrs	x0, mpidr_el1
	if (boot_cpu == 0xFF)
ffffffffea801ad8:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
	unsigned int cluster_num = (ARM64_READ_SYSREG(mpidr_el1) >> 8) & 0xff;
ffffffffea801adc:	d348fc00 	lsr	x0, x0, #8
	unsigned int cpu_num =  ARM64_READ_SYSREG(mpidr_el1) & 0xff;
ffffffffea801ae0:	12001c21 	and	w1, w1, #0xff
	if (boot_cpu == 0xFF)
ffffffffea801ae4:	b9400c62 	ldr	w2, [x3, #12]
	uint curr_cpu_num = (cpu_num + (cluster_num << 2));
ffffffffea801ae8:	0b200820 	add	w0, w1, w0, uxtb #2
	if (boot_cpu == 0xFF)
ffffffffea801aec:	7103fc5f 	cmp	w2, #0xff
ffffffffea801af0:	54000061 	b.ne	ffffffffea801afc <platform_init_mmu_mappings+0x2c>  // b.any
		boot_cpu = curr_cpu_num;
ffffffffea801af4:	2a0003e2 	mov	w2, w0
ffffffffea801af8:	b9000c60 	str	w0, [x3, #12]
	if (boot_cpu == A57_0)
ffffffffea801afc:	7100105f 	cmp	w2, #0x4
ffffffffea801b00:	540003e0 	b.eq	ffffffffea801b7c <platform_init_mmu_mappings+0xac>  // b.none
		return denver_boot_map[curr_cpu_num];
ffffffffea801b04:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801b08:	9101a021 	add	x1, x1, #0x68
ffffffffea801b0c:	b8607820 	ldr	w0, [x1, x0, lsl #2]
	if (plat_arch_curr_cpu_num() == 0) {
ffffffffea801b10:	35000340 	cbnz	w0, ffffffffea801b78 <platform_init_mmu_mappings+0xa8>
{
ffffffffea801b14:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea801b18:	910003fd 	mov	x29, sp
ffffffffea801b1c:	a9025bf5 	stp	x21, x22, [sp, #32]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b20:	900000d6 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea801b24:	9104c2c0 	add	x0, x22, #0x130
{
ffffffffea801b28:	a90153f3 	stp	x19, x20, [sp, #16]
		struct mmu_initial_mapping *m = mmu_initial_mappings;
ffffffffea801b2c:	900000d3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea801b30:	91006273 	add	x19, x19, #0x18
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801b34:	91046275 	add	x21, x19, #0x118
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b38:	f9400814 	ldr	x20, [x0, #16]
ffffffffea801b3c:	d503201f 	nop
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801b40:	b9401a60 	ldr	w0, [x19, #24]
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b44:	aa1403e1 	mov	x1, x20
			if (!(m->flags & MMU_INITIAL_MAPPING_FLAG_DYNAMIC))
ffffffffea801b48:	36180080 	tbz	w0, #3, ffffffffea801b58 <platform_init_mmu_mappings+0x88>
			if (strcmp(m->name, ram_arena.name) == 0) {
ffffffffea801b4c:	f9401260 	ldr	x0, [x19, #32]
ffffffffea801b50:	9400497a 	bl	ffffffffea814138 <strcmp>
ffffffffea801b54:	340001c0 	cbz	w0, ffffffffea801b8c <platform_init_mmu_mappings+0xbc>
		for (uint i = 0; i < countof(mmu_initial_mappings); i++, m++) {
ffffffffea801b58:	9100a273 	add	x19, x19, #0x28
ffffffffea801b5c:	eb15027f 	cmp	x19, x21
ffffffffea801b60:	54ffff01 	b.ne	ffffffffea801b40 <platform_init_mmu_mappings+0x70>  // b.any
		pmm_add_arena(&ram_arena);
ffffffffea801b64:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801b68:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801b6c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801b70:	a8c37bfd 	ldp	x29, x30, [sp], #48
		pmm_add_arena(&ram_arena);
ffffffffea801b74:	14003cef 	b	ffffffffea810f30 <pmm_add_arena>
ffffffffea801b78:	d65f03c0 	ret
		return a57_boot_map[curr_cpu_num];
ffffffffea801b7c:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801b80:	91012021 	add	x1, x1, #0x48
ffffffffea801b84:	b8607820 	ldr	w0, [x1, x0, lsl #2]
ffffffffea801b88:	17ffffe2 	b	ffffffffea801b10 <platform_init_mmu_mappings+0x40>
				ram_arena.base = m->phys;
ffffffffea801b8c:	9104c2c0 	add	x0, x22, #0x130
ffffffffea801b90:	f9400261 	ldr	x1, [x19]
				ram_arena.size = m->size;
ffffffffea801b94:	f9400a62 	ldr	x2, [x19, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801b98:	52800025 	mov	w5, #0x1                   	// #1
}
ffffffffea801b9c:	a94153f3 	ldp	x19, x20, [sp, #16]
				ram_arena.flags = PMM_ARENA_FLAG_KMAP;
ffffffffea801ba0:	b9001805 	str	w5, [x0, #24]
				ram_arena.size = m->size;
ffffffffea801ba4:	a9020801 	stp	x1, x2, [x0, #32]
		pmm_add_arena(&ram_arena);
ffffffffea801ba8:	9104c2c0 	add	x0, x22, #0x130
}
ffffffffea801bac:	a9425bf5 	ldp	x21, x22, [sp, #32]
				_mem_size = m->size;
ffffffffea801bb0:	900000c4 	adrp	x4, ffffffffea819000 <_mem_phys_base>
}
ffffffffea801bb4:	a8c37bfd 	ldp	x29, x30, [sp], #48
				_mem_phys_base = m->phys;
ffffffffea801bb8:	900000c3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
				_mem_size = m->size;
ffffffffea801bbc:	b9000882 	str	w2, [x4, #8]
				_mem_phys_base = m->phys;
ffffffffea801bc0:	f9000061 	str	x1, [x3]
		pmm_add_arena(&ram_arena);
ffffffffea801bc4:	14003cdb 	b	ffffffffea810f30 <pmm_add_arena>

ffffffffea801bc8 <comb_uart_putc>:
 * Indicates that we're only sending one byte at a time.
 */
#define MBOX_BYTE_COUNT	(1 << 24)

static void comb_uart_putc(char c)
{
ffffffffea801bc8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea801bcc:	910003fd 	mov	x29, sp
ffffffffea801bd0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801bd4:	12001c13 	and	w19, w0, #0xff
ffffffffea801bd8:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (c == '\n')
		msg |= MBOX_FLUSH;
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
		if (timed_out)
			return;
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801bdc:	d29423f5 	mov	x21, #0xa11f                	// #41247
{
ffffffffea801be0:	a90363f7 	stp	x23, x24, [sp, #48]
	start = current_time_hires();
ffffffffea801be4:	94000dcf 	bl	ffffffffea805320 <current_time_hires>
	uint32_t msg = MBOX_INTR_TRIGGER | MBOX_BYTE_COUNT | (uint8_t)(c & 0xff);
ffffffffea801be8:	52b02017 	mov	w23, #0x81000000            	// #-2130706432
ffffffffea801bec:	2a170277 	orr	w23, w19, w23
		msg |= MBOX_FLUSH;
ffffffffea801bf0:	71002a7f 	cmp	w19, #0xa
	start = current_time_hires();
ffffffffea801bf4:	aa0003f6 	mov	x22, x0
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801bf8:	929ffff3 	mov	x19, #0xffffffffffff0000    	// #-65536
		msg |= MBOX_FLUSH;
ffffffffea801bfc:	320602e0 	orr	w0, w23, #0x4000000
ffffffffea801c00:	90000378 	adrp	x24, ffffffffea86d000 <__bss_start>
ffffffffea801c04:	1a970017 	csel	w23, w0, w23, eq  // eq = none
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c08:	f2be3813 	movk	x19, #0xf1c0, lsl #16
		if (timed_out)
ffffffffea801c0c:	91000314 	add	x20, x24, #0x0
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c10:	f2a000f5 	movk	x21, #0x7, lsl #16
ffffffffea801c14:	14000007 	b	ffffffffea801c30 <comb_uart_putc+0x68>
		if (timed_out)
ffffffffea801c18:	39400280 	ldrb	w0, [x20]
ffffffffea801c1c:	35000120 	cbnz	w0, ffffffffea801c40 <comb_uart_putc+0x78>
		if (current_time_hires() - start >= TX_TIMEOUT_US) {
ffffffffea801c20:	94000dc0 	bl	ffffffffea805320 <current_time_hires>
ffffffffea801c24:	cb160000 	sub	x0, x0, x22
ffffffffea801c28:	eb15001f 	cmp	x0, x21
ffffffffea801c2c:	54000148 	b.hi	ffffffffea801c54 <comb_uart_putc+0x8c>  // b.pmore
	while (readl(TEGRA_COMBUART_BASE) & (MBOX_INTR_TRIGGER)) {
ffffffffea801c30:	b9400260 	ldr	w0, [x19]
ffffffffea801c34:	37ffff20 	tbnz	w0, #31, ffffffffea801c18 <comb_uart_putc+0x50>
			timed_out = true;
			return;
		}
	}
	timed_out = false;
ffffffffea801c38:	3900031f 	strb	wzr, [x24]
	 *
	 * If EL3 does attempt to print debug messages at the same time as Trusty, messages might
	 * be corrupted. This is acceptable, because it should not cause any functional issues
	 * in Trusty or EL3.
	 */
	writel(msg, TEGRA_COMBUART_BASE);
ffffffffea801c3c:	b9000277 	str	w23, [x19]
}
ffffffffea801c40:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801c44:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801c48:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801c4c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801c50:	d65f03c0 	ret
			timed_out = true;
ffffffffea801c54:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea801c58:	39000280 	strb	w0, [x20]
}
ffffffffea801c5c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801c60:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801c64:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801c68:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea801c6c:	d65f03c0 	ret

ffffffffea801c70 <platform_tegra_comb_uart_putc>:

void platform_tegra_comb_uart_putc(char c)
{
ffffffffea801c70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801c74:	910003fd 	mov	x29, sp
ffffffffea801c78:	f9000bf3 	str	x19, [sp, #16]
	if (c == '\0')
ffffffffea801c7c:	72001c13 	ands	w19, w0, #0xff
ffffffffea801c80:	540000e0 	b.eq	ffffffffea801c9c <platform_tegra_comb_uart_putc+0x2c>  // b.none
		return;
	if (c == '\n')
ffffffffea801c84:	71002a7f 	cmp	w19, #0xa
ffffffffea801c88:	54000100 	b.eq	ffffffffea801ca8 <platform_tegra_comb_uart_putc+0x38>  // b.none
		comb_uart_putc('\r');
	comb_uart_putc(c);
ffffffffea801c8c:	2a1303e0 	mov	w0, w19
}
ffffffffea801c90:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801c94:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801c98:	17ffffcc 	b	ffffffffea801bc8 <comb_uart_putc>
}
ffffffffea801c9c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801ca0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801ca4:	d65f03c0 	ret
		comb_uart_putc('\r');
ffffffffea801ca8:	528001a0 	mov	w0, #0xd                   	// #13
ffffffffea801cac:	97ffffc7 	bl	ffffffffea801bc8 <comb_uart_putc>
	comb_uart_putc(c);
ffffffffea801cb0:	2a1303e0 	mov	w0, w19
}
ffffffffea801cb4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801cb8:	a8c27bfd 	ldp	x29, x30, [sp], #32
	comb_uart_putc(c);
ffffffffea801cbc:	17ffffc3 	b	ffffffffea801bc8 <comb_uart_putc>
#include <sys/types.h>

__WEAK void platform_tegra_comb_uart_putc(char c)
{
	(void)c;
}
ffffffffea801cc0:	d65f03c0 	ret
ffffffffea801cc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea801cc8 <platform_tegra_comb_uart_getc>:

int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801cc8:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801ccc:	d65f03c0 	ret

__WEAK int platform_tegra_comb_uart_getc(bool wait)
{
	(void)wait;
	return -1;
}
ffffffffea801cd0:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea801cd4:	d65f03c0 	ret

ffffffffea801cd8 <get_and_clear_eks_info>:

/* Structure to hold EKS information */
static eks_info_t eks_info;

status_t get_and_clear_eks_info(eks_info_t *info)
{
ffffffffea801cd8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea801cdc:	910003fd 	mov	x29, sp
ffffffffea801ce0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801ce4:	aa0003f3 	mov	x19, x0
	if (!platform_is_bootstrapping()) {
ffffffffea801ce8:	9400013e 	bl	ffffffffea8021e0 <platform_is_bootstrapping>
ffffffffea801cec:	72001c1f 	tst	w0, #0xff
ffffffffea801cf0:	540001c0 	b.eq	ffffffffea801d28 <get_and_clear_eks_info+0x50>  // b.none
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
		return ERR_NOT_ALLOWED;
	}
	if (info == NULL) {
ffffffffea801cf4:	b4000293 	cbz	x19, ffffffffea801d44 <get_and_clear_eks_info+0x6c>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
		return ERR_INVALID_ARGS;
	}
	info->paddr = eks_info.paddr;
ffffffffea801cf8:	90000361 	adrp	x1, ffffffffea86d000 <__bss_start>
ffffffffea801cfc:	91002022 	add	x2, x1, #0x8

	/* clear eks_info, so this method cannot be used again */
	eks_info.paddr = NULL;
	eks_info.blob_length = 0;

	return NO_ERROR;
ffffffffea801d00:	52800000 	mov	w0, #0x0                   	// #0
	info->paddr = eks_info.paddr;
ffffffffea801d04:	f9400423 	ldr	x3, [x1, #8]
	eks_info.paddr = NULL;
ffffffffea801d08:	f900043f 	str	xzr, [x1, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801d0c:	b9400841 	ldr	w1, [x2, #8]
	info->paddr = eks_info.paddr;
ffffffffea801d10:	f9000263 	str	x3, [x19]
	eks_info.blob_length = 0;
ffffffffea801d14:	b900085f 	str	wzr, [x2, #8]
	info->blob_length = eks_info.blob_length;
ffffffffea801d18:	b9000a61 	str	w1, [x19, #8]
}
ffffffffea801d1c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801d20:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea801d24:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n", __func__);
ffffffffea801d28:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801d2c:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801d30:	91060021 	add	x1, x1, #0x180
ffffffffea801d34:	91066000 	add	x0, x0, #0x198
ffffffffea801d38:	9400418a 	bl	ffffffffea812360 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea801d3c:	12800200 	mov	w0, #0xffffffef            	// #-17
ffffffffea801d40:	17fffff7 	b	ffffffffea801d1c <get_and_clear_eks_info+0x44>
		dprintf(CRITICAL, "%s: ERROR: Attempting to access NULL pointer\n", __func__);
ffffffffea801d44:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801d48:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801d4c:	91060021 	add	x1, x1, #0x180
ffffffffea801d50:	91070000 	add	x0, x0, #0x1c0
ffffffffea801d54:	94004183 	bl	ffffffffea812360 <_dprintf>
		return ERR_INVALID_ARGS;
ffffffffea801d58:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea801d5c:	17fffff0 	b	ffffffffea801d1c <get_and_clear_eks_info+0x44>

ffffffffea801d60 <partner_process_boot_params>:
}

__WEAK status_t partner_process_boot_params(boot_params_t *boot_params)
{
	return NO_ERROR;
};
ffffffffea801d60:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea801d64:	d65f03c0 	ret

ffffffffea801d68 <process_boot_params>:

status_t process_boot_params(void)
{
ffffffffea801d68:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea801d6c:	910003fd 	mov	x29, sp
ffffffffea801d70:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801d74:	b0000313 	adrp	x19, ffffffffea862000 <__ctor_list>
	key_params *keys_params;
	size_t total_length, keys_length;
	uint32_t offset;
	status_t ret;
	/* get boot args */
	if ((ret = sm_get_boot_args((void **)&boot_params, &total_length))
ffffffffea801d78:	910143a1 	add	x1, x29, #0x50
ffffffffea801d7c:	910123a0 	add	x0, x29, #0x48
{
ffffffffea801d80:	f9402a62 	ldr	x2, [x19, #80]
ffffffffea801d84:	f9400043 	ldr	x3, [x2]
ffffffffea801d88:	f9002fa3 	str	x3, [x29, #88]
ffffffffea801d8c:	d2800003 	mov	x3, #0x0                   	// #0
	if ((ret = sm_get_boot_args((void **)&boot_params, &total_length))
ffffffffea801d90:	94001a3a 	bl	ffffffffea808678 <sm_get_boot_args>
ffffffffea801d94:	35000180 	cbnz	w0, ffffffffea801dc4 <process_boot_params+0x5c>
ffffffffea801d98:	f9000fb4 	str	x20, [x29, #24]
			!= NO_ERROR) {
		LTRACEF("sm_get_boot_args failed: %d\n", ret);
		return ret;
	}

	if (!boot_params) {
ffffffffea801d9c:	f94027b4 	ldr	x20, [x29, #72]
ffffffffea801da0:	b4000234 	cbz	x20, ffffffffea801de4 <process_boot_params+0x7c>
		ret = ERR_NOT_CONFIGURED;
		goto release_bootargs;
	}

	if (total_length < sizeof(boot_params_t)) {
ffffffffea801da4:	f9402ba1 	ldr	x1, [x29, #80]
		ret = ERR_BAD_LEN;
ffffffffea801da8:	128003e0 	mov	w0, #0xffffffe0            	// #-32
	if (total_length < sizeof(boot_params_t)) {
ffffffffea801dac:	f1023c3f 	cmp	x1, #0x8f
ffffffffea801db0:	540001e8 	b.hi	ffffffffea801dec <process_boot_params+0x84>  // b.pmore
ffffffffea801db4:	b9003fa0 	str	w0, [x29, #60]
		return ret;
	}

release_bootargs:
	/* release boot args reference */
	sm_put_boot_args();
ffffffffea801db8:	94001a56 	bl	ffffffffea808710 <sm_put_boot_args>
ffffffffea801dbc:	b9403fa0 	ldr	w0, [x29, #60]
ffffffffea801dc0:	f9400fb4 	ldr	x20, [x29, #24]

	return ret;
}
ffffffffea801dc4:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea801dc8:	f9402fa2 	ldr	x2, [x29, #88]
ffffffffea801dcc:	f9400261 	ldr	x1, [x19]
ffffffffea801dd0:	ca010041 	eor	x1, x2, x1
ffffffffea801dd4:	b5000801 	cbnz	x1, ffffffffea801ed4 <process_boot_params+0x16c>
ffffffffea801dd8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea801ddc:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea801de0:	d65f03c0 	ret
		ret = ERR_NOT_CONFIGURED;
ffffffffea801de4:	128004a0 	mov	w0, #0xffffffda            	// #-38
ffffffffea801de8:	17fffff3 	b	ffffffffea801db4 <process_boot_params+0x4c>
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801dec:	b0000301 	adrp	x1, ffffffffea862000 <__ctor_list>
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801df0:	b0000300 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea801df4:	a9025bb5 	stp	x21, x22, [x29, #32]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801df8:	b0000315 	adrp	x21, ffffffffea862000 <__ctor_list>
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801dfc:	f940a421 	ldr	x1, [x1, #328]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e00:	d2800802 	mov	x2, #0x40                  	// #64
	device_uid[0] = boot_params_ptr->chip_uid[0];
ffffffffea801e04:	29409e83 	ldp	w3, w7, [x20, #4]
	keys_params = (key_params *)((uintptr_t)boot_params + offset);
ffffffffea801e08:	91024296 	add	x22, x20, #0x90
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801e0c:	f9406000 	ldr	x0, [x0, #192]
	device_uid[2] = boot_params_ptr->chip_uid[2];
ffffffffea801e10:	29419686 	ldp	w6, w5, [x20, #12]
	device_uid[1] = boot_params_ptr->chip_uid[1];
ffffffffea801e14:	29001827 	stp	w7, w6, [x1]
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801e18:	b9401684 	ldr	w4, [x20, #20]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e1c:	f9409ab5 	ldr	x21, [x21, #304]
	debug_uart_id = boot_params_ptr->uart_id;
ffffffffea801e20:	b9000003 	str	w3, [x0]
	device_uid[3] = boot_params_ptr->chip_uid[3];
ffffffffea801e24:	29011025 	stp	w5, w4, [x1, #8]
	dest = memcpy((void *)&rb_data, (const void *)&(boot_params_ptr->rb_data),
ffffffffea801e28:	aa1503e0 	mov	x0, x21
ffffffffea801e2c:	91014281 	add	x1, x20, #0x50
ffffffffea801e30:	940047e6 	bl	ffffffffea813dc8 <memcpy>
	if (dest != (void *)&rb_data) {
ffffffffea801e34:	eb0002bf 	cmp	x21, x0
ffffffffea801e38:	540000e0 	b.eq	ffffffffea801e54 <process_boot_params+0xec>  // b.none
		TRACEF("error while doing mem copy\n");
ffffffffea801e3c:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801e40:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801e44:	52800a42 	mov	w2, #0x52                  	// #82
ffffffffea801e48:	91056021 	add	x1, x1, #0x158
ffffffffea801e4c:	9107c000 	add	x0, x0, #0x1f0
ffffffffea801e50:	94004782 	bl	ffffffffea813c58 <_printf>
	keys_length = keys_params->encrypted_key_sz;
ffffffffea801e54:	b9409294 	ldr	w20, [x20, #144]
ffffffffea801e58:	2a1403e3 	mov	w3, w20
        if (keys_length > MAXIMUM_ENCRYPTED_KEYS_SIZE) {
ffffffffea801e5c:	f140807f 	cmp	x3, #0x20, lsl #12
ffffffffea801e60:	540001e9 	b.ls	ffffffffea801e9c <process_boot_params+0x134>  // b.plast
		TRACEF("encrypted key length (%zu) exceeds maximum key length (%lu)\n",
ffffffffea801e64:	52800fe2 	mov	w2, #0x7f                  	// #127
ffffffffea801e68:	b00000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801e6c:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801e70:	9105a021 	add	x1, x1, #0x168
ffffffffea801e74:	d2a00044 	mov	x4, #0x20000               	// #131072
ffffffffea801e78:	91086000 	add	x0, x0, #0x218
ffffffffea801e7c:	94004777 	bl	ffffffffea813c58 <_printf>
		eks_info.paddr = NULL;
ffffffffea801e80:	90000361 	adrp	x1, ffffffffea86d000 <__bss_start>
ffffffffea801e84:	91002022 	add	x2, x1, #0x8
		goto release_bootargs;
ffffffffea801e88:	a9425bb5 	ldp	x21, x22, [x29, #32]
		ret = ERR_BAD_LEN;
ffffffffea801e8c:	128003e0 	mov	w0, #0xffffffe0            	// #-32
		eks_info.paddr = NULL;
ffffffffea801e90:	f900043f 	str	xzr, [x1, #8]
		eks_info.blob_length = 0;
ffffffffea801e94:	b900085f 	str	wzr, [x2, #8]
		goto release_bootargs;
ffffffffea801e98:	17ffffc7 	b	ffffffffea801db4 <process_boot_params+0x4c>
	eks_info.paddr = kvaddr_to_paddr(keys_params);
ffffffffea801e9c:	aa1603e0 	mov	x0, x22
ffffffffea801ea0:	94003e04 	bl	ffffffffea8116b0 <kvaddr_to_paddr>
ffffffffea801ea4:	90000361 	adrp	x1, ffffffffea86d000 <__bss_start>
ffffffffea801ea8:	91002022 	add	x2, x1, #0x8
ffffffffea801eac:	f9000420 	str	x0, [x1, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801eb0:	f94027a0 	ldr	x0, [x29, #72]
	eks_info.blob_length = keys_length;
ffffffffea801eb4:	b9000854 	str	w20, [x2, #8]
	ret = partner_process_boot_params(boot_params);
ffffffffea801eb8:	97ffffaa 	bl	ffffffffea801d60 <partner_process_boot_params>
 	if (ret != NO_ERROR) {
ffffffffea801ebc:	35000060 	cbnz	w0, ffffffffea801ec8 <process_boot_params+0x160>
ffffffffea801ec0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea801ec4:	17ffffbc 	b	ffffffffea801db4 <process_boot_params+0x4c>
ffffffffea801ec8:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea801ecc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea801ed0:	17ffffbd 	b	ffffffffea801dc4 <process_boot_params+0x5c>
ffffffffea801ed4:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea801ed8:	f90017b6 	str	x22, [x29, #40]
}
ffffffffea801edc:	94004793 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea801ee0 <uart_putc>:
{
	return *REG8(uart_base[port] + (reg << 2));
}

static int uart_putc(int port, char c )
{	
ffffffffea801ee0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea801ee4:	910003fd 	mov	x29, sp
ffffffffea801ee8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea801eec:	2a0003f3 	mov	w19, w0
ffffffffea801ef0:	a9025bf5 	stp	x21, x22, [sp, #32]
	lk_bigtime_t start = current_time_hires();

	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
		if (timed_out)
			return -1;
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801ef4:	d29423f5 	mov	x21, #0xa11f                	// #41247
{	
ffffffffea801ef8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea801efc:	12001c37 	and	w23, w1, #0xff
ffffffffea801f00:	f90023f9 	str	x25, [sp, #64]
	lk_bigtime_t start = current_time_hires();
ffffffffea801f04:	94000d07 	bl	ffffffffea805320 <current_time_hires>
ffffffffea801f08:	aa0003f6 	mov	x22, x0
ffffffffea801f0c:	b00000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea801f10:	91098000 	add	x0, x0, #0x260
ffffffffea801f14:	90000378 	adrp	x24, ffffffffea86d000 <__bss_start>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801f18:	f2a000f5 	movk	x21, #0x7, lsl #16
		if (timed_out)
ffffffffea801f1c:	91007314 	add	x20, x24, #0x1c
ffffffffea801f20:	f873d819 	ldr	x25, [x0, w19, sxtw #3]
ffffffffea801f24:	91005333 	add	x19, x25, #0x14
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801f28:	14000007 	b	ffffffffea801f44 <uart_putc+0x64>
		if (timed_out)
ffffffffea801f2c:	39400280 	ldrb	w0, [x20]
ffffffffea801f30:	350002c0 	cbnz	w0, ffffffffea801f88 <uart_putc+0xa8>
		if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea801f34:	94000cfb 	bl	ffffffffea805320 <current_time_hires>
ffffffffea801f38:	cb160000 	sub	x0, x0, x22
ffffffffea801f3c:	eb15001f 	cmp	x0, x21
ffffffffea801f40:	54000328 	b.hi	ffffffffea801fa4 <uart_putc+0xc4>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea801f44:	39400260 	ldrb	w0, [x19]
	while (!(read_uart_reg(port, UART_LSR) & (1<<5))) {
ffffffffea801f48:	362fff20 	tbz	w0, #5, ffffffffea801f2c <uart_putc+0x4c>
	*REG8(uart_base[port] + (reg << 2)) = data;
ffffffffea801f4c:	929fffe1 	mov	x1, #0xffffffffffff0000    	// #-65536
ffffffffea801f50:	52800700 	mov	w0, #0x38                  	// #56
ffffffffea801f54:	f2be2401 	movk	x1, #0xf120, lsl #16
ffffffffea801f58:	39000320 	strb	w0, [x25]
ffffffffea801f5c:	39000337 	strb	w23, [x25]
ffffffffea801f60:	52800722 	mov	w2, #0x39                  	// #57
			timed_out = true;
			return -1;
		}
	}

	timed_out = false;
ffffffffea801f64:	3900731f 	strb	wzr, [x24, #28]
	//write_uart_reg(port, UART_THR, (char)port );	
	write_uart_reg(port, UART_THR, Vtest);
	write_uart_reg(port, UART_THR, c);
	//write_uart_reg(3, UART_THR, Vtest3);
	write_uart_reg(1, UART_THR, Vtest2);
	return 0;
ffffffffea801f68:	52800000 	mov	w0, #0x0                   	// #0
	*REG8(uart_base[port] + (reg << 2)) = data;
ffffffffea801f6c:	39000022 	strb	w2, [x1]
}
ffffffffea801f70:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f74:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f78:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f7c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f80:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801f84:	d65f03c0 	ret
			return -1;
ffffffffea801f88:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea801f8c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801f90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801f94:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801f98:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801f9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801fa0:	d65f03c0 	ret
			timed_out = true;
ffffffffea801fa4:	52800021 	mov	w1, #0x1                   	// #1
			return -1;
ffffffffea801fa8:	12800000 	mov	w0, #0xffffffff            	// #-1
			timed_out = true;
ffffffffea801fac:	39000281 	strb	w1, [x20]
}
ffffffffea801fb0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea801fb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea801fb8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea801fbc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea801fc0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea801fc4:	d65f03c0 	ret

ffffffffea801fc8 <platform_dputc>:

	return read_uart_reg(port, UART_RHR);
}

void platform_dputc(char c)
{
ffffffffea801fc8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801fcc:	90000361 	adrp	x1, ffffffffea86d000 <__bss_start>
{
ffffffffea801fd0:	910003fd 	mov	x29, sp
ffffffffea801fd4:	f9000bf3 	str	x19, [sp, #16]
ffffffffea801fd8:	12001c13 	and	w19, w0, #0xff
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea801fdc:	b9401820 	ldr	w0, [x1, #24]
ffffffffea801fe0:	35000200 	cbnz	w0, ffffffffea802020 <platform_dputc+0x58>
ffffffffea801fe4:	f9000fb4 	str	x20, [x29, #24]
ffffffffea801fe8:	900000d4 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea801fec:	b9418280 	ldr	w0, [x20, #384]
ffffffffea801ff0:	34000160 	cbz	w0, ffffffffea80201c <platform_dputc+0x54>
		return;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea801ff4:	7103f81f 	cmp	w0, #0xfe
ffffffffea801ff8:	540001a0 	b.eq	ffffffffea80202c <platform_dputc+0x64>  // b.none
		platform_tegra_comb_uart_putc(c);
		return;
	}

	if (c == '\n') {
ffffffffea801ffc:	71002a7f 	cmp	w19, #0xa
ffffffffea802000:	54000200 	b.eq	ffffffffea802040 <platform_dputc+0x78>  // b.none
		uart_putc(debug_port, '\r');
	} else if (c == '\0') {
ffffffffea802004:	340000d3 	cbz	w19, ffffffffea80201c <platform_dputc+0x54>
		return;
	}
	uart_putc(debug_port, c);
ffffffffea802008:	2a1303e1 	mov	w1, w19
ffffffffea80200c:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802010:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802014:	a8c27bfd 	ldp	x29, x30, [sp], #32
	uart_putc(debug_port, c);
ffffffffea802018:	17ffffb2 	b	ffffffffea801ee0 <uart_putc>
ffffffffea80201c:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802020:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802024:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802028:	d65f03c0 	ret
		platform_tegra_comb_uart_putc(c);
ffffffffea80202c:	2a1303e0 	mov	w0, w19
ffffffffea802030:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea802034:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802038:	a8c27bfd 	ldp	x29, x30, [sp], #32
		platform_tegra_comb_uart_putc(c);
ffffffffea80203c:	17ffff0d 	b	ffffffffea801c70 <platform_tegra_comb_uart_putc>
		uart_putc(debug_port, '\r');
ffffffffea802040:	528001a1 	mov	w1, #0xd                   	// #13
ffffffffea802044:	97ffffa7 	bl	ffffffffea801ee0 <uart_putc>
ffffffffea802048:	b9418280 	ldr	w0, [x20, #384]
ffffffffea80204c:	17ffffef 	b	ffffffffea802008 <platform_dputc+0x40>

ffffffffea802050 <platform_dgetc>:

int platform_dgetc(char *c, bool wait)
{
	int _c;

	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea802050:	f0000342 	adrp	x2, ffffffffea86d000 <__bss_start>
ffffffffea802054:	b9401842 	ldr	w2, [x2, #24]
ffffffffea802058:	35000a62 	cbnz	w2, ffffffffea8021a4 <platform_dgetc+0x154>
{
ffffffffea80205c:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea802060:	f00000a2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
{
ffffffffea802064:	910003fd 	mov	x29, sp
ffffffffea802068:	f9000ff4 	str	x20, [sp, #24]
	if (disable_debug || (debug_port == TEGRA_UART_NONE))
ffffffffea80206c:	b9418054 	ldr	w20, [x2, #384]
ffffffffea802070:	34000694 	cbz	w20, ffffffffea802140 <platform_dgetc+0xf0>
ffffffffea802074:	f9000bb3 	str	x19, [x29, #16]
		return -1;

	if (debug_port == TEGRA_COMBUART_ID) {
ffffffffea802078:	7103fa9f 	cmp	w20, #0xfe
ffffffffea80207c:	f90017b6 	str	x22, [x29, #40]
ffffffffea802080:	aa0003f3 	mov	x19, x0
ffffffffea802084:	12001c36 	and	w22, w1, #0xff
ffffffffea802088:	54000520 	b.eq	ffffffffea80212c <platform_dgetc+0xdc>  // b.none
ffffffffea80208c:	f90013b5 	str	x21, [x29, #32]
ffffffffea802090:	a903e7b8 	stp	x24, x25, [x29, #56]
	lk_bigtime_t start = current_time_hires();
ffffffffea802094:	94000ca3 	bl	ffffffffea805320 <current_time_hires>
ffffffffea802098:	aa0003f5 	mov	x21, x0
ffffffffea80209c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8020a0:	91098000 	add	x0, x0, #0x260
ffffffffea8020a4:	f874d819 	ldr	x25, [x0, w20, sxtw #3]
ffffffffea8020a8:	91005334 	add	x20, x25, #0x14
	if (wait) {
ffffffffea8020ac:	35000216 	cbnz	w22, ffffffffea8020ec <platform_dgetc+0x9c>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020b0:	39405320 	ldrb	w0, [x25, #20]
		if (!(read_uart_reg(port, UART_LSR) & (1<<0)))
ffffffffea8020b4:	360006e0 	tbz	w0, #0, ffffffffea802190 <platform_dgetc+0x140>
ffffffffea8020b8:	f0000358 	adrp	x24, ffffffffea86d000 <__bss_start>
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020bc:	39400320 	ldrb	w0, [x25]
	timed_out = false;
ffffffffea8020c0:	3900771f 	strb	wzr, [x24, #29]
ffffffffea8020c4:	f94013b5 	ldr	x21, [x29, #32]
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea8020c8:	12001c00 	and	w0, w0, #0xff
ffffffffea8020cc:	a943e7b8 	ldp	x24, x25, [x29, #56]
	}

	if (_c < 0)
		return -1;

	*c = _c;
ffffffffea8020d0:	39000260 	strb	w0, [x19]
	return 0;
ffffffffea8020d4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8020d8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8020dc:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea8020e0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea8020e4:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8020e8:	d65f03c0 	ret
ffffffffea8020ec:	f9001bb7 	str	x23, [x29, #48]
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea8020f0:	d29423f7 	mov	x23, #0xa11f                	// #41247
ffffffffea8020f4:	f0000358 	adrp	x24, ffffffffea86d000 <__bss_start>
ffffffffea8020f8:	f2a000f7 	movk	x23, #0x7, lsl #16
			if (timed_out)
ffffffffea8020fc:	91007716 	add	x22, x24, #0x1d
ffffffffea802100:	14000007 	b	ffffffffea80211c <platform_dgetc+0xcc>
ffffffffea802104:	394002c1 	ldrb	w1, [x22]
ffffffffea802108:	35000241 	cbnz	w1, ffffffffea802150 <platform_dgetc+0x100>
			if (current_time_hires() - start >= UART_TIMEOUT_US) {
ffffffffea80210c:	94000c85 	bl	ffffffffea805320 <current_time_hires>
ffffffffea802110:	cb150000 	sub	x0, x0, x21
ffffffffea802114:	eb17001f 	cmp	x0, x23
ffffffffea802118:	54000288 	b.hi	ffffffffea802168 <platform_dgetc+0x118>  // b.pmore
	return *REG8(uart_base[port] + (reg << 2));
ffffffffea80211c:	39400281 	ldrb	w1, [x20]
		while (!(read_uart_reg(port, UART_LSR) & (1<<0))) {
ffffffffea802120:	3607ff21 	tbz	w1, #0, ffffffffea802104 <platform_dgetc+0xb4>
ffffffffea802124:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea802128:	17ffffe5 	b	ffffffffea8020bc <platform_dgetc+0x6c>
		_c = platform_tegra_comb_uart_getc(wait);
ffffffffea80212c:	2a1603e0 	mov	w0, w22
ffffffffea802130:	97fffee6 	bl	ffffffffea801cc8 <platform_tegra_comb_uart_getc>
	if (_c < 0)
ffffffffea802134:	36fffce0 	tbz	w0, #31, ffffffffea8020d0 <platform_dgetc+0x80>
ffffffffea802138:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80213c:	f94017b6 	ldr	x22, [x29, #40]
		return -1;
ffffffffea802140:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea802144:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802148:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80214c:	d65f03c0 	ret
ffffffffea802150:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea802154:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802158:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80215c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea802160:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea802164:	17fffff8 	b	ffffffffea802144 <platform_dgetc+0xf4>
				timed_out = true;
ffffffffea802168:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80216c:	390002c1 	strb	w1, [x22]
		return -1;
ffffffffea802170:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802174:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802178:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80217c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea802180:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea802184:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea802188:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80218c:	d65f03c0 	ret
ffffffffea802190:	f9400bb3 	ldr	x19, [x29, #16]
		return -1;
ffffffffea802194:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea802198:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80219c:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8021a0:	17ffffe9 	b	ffffffffea802144 <platform_dgetc+0xf4>
ffffffffea8021a4:	12800000 	mov	w0, #0xffffffff            	// #-1
}
ffffffffea8021a8:	d65f03c0 	ret
ffffffffea8021ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021b0 <platform_init_debug_port>:

void platform_init_debug_port(unsigned int dbg_port)
{
	debug_port = dbg_port;
ffffffffea8021b0:	f00000a2 	adrp	x2, ffffffffea819000 <_mem_phys_base>
	disable_debug = 1;
}

void platform_enable_debug_intf(void)
{
	disable_debug = 0;
ffffffffea8021b4:	f0000341 	adrp	x1, ffffffffea86d000 <__bss_start>
	debug_port = dbg_port;
ffffffffea8021b8:	b9018040 	str	w0, [x2, #384]
	disable_debug = 0;
ffffffffea8021bc:	b900183f 	str	wzr, [x1, #24]
}
ffffffffea8021c0:	d65f03c0 	ret
ffffffffea8021c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021c8 <platform_disable_debug_intf>:
	disable_debug = 1;
ffffffffea8021c8:	f0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea8021cc:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8021d0:	b9001801 	str	w1, [x0, #24]
}
ffffffffea8021d4:	d65f03c0 	ret

ffffffffea8021d8 <tegra_platform_bootstrap_epilog>:
} platform_state = {
	.bootstrap_done = false,
};

// platform specific hook for epilog
__WEAK void tegra_platform_bootstrap_epilog(void) {}
ffffffffea8021d8:	d65f03c0 	ret
ffffffffea8021dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8021e0 <platform_is_bootstrapping>:
	.ns_dram_map_list_head = LIST_INITIAL_VALUE(platform_ctx.ns_dram_map_list_head)
};

bool platform_is_bootstrapping(void)
{
	return !platform_state.bootstrap_done;
ffffffffea8021e0:	f0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea8021e4:	39408000 	ldrb	w0, [x0, #32]
}
ffffffffea8021e8:	52000000 	eor	w0, w0, #0x1
ffffffffea8021ec:	d65f03c0 	ret

ffffffffea8021f0 <platform_bootstrap_epilog>:
/*
 * Defining a common platform_bootstrap_epilog handler. If platform specific
 * cleanups are required, implement a platform specific epilog handler.
 */
void platform_bootstrap_epilog(void)
{
ffffffffea8021f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	platform_state.bootstrap_done = true;
ffffffffea8021f4:	f0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea8021f8:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea8021fc:	910003fd 	mov	x29, sp
	platform_state.bootstrap_done = true;
ffffffffea802200:	39008001 	strb	w1, [x0, #32]
	tegra_platform_bootstrap_epilog();
ffffffffea802204:	97fffff5 	bl	ffffffffea8021d8 <tegra_platform_bootstrap_epilog>
	 * its impact on boot KPI
	 */
#if !defined(TRUSTY_TARGET_PLATFORM_EMBEDDED)
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
#endif
}
ffffffffea802208:	a8c17bfd 	ldp	x29, x30, [sp], #16
	dprintf(ALWAYS, "%s: trusty bootstrap complete\n", __func__);
ffffffffea80220c:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802210:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802214:	910a4021 	add	x1, x1, #0x290
ffffffffea802218:	910b6000 	add	x0, x0, #0x2d8
ffffffffea80221c:	14004051 	b	ffffffffea812360 <_dprintf>

ffffffffea802220 <platform_arch_speculation_barrier>:

void platform_arch_speculation_barrier(void) {

#if defined(INSERT_SPECULATION_BARRIER)
	mb();
ffffffffea802220:	d5033f9f 	dsb	sy
	ISB;
ffffffffea802224:	d5033fdf 	isb
#endif

	return;
}
ffffffffea802228:	d65f03c0 	ret
ffffffffea80222c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802230 <platform_register_ns_dram_ranges>:

long platform_register_ns_dram_ranges(paddr_t ns_base, uint64_t ns_size)
{
ffffffffea802230:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea802234:	aa0003e5 	mov	x5, x0
ffffffffea802238:	910003fd 	mov	x29, sp
ffffffffea80223c:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea802240:	90000314 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea802244:	f9402a82 	ldr	x2, [x20, #80]
ffffffffea802248:	f9400043 	ldr	x3, [x2]
ffffffffea80224c:	f90037a3 	str	x3, [x29, #104]
ffffffffea802250:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea802254:	f9001bf7 	str	x23, [sp, #48]
#define TOS_NS_MEM_MAP_MAGIC_VALUE (0xfeedbeef)
#define TOS_NS_MEM_MAP_CUR_VERSION (0x1)
	dprintf(SPEW, "%s: ns_base: %lx, ns_size: %llu\n", __func__, ns_base, ns_size);

	/*Register DRAM ranges only once*/
	if (platform_ctx.ns_dram_range_available)
ffffffffea802258:	f00000b7 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea80225c:	394622e0 	ldrb	w0, [x23, #392]
ffffffffea802260:	350010a0 	cbnz	w0, ffffffffea802474 <platform_register_ns_dram_ranges+0x244>
ffffffffea802264:	f9001fb8 	str	x24, [x29, #56]

	offset = ns_base & (PAGE_SIZE - 1);
	aligned_addr = ROUNDDOWN(ns_base, PAGE_SIZE);
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea802268:	90000318 	adrp	x24, ffffffffea862000 <__ctor_list>
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea80226c:	913ffc22 	add	x2, x1, #0xfff
ffffffffea802270:	f9000bb3 	str	x19, [x29, #16]
	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea802274:	f9408700 	ldr	x0, [x24, #264]
	offset = ns_base & (PAGE_SIZE - 1);
ffffffffea802278:	92402cb3 	and	x19, x5, #0xfff
	aligned_size = ROUNDUP(ns_size + offset, PAGE_SIZE);
ffffffffea80227c:	8b130042 	add	x2, x2, x19
	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "cboot",
ffffffffea802280:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802284:	52800707 	mov	w7, #0x38                  	// #56
ffffffffea802288:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80228c:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea802290:	910183a3 	add	x3, x29, #0x60
ffffffffea802294:	910be021 	add	x1, x1, #0x2f8
ffffffffea802298:	9274cca5 	and	x5, x5, #0xfffffffffffff000
ffffffffea80229c:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea8022a0:	94003e56 	bl	ffffffffea811bf8 <vmm_alloc_physical>
ffffffffea8022a4:	93407c15 	sxtw	x21, w0
			aligned_size, (void **)&vptr, PAGE_SIZE_SHIFT,
			aligned_addr, 0,
			ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
			ARCH_MMU_FLAG_CACHED | ARCH_MMU_FLAG_PERM_RO);

	if (ret != NO_ERROR) {
ffffffffea8022a8:	b5000b95 	cbnz	x21, ffffffffea802418 <platform_register_ns_dram_ranges+0x1e8>
				"Trusty may fail to validate NS DRAM ranges\n"
				, __func__);
		return ret;
	}

	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea8022ac:	f94033a1 	ldr	x1, [x29, #96]

	/* Memory sanitization check */
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea8022b0:	5297dde2 	mov	w2, #0xbeef                	// #48879
ffffffffea8022b4:	72bfdda2 	movk	w2, #0xfeed, lsl #16
ffffffffea8022b8:	b8736823 	ldr	w3, [x1, x19]
ffffffffea8022bc:	f90017b6 	str	x22, [x29, #40]
	ns_mem_map = (tos_ns_mem_map_t *) (vptr + offset);
ffffffffea8022c0:	8b130036 	add	x22, x1, x19
	if (ns_mem_map->magic != TOS_NS_MEM_MAP_MAGIC_VALUE) {
ffffffffea8022c4:	6b02007f 	cmp	w3, w2
ffffffffea8022c8:	540007c1 	b.ne	ffffffffea8023c0 <platform_register_ns_dram_ranges+0x190>  // b.any
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	/* Check supported API version */
	if (ns_mem_map->ver != TOS_NS_MEM_MAP_CUR_VERSION) {
ffffffffea8022cc:	b94006c3 	ldr	w3, [x22, #4]
ffffffffea8022d0:	7100047f 	cmp	w3, #0x1
ffffffffea8022d4:	54000b21 	b.ne	ffffffffea802438 <platform_register_ns_dram_ranges+0x208>  // b.any
				ns_mem_map->ver);
		ret = ERR_INVALID_ARGS;
		goto lbl_free_vmm;
	}

	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea8022d8:	b9400ac0 	ldr	w0, [x22, #8]
ffffffffea8022dc:	a9046bb9 	stp	x25, x26, [x29, #64]

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
	item->prev = list->prev;
ffffffffea8022e0:	910622f9 	add	x25, x23, #0x188
ffffffffea8022e4:	a90573bb 	stp	x27, x28, [x29, #80]
	item->next = list;
ffffffffea8022e8:	9100233a 	add	x26, x25, #0x8
ffffffffea8022ec:	5280001c 	mov	w28, #0x0                   	// #0
					"Trusty may fail to validate NS DRAM ranges\n",
					__func__);
			ret = ERR_NO_MEMORY;
			goto err_free_dram_map;
		}
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea8022f0:	d28001db 	mov	x27, #0xe                   	// #14
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea8022f4:	350001e0 	cbnz	w0, ffffffffea802330 <platform_register_ns_dram_ranges+0x100>
ffffffffea8022f8:	1400005a 	b	ffffffffea802460 <platform_register_ns_dram_ranges+0x230>
		memcpy(&dram_map_node->ns_dram_entry, &ns_mem_map->mappings[map_index],
ffffffffea8022fc:	8b3c5361 	add	x1, x27, w28, uxtw #4
ffffffffea802300:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea802304:	8b0102c1 	add	x1, x22, x1
ffffffffea802308:	940046b0 	bl	ffffffffea813dc8 <memcpy>
	item->prev = list->prev;
ffffffffea80230c:	f9400720 	ldr	x0, [x25, #8]
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802310:	1100079c 	add	w28, w28, #0x1
ffffffffea802314:	b9400ac1 	ldr	w1, [x22, #8]
	item->next = list;
ffffffffea802318:	a9016a60 	stp	x0, x26, [x19, #16]
		dprintf(SPEW, "%s: base: %llx size: %llu entry size: %zu\n", __func__,
				dram_map_node->ns_dram_entry.base,
				dram_map_node->ns_dram_entry.size,
				sizeof(tos_ns_mem_map_entry_t));

		list_add_tail(&platform_ctx.ns_dram_map_list_head, &dram_map_node->node);
ffffffffea80231c:	91004273 	add	x19, x19, #0x10
	list->prev->next = item;
ffffffffea802320:	f9000413 	str	x19, [x0, #8]
	for (map_index = 0; map_index < ns_mem_map->num; map_index++) {
ffffffffea802324:	6b1c003f 	cmp	w1, w28
	list->prev = item;
ffffffffea802328:	f9000733 	str	x19, [x25, #8]
ffffffffea80232c:	54000989 	b.ls	ffffffffea80245c <platform_register_ns_dram_ranges+0x22c>  // b.plast
		tos_ns_dram_map_node_t *dram_map_node = calloc(1, sizeof(tos_ns_dram_map_node_t));
ffffffffea802330:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea802334:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea802338:	94004692 	bl	ffffffffea813d80 <calloc>
ffffffffea80233c:	aa0003f3 	mov	x19, x0
		if (NULL == dram_map_node) {
ffffffffea802340:	b5fffde0 	cbnz	x0, ffffffffea8022fc <platform_register_ns_dram_ranges+0xcc>

	platform_ctx.ns_dram_range_available = true;

	if (0) {
err_free_dram_map:
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea802344:	910622f7 	add	x23, x23, #0x188
			dprintf(CRITICAL, "%s: FATAL: unable to allocate memory. "
ffffffffea802348:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80234c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802350:	910ac021 	add	x1, x1, #0x2b0
ffffffffea802354:	9110e000 	add	x0, x0, #0x438
ffffffffea802358:	94004002 	bl	ffffffffea812360 <_dprintf>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea80235c:	f9400ae0 	ldr	x0, [x23, #16]
ffffffffea802360:	910022f5 	add	x21, x23, #0x8
ffffffffea802364:	d1004001 	sub	x1, x0, #0x10
ffffffffea802368:	eb15001f 	cmp	x0, x21
ffffffffea80236c:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea802370:	d1004053 	sub	x19, x2, #0x10
ffffffffea802374:	540001c0 	b.eq	ffffffffea8023ac <platform_register_ns_dram_ranges+0x17c>  // b.none

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
	item->next->prev = item->prev;
ffffffffea802378:	f9400823 	ldr	x3, [x1, #16]
				tmp_map_node, tos_ns_dram_map_node_t, node) {
			list_delete(&map_node->node);
			free(map_node);
ffffffffea80237c:	aa0103e0 	mov	x0, x1
ffffffffea802380:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea802384:	f9400823 	ldr	x3, [x1, #16]
ffffffffea802388:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea80238c:	a9017c3f 	stp	xzr, xzr, [x1, #16]
ffffffffea802390:	9400468c 	bl	ffffffffea813dc0 <free>
		list_for_every_entry_safe (&platform_ctx.ns_dram_map_list_head, map_node,
ffffffffea802394:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea802398:	91004260 	add	x0, x19, #0x10
ffffffffea80239c:	aa1303e1 	mov	x1, x19
ffffffffea8023a0:	eb15001f 	cmp	x0, x21
ffffffffea8023a4:	d1004053 	sub	x19, x2, #0x10
ffffffffea8023a8:	54fffe81 	b.ne	ffffffffea802378 <platform_register_ns_dram_ranges+0x148>  // b.any
			ret = ERR_NO_MEMORY;
ffffffffea8023ac:	92800095 	mov	x21, #0xfffffffffffffffb    	// #-5
ffffffffea8023b0:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea8023b4:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8023b8:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea8023bc:	14000008 	b	ffffffffea8023dc <platform_register_ns_dram_ranges+0x1ac>
		dprintf(CRITICAL, "%s: FATAL: unable to locate magic value "
ffffffffea8023c0:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8023c4:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8023c8:	910ac021 	add	x1, x1, #0x2b0
ffffffffea8023cc:	910d6000 	add	x0, x0, #0x358
ffffffffea8023d0:	94003fe4 	bl	ffffffffea812360 <_dprintf>
		ret = ERR_INVALID_ARGS;
ffffffffea8023d4:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea8023d8:	f94033a1 	ldr	x1, [x29, #96]
			map_node = NULL;
		}
	}
lbl_free_vmm:
	vmm_free_region(vmm_get_kernel_aspace(), vptr);
ffffffffea8023dc:	f9408700 	ldr	x0, [x24, #264]
ffffffffea8023e0:	94003e68 	bl	ffffffffea811d80 <vmm_free_region>
	return ret;
ffffffffea8023e4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8023e8:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8023ec:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea8023f0:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea8023f4:	aa1503e0 	mov	x0, x21
ffffffffea8023f8:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8023fc:	f9400281 	ldr	x1, [x20]
ffffffffea802400:	ca010041 	eor	x1, x2, x1
ffffffffea802404:	b50003c1 	cbnz	x1, ffffffffea80247c <platform_register_ns_dram_ranges+0x24c>
ffffffffea802408:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80240c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea802410:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea802414:	d65f03c0 	ret
		dprintf(CRITICAL, "%s: FATAL: unable to map shared memory. "
ffffffffea802418:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80241c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802420:	910ac021 	add	x1, x1, #0x2b0
ffffffffea802424:	910c0000 	add	x0, x0, #0x300
ffffffffea802428:	94003fce 	bl	ffffffffea812360 <_dprintf>
		return ret;
ffffffffea80242c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea802430:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea802434:	17ffffef 	b	ffffffffea8023f0 <platform_register_ns_dram_ranges+0x1c0>
		dprintf(CRITICAL, "%s: FATAL: unsupported version "
ffffffffea802438:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80243c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802440:	910ac021 	add	x1, x1, #0x2b0
ffffffffea802444:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea802448:	910f4000 	add	x0, x0, #0x3d0
ffffffffea80244c:	94003fc5 	bl	ffffffffea812360 <_dprintf>
		ret = ERR_INVALID_ARGS;
ffffffffea802450:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea802454:	f94033a1 	ldr	x1, [x29, #96]
		goto lbl_free_vmm;
ffffffffea802458:	17ffffe1 	b	ffffffffea8023dc <platform_register_ns_dram_ranges+0x1ac>
ffffffffea80245c:	f94033a1 	ldr	x1, [x29, #96]
	platform_ctx.ns_dram_range_available = true;
ffffffffea802460:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea802464:	390622e0 	strb	w0, [x23, #392]
lbl_free_vmm:
ffffffffea802468:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80246c:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea802470:	17ffffdb 	b	ffffffffea8023dc <platform_register_ns_dram_ranges+0x1ac>
		return ERR_ALREADY_EXISTS;
ffffffffea802474:	928001b5 	mov	x21, #0xfffffffffffffff2    	// #-14
ffffffffea802478:	17ffffde 	b	ffffffffea8023f0 <platform_register_ns_dram_ranges+0x1c0>
ffffffffea80247c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea802480:	f90017b6 	str	x22, [x29, #40]
ffffffffea802484:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea802488:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80248c:	f9002fbc 	str	x28, [x29, #88]
}
ffffffffea802490:	94004626 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea802494:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802498 <platform_is_denver_cpu>:
 * - Returns true if the cpu is Denver (or Carmel)
 * - Returns false otherwise
 */
bool platform_is_denver_cpu(void)
{
	uint64_t midr = ARM64_READ_SYSREG(midr_el1);
ffffffffea802498:	d5380000 	mrs	x0, midr_el1
	uint64_t impl = (midr >> MIDR_IMPL_SHIFT) & MIDR_IMPL_MASK;
ffffffffea80249c:	53187c00 	lsr	w0, w0, #24

	if (impl == DENVER_IMPL)
ffffffffea8024a0:	f101381f 	cmp	x0, #0x4e
		return true;
	else
		return false;
}
ffffffffea8024a4:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea8024a8:	d65f03c0 	ret
ffffffffea8024ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8024b0 <ioctl_map_eks_to_user>:
{
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

int32_t ioctl_map_eks_to_user(ioctl_map_eks_params p)
{
ffffffffea8024b0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
ffffffffea8024b4:	910003fd 	mov	x29, sp
ffffffffea8024b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8024bc:	90000313 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea8024c0:	aa0003f4 	mov	x20, x0
ffffffffea8024c4:	f90013f5 	str	x21, [sp, #32]
ffffffffea8024c8:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea8024cc:	aa0103f5 	mov	x21, x1
ffffffffea8024d0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea8024d4:	d360fc37 	lsr	x23, x1, #32
ffffffffea8024d8:	f90023f9 	str	x25, [sp, #64]
ffffffffea8024dc:	f9400001 	ldr	x1, [x0]
ffffffffea8024e0:	f9004fa1 	str	x1, [x29, #152]
ffffffffea8024e4:	d2800001 	mov	x1, #0x0                   	// #0
}

/* use the cpu local thread context pointer to store current_thread */
static inline struct thread *get_current_thread(void)
{
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8024e8:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea8024ec:	f9415800 	ldr	x0, [x0, #688]
ffffffffea8024f0:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea8024f4:	2a1403e1 	mov	w1, w20
ffffffffea8024f8:	94004ab8 	bl	ffffffffea814fd8 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)p.eks_addr_ptr, sizeof(uint32_t)))
ffffffffea8024fc:	72001c1f 	tst	w0, #0xff
ffffffffea802500:	54000da0 	b.eq	ffffffffea8026b4 <ioctl_map_eks_to_user+0x204>  // b.none
ffffffffea802504:	f90017b6 	str	x22, [x29, #40]
ffffffffea802508:	d360fe96 	lsr	x22, x20, #32
ffffffffea80250c:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802510:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802514:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802518:	aa1603e1 	mov	x1, x22
ffffffffea80251c:	94004aaf 	bl	ffffffffea814fd8 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.eks_size_ptr, sizeof(uint32_t)))
ffffffffea802520:	72001c1f 	tst	w0, #0xff
ffffffffea802524:	54000c60 	b.eq	ffffffffea8026b0 <ioctl_map_eks_to_user+0x200>  // b.none
ffffffffea802528:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea80252c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802530:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802534:	2a1503e1 	mov	w1, w21
ffffffffea802538:	94004aa8 	bl	ffffffffea814fd8 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_addr_ptr, sizeof(uint32_t)))
ffffffffea80253c:	72001c1f 	tst	w0, #0xff
ffffffffea802540:	54000b80 	b.eq	ffffffffea8026b0 <ioctl_map_eks_to_user+0x200>  // b.none
ffffffffea802544:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea802548:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80254c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802550:	aa1703e1 	mov	x1, x23
ffffffffea802554:	94004aa1 	bl	ffffffffea814fd8 <uthread_is_valid_range>
		return ERR_INVALID_ARGS;
	if (!valid_address((vaddr_t)p.map_size_ptr, sizeof(uint32_t)))
ffffffffea802558:	72001c1f 	tst	w0, #0xff
ffffffffea80255c:	54000aa0 	b.eq	ffffffffea8026b0 <ioctl_map_eks_to_user+0x200>  // b.none
		return ERR_INVALID_ARGS;

	status_t ret = NO_ERROR;
	eks_info_t info = {0};
ffffffffea802560:	a908ffbf 	stp	xzr, xzr, [x29, #136]

	/*
	 * Get eks struct's physical address and length
	 * saved in kernel context
	 */
	ret = get_and_clear_eks_info(&info);
ffffffffea802564:	910223a0 	add	x0, x29, #0x88
ffffffffea802568:	97fffddc 	bl	ffffffffea801cd8 <get_and_clear_eks_info>
ffffffffea80256c:	2a0003f9 	mov	w25, w0
	if (ret != NO_ERROR) {
ffffffffea802570:	35000920 	cbnz	w0, ffffffffea802694 <ioctl_map_eks_to_user+0x1e4>
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
		return ret;
	}
	if (info.paddr == NULL) {
ffffffffea802574:	f94047a0 	ldr	x0, [x29, #136]
ffffffffea802578:	b4000a20 	cbz	x0, ffffffffea8026bc <ioctl_map_eks_to_user+0x20c>
ffffffffea80257c:	f9001fb8 	str	x24, [x29, #56]
ffffffffea802580:	a904efba 	stp	x26, x27, [x29, #72]
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
		return ERR_NOT_ALLOWED;
	}

	/* map to userspace */
	vaddr_t vaddr = 0U;
ffffffffea802584:	f90033bf 	str	xzr, [x29, #96]
ffffffffea802588:	d538d081 	mrs	x1, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea80258c:	f9415821 	ldr	x1, [x1, #688]

	paddr_t paddr = ROUNDDOWN((paddr_t)info.paddr, PAGE_SIZE);
ffffffffea802590:	9274cc1b 	and	x27, x0, #0xfffffffffffff000
	size_t offset = (paddr_t)info.paddr - paddr;
ffffffffea802594:	cb1b0018 	sub	x24, x0, x27
ffffffffea802598:	910283a2 	add	x2, x29, #0xa0
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea80259c:	b94093a3 	ldr	w3, [x29, #144]
static inline __ALWAYS_INLINE
status_t uthread_map_contig(uthread_t *ut, vaddr_t *vaddrp, paddr_t paddr,
		size_t size, u_int flags, u_int align)
{
	flags = flags | UTM_PHYS_CONTIG;
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea8025a0:	910183ba 	add	x26, x29, #0x60
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea8025a4:	f9404820 	ldr	x0, [x1, #144]
ffffffffea8025a8:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea8025ac:	f81e0c5b 	str	x27, [x2, #-32]!
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8025b0:	913ffc63 	add	x3, x3, #0xfff
ffffffffea8025b4:	8b180063 	add	x3, x3, x24
ffffffffea8025b8:	52800c24 	mov	w4, #0x61                  	// #97

	ret = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea8025bc:	f9402c00 	ldr	x0, [x0, #88]
	size_t size = ROUNDUP(info.blob_length + offset, PAGE_SIZE);
ffffffffea8025c0:	9274cc63 	and	x3, x3, #0xfffffffffffff000
ffffffffea8025c4:	aa1a03e1 	mov	x1, x26
ffffffffea8025c8:	f90037a3 	str	x3, [x29, #104]
ffffffffea8025cc:	940048b9 	bl	ffffffffea8148b0 <uthread_map>
ffffffffea8025d0:	2a0003f9 	mov	w25, w0
			paddr, size,
			(uint32_t)UTM_R | (uint32_t)UTM_NS_MEM,
			UT_MAP_ALIGN_4KB);

	if (ret != NO_ERROR) {
ffffffffea8025d4:	350004a0 	cbnz	w0, ffffffffea802668 <ioctl_map_eks_to_user+0x1b8>
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
			(unsigned int)paddr, (unsigned int)size);
		return ret;
	}

	key_params* keys_params = (key_params *)(vaddr + offset);
ffffffffea8025d8:	f94033a4 	ldr	x4, [x29, #96]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea8025dc:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea8025e0:	9101c3a1 	add	x1, x29, #0x70
ffffffffea8025e4:	2a1403e0 	mov	w0, w20
ffffffffea8025e8:	8b040303 	add	x3, x24, x4
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea8025ec:	b8646b04 	ldr	w4, [x24, x4]
	vaddr_t key_string_addr = (vaddr_t)keys_params->encrypted_keys;
ffffffffea8025f0:	8b020063 	add	x3, x3, x2
	vaddr_t key_size = keys_params->encrypted_key_sz;
ffffffffea8025f4:	a90713a3 	stp	x3, x4, [x29, #112]
ffffffffea8025f8:	94004766 	bl	ffffffffea814390 <arch_copy_to_user>
ffffffffea8025fc:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802600:	9101e3a1 	add	x1, x29, #0x78
ffffffffea802604:	2a1603e0 	mov	w0, w22
ffffffffea802608:	94004762 	bl	ffffffffea814390 <arch_copy_to_user>
ffffffffea80260c:	aa1a03e1 	mov	x1, x26
ffffffffea802610:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802614:	2a1503e0 	mov	w0, w21
ffffffffea802618:	9400475e 	bl	ffffffffea814390 <arch_copy_to_user>
ffffffffea80261c:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea802620:	9101a3a1 	add	x1, x29, #0x68
ffffffffea802624:	2a1703e0 	mov	w0, w23
ffffffffea802628:	9400475a 	bl	ffffffffea814390 <arch_copy_to_user>
ffffffffea80262c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea802630:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea802634:	a944efba 	ldp	x26, x27, [x29, #72]
	copy_to_user((user_addr_t)p.eks_size_ptr, &key_size, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_addr_ptr, &vaddr, sizeof(uint32_t));
	copy_to_user((user_addr_t)p.map_size_ptr, &size, sizeof(uint32_t));

	return NO_ERROR;
}
ffffffffea802638:	2a1903e0 	mov	w0, w25
ffffffffea80263c:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea802640:	f9404fa2 	ldr	x2, [x29, #152]
ffffffffea802644:	f9400261 	ldr	x1, [x19]
ffffffffea802648:	ca010041 	eor	x1, x2, x1
ffffffffea80264c:	b5000481 	cbnz	x1, ffffffffea8026dc <ioctl_map_eks_to_user+0x22c>
ffffffffea802650:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802654:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea802658:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80265c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea802660:	a8ca7bfd 	ldp	x29, x30, [sp], #160
ffffffffea802664:	d65f03c0 	ret
		dprintf(CRITICAL, "%s error: failed to map eks physical address: %x, %u\n", __func__,
ffffffffea802668:	b9406ba3 	ldr	w3, [x29, #104]
ffffffffea80266c:	2a1b03e2 	mov	w2, w27
ffffffffea802670:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802674:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802678:	91128021 	add	x1, x1, #0x4a0
ffffffffea80267c:	91146000 	add	x0, x0, #0x518
ffffffffea802680:	94003f38 	bl	ffffffffea812360 <_dprintf>
		return ret;
ffffffffea802684:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea802688:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80268c:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea802690:	17ffffea 	b	ffffffffea802638 <ioctl_map_eks_to_user+0x188>
		dprintf(CRITICAL, "%s: ERROR: failed to retrieve eks info from kernel\n", __func__);
ffffffffea802694:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802698:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80269c:	91128021 	add	x1, x1, #0x4a0
ffffffffea8026a0:	9112e000 	add	x0, x0, #0x4b8
ffffffffea8026a4:	94003f2f 	bl	ffffffffea812360 <_dprintf>
		return ret;
ffffffffea8026a8:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8026ac:	17ffffe3 	b	ffffffffea802638 <ioctl_map_eks_to_user+0x188>
ffffffffea8026b0:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_INVALID_ARGS;
ffffffffea8026b4:	128000f9 	mov	w25, #0xfffffff8            	// #-8
ffffffffea8026b8:	17ffffe0 	b	ffffffffea802638 <ioctl_map_eks_to_user+0x188>
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea8026bc:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8026c0:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8026c4:	91128021 	add	x1, x1, #0x4a0
ffffffffea8026c8:	9113c000 	add	x0, x0, #0x4f0
		return ERR_NOT_ALLOWED;
ffffffffea8026cc:	12800219 	mov	w25, #0xffffffef            	// #-17
		dprintf(CRITICAL, "%s: ERROR: ioctl called more than once\n", __func__);
ffffffffea8026d0:	94003f24 	bl	ffffffffea812360 <_dprintf>
		return ERR_NOT_ALLOWED;
ffffffffea8026d4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8026d8:	17ffffd8 	b	ffffffffea802638 <ioctl_map_eks_to_user+0x188>
ffffffffea8026dc:	f90017b6 	str	x22, [x29, #40]
ffffffffea8026e0:	f9001fb8 	str	x24, [x29, #56]
ffffffffea8026e4:	a904efba 	stp	x26, x27, [x29, #72]
}
ffffffffea8026e8:	94004590 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8026ec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8026f0 <sys_std_platform_ioctl_partner>:
}

int32_t sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr);

int32_t __WEAK sys_std_platform_ioctl_partner(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea8026f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea8026f4:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8026f8:	91162000 	add	x0, x0, #0x588
{
ffffffffea8026fc:	910003fd 	mov	x29, sp
	dprintf(ALWAYS, "Unsupported IOCTL request: %d\n", cmd);
ffffffffea802700:	94003f18 	bl	ffffffffea812360 <_dprintf>
	return ERR_NOT_SUPPORTED;
}
ffffffffea802704:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea802708:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80270c:	d65f03c0 	ret

ffffffffea802710 <sys_std_platform_ioctl>:

int32_t sys_std_platform_ioctl(uint32_t fd, uint32_t cmd, user_addr_t user_ptr)
{
ffffffffea802710:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int32_t ret = 0;
	DEBUG_ASSERT( fd == 3 ); // sys_fd of ioctl

	switch ( cmd ) {
ffffffffea802714:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea802718:	72a40003 	movk	w3, #0x2000, lsl #16
ffffffffea80271c:	6b03003f 	cmp	w1, w3
{
ffffffffea802720:	910003fd 	mov	x29, sp
ffffffffea802724:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802728:	90000313 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80272c:	f9402a63 	ldr	x3, [x19, #80]
ffffffffea802730:	f9400064 	ldr	x4, [x3]
ffffffffea802734:	f9001fa4 	str	x4, [x29, #56]
ffffffffea802738:	d2800004 	mov	x4, #0x0                   	// #0
	switch ( cmd ) {
ffffffffea80273c:	54000481 	b.ne	ffffffffea8027cc <sys_std_platform_ioctl+0xbc>  // b.any
ffffffffea802740:	f9000fb4 	str	x20, [x29, #24]
ffffffffea802744:	2a0203f4 	mov	w20, w2
ffffffffea802748:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea80274c:	f9415800 	ldr	x0, [x0, #688]
ffffffffea802750:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea802754:	2a1403e1 	mov	w1, w20
ffffffffea802758:	94004a20 	bl	ffffffffea814fd8 <uthread_is_valid_range>
		case IOCTL_MAP_EKS_TO_USER:

			if (!valid_address((vaddr_t)user_ptr,
ffffffffea80275c:	72001c1f 	tst	w0, #0xff
ffffffffea802760:	54000201 	b.ne	ffffffffea8027a0 <sys_std_platform_ioctl+0x90>  // b.any
					sizeof(ioctl_map_eks_params))) {
				dprintf(CRITICAL, "%s error: Invalid arguments\n",
ffffffffea802764:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802768:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80276c:	91154021 	add	x1, x1, #0x550
ffffffffea802770:	9115a000 	add	x0, x0, #0x568
ffffffffea802774:	94003efb 	bl	ffffffffea812360 <_dprintf>
						__func__);
				return ERR_INVALID_ARGS;
ffffffffea802778:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80277c:	128000e0 	mov	w0, #0xfffffff8            	// #-8

		default:
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
        }
	return ret;
}
ffffffffea802780:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea802784:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea802788:	f9400261 	ldr	x1, [x19]
ffffffffea80278c:	ca010041 	eor	x1, x2, x1
ffffffffea802790:	b5000321 	cbnz	x1, ffffffffea8027f4 <sys_std_platform_ioctl+0xe4>
ffffffffea802794:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802798:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80279c:	d65f03c0 	ret
			if (!platform_is_bootstrapping()) {
ffffffffea8027a0:	97fffe90 	bl	ffffffffea8021e0 <platform_is_bootstrapping>
ffffffffea8027a4:	72001c1f 	tst	w0, #0xff
ffffffffea8027a8:	54000161 	b.ne	ffffffffea8027d4 <sys_std_platform_ioctl+0xc4>  // b.any
				dprintf(CRITICAL, "%s: ERROR: Not allowed after boot\n",
ffffffffea8027ac:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8027b0:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8027b4:	91154021 	add	x1, x1, #0x550
ffffffffea8027b8:	91066000 	add	x0, x0, #0x198
ffffffffea8027bc:	94003ee9 	bl	ffffffffea812360 <_dprintf>
				return ERR_NOT_ALLOWED;
ffffffffea8027c0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8027c4:	12800200 	mov	w0, #0xffffffef            	// #-17
ffffffffea8027c8:	17ffffee 	b	ffffffffea802780 <sys_std_platform_ioctl+0x70>
			ret = sys_std_platform_ioctl_partner(fd, cmd, user_ptr);
ffffffffea8027cc:	97ffffc9 	bl	ffffffffea8026f0 <sys_std_platform_ioctl_partner>
	return ret;
ffffffffea8027d0:	17ffffec 	b	ffffffffea802780 <sys_std_platform_ioctl+0x70>
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea8027d4:	2a1403e1 	mov	w1, w20
ffffffffea8027d8:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8027dc:	9100a3a0 	add	x0, x29, #0x28
ffffffffea8027e0:	940046f4 	bl	ffffffffea8143b0 <arch_copy_from_user>
			return ioctl_map_eks_to_user(params);
ffffffffea8027e4:	a94287a0 	ldp	x0, x1, [x29, #40]
ffffffffea8027e8:	97ffff32 	bl	ffffffffea8024b0 <ioctl_map_eks_to_user>
ffffffffea8027ec:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8027f0:	17ffffe4 	b	ffffffffea802780 <sys_std_platform_ioctl+0x70>
ffffffffea8027f4:	f9000fb4 	str	x20, [x29, #24]
}
ffffffffea8027f8:	9400454c 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8027fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802800 <trusty_hyp_check_guest_pa_valid>:
	(void) buf_pa_start;
	(void) buf_size;
	(void) guest;

	return NO_ERROR;
}
ffffffffea802800:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea802804:	d65f03c0 	ret

ffffffffea802808 <trusty_hyp_check_guest_access>:
{
	(void) guest;
	(void) peer;

	return NO_ERROR;
}
ffffffffea802808:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80280c:	d65f03c0 	ret

ffffffffea802810 <arm64_context_switch>:
#include <arch/asm_macros.h>

/* void arm64_context_switch(vaddr_t *old_sp, vaddr_t new_sp); */
FUNCTION(arm64_context_switch)
    /* save old frame */
    push x28, x29
ffffffffea802810:	a9bf77fc 	stp	x28, x29, [sp, #-16]!
    push x26, x27
ffffffffea802814:	a9bf6ffa 	stp	x26, x27, [sp, #-16]!
    push x24, x25
ffffffffea802818:	a9bf67f8 	stp	x24, x25, [sp, #-16]!
    push x22, x23
ffffffffea80281c:	a9bf5ff6 	stp	x22, x23, [sp, #-16]!
    push x20, x21
ffffffffea802820:	a9bf57f4 	stp	x20, x21, [sp, #-16]!
    push x18, x19
ffffffffea802824:	a9bf4ff2 	stp	x18, x19, [sp, #-16]!
    str  x30, [sp,#-8]!
ffffffffea802828:	f81f8ffe 	str	x30, [sp, #-8]!

    /* save old sp */
    mov  x15, sp
ffffffffea80282c:	910003ef 	mov	x15, sp
    str  x15, [x0]
ffffffffea802830:	f900000f 	str	x15, [x0]

    /* load new sp */
    mov  sp, x1
ffffffffea802834:	9100003f 	mov	sp, x1

    /* restore new frame */
    ldr  x30, [sp], #8
ffffffffea802838:	f84087fe 	ldr	x30, [sp], #8
    pop  x18, x19
ffffffffea80283c:	a8c14ff2 	ldp	x18, x19, [sp], #16
    pop  x20, x21
ffffffffea802840:	a8c157f4 	ldp	x20, x21, [sp], #16
    pop  x22, x23
ffffffffea802844:	a8c15ff6 	ldp	x22, x23, [sp], #16
    pop  x24, x25
ffffffffea802848:	a8c167f8 	ldp	x24, x25, [sp], #16
    pop  x26, x27
ffffffffea80284c:	a8c16ffa 	ldp	x26, x27, [sp], #16
    pop  x28, x29
ffffffffea802850:	a8c177fc 	ldp	x28, x29, [sp], #16

    ret
ffffffffea802854:	d65f03c0 	ret

ffffffffea802858 <arm64_el3_to_el1>:

FUNCTION(arm64_el3_to_el1)
    /* set EL2 to 64bit */
    mrs x0, scr_el3
ffffffffea802858:	d53e1100 	mrs	x0, scr_el3
    orr x0, x0, #(1<<10)
ffffffffea80285c:	b2760000 	orr	x0, x0, #0x400
    msr scr_el3, x0
ffffffffea802860:	d51e1100 	msr	scr_el3, x0

    /* set EL1 to 64bit */
    mov x0, #(1<<31)
ffffffffea802864:	d2b00000 	mov	x0, #0x80000000            	// #2147483648
    msr hcr_el2, x0
ffffffffea802868:	d51c1100 	msr	hcr_el2, x0

    /* disable EL2 coprocessor traps */
    mov x0, #0x33ff
ffffffffea80286c:	d2867fe0 	mov	x0, #0x33ff                	// #13311
    msr cptr_el2, x0
ffffffffea802870:	d51c1140 	msr	cptr_el2, x0

    /* disable EL1 FPU traps */
    mov x0, #(0b11<<20)
ffffffffea802874:	d2a00600 	mov	x0, #0x300000              	// #3145728
    msr cpacr_el1, x0
ffffffffea802878:	d5181040 	msr	cpacr_el1, x0

    /* set up the EL1 bounce interrupt */
    mov x0, sp
ffffffffea80287c:	910003e0 	mov	x0, sp
    msr sp_el1, x0
ffffffffea802880:	d51c4100 	msr	sp_el1, x0

    adr x0, .Ltarget
ffffffffea802884:	10000100 	adr	x0, ffffffffea8028a4 <arm64_el3_to_el1+0x4c>
    msr elr_el3, x0
ffffffffea802888:	d51e4020 	msr	elr_el3, x0

    mov x0, #((0b1111 << 6) | (0b0101)) /* EL1h runlevel */
ffffffffea80288c:	d28078a0 	mov	x0, #0x3c5                 	// #965
    msr spsr_el3, x0
ffffffffea802890:	d51e4000 	msr	spsr_el3, x0
    isb
ffffffffea802894:	d5033fdf 	isb

    exception_return
ffffffffea802898:	d69f03e0 	eret
ffffffffea80289c:	d503379f 	dsb	nsh
ffffffffea8028a0:	d5033fdf 	isb

.Ltarget:
    ret
ffffffffea8028a4:	d65f03c0 	ret

ffffffffea8028a8 <arch_spin_trylock>:
#include <asm.h>

.text

FUNCTION(arch_spin_trylock)
	mov	x2, x0
ffffffffea8028a8:	aa0003e2 	mov	x2, x0
	mov	x1, #1
ffffffffea8028ac:	d2800021 	mov	x1, #0x1                   	// #1
	ldaxr	x0, [x2]
ffffffffea8028b0:	c85ffc40 	ldaxr	x0, [x2]
	cbnz	x0, 1f
ffffffffea8028b4:	b5000040 	cbnz	x0, ffffffffea8028bc <arch_spin_trylock+0x14>
	stxr	w0, x1, [x2]
ffffffffea8028b8:	c8007c41 	stxr	w0, x1, [x2]
1:
	ret
ffffffffea8028bc:	d65f03c0 	ret

ffffffffea8028c0 <arch_spin_lock>:

FUNCTION(arch_spin_lock)
	mov	x1, #1
ffffffffea8028c0:	d2800021 	mov	x1, #0x1                   	// #1
	sevl
ffffffffea8028c4:	d50320bf 	sevl
1:
	wfe
ffffffffea8028c8:	d503205f 	wfe
	ldaxr	x2, [x0]
ffffffffea8028cc:	c85ffc02 	ldaxr	x2, [x0]
	cbnz	x2, 1b
ffffffffea8028d0:	b5ffffc2 	cbnz	x2, ffffffffea8028c8 <arch_spin_lock+0x8>
	stxr	w2, x1, [x0]
ffffffffea8028d4:	c8027c01 	stxr	w2, x1, [x0]
	cbnz	w2, 1b
ffffffffea8028d8:	35ffff82 	cbnz	w2, ffffffffea8028c8 <arch_spin_lock+0x8>
	ret
ffffffffea8028dc:	d65f03c0 	ret

ffffffffea8028e0 <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
	stlr	xzr, [x0]
ffffffffea8028e0:	c89ffc1f 	stlr	xzr, [x0]
	ret
ffffffffea8028e4:	d65f03c0 	ret

ffffffffea8028e8 <arch_clean_cache_range>:
    dsb     sy
.endm

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range)
    cache_range_op dc cvac         // clean cache to PoC by MVA
ffffffffea8028e8:	8b010002 	add	x2, x0, x1
ffffffffea8028ec:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea8028f0:	d50b7a23 	dc	cvac, x3
ffffffffea8028f4:	91008063 	add	x3, x3, #0x20
ffffffffea8028f8:	eb02007f 	cmp	x3, x2
ffffffffea8028fc:	54ffffa3 	b.cc	ffffffffea8028f0 <arch_clean_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea802900:	d5033f9f 	dsb	sy
    ret
ffffffffea802904:	d65f03c0 	ret

ffffffffea802908 <arch_clean_invalidate_cache_range>:

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range)
    cache_range_op dc civac        // clean & invalidate dcache to PoC by MVA
ffffffffea802908:	8b010002 	add	x2, x0, x1
ffffffffea80290c:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802910:	d50b7e23 	dc	civac, x3
ffffffffea802914:	91008063 	add	x3, x3, #0x20
ffffffffea802918:	eb02007f 	cmp	x3, x2
ffffffffea80291c:	54ffffa3 	b.cc	ffffffffea802910 <arch_clean_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea802920:	d5033f9f 	dsb	sy
    ret
ffffffffea802924:	d65f03c0 	ret

ffffffffea802928 <arch_invalidate_cache_range>:

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range)
    cache_range_op dc ivac         // invalidate dcache to PoC by MVA
ffffffffea802928:	8b010002 	add	x2, x0, x1
ffffffffea80292c:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802930:	d5087623 	dc	ivac, x3
ffffffffea802934:	91008063 	add	x3, x3, #0x20
ffffffffea802938:	eb02007f 	cmp	x3, x2
ffffffffea80293c:	54ffffa3 	b.cc	ffffffffea802930 <arch_invalidate_cache_range+0x8>  // b.lo, b.ul, b.last
ffffffffea802940:	d5033f9f 	dsb	sy
    ret
ffffffffea802944:	d65f03c0 	ret

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range)
    cache_range_op dc cvau         // clean dcache to PoU by MVA
ffffffffea802948:	8b010002 	add	x2, x0, x1
ffffffffea80294c:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea802950:	d50b7b23 	dc	cvau, x3
ffffffffea802954:	91008063 	add	x3, x3, #0x20
ffffffffea802958:	eb02007f 	cmp	x3, x2
ffffffffea80295c:	54ffffa3 	b.cc	ffffffffea802950 <arch_invalidate_cache_range+0x28>  // b.lo, b.ul, b.last
ffffffffea802960:	d5033f9f 	dsb	sy
    cache_range_op ic ivau         // invalidate icache to PoU by MVA
ffffffffea802964:	8b010002 	add	x2, x0, x1
ffffffffea802968:	927be803 	and	x3, x0, #0xffffffffffffffe0
ffffffffea80296c:	d50b7523 	ic	ivau, x3
ffffffffea802970:	91008063 	add	x3, x3, #0x20
ffffffffea802974:	eb02007f 	cmp	x3, x2
ffffffffea802978:	54ffffa3 	b.cc	ffffffffea80296c <arch_invalidate_cache_range+0x44>  // b.lo, b.ul, b.last
ffffffffea80297c:	d5033f9f 	dsb	sy
    ret
ffffffffea802980:	d65f03c0 	ret

ffffffffea802984 <arch_clean_dcache>:

FUNCTION(arch_clean_dcache)
    mrs x9, clidr_el1
ffffffffea802984:	d5390029 	mrs	x9, clidr_el1
    lsl x3, x0, #LEVEL_SHIFT
ffffffffea802988:	d37ff803 	lsl	x3, x0, #1
    sub x10, x3, #2
ffffffffea80298c:	d100086a 	sub	x10, x3, #0x2
    mov x0, #DCCSW
ffffffffea802990:	d2800040 	mov	x0, #0x2                   	// #2
    bl do_dcsw_op
ffffffffea802994:	94000002 	bl	ffffffffea80299c <do_dcsw_op>
    ret
ffffffffea802998:	d65f03c0 	ret

ffffffffea80299c <do_dcsw_op>:
	mov	x10, xzr
	b	do_dcsw_op
	.endm

FUNCTION(do_dcsw_op)
	cbz	x3, exit
ffffffffea80299c:	b40003c3 	cbz	x3, ffffffffea802a14 <exit>
	adr	x14, dcsw_loop_table	// compute inner loop address
ffffffffea8029a0:	100003ce 	adr	x14, ffffffffea802a18 <dcsw_loop_table>
	add	x14, x14, x0, lsl #5	// inner loop is 8x32-bit instructions
ffffffffea8029a4:	8b0015ce 	add	x14, x14, x0, lsl #5
	mov	x0, x9
ffffffffea8029a8:	aa0903e0 	mov	x0, x9
	mov	w8, #1
ffffffffea8029ac:	52800028 	mov	w8, #0x1                   	// #1

ffffffffea8029b0 <loop1>:
loop1:
	add	x2, x10, x10, lsr #1	// work out 3x current cache level
ffffffffea8029b0:	8b4a0542 	add	x2, x10, x10, lsr #1
	lsr	x1, x0, x2		// extract cache type bits from clidr
ffffffffea8029b4:	9ac22401 	lsr	x1, x0, x2
	and	x1, x1, #7		// mask the bits for current cache only
ffffffffea8029b8:	92400821 	and	x1, x1, #0x7
	cmp	x1, #2			// see what cache we have at this level
ffffffffea8029bc:	f100083f 	cmp	x1, #0x2
	b.lt	level_done		// nothing to do if no cache or icache
ffffffffea8029c0:	540001eb 	b.lt	ffffffffea8029fc <level_done>  // b.tstop

	msr	csselr_el1, x10		// select current cache level in csselr
ffffffffea8029c4:	d51a000a 	msr	csselr_el1, x10
	isb				// isb to sych the new cssr&csidr
ffffffffea8029c8:	d5033fdf 	isb
	mrs	x1, ccsidr_el1		// read the new ccsidr
ffffffffea8029cc:	d5390001 	mrs	x1, ccsidr_el1
	and	x2, x1, #7		// extract the length of the cache lines
ffffffffea8029d0:	92400822 	and	x2, x1, #0x7
	add	x2, x2, #4		// add 4 (line length offset)
ffffffffea8029d4:	91001042 	add	x2, x2, #0x4
	ubfx	x4, x1, #3, #10		// maximum way number
ffffffffea8029d8:	d3433024 	ubfx	x4, x1, #3, #10
	clz	w5, w4			// bit position of way size increment
ffffffffea8029dc:	5ac01085 	clz	w5, w4
	lsl	w9, w4, w5		// w9 = aligned max way number
ffffffffea8029e0:	1ac52089 	lsl	w9, w4, w5
	lsl	w16, w8, w5		// w16 = way number loop decrement
ffffffffea8029e4:	1ac52110 	lsl	w16, w8, w5
	orr	w9, w10, w9		// w9 = combine way and cache number
ffffffffea8029e8:	2a090149 	orr	w9, w10, w9
	ubfx	w6, w1, #13, #15	// w6 = max set number
ffffffffea8029ec:	530d6c26 	ubfx	w6, w1, #13, #15
	lsl	w17, w8, w2		// w17 = set number loop decrement
ffffffffea8029f0:	1ac22111 	lsl	w17, w8, w2
	dsb	sy			// barrier before we start this level
ffffffffea8029f4:	d5033f9f 	dsb	sy
	br	x14			// jump to DC operation specific loop
ffffffffea8029f8:	d61f01c0 	br	x14

ffffffffea8029fc <level_done>:

	b	level_done
	.endm

level_done:
	add	x10, x10, #2		// increment cache number
ffffffffea8029fc:	9100094a 	add	x10, x10, #0x2
	cmp	x3, x10
ffffffffea802a00:	eb0a007f 	cmp	x3, x10
	b.gt    loop1
ffffffffea802a04:	54fffd6c 	b.gt	ffffffffea8029b0 <loop1>
	msr	csselr_el1, xzr		// select cache level 0 in csselr
ffffffffea802a08:	d51a001f 	msr	csselr_el1, xzr
	dsb	sy			// barrier to complete final cache operation
ffffffffea802a0c:	d5033f9f 	dsb	sy
	isb
ffffffffea802a10:	d5033fdf 	isb

ffffffffea802a14 <exit>:
exit:
	ret
ffffffffea802a14:	d65f03c0 	ret

ffffffffea802a18 <dcsw_loop_table>:

dcsw_loop_table:
	dcsw_loop isw
ffffffffea802a18:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802a1c <loop3_isw>:
ffffffffea802a1c:	2a07012b 	orr	w11, w9, w7
ffffffffea802a20:	d508764b 	dc	isw, x11
ffffffffea802a24:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a28:	54ffffaa 	b.ge	ffffffffea802a1c <loop3_isw>  // b.tcont
ffffffffea802a2c:	eb100129 	subs	x9, x9, x16
ffffffffea802a30:	54ffff4a 	b.ge	ffffffffea802a18 <dcsw_loop_table>  // b.tcont
ffffffffea802a34:	17fffff2 	b	ffffffffea8029fc <level_done>

ffffffffea802a38 <loop2_cisw>:
	dcsw_loop cisw
ffffffffea802a38:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802a3c <loop3_cisw>:
ffffffffea802a3c:	2a07012b 	orr	w11, w9, w7
ffffffffea802a40:	d5087e4b 	dc	cisw, x11
ffffffffea802a44:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a48:	54ffffaa 	b.ge	ffffffffea802a3c <loop3_cisw>  // b.tcont
ffffffffea802a4c:	eb100129 	subs	x9, x9, x16
ffffffffea802a50:	54ffff4a 	b.ge	ffffffffea802a38 <loop2_cisw>  // b.tcont
ffffffffea802a54:	17ffffea 	b	ffffffffea8029fc <level_done>

ffffffffea802a58 <loop2_csw>:
	dcsw_loop csw
ffffffffea802a58:	1ac220c7 	lsl	w7, w6, w2

ffffffffea802a5c <loop3_csw>:
ffffffffea802a5c:	2a07012b 	orr	w11, w9, w7
ffffffffea802a60:	d5087a4b 	dc	csw, x11
ffffffffea802a64:	6b1100e7 	subs	w7, w7, w17
ffffffffea802a68:	54ffffaa 	b.ge	ffffffffea802a5c <loop3_csw>  // b.tcont
ffffffffea802a6c:	eb100129 	subs	x9, x9, x16
ffffffffea802a70:	54ffff4a 	b.ge	ffffffffea802a58 <loop2_csw>  // b.tcont
ffffffffea802a74:	17ffffe2 	b	ffffffffea8029fc <level_done>

ffffffffea802a78 <dcsw_op_louis>:


FUNCTION(dcsw_op_louis)
	dcsw_op #LOUIS_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802a78:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a7c:	d3555d23 	ubfx	x3, x9, #21, #3
ffffffffea802a80:	d37ff863 	lsl	x3, x3, #1
ffffffffea802a84:	aa1f03ea 	mov	x10, xzr
ffffffffea802a88:	17ffffc5 	b	ffffffffea80299c <do_dcsw_op>

ffffffffea802a8c <dcsw_op_all>:


FUNCTION(dcsw_op_all)
	dcsw_op #LOC_SHIFT, #CLIDR_FIELD_WIDTH, #LEVEL_SHIFT
ffffffffea802a8c:	d5390029 	mrs	x9, clidr_el1
ffffffffea802a90:	d3586923 	ubfx	x3, x9, #24, #3
ffffffffea802a94:	d37ff863 	lsl	x3, x3, #1
ffffffffea802a98:	aa1f03ea 	mov	x10, xzr
ffffffffea802a9c:	17ffffc0 	b	ffffffffea80299c <do_dcsw_op>

ffffffffea802aa0 <dcsw_op_level1>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level1)
	dcsw_op_level #(1 << LEVEL_SHIFT)
ffffffffea802aa0:	d5390029 	mrs	x9, clidr_el1
ffffffffea802aa4:	d2800043 	mov	x3, #0x2                   	// #2
ffffffffea802aa8:	d100086a 	sub	x10, x3, #0x2
ffffffffea802aac:	17ffffbc 	b	ffffffffea80299c <do_dcsw_op>

ffffffffea802ab0 <dcsw_op_level2>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level2)
	dcsw_op_level #(2 << LEVEL_SHIFT)
ffffffffea802ab0:	d5390029 	mrs	x9, clidr_el1
ffffffffea802ab4:	d2800083 	mov	x3, #0x4                   	// #4
ffffffffea802ab8:	d100086a 	sub	x10, x3, #0x2
ffffffffea802abc:	17ffffb8 	b	ffffffffea80299c <do_dcsw_op>

ffffffffea802ac0 <dcsw_op_level3>:
	 * The main function, do_dcsw_op requires:
	 * x0: The operation type (0-2), as defined in arch.h
	 * ---------------------------------------------------------------
	 */
FUNCTION(dcsw_op_level3)
	dcsw_op_level #(3 << LEVEL_SHIFT)
ffffffffea802ac0:	d5390029 	mrs	x9, clidr_el1
ffffffffea802ac4:	d28000c3 	mov	x3, #0x6                   	// #6
ffffffffea802ac8:	d100086a 	sub	x10, x3, #0x2
ffffffffea802acc:	17ffffb4 	b	ffffffffea80299c <do_dcsw_op>

ffffffffea802ad0 <arch_curr_cpu_num>:
#endif
/* NV: Move this function from arch\arm64\include\arch\arch_ops.h */
inline uint arch_curr_cpu_num(void)
{
    /* NV: Define plat_arch_curr_cpu_num in platform code */
    return plat_arch_curr_cpu_num();
ffffffffea802ad0:	17fffbb8 	b	ffffffffea8019b0 <plat_arch_curr_cpu_num>
ffffffffea802ad4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802ad8 <arch_early_init>:
}

static void arm64_cpu_early_init(void)
{
    /* set the vector base */
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802ad8:	90000300 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea802adc:	f9401800 	ldr	x0, [x0, #48]
ffffffffea802ae0:	d518c000 	msr	vbar_el1, x0
ffffffffea802ae4:	d5033fdf 	isb

    /* switch to EL1 */
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802ae8:	d5384240 	mrs	x0, currentel
ffffffffea802aec:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802af0:	7100041f 	cmp	w0, #0x1
ffffffffea802af4:	540000e9 	b.ls	ffffffffea802b10 <arch_early_init+0x38>  // b.plast

    arch_enable_fiqs();
}

void arch_early_init(void)
{
ffffffffea802af8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea802afc:	910003fd 	mov	x29, sp
        arm64_el3_to_el1();
ffffffffea802b00:	97ffff56 	bl	ffffffffea802858 <arm64_el3_to_el1>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802b04:	d50341ff 	msr	daifclr, #0x1
    arm64_cpu_early_init();
    platform_init_mmu_mappings();
}
ffffffffea802b08:	a8c17bfd 	ldp	x29, x30, [sp], #16
    platform_init_mmu_mappings();
ffffffffea802b0c:	17fffbf1 	b	ffffffffea801ad0 <platform_init_mmu_mappings>
ffffffffea802b10:	d50341ff 	msr	daifclr, #0x1
ffffffffea802b14:	17fffbef 	b	ffffffffea801ad0 <platform_init_mmu_mappings>

ffffffffea802b18 <arch_init>:

void arch_init(void)
{
ffffffffea802b18:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802b1c:	910003fd 	mov	x29, sp
ffffffffea802b20:	f9000bf3 	str	x19, [sp, #16]
    arch_mp_init_percpu();
ffffffffea802b24:	940001ef 	bl	ffffffffea8032e0 <arch_mp_init_percpu>

#if WITH_SMP
    LTRACEF("midr_el1 0x%llx\n", ARM64_READ_SYSREG(midr_el1));

    secondaries_to_init = SMP_MAX_CPUS - 1; /* TODO: get count from somewhere else, or add cpus as they boot */
ffffffffea802b28:	f0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea802b2c:	528000e1 	mov	w1, #0x7                   	// #7
}

/* interrupts should already be disabled */
static inline void spin_unlock(spin_lock_t *lock)
{
    arch_spin_unlock(lock);
ffffffffea802b30:	f00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea802b34:	9106a273 	add	x19, x19, #0x1a8
ffffffffea802b38:	b9002401 	str	w1, [x0, #36]

    lk_init_secondary_cpus(secondaries_to_init);
ffffffffea802b3c:	b9402400 	ldr	w0, [x0, #36]
ffffffffea802b40:	94000554 	bl	ffffffffea804090 <lk_init_secondary_cpus>
ffffffffea802b44:	aa1303e0 	mov	x0, x19
ffffffffea802b48:	97ffff66 	bl	ffffffffea8028e0 <arch_spin_unlock>

    /* release the secondary cpus */
    spin_unlock(&arm_boot_cpu_lock);

    /* flush the release of the lock, since the secondary cpus are running without cache on */
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802b4c:	aa1303e0 	mov	x0, x19
#endif
}
ffffffffea802b50:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802b54:	a8c27bfd 	ldp	x29, x30, [sp], #32
    arch_clean_cache_range((addr_t)&arm_boot_cpu_lock, sizeof(arm_boot_cpu_lock));
ffffffffea802b58:	d2800101 	mov	x1, #0x8                   	// #8
ffffffffea802b5c:	17ffff63 	b	ffffffffea8028e8 <arch_clean_cache_range>

ffffffffea802b60 <arch_idle>:
{
}

void arch_idle(void)
{
    __asm__ volatile("wfi");
ffffffffea802b60:	d503207f 	wfi
}
ffffffffea802b64:	d65f03c0 	ret

ffffffffea802b68 <arm64_secondary_entry>:
    PANIC_UNIMPLEMENTED;
}

#if WITH_SMP
void arm64_secondary_entry(ulong asm_cpu_num)
{
ffffffffea802b68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802b6c:	910003fd 	mov	x29, sp
ffffffffea802b70:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802b74:	aa0003f3 	mov	x19, x0
    return plat_arch_curr_cpu_num();
ffffffffea802b78:	97fffb8e 	bl	ffffffffea8019b0 <plat_arch_curr_cpu_num>
    uint cpu = arch_curr_cpu_num();
    if (cpu != asm_cpu_num)
ffffffffea802b7c:	eb20427f 	cmp	x19, w0, uxtw
ffffffffea802b80:	54000080 	b.eq	ffffffffea802b90 <arm64_secondary_entry+0x28>  // b.none
    /* we're done, tell the main cpu we're up */
    atomic_add(&secondaries_to_init, -1);
    __asm__ volatile("sev");

    lk_secondary_cpu_entry();
}
ffffffffea802b84:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802b88:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802b8c:	d65f03c0 	ret
    ARM64_WRITE_SYSREG(VBAR_EL1, (uint64_t)&arm64_exception_base);
ffffffffea802b90:	90000300 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea802b94:	f9401800 	ldr	x0, [x0, #48]
ffffffffea802b98:	d518c000 	msr	vbar_el1, x0
ffffffffea802b9c:	d5033fdf 	isb
    unsigned int current_el = ARM64_READ_SYSREG(CURRENTEL) >> 2;
ffffffffea802ba0:	d5384240 	mrs	x0, currentel
ffffffffea802ba4:	d342fc00 	lsr	x0, x0, #2
    if (current_el > 1) {
ffffffffea802ba8:	7100041f 	cmp	w0, #0x1
ffffffffea802bac:	54000049 	b.ls	ffffffffea802bb4 <arm64_secondary_entry+0x4c>  // b.plast
        arm64_el3_to_el1();
ffffffffea802bb0:	97ffff2a 	bl	ffffffffea802858 <arm64_el3_to_el1>
ffffffffea802bb4:	d50341ff 	msr	daifclr, #0x1
    arch_spin_lock(lock);
ffffffffea802bb8:	f00000b3 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea802bbc:	9106a273 	add	x19, x19, #0x1a8
ffffffffea802bc0:	aa1303e0 	mov	x0, x19
ffffffffea802bc4:	97ffff3f 	bl	ffffffffea8028c0 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea802bc8:	aa1303e0 	mov	x0, x19
ffffffffea802bcc:	97ffff45 	bl	ffffffffea8028e0 <arch_spin_unlock>
    lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_THREADING - 1);
ffffffffea802bd0:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea802bd4:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea802bd8:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea802bdc:	94000431 	bl	ffffffffea803ca0 <lk_init_level>
    arch_mp_init_percpu();
ffffffffea802be0:	940001c0 	bl	ffffffffea8032e0 <arch_mp_init_percpu>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea802be4:	f0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea802be8:	91009000 	add	x0, x0, #0x24
ffffffffea802bec:	885f7c01 	ldxr	w1, [x0]
ffffffffea802bf0:	51000421 	sub	w1, w1, #0x1
ffffffffea802bf4:	88027c01 	stxr	w2, w1, [x0]
ffffffffea802bf8:	35ffffa2 	cbnz	w2, ffffffffea802bec <arm64_secondary_entry+0x84>
    __asm__ volatile("sev");
ffffffffea802bfc:	d503209f 	sev
}
ffffffffea802c00:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802c04:	a8c27bfd 	ldp	x29, x30, [sp], #32
    lk_secondary_cpu_entry();
ffffffffea802c08:	1400050c 	b	ffffffffea804038 <lk_secondary_cpu_entry>
ffffffffea802c0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea802c10 <dump_iframe>:
#if HAVE_STACKTRACE
void arm64_print_stacktrace(struct arm64_iframe_long *iframe);
#endif

static void dump_iframe(const struct arm64_iframe_long *iframe)
{
ffffffffea802c10:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802c14:	910003fd 	mov	x29, sp
ffffffffea802c18:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802c1c:	aa0003f3 	mov	x19, x0
    printf("iframe %p:\n", iframe);
ffffffffea802c20:	aa1303e1 	mov	x1, x19
ffffffffea802c24:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c28:	9119a000 	add	x0, x0, #0x668
ffffffffea802c2c:	9400440b 	bl	ffffffffea813c58 <_printf>
    printf("x0  0x%16llx x1  0x%16llx x2  0x%16llx x3  0x%16llx\n", iframe->r[0], iframe->r[1], iframe->r[2], iframe->r[3]);
ffffffffea802c30:	a9400a61 	ldp	x1, x2, [x19]
ffffffffea802c34:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c38:	a9411263 	ldp	x3, x4, [x19, #16]
ffffffffea802c3c:	9119e000 	add	x0, x0, #0x678
ffffffffea802c40:	94004406 	bl	ffffffffea813c58 <_printf>
    printf("x4  0x%16llx x5  0x%16llx x6  0x%16llx x7  0x%16llx\n", iframe->r[4], iframe->r[5], iframe->r[6], iframe->r[7]);
ffffffffea802c44:	a9420a61 	ldp	x1, x2, [x19, #32]
ffffffffea802c48:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c4c:	a9431263 	ldp	x3, x4, [x19, #48]
ffffffffea802c50:	911ac000 	add	x0, x0, #0x6b0
ffffffffea802c54:	94004401 	bl	ffffffffea813c58 <_printf>
    printf("x8  0x%16llx x9  0x%16llx x10 0x%16llx x11 0x%16llx\n", iframe->r[8], iframe->r[9], iframe->r[10], iframe->r[11]);
ffffffffea802c58:	a9440a61 	ldp	x1, x2, [x19, #64]
ffffffffea802c5c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c60:	a9451263 	ldp	x3, x4, [x19, #80]
ffffffffea802c64:	911ba000 	add	x0, x0, #0x6e8
ffffffffea802c68:	940043fc 	bl	ffffffffea813c58 <_printf>
    printf("x12 0x%16llx x13 0x%16llx x14 0x%16llx x15 0x%16llx\n", iframe->r[12], iframe->r[13], iframe->r[14], iframe->r[15]);
ffffffffea802c6c:	a9460a61 	ldp	x1, x2, [x19, #96]
ffffffffea802c70:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c74:	a9471263 	ldp	x3, x4, [x19, #112]
ffffffffea802c78:	911c8000 	add	x0, x0, #0x720
ffffffffea802c7c:	940043f7 	bl	ffffffffea813c58 <_printf>
    printf("x16 0x%16llx x17 0x%16llx x18 0x%16llx x19 0x%16llx\n", iframe->r[16], iframe->r[17], iframe->r[18], iframe->r[19]);
ffffffffea802c80:	a9480a61 	ldp	x1, x2, [x19, #128]
ffffffffea802c84:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c88:	a9491263 	ldp	x3, x4, [x19, #144]
ffffffffea802c8c:	911d6000 	add	x0, x0, #0x758
ffffffffea802c90:	940043f2 	bl	ffffffffea813c58 <_printf>
    printf("x20 0x%16llx x21 0x%16llx x22 0x%16llx x23 0x%16llx\n", iframe->r[20], iframe->r[21], iframe->r[22], iframe->r[23]);
ffffffffea802c94:	a94a0a61 	ldp	x1, x2, [x19, #160]
ffffffffea802c98:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802c9c:	a94b1263 	ldp	x3, x4, [x19, #176]
ffffffffea802ca0:	911e4000 	add	x0, x0, #0x790
ffffffffea802ca4:	940043ed 	bl	ffffffffea813c58 <_printf>
    printf("x24 0x%16llx x25 0x%16llx x26 0x%16llx x27 0x%16llx\n", iframe->r[24], iframe->r[25], iframe->r[26], iframe->r[27]);
ffffffffea802ca8:	a94c0a61 	ldp	x1, x2, [x19, #192]
ffffffffea802cac:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802cb0:	a94d1263 	ldp	x3, x4, [x19, #208]
ffffffffea802cb4:	911f2000 	add	x0, x0, #0x7c8
ffffffffea802cb8:	940043e8 	bl	ffffffffea813c58 <_printf>
    printf("x28 0x%16llx x29 0x%16llx lr  0x%16llx sp  0x%16llx\n", iframe->r[28], iframe->r[29], iframe->r[30], iframe->r[31]);
ffffffffea802cbc:	a94e0a61 	ldp	x1, x2, [x19, #224]
ffffffffea802cc0:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802cc4:	a94f1263 	ldp	x3, x4, [x19, #240]
ffffffffea802cc8:	91200000 	add	x0, x0, #0x800
ffffffffea802ccc:	940043e3 	bl	ffffffffea813c58 <_printf>
    printf("elr 0x%16llx\n", iframe->elr);
ffffffffea802cd0:	f9408261 	ldr	x1, [x19, #256]
ffffffffea802cd4:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802cd8:	9120e000 	add	x0, x0, #0x838
ffffffffea802cdc:	940043df 	bl	ffffffffea813c58 <_printf>
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802ce0:	f9408661 	ldr	x1, [x19, #264]
ffffffffea802ce4:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
}
ffffffffea802ce8:	f9400bf3 	ldr	x19, [sp, #16]
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802cec:	91212000 	add	x0, x0, #0x848
}
ffffffffea802cf0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    printf("spsr 0x%16llx\n", iframe->spsr);
ffffffffea802cf4:	140043d9 	b	ffffffffea813c58 <_printf>

ffffffffea802cf8 <arm64_sync_exception>:

void arm64_sync_exception(struct arm64_iframe_long *iframe)
{
ffffffffea802cf8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea802cfc:	910003fd 	mov	x29, sp
ffffffffea802d00:	a90153f3 	stp	x19, x20, [sp, #16]
    struct fault_handler_table_entry *fault_handler;
    uint32_t esr = ARM64_READ_SYSREG(esr_el1);
ffffffffea802d04:	d5385214 	mrs	x20, esr_el1
    uint32_t ec = esr >> 26;
ffffffffea802d08:	531a7e93 	lsr	w19, w20, #26
    uint32_t il = (esr >> 25) & 0x1;
    uint32_t iss = esr & ((1<<24) - 1);

#ifdef WITH_LIB_SYSCALL
    if (ec == 0x15 || ec == 0x11) { // syscall 64/32
ffffffffea802d0c:	121d7a61 	and	w1, w19, #0xfffffffb
ffffffffea802d10:	7100443f 	cmp	w1, #0x11
ffffffffea802d14:	540007c0 	b.eq	ffffffffea802e0c <arm64_sync_exception+0x114>  // b.none
        return;
    }
#endif

    /* floating point */
    if (ec == 0x07) {
ffffffffea802d18:	71001e7f 	cmp	w19, #0x7
ffffffffea802d1c:	54000940 	b.eq	ffffffffea802e44 <arm64_sync_exception+0x14c>  // b.none
        arm64_fpu_exception(iframe);
        return;
    }

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802d20:	90000302 	adrp	x2, ffffffffea862000 <__ctor_list>
ffffffffea802d24:	f90013b5 	str	x21, [x29, #32]
ffffffffea802d28:	aa0003f5 	mov	x21, x0
ffffffffea802d2c:	90000300 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea802d30:	f9408842 	ldr	x2, [x2, #272]
ffffffffea802d34:	f9001bb7 	str	x23, [x29, #48]
ffffffffea802d38:	aa1e03f7 	mov	x23, x30
ffffffffea802d3c:	f9404c00 	ldr	x0, [x0, #152]
ffffffffea802d40:	eb02001f 	cmp	x0, x2
ffffffffea802d44:	54000222 	b.cs	ffffffffea802d88 <arm64_sync_exception+0x90>  // b.hs, b.nlast
        if (fault_handler->pc == iframe->elr) {
ffffffffea802d48:	f9400001 	ldr	x1, [x0]
ffffffffea802d4c:	f94082a4 	ldr	x4, [x21, #256]
ffffffffea802d50:	eb01009f 	cmp	x4, x1
ffffffffea802d54:	54000680 	b.eq	ffffffffea802e24 <arm64_sync_exception+0x12c>  // b.none
ffffffffea802d58:	91004000 	add	x0, x0, #0x10
ffffffffea802d5c:	91003c42 	add	x2, x2, #0xf
ffffffffea802d60:	cb000042 	sub	x2, x2, x0
ffffffffea802d64:	927cec42 	and	x2, x2, #0xfffffffffffffff0
ffffffffea802d68:	8b000042 	add	x2, x2, x0
ffffffffea802d6c:	14000004 	b	ffffffffea802d7c <arm64_sync_exception+0x84>
ffffffffea802d70:	f8410403 	ldr	x3, [x0], #16
ffffffffea802d74:	eb04007f 	cmp	x3, x4
ffffffffea802d78:	54000580 	b.eq	ffffffffea802e28 <arm64_sync_exception+0x130>  // b.none
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802d7c:	aa0003e5 	mov	x5, x0
ffffffffea802d80:	eb02001f 	cmp	x0, x2
ffffffffea802d84:	54ffff61 	b.ne	ffffffffea802d70 <arm64_sync_exception+0x78>  // b.any
ffffffffea802d88:	f90017b6 	str	x22, [x29, #40]
            iframe->elr = fault_handler->fault_handler;
            return;
        }
    }

    printf("sync_exception\n");
ffffffffea802d8c:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>

#if HAVE_STACKTRACE
    printf("-----------------------------------------------\n");
ffffffffea802d90:	900000b6 	adrp	x22, ffffffffea816000 <__fault_handler_table_start>
    printf("sync_exception\n");
ffffffffea802d94:	91172000 	add	x0, x0, #0x5c8
    printf("-----------------------------------------------\n");
ffffffffea802d98:	911762d6 	add	x22, x22, #0x5d8
    printf("sync_exception\n");
ffffffffea802d9c:	940043af 	bl	ffffffffea813c58 <_printf>
    printf("-----------------------------------------------\n");
ffffffffea802da0:	aa1603e0 	mov	x0, x22
ffffffffea802da4:	940043ad 	bl	ffffffffea813c58 <_printf>
    printf(" [Stack Trace]\n\n");
ffffffffea802da8:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802dac:	91184000 	add	x0, x0, #0x610
ffffffffea802db0:	940043aa 	bl	ffffffffea813c58 <_printf>
    arm64_print_stacktrace(iframe);
ffffffffea802db4:	aa1503e0 	mov	x0, x21
ffffffffea802db8:	94000130 	bl	ffffffffea803278 <arm64_print_stacktrace>
    printf("-----------------------------------------------\n");
ffffffffea802dbc:	aa1603e0 	mov	x0, x22
ffffffffea802dc0:	940043a6 	bl	ffffffffea813c58 <_printf>
#endif

    dump_iframe(iframe);
ffffffffea802dc4:	aa1503e0 	mov	x0, x21
ffffffffea802dc8:	97ffff92 	bl	ffffffffea802c10 <dump_iframe>

    printf("ESR 0x%x: ec 0x%x, il 0x%x, iss 0x%x\n", esr, ec, il, iss);
ffffffffea802dcc:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802dd0:	12005e84 	and	w4, w20, #0xffffff
ffffffffea802dd4:	53196683 	ubfx	w3, w20, #25, #1
ffffffffea802dd8:	2a1303e2 	mov	w2, w19
ffffffffea802ddc:	2a1403e1 	mov	w1, w20
ffffffffea802de0:	9118a000 	add	x0, x0, #0x628
ffffffffea802de4:	9400439d 	bl	ffffffffea813c58 <_printf>

    if (ec == 0x15) { // syscall
ffffffffea802de8:	7100567f 	cmp	w19, #0x15
ffffffffea802dec:	54000321 	b.ne	ffffffffea802e50 <arm64_sync_exception+0x158>  // b.any
        printf("syscall\n");
ffffffffea802df0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea802df4:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
        return;
    }

    panic("die\n");
}
ffffffffea802df8:	a94153f3 	ldp	x19, x20, [sp, #16]
        printf("syscall\n");
ffffffffea802dfc:	91194000 	add	x0, x0, #0x650
ffffffffea802e00:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea802e04:	a8c47bfd 	ldp	x29, x30, [sp], #64
        printf("syscall\n");
ffffffffea802e08:	14004394 	b	ffffffffea813c58 <_printf>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea802e0c:	d50341ff 	msr	daifclr, #0x1
        arm64_syscall(iframe);
ffffffffea802e10:	94004546 	bl	ffffffffea814328 <arm64_syscall>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea802e14:	d50341df 	msr	daifset, #0x1
}
ffffffffea802e18:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802e1c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802e20:	d65f03c0 	ret
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
ffffffffea802e24:	aa0003e5 	mov	x5, x0
            iframe->elr = fault_handler->fault_handler;
ffffffffea802e28:	f94004a0 	ldr	x0, [x5, #8]
            return;
ffffffffea802e2c:	f9401bb7 	ldr	x23, [x29, #48]
            iframe->elr = fault_handler->fault_handler;
ffffffffea802e30:	f90082a0 	str	x0, [x21, #256]
}
ffffffffea802e34:	a94153f3 	ldp	x19, x20, [sp, #16]
            return;
ffffffffea802e38:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea802e3c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea802e40:	d65f03c0 	ret
ffffffffea802e44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea802e48:	a8c47bfd 	ldp	x29, x30, [sp], #64
        arm64_fpu_exception(iframe);
ffffffffea802e4c:	14000029 	b	ffffffffea802ef0 <arm64_fpu_exception>
    panic("die\n");
ffffffffea802e50:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802e54:	aa1703e0 	mov	x0, x23
ffffffffea802e58:	91198021 	add	x1, x1, #0x660
ffffffffea802e5c:	94003dc9 	bl	ffffffffea812580 <_panic>

ffffffffea802e60 <arm64_invalid_exception>:

void arm64_invalid_exception(struct arm64_iframe_long *iframe, unsigned int which)
{
ffffffffea802e60:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802e64:	910003fd 	mov	x29, sp
ffffffffea802e68:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802e6c:	aa1e03f3 	mov	x19, x30
ffffffffea802e70:	aa0003f4 	mov	x20, x0
    printf("invalid exception, which 0x%x\n", which);
ffffffffea802e74:	900000a0 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802e78:	9116a000 	add	x0, x0, #0x5a8
ffffffffea802e7c:	94004377 	bl	ffffffffea813c58 <_printf>
    dump_iframe(iframe);
ffffffffea802e80:	aa1403e0 	mov	x0, x20
ffffffffea802e84:	97ffff63 	bl	ffffffffea802c10 <dump_iframe>

    panic("die\n");
ffffffffea802e88:	900000a1 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea802e8c:	aa1303e0 	mov	x0, x19
ffffffffea802e90:	91198021 	add	x1, x1, #0x660
ffffffffea802e94:	94003dbb 	bl	ffffffffea812580 <_panic>

ffffffffea802e98 <arm64_fpu_save_state>:
                     :: "r"(fpstate), "r"(fpstate->fpcr), "r"(fpstate->fpsr));
}

void arm64_fpu_save_state(struct thread *t)
{
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802e98:	91016000 	add	x0, x0, #0x58
    __asm__ volatile("stp     q0, q1, [%2, #(0 * 32)]\n"
ffffffffea802e9c:	ad000400 	stp	q0, q1, [x0]
ffffffffea802ea0:	ad010c02 	stp	q2, q3, [x0, #32]
ffffffffea802ea4:	ad021404 	stp	q4, q5, [x0, #64]
ffffffffea802ea8:	ad031c06 	stp	q6, q7, [x0, #96]
ffffffffea802eac:	ad042408 	stp	q8, q9, [x0, #128]
ffffffffea802eb0:	ad052c0a 	stp	q10, q11, [x0, #160]
ffffffffea802eb4:	ad06340c 	stp	q12, q13, [x0, #192]
ffffffffea802eb8:	ad073c0e 	stp	q14, q15, [x0, #224]
ffffffffea802ebc:	ad084410 	stp	q16, q17, [x0, #256]
ffffffffea802ec0:	ad094c12 	stp	q18, q19, [x0, #288]
ffffffffea802ec4:	ad0a5414 	stp	q20, q21, [x0, #320]
ffffffffea802ec8:	ad0b5c16 	stp	q22, q23, [x0, #352]
ffffffffea802ecc:	ad0c6418 	stp	q24, q25, [x0, #384]
ffffffffea802ed0:	ad0d6c1a 	stp	q26, q27, [x0, #416]
ffffffffea802ed4:	ad0e741c 	stp	q28, q29, [x0, #448]
ffffffffea802ed8:	ad0f7c1e 	stp	q30, q31, [x0, #480]
ffffffffea802edc:	d53b4402 	mrs	x2, fpcr
ffffffffea802ee0:	d53b4421 	mrs	x1, fpsr
ffffffffea802ee4:	b9020002 	str	w2, [x0, #512]
ffffffffea802ee8:	b9020401 	str	w1, [x0, #516]
                     "mrs     %1, fpsr\n"
                     : "=r"(fpstate->fpcr), "=r"(fpstate->fpsr)
                     : "r"(fpstate));

    LTRACEF("thread %s, fpcr %x, fpsr %x\n", t->name, fpstate->fpcr, fpstate->fpsr);
}
ffffffffea802eec:	d65f03c0 	ret

ffffffffea802ef0 <arm64_fpu_exception>:

void arm64_fpu_exception(struct arm64_iframe_long *iframe)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea802ef0:	d5381040 	mrs	x0, cpacr_el1
    if (((cpacr >> 20) & 3) != 3) {
ffffffffea802ef4:	53145401 	ubfx	w1, w0, #20, #2
ffffffffea802ef8:	71000c3f 	cmp	w1, #0x3
ffffffffea802efc:	54000540 	b.eq	ffffffffea802fa4 <arm64_fpu_exception+0xb4>  // b.none
{
ffffffffea802f00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
        cpacr |= 3 << 20;
ffffffffea802f04:	320c0400 	orr	w0, w0, #0x300000
{
ffffffffea802f08:	910003fd 	mov	x29, sp
ffffffffea802f0c:	f9000bf3 	str	x19, [sp, #16]
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea802f10:	d5181040 	msr	cpacr_el1, x0
ffffffffea802f14:	d5033fdf 	isb
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea802f18:	d538d093 	mrs	x19, tpidr_el1
    uint cpu = arch_curr_cpu_num();
ffffffffea802f1c:	97fffeed 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802f20:	2a0003e3 	mov	w3, w0
ffffffffea802f24:	f0000342 	adrp	x2, ffffffffea86d000 <__bss_start>
ffffffffea802f28:	9100a044 	add	x4, x2, #0x28
    struct fpstate *fpstate = &t->arch.fpstate;
ffffffffea802f2c:	91016261 	add	x1, x19, #0x58
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802f30:	f8637884 	ldr	x4, [x4, x3, lsl #3]
ffffffffea802f34:	eb04003f 	cmp	x1, x4
ffffffffea802f38:	54000380 	b.eq	ffffffffea802fa8 <arm64_fpu_exception+0xb8>  // b.none
    current_fpstate[cpu] = fpstate;
ffffffffea802f3c:	9100a042 	add	x2, x2, #0x28
    fpstate->current_cpu = cpu;
ffffffffea802f40:	b9020820 	str	w0, [x1, #520]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802f44:	b9420424 	ldr	w4, [x1, #516]
ffffffffea802f48:	b9420020 	ldr	w0, [x1, #512]
    current_fpstate[cpu] = fpstate;
ffffffffea802f4c:	f8237841 	str	x1, [x2, x3, lsl #3]
    __asm__ volatile("ldp     q0, q1, [%0, #(0 * 32)]\n"
ffffffffea802f50:	ad400420 	ldp	q0, q1, [x1]
ffffffffea802f54:	ad410c22 	ldp	q2, q3, [x1, #32]
ffffffffea802f58:	ad421424 	ldp	q4, q5, [x1, #64]
ffffffffea802f5c:	ad431c26 	ldp	q6, q7, [x1, #96]
ffffffffea802f60:	ad442428 	ldp	q8, q9, [x1, #128]
ffffffffea802f64:	ad452c2a 	ldp	q10, q11, [x1, #160]
ffffffffea802f68:	ad46342c 	ldp	q12, q13, [x1, #192]
ffffffffea802f6c:	ad473c2e 	ldp	q14, q15, [x1, #224]
ffffffffea802f70:	ad484430 	ldp	q16, q17, [x1, #256]
ffffffffea802f74:	ad494c32 	ldp	q18, q19, [x1, #288]
ffffffffea802f78:	ad4a5434 	ldp	q20, q21, [x1, #320]
ffffffffea802f7c:	ad4b5c36 	ldp	q22, q23, [x1, #352]
ffffffffea802f80:	ad4c6438 	ldp	q24, q25, [x1, #384]
ffffffffea802f84:	ad4d6c3a 	ldp	q26, q27, [x1, #416]
ffffffffea802f88:	ad4e743c 	ldp	q28, q29, [x1, #448]
ffffffffea802f8c:	ad4f7c3e 	ldp	q30, q31, [x1, #480]
ffffffffea802f90:	d51b4400 	msr	fpcr, x0
ffffffffea802f94:	d51b4424 	msr	fpsr, x4
        arm64_fpu_load_state(get_current_thread());
        return;
    }
}
ffffffffea802f98:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea802f9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea802fa0:	d65f03c0 	ret
ffffffffea802fa4:	d65f03c0 	ret
    if (fpstate == current_fpstate[cpu] && fpstate->current_cpu == cpu) {
ffffffffea802fa8:	b9420824 	ldr	w4, [x1, #520]
ffffffffea802fac:	6b04001f 	cmp	w0, w4
ffffffffea802fb0:	54fffc61 	b.ne	ffffffffea802f3c <arm64_fpu_exception+0x4c>  // b.any
ffffffffea802fb4:	17fffff9 	b	ffffffffea802f98 <arm64_fpu_exception+0xa8>

ffffffffea802fb8 <initial_thread_func>:

extern void arm64_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
ffffffffea802fb8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea802fbc:	910003fd 	mov	x29, sp
ffffffffea802fc0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea802fc4:	d538d093 	mrs	x19, tpidr_el1
ffffffffea802fc8:	90000300 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea802fcc:	f9406c00 	ldr	x0, [x0, #216]
ffffffffea802fd0:	97fffe44 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea802fd4:	d50342ff 	msr	daifclr, #0x2

    /* release the thread lock that was implicitly held across the reschedule */
    spin_unlock(&thread_lock);
    arch_enable_ints();

    ret = current_thread->entry(current_thread->arg);
ffffffffea802fd8:	f9413e61 	ldr	x1, [x19, #632]
ffffffffea802fdc:	f9414260 	ldr	x0, [x19, #640]
ffffffffea802fe0:	d63f0020 	blr	x1

    LTRACEF("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

    thread_exit(ret);
ffffffffea802fe4:	94000fd3 	bl	ffffffffea806f30 <thread_exit>

ffffffffea802fe8 <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
ffffffffea802fe8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!

    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
    frame--;

    // fill it in
    memset(frame, 0, sizeof(*frame));
ffffffffea802fec:	d2800d02 	mov	x2, #0x68                  	// #104
ffffffffea802ff0:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea802ff4:	910003fd 	mov	x29, sp
ffffffffea802ff8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea802ffc:	aa0003f4 	mov	x20, x0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea803000:	f9413413 	ldr	x19, [x0, #616]
ffffffffea803004:	f9413800 	ldr	x0, [x0, #624]
{
ffffffffea803008:	f90013f5 	str	x21, [sp, #32]
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
ffffffffea80300c:	8b000273 	add	x19, x19, x0
    stack_top = ROUNDDOWN(stack_top, 16);
ffffffffea803010:	927cee73 	and	x19, x19, #0xfffffffffffffff0
    frame--;
ffffffffea803014:	d101a275 	sub	x21, x19, #0x68
    memset(frame, 0, sizeof(*frame));
ffffffffea803018:	aa1503e0 	mov	x0, x21
ffffffffea80301c:	94004427 	bl	ffffffffea8140b8 <memset>
    frame->lr = (vaddr_t)&initial_thread_func;

    /* Set this to enable OS stack traces on exceptions */
    extern vaddr_t arch_stack_trace_epoch;
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea803020:	f00002e1 	adrp	x1, ffffffffea862000 <__ctor_list>
    frame->lr = (vaddr_t)&initial_thread_func;
ffffffffea803024:	f0ffffe0 	adrp	x0, ffffffffea802000 <platform_dputc+0x38>
ffffffffea803028:	913ee000 	add	x0, x0, #0xfb8
ffffffffea80302c:	f8198260 	stur	x0, [x19, #-104]
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea803030:	f9404021 	ldr	x1, [x1, #128]

    // set the stack pointer
    t->arch.sp = (vaddr_t)frame;
ffffffffea803034:	f9002a95 	str	x21, [x20, #80]
}
ffffffffea803038:	a94153f3 	ldp	x19, x20, [sp, #16]
    arch_stack_trace_epoch = (vaddr_t)&initial_thread_func;
ffffffffea80303c:	f9000020 	str	x0, [x1]
}
ffffffffea803040:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea803044:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea803048:	d65f03c0 	ret
ffffffffea80304c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803050 <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
ffffffffea803050:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea803054:	910003fd 	mov	x29, sp
ffffffffea803058:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80305c:	aa0003f4 	mov	x20, x0
ffffffffea803060:	f90013f5 	str	x21, [sp, #32]
ffffffffea803064:	aa0103f5 	mov	x21, x1
void arm64_fpu_exception(struct arm64_iframe_long *iframe);
void arm64_fpu_save_state(struct thread *thread);

static inline void arm64_fpu_pre_context_switch(struct thread *thread)
{
    uint32_t cpacr = ARM64_READ_SYSREG(cpacr_el1);
ffffffffea803068:	d5381053 	mrs	x19, cpacr_el1
    if ((cpacr >> 20) & 3) {
ffffffffea80306c:	720c067f 	tst	w19, #0x300000
ffffffffea803070:	540000a0 	b.eq	ffffffffea803084 <arch_context_switch+0x34>  // b.none
        arm64_fpu_save_state(thread);
ffffffffea803074:	97ffff89 	bl	ffffffffea802e98 <arm64_fpu_save_state>
        cpacr &= ~(3 << 20);
ffffffffea803078:	120a7673 	and	w19, w19, #0xffcfffff
        ARM64_WRITE_SYSREG(cpacr_el1, cpacr);
ffffffffea80307c:	d5181053 	msr	cpacr_el1, x19
ffffffffea803080:	d5033fdf 	isb
    LTRACEF("old %p (%s), new %p (%s)\n", oldthread, oldthread->name, newthread, newthread->name);
    arm64_fpu_pre_context_switch(oldthread);
#if WITH_SMP
    DSB; /* broadcast tlb operations in case the thread moves to another cpu */
ffffffffea803084:	d5033f9f 	dsb	sy
#endif
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea803088:	91014280 	add	x0, x20, #0x50
ffffffffea80308c:	f9402aa1 	ldr	x1, [x21, #80]
}
ffffffffea803090:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803094:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea803098:	a8c37bfd 	ldp	x29, x30, [sp], #48
    arm64_context_switch(&oldthread->arch.sp, newthread->arch.sp);
ffffffffea80309c:	17fffddd 	b	ffffffffea802810 <arm64_context_switch>

ffffffffea8030a0 <arch_print_stacktrace>:
/* For arm64 this is set in arm64/thread.c to the initial_thread_func function */
vaddr_t arch_stack_trace_epoch;
extern vaddr_t arch_stack_trace_epoch;

void arch_print_stacktrace(vaddr_t p_fp, vaddr_t p_sp, vaddr_t p_pc)
{
ffffffffea8030a0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8030a4:	910003fd 	mov	x29, sp
ffffffffea8030a8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8030ac:	aa0003f3 	mov	x19, x0
ffffffffea8030b0:	f9001ff8 	str	x24, [sp, #56]
ffffffffea8030b4:	aa0203f4 	mov	x20, x2
ffffffffea8030b8:	aa0103f8 	mov	x24, x1
	uint32_t tcount = 0U;
	vaddr_t fp = p_fp;
	vaddr_t sp = p_sp;
	vaddr_t pc = p_pc;

	if (0UL == pc) {
ffffffffea8030bc:	b4000702 	cbz	x2, ffffffffea80319c <arch_print_stacktrace+0xfc>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
	}

	if ((0UL == fp) || (0UL == sp)) {
ffffffffea8030c0:	f100027f 	cmp	x19, #0x0
ffffffffea8030c4:	fa401b04 	ccmp	x24, #0x0, #0x4, ne  // ne = any
ffffffffea8030c8:	54000760 	b.eq	ffffffffea8031b4 <arch_print_stacktrace+0x114>  // b.none
ffffffffea8030cc:	f9001bb7 	str	x23, [x29, #48]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
			fp, sp, pc);
		goto fail;
	}

	if (0UL == arch_stack_trace_epoch) {
ffffffffea8030d0:	f00002f7 	adrp	x23, ffffffffea862000 <__ctor_list>
ffffffffea8030d4:	f94042f7 	ldr	x23, [x23, #128]
ffffffffea8030d8:	f94002e0 	ldr	x0, [x23]
ffffffffea8030dc:	b4000520 	cbz	x0, ffffffffea803180 <arch_print_stacktrace+0xe0>
ffffffffea8030e0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8030e4:	aa1803f6 	mov	x22, x24
ffffffffea8030e8:	f90023b9 	str	x25, [x29, #64]
	uint32_t tcount = 0U;
ffffffffea8030ec:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8030f0:	f0000099 	adrp	x25, ffffffffea816000 <__fault_handler_table_start>
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
		goto fail;
	}

	while (tcount < MAX_STACK_TRACE_DEPTH) {
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea8030f4:	91240339 	add	x25, x25, #0x900
ffffffffea8030f8:	1400000f 	b	ffffffffea803134 <arch_print_stacktrace+0x94>
		}

		/* ARM-64 stack && frame pointers aligned to 64 bit
		 * boundary, detect simple stack corruption
		 */
		if ((fp & 0xfUL) != 0UL) {
ffffffffea8030fc:	f2400e7f 	tst	x19, #0xf
ffffffffea803100:	54000841 	b.ne	ffffffffea803208 <arch_print_stacktrace+0x168>  // b.any
		}

		/* Native Arm-64 instructions are aligned to 32 bit word
		 * boundary, detect simple PC corruption
		 */
		if ((pc & 0x3UL) != 0UL) {
ffffffffea803104:	f240069f 	tst	x20, #0x3
ffffffffea803108:	540008a1 	b.ne	ffffffffea80321c <arch_print_stacktrace+0x17c>  // b.any
				      pc);
			break;
		}

		sp = fp;
		pc = *REG64(fp+8UL);
ffffffffea80310c:	f9400660 	ldr	x0, [x19, #8]
ffffffffea803110:	aa1303f6 	mov	x22, x19

		if (pc != arch_stack_trace_epoch) {
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
		}

		fp = *REG64(fp);
ffffffffea803114:	f9400262 	ldr	x2, [x19]
		if (pc != arch_stack_trace_epoch) {
ffffffffea803118:	f94002f4 	ldr	x20, [x23]
			pc = pc - 4UL; /* LR = PC at function-call + 4 */
ffffffffea80311c:	d1001001 	sub	x1, x0, #0x4
ffffffffea803120:	eb14001f 	cmp	x0, x20
ffffffffea803124:	9a941034 	csel	x20, x1, x20, ne  // ne = any
	while (tcount < MAX_STACK_TRACE_DEPTH) {
ffffffffea803128:	7100cabf 	cmp	w21, #0x32
ffffffffea80312c:	54000820 	b.eq	ffffffffea803230 <arch_print_stacktrace+0x190>  // b.none
		fp = *REG64(fp);
ffffffffea803130:	aa0203f3 	mov	x19, x2
		dprintf(CRITICAL, "[ %02u ] => pc: 0x%016lX  sp: 0x%016lX\n", tcount, pc, sp);
ffffffffea803134:	2a1503e1 	mov	w1, w21
ffffffffea803138:	aa1603e3 	mov	x3, x22
ffffffffea80313c:	aa1403e2 	mov	x2, x20
ffffffffea803140:	aa1903e0 	mov	x0, x25
ffffffffea803144:	94003c87 	bl	ffffffffea812360 <_dprintf>
		tcount++;
ffffffffea803148:	110006b5 	add	w21, w21, #0x1
		if ((0UL == fp) || (fp < sp)) {
ffffffffea80314c:	f100027f 	cmp	x19, #0x0
ffffffffea803150:	fa5312c2 	ccmp	x22, x19, #0x2, ne  // ne = any
ffffffffea803154:	54fffd49 	b.ls	ffffffffea8030fc <arch_print_stacktrace+0x5c>  // b.plast
	}

	stack_size = sp - p_sp;
ffffffffea803158:	cb1802c1 	sub	x1, x22, x24
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea80315c:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea803160:	54000428 	b.hi	ffffffffea8031e4 <arch_print_stacktrace+0x144>  // b.pmore
ffffffffea803164:	a9425bb5 	ldp	x21, x22, [x29, #32]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
			      MAX_STACK_TRACE_DEPTH);
	}
fail:
	return;
}
ffffffffea803168:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80316c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea803170:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea803174:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea803178:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80317c:	d65f03c0 	ret
ffffffffea803180:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea803184:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803188:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80318c:	9128c000 	add	x0, x0, #0xa30
}
ffffffffea803190:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea803194:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ Stack tracing disabled ]\n");
ffffffffea803198:	14003c72 	b	ffffffffea812360 <_dprintf>
		dprintf(CRITICAL, "[ PC value zero => potential corruption, tracing anyway ]\n");
ffffffffea80319c:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8031a0:	91216000 	add	x0, x0, #0x858
ffffffffea8031a4:	94003c6f 	bl	ffffffffea812360 <_dprintf>
	if ((0UL == fp) || (0UL == sp)) {
ffffffffea8031a8:	f100027f 	cmp	x19, #0x0
ffffffffea8031ac:	fa401b04 	ccmp	x24, #0x0, #0x4, ne  // ne = any
ffffffffea8031b0:	54fff8e1 	b.ne	ffffffffea8030cc <arch_print_stacktrace+0x2c>  // b.any
		dprintf(CRITICAL, "[ No frame/stack register values => no stack traces ]\n");
ffffffffea8031b4:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8031b8:	91226000 	add	x0, x0, #0x898
ffffffffea8031bc:	94003c69 	bl	ffffffffea812360 <_dprintf>
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea8031c0:	aa1403e3 	mov	x3, x20
ffffffffea8031c4:	aa1803e2 	mov	x2, x24
ffffffffea8031c8:	aa1303e1 	mov	x1, x19
}
ffffffffea8031cc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8031d0:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea8031d4:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
}
ffffffffea8031d8:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "[ => fp=0x%016lX, sp=0x%016lX, pc=0x%016lX ]\n",
ffffffffea8031dc:	91234000 	add	x0, x0, #0x8d0
ffffffffea8031e0:	14003c60 	b	ffffffffea812360 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea8031e4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8031e8:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
}
ffffffffea8031ec:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea8031f0:	9126e000 	add	x0, x0, #0x9b8
ffffffffea8031f4:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea8031f8:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea8031fc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea803200:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea803204:	14003c57 	b	ffffffffea812360 <_dprintf>
			dprintf(CRITICAL,
ffffffffea803208:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80320c:	aa1303e1 	mov	x1, x19
ffffffffea803210:	9124a000 	add	x0, x0, #0x928
ffffffffea803214:	94003c53 	bl	ffffffffea812360 <_dprintf>
ffffffffea803218:	17ffffd0 	b	ffffffffea803158 <arch_print_stacktrace+0xb8>
			dprintf(CRITICAL,
ffffffffea80321c:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803220:	aa1403e1 	mov	x1, x20
ffffffffea803224:	9125c000 	add	x0, x0, #0x970
ffffffffea803228:	94003c4e 	bl	ffffffffea812360 <_dprintf>
ffffffffea80322c:	17ffffcb 	b	ffffffffea803158 <arch_print_stacktrace+0xb8>
	stack_size = sp - p_sp;
ffffffffea803230:	cb180261 	sub	x1, x19, x24
	if (stack_size >= (uint64_t)ARCH_DEFAULT_STACK_SIZE) {
ffffffffea803234:	f13ffc3f 	cmp	x1, #0xfff
ffffffffea803238:	54000168 	b.hi	ffffffffea803264 <arch_print_stacktrace+0x1c4>  // b.pmore
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea80323c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea803240:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
}
ffffffffea803244:	a94153f3 	ldp	x19, x20, [sp, #16]
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea803248:	52800641 	mov	w1, #0x32                  	// #50
ffffffffea80324c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea803250:	9127a000 	add	x0, x0, #0x9e8
ffffffffea803254:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea803258:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80325c:	a8c57bfd 	ldp	x29, x30, [sp], #80
		dprintf(CRITICAL, "\n [ Configured stack trace depth (%u) exeeded -- trace terminated ]\n",
ffffffffea803260:	14003c40 	b	ffffffffea812360 <_dprintf>
		dprintf(CRITICAL, "\n Using %llu bytes - STACK OVERFLOW !!!\n",
ffffffffea803264:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803268:	9126e000 	add	x0, x0, #0x9b8
ffffffffea80326c:	94003c3d 	bl	ffffffffea812360 <_dprintf>
ffffffffea803270:	17fffff3 	b	ffffffffea80323c <arch_print_stacktrace+0x19c>
ffffffffea803274:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803278 <arm64_print_stacktrace>:

/* Stack tracer for the Arm-64 exception handler */
void arm64_print_stacktrace(const struct arm64_iframe_long *iframe)
{
ffffffffea803278:	aa0003e2 	mov	x2, x0
	vaddr_t fp, sp, pc;

	if (NULL == iframe) {
ffffffffea80327c:	b4000080 	cbz	x0, ffffffffea80328c <arm64_print_stacktrace+0x14>

	fp = iframe->r[29];
	sp = iframe->r[31];
	pc = iframe->elr;

	arch_print_stacktrace(fp, sp, pc);
ffffffffea803280:	f9407400 	ldr	x0, [x0, #232]
ffffffffea803284:	a94f8841 	ldp	x1, x2, [x2, #248]
ffffffffea803288:	17ffff86 	b	ffffffffea8030a0 <arch_print_stacktrace>
		dprintf(CRITICAL, "[ No iframe, no stack traces ]\n");
ffffffffea80328c:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803290:	91294000 	add	x0, x0, #0xa50
ffffffffea803294:	14003c33 	b	ffffffffea812360 <_dprintf>

ffffffffea803298 <arm_ipi_generic_handler>:
enum handler_return arm_ipi_generic_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return INT_NO_RESCHEDULE;
}
ffffffffea803298:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80329c:	d65f03c0 	ret

ffffffffea8032a0 <arm_ipi_reschedule_handler>:

enum handler_return arm_ipi_reschedule_handler(void *arg)
{
    LTRACEF("cpu %u, arg %p\n", arch_curr_cpu_num(), arg);

    return mp_mbx_reschedule_irq();
ffffffffea8032a0:	140010da 	b	ffffffffea807608 <mp_mbx_reschedule_irq>
ffffffffea8032a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8032a8 <arch_mp_send_ipi>:
    if (target != 0) {
ffffffffea8032a8:	72001c02 	ands	w2, w0, #0xff
ffffffffea8032ac:	54000061 	b.ne	ffffffffea8032b8 <arch_mp_send_ipi+0x10>  // b.any
}
ffffffffea8032b0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8032b4:	d65f03c0 	ret
{
ffffffffea8032b8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8032bc:	2a0103e0 	mov	w0, w1
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea8032c0:	11003800 	add	w0, w0, #0xe
ffffffffea8032c4:	52800081 	mov	w1, #0x4                   	// #4
{
ffffffffea8032c8:	910003fd 	mov	x29, sp
        arm_gic_sgi(gic_ipi_num, ARM_GIC_SGI_FLAG_NS, target);
ffffffffea8032cc:	9400052d 	bl	ffffffffea804780 <arm_gic_sgi>
}
ffffffffea8032d0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8032d4:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8032d8:	d65f03c0 	ret
ffffffffea8032dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8032e0 <arch_mp_init_percpu>:
}

void arch_mp_init_percpu(void)
{
ffffffffea8032e0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea8032e4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8032e8:	528001c0 	mov	w0, #0xe                   	// #14
ffffffffea8032ec:	90000001 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x18>
{
ffffffffea8032f0:	910003fd 	mov	x29, sp
    register_int_handler(MP_IPI_GENERIC + GIC_IPI_BASE, &arm_ipi_generic_handler, 0);
ffffffffea8032f4:	910a6021 	add	x1, x1, #0x298
ffffffffea8032f8:	94000468 	bl	ffffffffea804498 <register_int_handler>
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);

    //unmask_interrupt(MP_IPI_GENERIC);
    //unmask_interrupt(MP_IPI_RESCHEDULE);
}
ffffffffea8032fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
    register_int_handler(MP_IPI_RESCHEDULE + GIC_IPI_BASE, &arm_ipi_reschedule_handler, 0);
ffffffffea803300:	90000001 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x18>
ffffffffea803304:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea803308:	910a8021 	add	x1, x1, #0x2a0
ffffffffea80330c:	528001e0 	mov	w0, #0xf                   	// #15
ffffffffea803310:	14000462 	b	ffffffffea804498 <register_int_handler>
ffffffffea803314:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803318 <arm64_mmu_unmap_pt>:
    paddr_t page_table_paddr;

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, size 0x%lx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, size, index_shift, page_size_shift, page_table);

    while (size) {
ffffffffea803318:	b4000762 	cbz	x2, ffffffffea803404 <arm64_mmu_unmap_pt+0xec>
{
ffffffffea80331c:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    int count = 1U << (page_size_shift - 3);
ffffffffea803320:	51000c8b 	sub	w11, w4, #0x3
        block_size = 1UL << index_shift;
ffffffffea803324:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803328:	2a0603ea 	mov	w10, w6
    int count = 1U << (page_size_shift - 3);
ffffffffea80332c:	1acb210b 	lsl	w11, w8, w11
{
ffffffffea803330:	910003fd 	mov	x29, sp
ffffffffea803334:	5100056c 	sub	w12, w11, #0x1
ffffffffea803338:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80333c:	aa0003f6 	mov	x22, x0
ffffffffea803340:	d2800100 	mov	x0, #0x8                   	// #8
ffffffffea803344:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803348:	a90363f7 	stp	x23, x24, [sp, #48]
        block_size = 1UL << index_shift;
ffffffffea80334c:	9ac32107 	lsl	x7, x8, x3
{
ffffffffea803350:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea803354:	aa0103f5 	mov	x21, x1
ffffffffea803358:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea80335c:	aa1e03f9 	mov	x25, x30
ffffffffea803360:	aa0203f4 	mov	x20, x2
ffffffffea803364:	2a0303f7 	mov	w23, w3
ffffffffea803368:	2a0403fb 	mov	w27, w4
ffffffffea80336c:	aa0503fc 	mov	x28, x5
        block_mask = block_size - 1;
ffffffffea803370:	d10004e9 	sub	x9, x7, #0x1
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
            CF;
            if (asid == MMU_ARM64_GLOBAL_ASID)
                ARM64_TLBI(vaae1is, vaddr >> 12);
            else
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea803374:	d3503d4d 	lsl	x13, x10, #48
ffffffffea803378:	8b2c4c0c 	add	x12, x0, w12, uxtw #3
    size_t size = 1U << page_size_shift;
ffffffffea80337c:	1ac42108 	lsl	w8, w8, w4
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea803380:	8a15013a 	and	x26, x9, x21
        index = vaddr_rel >> index_shift;
ffffffffea803384:	9ad726b8 	lsr	x24, x21, x23
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803388:	cb1a00f3 	sub	x19, x7, x26
ffffffffea80338c:	eb14027f 	cmp	x19, x20
        pte = page_table[index];
ffffffffea803390:	f8787b80 	ldr	x0, [x28, x24, lsl #3]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803394:	9a949273 	csel	x19, x19, x20, ls  // ls = plast
        if (index_shift > page_size_shift &&
ffffffffea803398:	6b1b02ff 	cmp	w23, w27
ffffffffea80339c:	54000089 	b.ls	ffffffffea8033ac <arm64_mmu_unmap_pt+0x94>  // b.plast
            (pte & MMU_PTE_DESCRIPTOR_MASK) == MMU_PTE_L012_DESCRIPTOR_TABLE) {
ffffffffea8033a0:	92400403 	and	x3, x0, #0x3
        if (index_shift > page_size_shift &&
ffffffffea8033a4:	f1000c7f 	cmp	x3, #0x3
ffffffffea8033a8:	54000300 	b.eq	ffffffffea803408 <arm64_mmu_unmap_pt+0xf0>  // b.none
        } else if (pte) {
ffffffffea8033ac:	b4000100 	cbz	x0, ffffffffea8033cc <arm64_mmu_unmap_pt+0xb4>
            page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea8033b0:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
            CF;
ffffffffea8033b4:	d34cfec0 	lsr	x0, x22, #12
            if (asid == MMU_ARM64_GLOBAL_ASID)
ffffffffea8033b8:	3100055f 	cmn	w10, #0x1
ffffffffea8033bc:	540001e0 	b.eq	ffffffffea8033f8 <arm64_mmu_unmap_pt+0xe0>  // b.none
                ARM64_TLBI(vae1is, vaddr >> 12 | (vaddr_t)asid << 48);
ffffffffea8033c0:	aa0001a0 	orr	x0, x13, x0
ffffffffea8033c4:	d5088320 	tlbi	vae1is, x0
ffffffffea8033c8:	d5033fdf 	isb
        } else {
            LTRACEF("pte %p[0x%lx] already clear\n", page_table, index);
        }
        vaddr += chunk_size;
ffffffffea8033cc:	8b1302d6 	add	x22, x22, x19
        vaddr_rel += chunk_size;
ffffffffea8033d0:	8b1302b5 	add	x21, x21, x19
    while (size) {
ffffffffea8033d4:	eb130294 	subs	x20, x20, x19
ffffffffea8033d8:	54fffd41 	b.ne	ffffffffea803380 <arm64_mmu_unmap_pt+0x68>  // b.any
        size -= chunk_size;
    }
}
ffffffffea8033dc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8033e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8033e4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8033e8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8033ec:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea8033f0:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea8033f4:	d65f03c0 	ret
                ARM64_TLBI(vaae1is, vaddr >> 12);
ffffffffea8033f8:	d5088360 	tlbi	vaae1is, x0
ffffffffea8033fc:	d5033fdf 	isb
ffffffffea803400:	17fffff3 	b	ffffffffea8033cc <arm64_mmu_unmap_pt+0xb4>
ffffffffea803404:	d65f03c0 	ret
ffffffffea803408:	b9007ba8 	str	w8, [x29, #120]
            page_table_paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea80340c:	92748c00 	and	x0, x0, #0xfffffffff000
ffffffffea803410:	a906b3a0 	stp	x0, x12, [x29, #104]
ffffffffea803414:	b90087ab 	str	w11, [x29, #132]
ffffffffea803418:	a9089fa9 	stp	x9, x7, [x29, #136]
ffffffffea80341c:	a9098fad 	stp	x13, x3, [x29, #152]
ffffffffea803420:	b900abaa 	str	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea803424:	9400388d 	bl	ffffffffea811658 <paddr_to_kvaddr>
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea803428:	b940abaa 	ldr	w10, [x29, #168]
            next_page_table = paddr_to_kvaddr(page_table_paddr);
ffffffffea80342c:	aa0003ef 	mov	x15, x0
            arm64_mmu_unmap_pt(vaddr, vaddr_rem, chunk_size,
ffffffffea803430:	f94053a3 	ldr	x3, [x29, #160]
ffffffffea803434:	aa0f03e5 	mov	x5, x15
ffffffffea803438:	2a0a03e6 	mov	w6, w10
ffffffffea80343c:	b900a3aa 	str	w10, [x29, #160]
ffffffffea803440:	4b1b0063 	sub	w3, w3, w27
ffffffffea803444:	f90057af 	str	x15, [x29, #168]
ffffffffea803448:	aa1603e0 	mov	x0, x22
ffffffffea80344c:	aa1a03e1 	mov	x1, x26
ffffffffea803450:	2a1b03e4 	mov	w4, w27
ffffffffea803454:	aa1303e2 	mov	x2, x19
ffffffffea803458:	0b170063 	add	w3, w3, w23
ffffffffea80345c:	97ffffaf 	bl	ffffffffea803318 <arm64_mmu_unmap_pt>
            if (chunk_size == block_size ||
ffffffffea803460:	a9489fa9 	ldp	x9, x7, [x29, #136]
ffffffffea803464:	b9407ba8 	ldr	w8, [x29, #120]
ffffffffea803468:	b94087ab 	ldr	w11, [x29, #132]
ffffffffea80346c:	eb1300ff 	cmp	x7, x19
ffffffffea803470:	b940a3aa 	ldr	w10, [x29, #160]
ffffffffea803474:	f9403bac 	ldr	x12, [x29, #112]
ffffffffea803478:	f9404fad 	ldr	x13, [x29, #152]
ffffffffea80347c:	f94057af 	ldr	x15, [x29, #168]
ffffffffea803480:	54000180 	b.eq	ffffffffea8034b0 <arm64_mmu_unmap_pt+0x198>  // b.none
    for (i = 0; i < count; i++) {
ffffffffea803484:	7100017f 	cmp	w11, #0x0
ffffffffea803488:	5400014d 	b.le	ffffffffea8034b0 <arm64_mmu_unmap_pt+0x198>
        if (pte != MMU_PTE_DESCRIPTOR_INVALID) {
ffffffffea80348c:	f94001e0 	ldr	x0, [x15]
ffffffffea803490:	b5fff9e0 	cbnz	x0, ffffffffea8033cc <arm64_mmu_unmap_pt+0xb4>
ffffffffea803494:	910021e0 	add	x0, x15, #0x8
ffffffffea803498:	8b0c01e2 	add	x2, x15, x12
ffffffffea80349c:	14000003 	b	ffffffffea8034a8 <arm64_mmu_unmap_pt+0x190>
ffffffffea8034a0:	f8408401 	ldr	x1, [x0], #8
ffffffffea8034a4:	b5fff941 	cbnz	x1, ffffffffea8033cc <arm64_mmu_unmap_pt+0xb4>
    for (i = 0; i < count; i++) {
ffffffffea8034a8:	eb00005f 	cmp	x2, x0
ffffffffea8034ac:	54ffffa1 	b.ne	ffffffffea8034a0 <arm64_mmu_unmap_pt+0x188>  // b.any
                page_table[index] = MMU_PTE_DESCRIPTOR_INVALID;
ffffffffea8034b0:	f8387b9f 	str	xzr, [x28, x24, lsl #3]
                __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea8034b4:	d5033abf 	dmb	ishst
ffffffffea8034b8:	f9003fac 	str	x12, [x29, #120]
    if (size >= PAGE_SIZE) {
ffffffffea8034bc:	713ffd1f 	cmp	w8, #0xfff
ffffffffea8034c0:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea8034c4:	b90093ab 	str	w11, [x29, #144]
ffffffffea8034c8:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea8034cc:	f90057ad 	str	x13, [x29, #168]
ffffffffea8034d0:	54000209 	b.ls	ffffffffea803510 <arm64_mmu_unmap_pt+0x1f8>  // b.plast
        page = address_to_page(paddr);
ffffffffea8034d4:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8034d8:	9400367c 	bl	ffffffffea810ec8 <address_to_page>
        if (!page)
ffffffffea8034dc:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea8034e0:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea8034e4:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea8034e8:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea8034ec:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea8034f0:	b4000200 	cbz	x0, ffffffffea803530 <arm64_mmu_unmap_pt+0x218>
ffffffffea8034f4:	f9003fac 	str	x12, [x29, #120]
ffffffffea8034f8:	2910a3aa 	stp	w10, w8, [x29, #132]
ffffffffea8034fc:	b90093ab 	str	w11, [x29, #144]
ffffffffea803500:	a9099fa9 	stp	x9, x7, [x29, #152]
ffffffffea803504:	f90057ad 	str	x13, [x29, #168]
        pmm_free_page(page);
ffffffffea803508:	940037aa 	bl	ffffffffea8113b0 <pmm_free_page>
ffffffffea80350c:	14000003 	b	ffffffffea803518 <arm64_mmu_unmap_pt+0x200>
        heap_free(vaddr);
ffffffffea803510:	aa0f03e0 	mov	x0, x15
ffffffffea803514:	94003dbd 	bl	ffffffffea812c08 <heap_free>
ffffffffea803518:	2950a3aa 	ldp	w10, w8, [x29, #132]
ffffffffea80351c:	b94093ab 	ldr	w11, [x29, #144]
ffffffffea803520:	f9403fac 	ldr	x12, [x29, #120]
ffffffffea803524:	a9499fa9 	ldp	x9, x7, [x29, #152]
ffffffffea803528:	f94057ad 	ldr	x13, [x29, #168]
ffffffffea80352c:	17ffffa8 	b	ffffffffea8033cc <arm64_mmu_unmap_pt+0xb4>
            panic("bad page table paddr 0x%lx\n", paddr);
ffffffffea803530:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea803534:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803538:	aa1903e0 	mov	x0, x25
ffffffffea80353c:	91302021 	add	x1, x1, #0xc08
ffffffffea803540:	94003c10 	bl	ffffffffea812580 <_panic>
ffffffffea803544:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803548 <arch_mmu_query>:
{
ffffffffea803548:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    if (vaddr < kernel_base) {
ffffffffea80354c:	92a40003 	mov	x3, #0xffffffffdfffffff    	// #-536870913
ffffffffea803550:	eb03001f 	cmp	x0, x3
{
ffffffffea803554:	910003fd 	mov	x29, sp
    if (vaddr < kernel_base) {
ffffffffea803558:	54000c09 	b.ls	ffffffffea8036d8 <arch_mmu_query+0x190>  // b.plast
ffffffffea80355c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea803560:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea803564:	aa0103f6 	mov	x22, x1
    vaddr_rem = vaddr - kernel_base;
ffffffffea803568:	d2a40001 	mov	x1, #0x20000000            	// #536870912
ffffffffea80356c:	8b010013 	add	x19, x0, x1
        pte = page_table[index];
ffffffffea803570:	90000300 	adrp	x0, ffffffffea863000 <arm64_kernel_translation_table>
ffffffffea803574:	91000000 	add	x0, x0, #0x0
        index = vaddr_rem >> index_shift;
ffffffffea803578:	d355fe61 	lsr	x1, x19, #21
ffffffffea80357c:	aa0203f5 	mov	x21, x2
ffffffffea803580:	92405274 	and	x20, x19, #0x1fffff
        pte = page_table[index];
ffffffffea803584:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803588:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea80358c:	72000422 	ands	w2, w1, #0x3
ffffffffea803590:	54000460 	b.eq	ffffffffea80361c <arch_mmu_query+0xd4>  // b.none
ffffffffea803594:	f9001bb7 	str	x23, [x29, #48]
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea803598:	7100045f 	cmp	w2, #0x1
ffffffffea80359c:	aa1e03f7 	mov	x23, x30
ffffffffea8035a0:	54000180 	b.eq	ffffffffea8035d0 <arch_mmu_query+0x88>  // b.none
        if (index_shift <= MMU_KERNEL_PAGE_SIZE_SHIFT ||
ffffffffea8035a4:	71000c5f 	cmp	w2, #0x3
ffffffffea8035a8:	540002c1 	b.ne	ffffffffea803600 <arch_mmu_query+0xb8>  // b.any
        page_table = paddr_to_kvaddr(pte_addr);
ffffffffea8035ac:	9400382b 	bl	ffffffffea811658 <paddr_to_kvaddr>
ffffffffea8035b0:	d34c5261 	ubfx	x1, x19, #12, #9
        vaddr_rem -= (vaddr_t)index << index_shift;
ffffffffea8035b4:	cb013294 	sub	x20, x20, x1, lsl #12
        pte = page_table[index];
ffffffffea8035b8:	f8617801 	ldr	x1, [x0, x1, lsl #3]
        pte_addr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea8035bc:	92748c20 	and	x0, x1, #0xfffffffff000
        if (descriptor_type == MMU_PTE_DESCRIPTOR_INVALID)
ffffffffea8035c0:	72000422 	ands	w2, w1, #0x3
ffffffffea8035c4:	540002a0 	b.eq	ffffffffea803618 <arch_mmu_query+0xd0>  // b.none
        if (descriptor_type == ((index_shift > MMU_KERNEL_PAGE_SIZE_SHIFT) ?
ffffffffea8035c8:	71000c5f 	cmp	w2, #0x3
ffffffffea8035cc:	540001a1 	b.ne	ffffffffea803600 <arch_mmu_query+0xb8>  // b.any
    if (paddr)
ffffffffea8035d0:	b4000076 	cbz	x22, ffffffffea8035dc <arch_mmu_query+0x94>
        *paddr = pte_addr + vaddr_rem;
ffffffffea8035d4:	8b000294 	add	x20, x20, x0
ffffffffea8035d8:	f90002d4 	str	x20, [x22]
    if (flags) {
ffffffffea8035dc:	b40005d5 	cbz	x21, ffffffffea803694 <arch_mmu_query+0x14c>
            *flags |= ARCH_MMU_FLAG_NS;
ffffffffea8035e0:	121b0020 	and	w0, w1, #0x20
ffffffffea8035e4:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_ATTR_INDEX_MASK) {
ffffffffea8035e8:	927e0822 	and	x2, x1, #0x1c
ffffffffea8035ec:	f100105f 	cmp	x2, #0x4
ffffffffea8035f0:	54000660 	b.eq	ffffffffea8036bc <arch_mmu_query+0x174>  // b.none
ffffffffea8035f4:	f100205f 	cmp	x2, #0x8
ffffffffea8035f8:	54000200 	b.eq	ffffffffea803638 <arch_mmu_query+0xf0>  // b.none
ffffffffea8035fc:	b40001a2 	cbz	x2, ffffffffea803630 <arch_mmu_query+0xe8>
                PANIC_UNIMPLEMENTED;
ffffffffea803600:	f0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803604:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803608:	9129c042 	add	x2, x2, #0xa70
ffffffffea80360c:	912c0021 	add	x1, x1, #0xb00
ffffffffea803610:	aa1703e0 	mov	x0, x23
ffffffffea803614:	94003bdb 	bl	ffffffffea812580 <_panic>
ffffffffea803618:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80361c:	a94153b3 	ldp	x19, x20, [x29, #16]
            return ERR_NOT_FOUND;
ffffffffea803620:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea803624:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea803628:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80362c:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea803630:	32000000 	orr	w0, w0, #0x1
ffffffffea803634:	b90002a0 	str	w0, [x21]
        switch (pte & MMU_PTE_ATTR_AP_MASK) {
ffffffffea803638:	927a0420 	and	x0, x1, #0xc0
ffffffffea80363c:	f102001f 	cmp	x0, #0x80
ffffffffea803640:	54000440 	b.eq	ffffffffea8036c8 <arch_mmu_query+0x180>  // b.none
ffffffffea803644:	f103001f 	cmp	x0, #0xc0
ffffffffea803648:	54000320 	b.eq	ffffffffea8036ac <arch_mmu_query+0x164>  // b.none
ffffffffea80364c:	f101001f 	cmp	x0, #0x40
ffffffffea803650:	54000081 	b.ne	ffffffffea803660 <arch_mmu_query+0x118>  // b.any
                *flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea803654:	b94002a0 	ldr	w0, [x21]
ffffffffea803658:	321e0000 	orr	w0, w0, #0x4
ffffffffea80365c:	b90002a0 	str	w0, [x21]
        if ((pte & MMU_PTE_ATTR_UXN) && (pte & MMU_PTE_ATTR_PXN)) {
ffffffffea803660:	924b0421 	and	x1, x1, #0x60000000000000
ffffffffea803664:	d2e00c00 	mov	x0, #0x60000000000000      	// #27021597764222976
ffffffffea803668:	eb00003f 	cmp	x1, x0
ffffffffea80366c:	54000141 	b.ne	ffffffffea803694 <arch_mmu_query+0x14c>  // b.any
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea803670:	b94002a1 	ldr	w1, [x21]
    return 0;
ffffffffea803674:	52800000 	mov	w0, #0x0                   	// #0
            *flags |= ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea803678:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80367c:	321c0021 	orr	w1, w1, #0x10
ffffffffea803680:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea803684:	b90002a1 	str	w1, [x21]
ffffffffea803688:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80368c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea803690:	d65f03c0 	ret
    return 0;
ffffffffea803694:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803698:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80369c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea8036a0:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea8036a4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8036a8:	d65f03c0 	ret
                *flags |= ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO;
ffffffffea8036ac:	b94002a0 	ldr	w0, [x21]
ffffffffea8036b0:	321e0400 	orr	w0, w0, #0xc
ffffffffea8036b4:	b90002a0 	str	w0, [x21]
                break;
ffffffffea8036b8:	17ffffea 	b	ffffffffea803660 <arch_mmu_query+0x118>
                *flags |= ARCH_MMU_FLAG_UNCACHED_DEVICE;
ffffffffea8036bc:	321f0000 	orr	w0, w0, #0x2
ffffffffea8036c0:	b90002a0 	str	w0, [x21]
                break;
ffffffffea8036c4:	17ffffdd 	b	ffffffffea803638 <arch_mmu_query+0xf0>
                *flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea8036c8:	b94002a0 	ldr	w0, [x21]
ffffffffea8036cc:	321d0000 	orr	w0, w0, #0x8
ffffffffea8036d0:	b90002a0 	str	w0, [x21]
                break;
ffffffffea8036d4:	17ffffe3 	b	ffffffffea803660 <arch_mmu_query+0x118>
        TRACEF("vaddr 0x%lx < base 0x%lx\n", vaddr, kernel_base);
ffffffffea8036d8:	f0000085 	adrp	x5, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8036dc:	aa0003e3 	mov	x3, x0
ffffffffea8036e0:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8036e4:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea8036e8:	52800d02 	mov	w2, #0x68                  	// #104
ffffffffea8036ec:	9129c021 	add	x1, x1, #0xa70
ffffffffea8036f0:	912b60a0 	add	x0, x5, #0xad8
ffffffffea8036f4:	94004159 	bl	ffffffffea813c58 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea8036f8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea8036fc:	17ffffcb 	b	ffffffffea803628 <arch_mmu_query+0xe0>

ffffffffea803700 <arm64_mmu_map_pt>:
static int arm64_mmu_map_pt(vaddr_t vaddr_in, vaddr_t vaddr_rel_in,
                            paddr_t paddr_in,
                            size_t size_in, pte_t attrs,
                            uint index_shift, uint page_size_shift,
                            pte_t *page_table, uint asid)
{
ffffffffea803700:	d10383ff 	sub	sp, sp, #0xe0
ffffffffea803704:	aa0103e8 	mov	x8, x1
ffffffffea803708:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea80370c:	910043fd 	add	x29, sp, #0x10
ffffffffea803710:	a90887a3 	stp	x3, x1, [x29, #136]
ffffffffea803714:	f00002e1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea803718:	f9002ffa 	str	x26, [sp, #88]
ffffffffea80371c:	aa0203fa 	mov	x26, x2
ffffffffea803720:	aa0303e2 	mov	x2, x3
ffffffffea803724:	f9402823 	ldr	x3, [x1, #80]
ffffffffea803728:	f90023f7 	str	x23, [sp, #64]

    LTRACEF("vaddr 0x%lx, vaddr_rel 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, index shift %d, page_size_shift %d, page_table %p\n",
            vaddr, vaddr_rel, paddr, size, attrs,
            index_shift, page_size_shift, page_table);

    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea80372c:	aa020341 	orr	x1, x26, x2
{
ffffffffea803730:	f9400069 	ldr	x9, [x3]
ffffffffea803734:	f90067a9 	str	x9, [x29, #200]
ffffffffea803738:	d2800009 	mov	x9, #0x0                   	// #0
ffffffffea80373c:	2a0603f7 	mov	w23, w6
ffffffffea803740:	f90033be 	str	x30, [x29, #96]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea803744:	aa0203e6 	mov	x6, x2
{
ffffffffea803748:	f9004fa0 	str	x0, [x29, #152]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea80374c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
ffffffffea803750:	a90b1fa4 	stp	x4, x7, [x29, #176]
    if ((vaddr_rel | paddr | size) & ((1UL << page_size_shift) - 1)) {
ffffffffea803754:	aa080021 	orr	x1, x1, x8
ffffffffea803758:	9ad72042 	lsl	x2, x2, x23
ffffffffea80375c:	ea22003f 	bics	xzr, x1, x2
ffffffffea803760:	540014c1 	b.ne	ffffffffea8039f8 <arm64_mmu_map_pt+0x2f8>  // b.any
        TRACEF("not page aligned\n");
        return ERR_INVALID_ARGS;
    }

    while (size) {
ffffffffea803764:	b4001306 	cbz	x6, ffffffffea8039c4 <arm64_mmu_map_pt+0x2c4>
ffffffffea803768:	a9025bb5 	stp	x21, x22, [x29, #32]
        block_size = 1UL << index_shift;
ffffffffea80376c:	d2800035 	mov	x21, #0x1                   	// #1
    size_t size = 1U << page_size_shift;
ffffffffea803770:	1ad722a0 	lsl	w0, w21, w23
ffffffffea803774:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea803778:	a90573bb 	stp	x27, x28, [x29, #80]
            next_page_table = arm64_mmu_get_page_table(index, page_size_shift,
                                                       page_table);
            if (!next_page_table)
                goto err;

            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea80377c:	11000cb9 	add	w25, w5, #0x3
    vaddr_t vaddr_rel = vaddr_rel_in;
ffffffffea803780:	a948efbc 	ldp	x28, x27, [x29, #136]
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803784:	4b170321 	sub	w1, w25, w23
    size_t size = 1U << page_size_shift;
ffffffffea803788:	f90053a0 	str	x0, [x29, #160]
        block_size = 1UL << index_shift;
ffffffffea80378c:	9ac522b5 	lsl	x21, x21, x5
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803790:	291507a0 	stp	w0, w1, [x29, #168]
        count = size / PAGE_SIZE;
ffffffffea803794:	d34cfc00 	lsr	x0, x0, #12
ffffffffea803798:	290d03a0 	stp	w0, w0, [x29, #104]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea80379c:	910303a0 	add	x0, x29, #0xc0
ffffffffea8037a0:	f9003ba0 	str	x0, [x29, #112]
ffffffffea8037a4:	aa1c03e0 	mov	x0, x28
ffffffffea8037a8:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8037ac:	aa1b03fc 	mov	x28, x27
ffffffffea8037b0:	2a0503f3 	mov	w19, w5
        block_mask = block_size - 1;
ffffffffea8037b4:	d10006b6 	sub	x22, x21, #0x1
    vaddr_t vaddr = vaddr_in;
ffffffffea8037b8:	f9404fb4 	ldr	x20, [x29, #152]
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea8037bc:	aa0003fb 	mov	x27, x0
ffffffffea8037c0:	1400000f 	b	ffffffffea8037fc <arm64_mmu_map_pt+0xfc>
                                   page_size_shift, next_page_table, asid);
            if (ret)
                goto err;
        } else {
            pte = page_table[index];
            if (pte) {
ffffffffea8037c4:	b5001044 	cbnz	x4, ffffffffea8039cc <arm64_mmu_map_pt+0x2cc>
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
                       index, pte);
                goto err;
            }

            pte = paddr | attrs;
ffffffffea8037c8:	f9405ba0 	ldr	x0, [x29, #176]
            if (index_shift > page_size_shift)
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea8037cc:	6b1302ff 	cmp	w23, w19
            pte = paddr | attrs;
ffffffffea8037d0:	aa1a0000 	orr	x0, x0, x26
                pte |= MMU_PTE_L012_DESCRIPTOR_BLOCK;
ffffffffea8037d4:	b2400001 	orr	x1, x0, #0x1
ffffffffea8037d8:	b2400400 	orr	x0, x0, #0x3
ffffffffea8037dc:	9a812000 	csel	x0, x0, x1, cs  // cs = hs, nlast
            else
                pte |= MMU_PTE_L3_DESCRIPTOR_PAGE;

            LTRACEF("pte %p[0x%lx] = 0x%llx\n", page_table, index, pte);
            page_table[index] = pte;
ffffffffea8037e0:	f9405fa1 	ldr	x1, [x29, #184]
ffffffffea8037e4:	f8397820 	str	x0, [x1, x25, lsl #3]
        }
        vaddr += chunk_size;
ffffffffea8037e8:	8b180294 	add	x20, x20, x24
        vaddr_rel += chunk_size;
ffffffffea8037ec:	8b18039c 	add	x28, x28, x24
        paddr += chunk_size;
ffffffffea8037f0:	8b18035a 	add	x26, x26, x24
    while (size) {
ffffffffea8037f4:	eb18037b 	subs	x27, x27, x24
ffffffffea8037f8:	54000de0 	b.eq	ffffffffea8039b4 <arm64_mmu_map_pt+0x2b4>  // b.none
        vaddr_rem = vaddr_rel & block_mask;
ffffffffea8037fc:	8a1c02cc 	and	x12, x22, x28
ffffffffea803800:	f9405fa0 	ldr	x0, [x29, #184]
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803804:	cb0c02a8 	sub	x8, x21, x12
        index = vaddr_rel >> index_shift;
ffffffffea803808:	9ad32799 	lsr	x25, x28, x19
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea80380c:	eb1b011f 	cmp	x8, x27
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea803810:	aa1a0381 	orr	x1, x28, x26
        chunk_size = MIN(size, block_size - vaddr_rem);
ffffffffea803814:	9a9b9118 	csel	x24, x8, x27, ls  // ls = plast
ffffffffea803818:	f8797804 	ldr	x4, [x0, x25, lsl #3]
        if (((vaddr_rel | paddr) & block_mask) ||
ffffffffea80381c:	ea16003f 	tst	x1, x22
ffffffffea803820:	54000081 	b.ne	ffffffffea803830 <arm64_mmu_map_pt+0x130>  // b.any
            (chunk_size != block_size) ||
ffffffffea803824:	eb1802bf 	cmp	x21, x24
ffffffffea803828:	7a5e0a62 	ccmp	w19, #0x1e, #0x2, eq  // eq = none
ffffffffea80382c:	54fffcc9 	b.ls	ffffffffea8037c4 <arm64_mmu_map_pt+0xc4>  // b.plast
    switch (pte & MMU_PTE_DESCRIPTOR_MASK) {
ffffffffea803830:	92400480 	and	x0, x4, #0x3
ffffffffea803834:	f100041f 	cmp	x0, #0x1
ffffffffea803838:	540002c0 	b.eq	ffffffffea803890 <arm64_mmu_map_pt+0x190>  // b.none
ffffffffea80383c:	b40005e0 	cbz	x0, ffffffffea8038f8 <arm64_mmu_map_pt+0x1f8>
ffffffffea803840:	f1000c1f 	cmp	x0, #0x3
ffffffffea803844:	54000ea1 	b.ne	ffffffffea803a18 <arm64_mmu_map_pt+0x318>  // b.any
        paddr = pte & MMU_PTE_OUTPUT_ADDR_MASK;
ffffffffea803848:	92748c80 	and	x0, x4, #0xfffffffff000
ffffffffea80384c:	f90043ac 	str	x12, [x29, #128]
ffffffffea803850:	f90063a0 	str	x0, [x29, #192]
        return paddr_to_kvaddr(paddr);
ffffffffea803854:	94003781 	bl	ffffffffea811658 <paddr_to_kvaddr>
ffffffffea803858:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea80385c:	aa0003e7 	mov	x7, x0
            if (!next_page_table)
ffffffffea803860:	b4000187 	cbz	x7, ffffffffea803890 <arm64_mmu_map_pt+0x190>
            ret = arm64_mmu_map_pt(vaddr, vaddr_rem, paddr, chunk_size, attrs,
ffffffffea803864:	b940afa5 	ldr	w5, [x29, #172]
ffffffffea803868:	2a1703e6 	mov	w6, w23
ffffffffea80386c:	f9405ba4 	ldr	x4, [x29, #176]
ffffffffea803870:	aa0c03e1 	mov	x1, x12
ffffffffea803874:	b940d3a0 	ldr	w0, [x29, #208]
ffffffffea803878:	aa1803e3 	mov	x3, x24
ffffffffea80387c:	b90003e0 	str	w0, [sp]
ffffffffea803880:	aa1a03e2 	mov	x2, x26
ffffffffea803884:	aa1403e0 	mov	x0, x20
ffffffffea803888:	97ffff9e 	bl	ffffffffea803700 <arm64_mmu_map_pt>
            if (ret)
ffffffffea80388c:	34fffae0 	cbz	w0, ffffffffea8037e8 <arm64_mmu_map_pt+0xe8>
ffffffffea803890:	aa1b03fc 	mov	x28, x27
    }

    return 0;

err:
    arm64_mmu_unmap_pt(vaddr_in, vaddr_rel_in, size_in - size,
ffffffffea803894:	a94887a0 	ldp	x0, x1, [x29, #136]
ffffffffea803898:	2a1703e4 	mov	w4, w23
ffffffffea80389c:	b940d3a6 	ldr	w6, [x29, #208]
ffffffffea8038a0:	2a1303e3 	mov	w3, w19
ffffffffea8038a4:	cb1c0002 	sub	x2, x0, x28
ffffffffea8038a8:	f9404fa0 	ldr	x0, [x29, #152]
ffffffffea8038ac:	f9405fa5 	ldr	x5, [x29, #184]
ffffffffea8038b0:	97fffe9a 	bl	ffffffffea803318 <arm64_mmu_unmap_pt>
                       index_shift, page_size_shift, page_table, asid);
    DSB;
ffffffffea8038b4:	d5033f9f 	dsb	sy
    return ERR_GENERIC;
ffffffffea8038b8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea8038bc:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea8038c0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8038c4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8038c8:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea8038cc:	f00002e1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea8038d0:	f9402821 	ldr	x1, [x1, #80]
ffffffffea8038d4:	f94067a2 	ldr	x2, [x29, #200]
ffffffffea8038d8:	f9400021 	ldr	x1, [x1]
ffffffffea8038dc:	ca010041 	eor	x1, x2, x1
ffffffffea8038e0:	b5000a81 	cbnz	x1, ffffffffea803a30 <arm64_mmu_map_pt+0x330>
ffffffffea8038e4:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea8038e8:	f94023f7 	ldr	x23, [sp, #64]
ffffffffea8038ec:	f9402ffa 	ldr	x26, [sp, #88]
ffffffffea8038f0:	910383ff 	add	sp, sp, #0xe0
ffffffffea8038f4:	d65f03c0 	ret
    if (size >= PAGE_SIZE) {
ffffffffea8038f8:	b940aba0 	ldr	w0, [x29, #168]
ffffffffea8038fc:	713ffc1f 	cmp	w0, #0xfff
ffffffffea803900:	54000309 	b.ls	ffffffffea803960 <arm64_mmu_map_pt+0x260>  // b.plast
        ret = pmm_alloc_contiguous(count, page_size_shift, paddrp, NULL);
ffffffffea803904:	b9406ba0 	ldr	w0, [x29, #104]
ffffffffea803908:	2a1703e1 	mov	w1, w23
ffffffffea80390c:	f9403ba2 	ldr	x2, [x29, #112]
ffffffffea803910:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea803914:	f90043ac 	str	x12, [x29, #128]
ffffffffea803918:	940036da 	bl	ffffffffea811480 <pmm_alloc_contiguous>
        if (ret != count)
ffffffffea80391c:	b9406fa1 	ldr	w1, [x29, #108]
ffffffffea803920:	f94043ac 	ldr	x12, [x29, #128]
ffffffffea803924:	6b00003f 	cmp	w1, w0
ffffffffea803928:	54000641 	b.ne	ffffffffea8039f0 <arm64_mmu_map_pt+0x2f0>  // b.any
        vaddr = paddr_to_kvaddr(paddr);
ffffffffea80392c:	f94063a0 	ldr	x0, [x29, #192]
ffffffffea803930:	f9003fac 	str	x12, [x29, #120]
ffffffffea803934:	94003749 	bl	ffffffffea811658 <paddr_to_kvaddr>
ffffffffea803938:	f90043a0 	str	x0, [x29, #128]
        memset(vaddr, MMU_PTE_DESCRIPTOR_INVALID, 1U << page_size_shift);
ffffffffea80393c:	f94053a2 	ldr	x2, [x29, #160]
ffffffffea803940:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea803944:	940041dd 	bl	ffffffffea8140b8 <memset>
        __asm__ volatile("dmb ishst" ::: "memory");
ffffffffea803948:	d5033abf 	dmb	ishst
        pte = paddr | MMU_PTE_L012_DESCRIPTOR_TABLE;
ffffffffea80394c:	a94b83a1 	ldp	x1, x0, [x29, #184]
ffffffffea803950:	a9479fac 	ldp	x12, x7, [x29, #120]
ffffffffea803954:	b2400400 	orr	x0, x0, #0x3
        page_table[index] = pte;
ffffffffea803958:	f8397820 	str	x0, [x1, x25, lsl #3]
ffffffffea80395c:	17ffffc1 	b	ffffffffea803860 <arm64_mmu_map_pt+0x160>
        vaddr = heap_alloc(size, size);
ffffffffea803960:	b940aba1 	ldr	w1, [x29, #168]
ffffffffea803964:	f94053a0 	ldr	x0, [x29, #160]
ffffffffea803968:	f9003fac 	str	x12, [x29, #120]
ffffffffea80396c:	94003be5 	bl	ffffffffea812900 <heap_alloc>
        if (!vaddr)
ffffffffea803970:	f90043a0 	str	x0, [x29, #128]
ffffffffea803974:	b40003e0 	cbz	x0, ffffffffea8039f0 <arm64_mmu_map_pt+0x2f0>
        ret = arch_mmu_query((vaddr_t)vaddr, paddrp, NULL);
ffffffffea803978:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea80397c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea803980:	97fffef2 	bl	ffffffffea803548 <arch_mmu_query>
        if (ret) {
ffffffffea803984:	a9478fac 	ldp	x12, x3, [x29, #120]
ffffffffea803988:	34fffd20 	cbz	w0, ffffffffea80392c <arm64_mmu_map_pt+0x22c>
ffffffffea80398c:	aa1b03fc 	mov	x28, x27
            heap_free(vaddr);
ffffffffea803990:	aa0303e0 	mov	x0, x3
ffffffffea803994:	94003c9d 	bl	ffffffffea812c08 <heap_free>
            TRACEF("failed to allocate page table\n");
ffffffffea803998:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80399c:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8039a0:	52801da2 	mov	w2, #0xed                  	// #237
ffffffffea8039a4:	912a0021 	add	x1, x1, #0xa80
ffffffffea8039a8:	912e8000 	add	x0, x0, #0xba0
ffffffffea8039ac:	940040ab 	bl	ffffffffea813c58 <_printf>
ffffffffea8039b0:	17ffffb9 	b	ffffffffea803894 <arm64_mmu_map_pt+0x194>
ffffffffea8039b4:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea8039b8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8039bc:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea8039c0:	a94573bb 	ldp	x27, x28, [x29, #80]
    return 0;
ffffffffea8039c4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8039c8:	17ffffc1 	b	ffffffffea8038cc <arm64_mmu_map_pt+0x1cc>
ffffffffea8039cc:	aa1b03fc 	mov	x28, x27
                TRACEF("page table entry already in use, index 0x%lx, 0x%llx\n",
ffffffffea8039d0:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8039d4:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8039d8:	aa1903e3 	mov	x3, x25
ffffffffea8039dc:	528030e2 	mov	w2, #0x187                 	// #391
ffffffffea8039e0:	912a8021 	add	x1, x1, #0xaa0
ffffffffea8039e4:	912f2000 	add	x0, x0, #0xbc8
ffffffffea8039e8:	9400409c 	bl	ffffffffea813c58 <_printf>
                goto err;
ffffffffea8039ec:	17ffffaa 	b	ffffffffea803894 <arm64_mmu_map_pt+0x194>
ffffffffea8039f0:	aa1b03fc 	mov	x28, x27
ffffffffea8039f4:	17ffffe9 	b	ffffffffea803998 <arm64_mmu_map_pt+0x298>
        TRACEF("not page aligned\n");
ffffffffea8039f8:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8039fc:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803a00:	52802d62 	mov	w2, #0x16b                 	// #363
ffffffffea803a04:	912a8021 	add	x1, x1, #0xaa0
ffffffffea803a08:	912e0000 	add	x0, x0, #0xb80
ffffffffea803a0c:	94004093 	bl	ffffffffea813c58 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803a10:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803a14:	17ffffae 	b	ffffffffea8038cc <arm64_mmu_map_pt+0x1cc>
        PANIC_UNIMPLEMENTED;
ffffffffea803a18:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea803a1c:	f0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803a20:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803a24:	912a0042 	add	x2, x2, #0xa80
ffffffffea803a28:	912c0021 	add	x1, x1, #0xb00
ffffffffea803a2c:	94003ad5 	bl	ffffffffea812580 <_panic>
ffffffffea803a30:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea803a34:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea803a38:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea803a3c:	a90573bb 	stp	x27, x28, [x29, #80]
}
ffffffffea803a40:	940040ba 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea803a44:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803a48 <arm64_mmu_map>:

int arm64_mmu_map(vaddr_t vaddr, paddr_t paddr, size_t size, pte_t attrs,
                  vaddr_t vaddr_base, uint top_size_shift,
                  uint top_index_shift, uint page_size_shift,
                  pte_t *top_page_table, uint asid)
{
ffffffffea803a48:	d10083ff 	sub	sp, sp, #0x20
    int ret;
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea803a4c:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803a50:	9ac52108 	lsl	x8, x8, x5
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea803a54:	cb040009 	sub	x9, x0, x4

    LTRACEF("vaddr 0x%lx, paddr 0x%lx, size 0x%lx, attrs 0x%llx, asid 0x%x\n",
            vaddr, paddr, size, attrs, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a58:	cb020105 	sub	x5, x8, x2
{
ffffffffea803a5c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803a60:	910043fd 	add	x29, sp, #0x10
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a64:	eb0900bf 	cmp	x5, x9
{
ffffffffea803a68:	2a0603e5 	mov	w5, w6
ffffffffea803a6c:	2a0703e6 	mov	w6, w7
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a70:	fa422100 	ccmp	x8, x2, #0x0, cs  // cs = hs, nlast
{
ffffffffea803a74:	f9400ba7 	ldr	x7, [x29, #16]
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803a78:	540001a3 	b.cc	ffffffffea803aac <arm64_mmu_map+0x64>  // b.lo, b.ul, b.last
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803a7c:	b4000327 	cbz	x7, ffffffffea803ae0 <arm64_mmu_map+0x98>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    ret = arm64_mmu_map_pt(vaddr, vaddr_rel, paddr, size, attrs,
ffffffffea803a80:	b9401ba4 	ldr	w4, [x29, #24]
ffffffffea803a84:	b90003e4 	str	w4, [sp]
ffffffffea803a88:	aa0303e4 	mov	x4, x3
ffffffffea803a8c:	aa0203e3 	mov	x3, x2
ffffffffea803a90:	aa0103e2 	mov	x2, x1
ffffffffea803a94:	aa0903e1 	mov	x1, x9
ffffffffea803a98:	97ffff1a 	bl	ffffffffea803700 <arm64_mmu_map_pt>
                           top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803a9c:	d5033f9f 	dsb	sy
    return ret;
}
ffffffffea803aa0:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803aa4:	910083ff 	add	sp, sp, #0x20
ffffffffea803aa8:	d65f03c0 	ret
ffffffffea803aac:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803ab0:	aa0403e5 	mov	x5, x4
ffffffffea803ab4:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803ab8:	aa0203e4 	mov	x4, x2
ffffffffea803abc:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803ac0:	aa0803e6 	mov	x6, x8
ffffffffea803ac4:	aa0a03e3 	mov	x3, x10
ffffffffea803ac8:	52803622 	mov	w2, #0x1b1                 	// #433
ffffffffea803acc:	912ae021 	add	x1, x1, #0xab8
ffffffffea803ad0:	912c6000 	add	x0, x0, #0xb18
ffffffffea803ad4:	94004061 	bl	ffffffffea813c58 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803ad8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803adc:	17fffff1 	b	ffffffffea803aa0 <arm64_mmu_map+0x58>
        TRACEF("page table is NULL\n");
ffffffffea803ae0:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803ae4:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803ae8:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea803aec:	912ae021 	add	x1, x1, #0xab8
ffffffffea803af0:	912d8000 	add	x0, x0, #0xb60
ffffffffea803af4:	94004059 	bl	ffffffffea813c58 <_printf>
ffffffffea803af8:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803afc:	17ffffe9 	b	ffffffffea803aa0 <arm64_mmu_map+0x58>

ffffffffea803b00 <arm64_mmu_unmap>:

int arm64_mmu_unmap(vaddr_t vaddr, size_t size,
                    vaddr_t vaddr_base, uint top_size_shift,
                    uint top_index_shift, uint page_size_shift,
                    pte_t *top_page_table, uint asid)
{
ffffffffea803b00:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    vaddr_t vaddr_rel = vaddr - vaddr_base;
    vaddr_t vaddr_rel_max = 1UL << top_size_shift;
ffffffffea803b04:	d2800028 	mov	x8, #0x1                   	// #1
ffffffffea803b08:	9ac32108 	lsl	x8, x8, x3
    vaddr_t vaddr_rel = vaddr - vaddr_base;
ffffffffea803b0c:	cb020009 	sub	x9, x0, x2

    LTRACEF("vaddr 0x%lx, size 0x%lx, asid 0x%x\n", vaddr, size, asid);

    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803b10:	cb01010b 	sub	x11, x8, x1
{
ffffffffea803b14:	910003fd 	mov	x29, sp
    if (vaddr_rel > vaddr_rel_max - size || size > vaddr_rel_max) {
ffffffffea803b18:	eb09017f 	cmp	x11, x9
ffffffffea803b1c:	fa412100 	ccmp	x8, x1, #0x0, cs  // cs = hs, nlast
ffffffffea803b20:	540001a3 	b.cc	ffffffffea803b54 <arm64_mmu_unmap+0x54>  // b.lo, b.ul, b.last
ffffffffea803b24:	2a0403e3 	mov	w3, w4
ffffffffea803b28:	2a0503e4 	mov	w4, w5
ffffffffea803b2c:	aa0603e5 	mov	x5, x6
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
               vaddr, size, vaddr_base, vaddr_rel_max);
        return ERR_INVALID_ARGS;
    }

    if (!top_page_table) {
ffffffffea803b30:	b40002c6 	cbz	x6, ffffffffea803b88 <arm64_mmu_unmap+0x88>
        TRACEF("page table is NULL\n");
        return ERR_INVALID_ARGS;
    }

    arm64_mmu_unmap_pt(vaddr, vaddr_rel, size,
ffffffffea803b34:	aa0103e2 	mov	x2, x1
ffffffffea803b38:	2a0703e6 	mov	w6, w7
ffffffffea803b3c:	aa0903e1 	mov	x1, x9
ffffffffea803b40:	97fffdf6 	bl	ffffffffea803318 <arm64_mmu_unmap_pt>
                       top_index_shift, page_size_shift, top_page_table, asid);
    DSB;
ffffffffea803b44:	d5033f9f 	dsb	sy
    return 0;
ffffffffea803b48:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea803b4c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803b50:	d65f03c0 	ret
ffffffffea803b54:	aa0003ea 	mov	x10, x0
        TRACEF("vaddr 0x%lx, size 0x%lx out of range vaddr 0x%lx, size 0x%lx\n",
ffffffffea803b58:	f0000087 	adrp	x7, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803b5c:	aa0203e5 	mov	x5, x2
ffffffffea803b60:	aa0103e4 	mov	x4, x1
ffffffffea803b64:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803b68:	aa0803e6 	mov	x6, x8
ffffffffea803b6c:	aa0a03e3 	mov	x3, x10
ffffffffea803b70:	52803982 	mov	w2, #0x1cc                 	// #460
ffffffffea803b74:	912b20e1 	add	x1, x7, #0xac8
ffffffffea803b78:	912c6000 	add	x0, x0, #0xb18
ffffffffea803b7c:	94004037 	bl	ffffffffea813c58 <_printf>
        return ERR_INVALID_ARGS;
ffffffffea803b80:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803b84:	17fffff2 	b	ffffffffea803b4c <arm64_mmu_unmap+0x4c>
        TRACEF("page table is NULL\n");
ffffffffea803b88:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803b8c:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803b90:	52803a22 	mov	w2, #0x1d1                 	// #465
ffffffffea803b94:	912b2021 	add	x1, x1, #0xac8
ffffffffea803b98:	912d8000 	add	x0, x0, #0xb60
ffffffffea803b9c:	9400402f 	bl	ffffffffea813c58 <_printf>
ffffffffea803ba0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea803ba4:	17ffffea 	b	ffffffffea803b4c <arm64_mmu_unmap+0x4c>

ffffffffea803ba8 <arch_mmu_map>:

int arch_mmu_map(vaddr_t vaddr, paddr_t paddr, uint count, uint flags)
{
ffffffffea803ba8:	d10083ff 	sub	sp, sp, #0x20
ffffffffea803bac:	2a0303e4 	mov	w4, w3
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803bb0:	12000463 	and	w3, w3, #0x3
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803bb4:	d3747c42 	ubfiz	x2, x2, #12, #32
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803bb8:	7100047f 	cmp	w3, #0x1
{
ffffffffea803bbc:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea803bc0:	910043fd 	add	x29, sp, #0x10
    switch (flags & ARCH_MMU_FLAG_CACHE_MASK) {
ffffffffea803bc4:	54000500 	b.eq	ffffffffea803c64 <arch_mmu_map+0xbc>  // b.none
ffffffffea803bc8:	34000423 	cbz	w3, ffffffffea803c4c <arch_mmu_map+0xa4>
ffffffffea803bcc:	7100087f 	cmp	w3, #0x2
ffffffffea803bd0:	54000221 	b.ne	ffffffffea803c14 <arch_mmu_map+0x6c>  // b.any
            attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea803bd4:	d2808083 	mov	x3, #0x404                 	// #1028
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803bd8:	121e0485 	and	w5, w4, #0xc
ffffffffea803bdc:	710020bf 	cmp	w5, #0x8
ffffffffea803be0:	540003e0 	b.eq	ffffffffea803c5c <arch_mmu_map+0xb4>  // b.none
ffffffffea803be4:	710030bf 	cmp	w5, #0xc
ffffffffea803be8:	54000420 	b.eq	ffffffffea803c6c <arch_mmu_map+0xc4>  // b.none
            attr |= MMU_PTE_ATTR_AP_P_RW_U_RW;
ffffffffea803bec:	b27a0066 	orr	x6, x3, #0x40
ffffffffea803bf0:	710010bf 	cmp	w5, #0x4
ffffffffea803bf4:	9a8300c3 	csel	x3, x6, x3, eq  // eq = none
        attr |= MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN;
ffffffffea803bf8:	f27c009f 	tst	x4, #0x10
ffffffffea803bfc:	b24b0465 	orr	x5, x3, #0x60000000000000
ffffffffea803c00:	9a8310a3 	csel	x3, x5, x3, ne  // ne = any
            attr |= MMU_PTE_ATTR_NON_SECURE;
ffffffffea803c04:	f27b009f 	tst	x4, #0x20
ffffffffea803c08:	b27b0064 	orr	x4, x3, #0x20
ffffffffea803c0c:	9a831083 	csel	x3, x4, x3, ne  // ne = any
ffffffffea803c10:	14000002 	b	ffffffffea803c18 <arch_mmu_map+0x70>
            return ERR_INVALID_ARGS;
ffffffffea803c14:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
    return arm64_mmu_map(vaddr, paddr, count * PAGE_SIZE,
ffffffffea803c18:	12800005 	mov	w5, #0xffffffff            	// #-1
ffffffffea803c1c:	90000304 	adrp	x4, ffffffffea863000 <arm64_kernel_translation_table>
ffffffffea803c20:	b9000be5 	str	w5, [sp, #8]
ffffffffea803c24:	91000084 	add	x4, x4, #0x0
ffffffffea803c28:	f90003e4 	str	x4, [sp]
ffffffffea803c2c:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea803c30:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea803c34:	528003a5 	mov	w5, #0x1d                  	// #29
ffffffffea803c38:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea803c3c:	97ffff83 	bl	ffffffffea803a48 <arm64_mmu_map>
                         mmu_flags_to_pte_attr(flags),
                         ~0UL << MMU_KERNEL_SIZE_SHIFT, MMU_KERNEL_SIZE_SHIFT,
                         MMU_KERNEL_TOP_SHIFT, MMU_KERNEL_PAGE_SIZE_SHIFT,
                         arm64_kernel_translation_table, MMU_ARM64_GLOBAL_ASID);
}
ffffffffea803c40:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea803c44:	910083ff 	add	sp, sp, #0x20
ffffffffea803c48:	d65f03c0 	ret
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803c4c:	121e0485 	and	w5, w4, #0xc
            attr |= MMU_PTE_ATTR_NORMAL_MEMORY | MMU_PTE_ATTR_SH_INNER_SHAREABLE;
ffffffffea803c50:	d280e103 	mov	x3, #0x708                 	// #1800
    switch (flags & (ARCH_MMU_FLAG_PERM_USER | ARCH_MMU_FLAG_PERM_RO)) {
ffffffffea803c54:	710020bf 	cmp	w5, #0x8
ffffffffea803c58:	54fffc61 	b.ne	ffffffffea803be4 <arch_mmu_map+0x3c>  // b.any
            attr |= MMU_PTE_ATTR_AP_P_RO_U_NA;
ffffffffea803c5c:	b2790063 	orr	x3, x3, #0x80
ffffffffea803c60:	17ffffe6 	b	ffffffffea803bf8 <arch_mmu_map+0x50>
            attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
ffffffffea803c64:	d2808003 	mov	x3, #0x400                 	// #1024
ffffffffea803c68:	17ffffdc 	b	ffffffffea803bd8 <arch_mmu_map+0x30>
            attr |= MMU_PTE_ATTR_AP_P_RO_U_RO;
ffffffffea803c6c:	b27a0463 	orr	x3, x3, #0xc0
ffffffffea803c70:	17ffffe2 	b	ffffffffea803bf8 <arch_mmu_map+0x50>
ffffffffea803c74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803c78 <arch_mmu_unmap>:

int arch_mmu_unmap(vaddr_t vaddr, uint count)
{
    return arm64_mmu_unmap(vaddr, count * PAGE_SIZE,
ffffffffea803c78:	90000306 	adrp	x6, ffffffffea863000 <arm64_kernel_translation_table>
ffffffffea803c7c:	12800007 	mov	w7, #0xffffffff            	// #-1
ffffffffea803c80:	910000c6 	add	x6, x6, #0x0
ffffffffea803c84:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea803c88:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea803c8c:	528003a3 	mov	w3, #0x1d                  	// #29
ffffffffea803c90:	b2638be2 	mov	x2, #0xffffffffe0000000    	// #-536870912
ffffffffea803c94:	d3747c21 	ubfiz	x1, x1, #12, #32
ffffffffea803c98:	17ffff9a 	b	ffffffffea803b00 <arm64_mmu_unmap>
ffffffffea803c9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803ca0 <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
ffffffffea803ca0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea803ca4:	910003fd 	mov	x29, sp
ffffffffea803ca8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803cac:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803cb0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea803cb4:	f90023f9 	str	x25, [sp, #64]
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
ffffffffea803cb8:	340007a1 	cbz	w1, ffffffffea803dac <lk_init_level+0x10c>
ffffffffea803cbc:	f00002f6 	adrp	x22, ffffffffea862000 <__ctor_list>
ffffffffea803cc0:	f00002f9 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea803cc4:	2a0003f4 	mov	w20, w0
ffffffffea803cc8:	2a0103f8 	mov	w24, w1
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803ccc:	f94016d6 	ldr	x22, [x22, #40]
ffffffffea803cd0:	2a0203f7 	mov	w23, w2
ffffffffea803cd4:	f9403339 	ldr	x25, [x25, #96]
    uint last_called_level = start_level - 1;
ffffffffea803cd8:	51000425 	sub	w5, w1, #0x1
    const struct lk_init_struct *last = NULL;
ffffffffea803cdc:	d2800013 	mov	x19, #0x0                   	// #0
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803ce0:	aa1603f5 	mov	x21, x22
ffffffffea803ce4:	eb16033f 	cmp	x25, x22
ffffffffea803ce8:	54000520 	b.eq	ffffffffea803d8c <lk_init_level+0xec>  // b.none
ffffffffea803cec:	d503201f 	nop
ffffffffea803cf0:	aa1903e3 	mov	x3, x25
        bool seen_last = false;
ffffffffea803cf4:	52800004 	mov	w4, #0x0                   	// #0
        const struct lk_init_struct *found = NULL;
ffffffffea803cf8:	d2800007 	mov	x7, #0x0                   	// #0
            LTRACEF("looking at %p (%s) level %#x, flags %#x, seen_last %d\n", ptr, ptr->name, ptr->level, ptr->flags, seen_last);

            if (ptr == last)
                seen_last = true;
ffffffffea803cfc:	52800026 	mov	w6, #0x1                   	// #1
ffffffffea803d00:	14000004 	b	ffffffffea803d10 <lk_init_level+0x70>
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d04:	91006063 	add	x3, x3, #0x18
ffffffffea803d08:	eb15007f 	cmp	x3, x21
ffffffffea803d0c:	54000300 	b.eq	ffffffffea803d6c <lk_init_level+0xcc>  // b.none

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
ffffffffea803d10:	b9400460 	ldr	w0, [x3, #4]
                seen_last = true;
ffffffffea803d14:	eb03027f 	cmp	x19, x3
ffffffffea803d18:	1a861084 	csel	w4, w4, w6, ne  // ne = any
            if (!(ptr->flags & required_flag))
ffffffffea803d1c:	6a00029f 	tst	w20, w0
ffffffffea803d20:	54ffff20 	b.eq	ffffffffea803d04 <lk_init_level+0x64>  // b.none
                continue;
            if (ptr->level > stop_level)
ffffffffea803d24:	b9400060 	ldr	w0, [x3]
                continue;
            if (ptr->level < last_called_level)
ffffffffea803d28:	6b0000bf 	cmp	w5, w0
ffffffffea803d2c:	7a579002 	ccmp	w0, w23, #0x2, ls  // ls = plast
ffffffffea803d30:	54fffea8 	b.hi	ffffffffea803d04 <lk_init_level+0x64>  // b.pmore
                continue;
            if (found && found->level <= ptr->level)
ffffffffea803d34:	b4000087 	cbz	x7, ffffffffea803d44 <lk_init_level+0xa4>
ffffffffea803d38:	b94000e2 	ldr	w2, [x7]
ffffffffea803d3c:	6b02001f 	cmp	w0, w2
ffffffffea803d40:	54fffe22 	b.cs	ffffffffea803d04 <lk_init_level+0x64>  // b.hs, b.nlast
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
ffffffffea803d44:	6b0000bf 	cmp	w5, w0
ffffffffea803d48:	7a583000 	ccmp	w0, w24, #0x0, cc  // cc = lo, ul, last
ffffffffea803d4c:	540002c2 	b.cs	ffffffffea803da4 <lk_init_level+0x104>  // b.hs, b.nlast

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
ffffffffea803d50:	6b0000bf 	cmp	w5, w0
ffffffffea803d54:	54fffd81 	b.ne	ffffffffea803d04 <lk_init_level+0x64>  // b.any
ffffffffea803d58:	7100009f 	cmp	w4, #0x0
ffffffffea803d5c:	fa431264 	ccmp	x19, x3, #0x4, ne  // ne = any
ffffffffea803d60:	54fffd20 	b.eq	ffffffffea803d04 <lk_init_level+0x64>  // b.none
ffffffffea803d64:	aa0303f3 	mov	x19, x3
ffffffffea803d68:	14000004 	b	ffffffffea803d78 <lk_init_level+0xd8>
                found = ptr;
                break;
            }
        }

        if (!found)
ffffffffea803d6c:	b4000107 	cbz	x7, ffffffffea803d8c <lk_init_level+0xec>
ffffffffea803d70:	b94000e0 	ldr	w0, [x7]
ffffffffea803d74:	aa0703f3 	mov	x19, x7
        if (found->level >= EARLIEST_TRACE_LEVEL) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
ffffffffea803d78:	f9400661 	ldr	x1, [x19, #8]
ffffffffea803d7c:	d63f0020 	blr	x1
        last_called_level = found->level;
ffffffffea803d80:	b9400265 	ldr	w5, [x19]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
ffffffffea803d84:	eb16033f 	cmp	x25, x22
ffffffffea803d88:	54fffb41 	b.ne	ffffffffea803cf0 <lk_init_level+0x50>  // b.any
        last = found;
    }
}
ffffffffea803d8c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea803d90:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea803d94:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea803d98:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea803d9c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea803da0:	d65f03c0 	ret
ffffffffea803da4:	aa0303e7 	mov	x7, x3
ffffffffea803da8:	17ffffd7 	b	ffffffffea803d04 <lk_init_level+0x64>
    ASSERT(start_level > 0);
ffffffffea803dac:	f0000084 	adrp	x4, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803db0:	f0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803db4:	f0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803db8:	9130a084 	add	x4, x4, #0xc28
ffffffffea803dbc:	52800663 	mov	w3, #0x33                  	// #51
ffffffffea803dc0:	9130e042 	add	x2, x2, #0xc38
ffffffffea803dc4:	91314021 	add	x1, x1, #0xc50
ffffffffea803dc8:	aa1e03e0 	mov	x0, x30
ffffffffea803dcc:	940039ed 	bl	ffffffffea812580 <_panic>

ffffffffea803dd0 <bootstrap2>:
	// become the idle thread and enable interrupts to start the scheduler
	thread_become_idle();
}

static int bootstrap2(void *arg)
{
ffffffffea803dd0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
};

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level) {
	lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
ffffffffea803dd4:	12bfff02 	mov	w2, #0x7ffff               	// #524287
ffffffffea803dd8:	52a000e1 	mov	w1, #0x70000               	// #458752
ffffffffea803ddc:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803de0:	910003fd 	mov	x29, sp
ffffffffea803de4:	97ffffaf 	bl	ffffffffea803ca0 <lk_init_level>
	dprintf(SPEW, "top of bootstrap2()\n");

	lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
	arch_init();
ffffffffea803de8:	97fffb4c 	bl	ffffffffea802b18 <arch_init>
ffffffffea803dec:	12bffee2 	mov	w2, #0x8ffff               	// #589823
ffffffffea803df0:	52a00101 	mov	w1, #0x80000               	// #524288
ffffffffea803df4:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803df8:	97ffffaa 	bl	ffffffffea803ca0 <lk_init_level>

	// initialize the rest of the platform
	dprintf(SPEW, "initializing platform\n");
	lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
	platform_init();
ffffffffea803dfc:	97fff725 	bl	ffffffffea801a90 <platform_init>
	tegra_boot_profiler_record("bootstrap2: platform_init done");
ffffffffea803e00:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803e04:	9131c000 	add	x0, x0, #0xc70
ffffffffea803e08:	94000e10 	bl	ffffffffea807648 <tegra_boot_profiler_record>
ffffffffea803e0c:	12bffec2 	mov	w2, #0x9ffff               	// #655359
ffffffffea803e10:	52a00121 	mov	w1, #0x90000               	// #589824
ffffffffea803e14:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e18:	97ffffa2 	bl	ffffffffea803ca0 <lk_init_level>

	// initialize the target
	dprintf(SPEW, "initializing target\n");
	lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
	target_init();
ffffffffea803e1c:	9400337f 	bl	ffffffffea810c18 <target_init>
	tegra_boot_profiler_record("bootstrap2: target_init done");
ffffffffea803e20:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803e24:	91324000 	add	x0, x0, #0xc90
ffffffffea803e28:	94000e08 	bl	ffffffffea807648 <tegra_boot_profiler_record>
ffffffffea803e2c:	12bffea2 	mov	w2, #0xaffff               	// #720895
ffffffffea803e30:	52a00141 	mov	w1, #0xa0000               	// #655360
ffffffffea803e34:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e38:	97ffff9a 	bl	ffffffffea803ca0 <lk_init_level>

	dprintf(SPEW, "calling apps_init()\n");
	lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
	apps_init();
ffffffffea803e3c:	940000cf 	bl	ffffffffea804178 <apps_init>
	tegra_boot_profiler_record("bootstrap2: apps_init done");
ffffffffea803e40:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803e44:	9132c000 	add	x0, x0, #0xcb0
ffffffffea803e48:	94000e00 	bl	ffffffffea807648 <tegra_boot_profiler_record>
ffffffffea803e4c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803e50:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803e54:	52a00161 	mov	w1, #0xb0000               	// #720896
ffffffffea803e58:	97ffff92 	bl	ffffffffea803ca0 <lk_init_level>

	lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

	dprintf(SPEW, "calling platform_bootstrap_epilog\n");
	platform_bootstrap_epilog();
ffffffffea803e5c:	97fff8e5 	bl	ffffffffea8021f0 <platform_bootstrap_epilog>

	return 0;
}
ffffffffea803e60:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803e64:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803e68:	d65f03c0 	ret
ffffffffea803e6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803e70 <secondary_cpu_bootstrap2>:
	dprintf(SPEW, "entering scheduler on cpu %d\n", cpu);
	thread_secondary_cpu_entry();
}

static int secondary_cpu_bootstrap2(void *arg)
{
ffffffffea803e70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	/* secondary cpu initialize from threading level up. 0 to threading was handled in arch */
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803e74:	52800040 	mov	w0, #0x2                   	// #2
ffffffffea803e78:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea803e7c:	52a000e1 	mov	w1, #0x70000               	// #458752
{
ffffffffea803e80:	910003fd 	mov	x29, sp
	lk_init_level(LK_INIT_FLAG_SECONDARY_CPUS, LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_LAST);
ffffffffea803e84:	97ffff87 	bl	ffffffffea803ca0 <lk_init_level>

	return 0;
}
ffffffffea803e88:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea803e8c:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea803e90:	d65f03c0 	ret
ffffffffea803e94:	00000000 	.inst	0x00000000 ; undefined

ffffffffea803e98 <lk_main>:
{
ffffffffea803e98:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	lk_boot_args[0] = arg0;
ffffffffea803e9c:	f00002e4 	adrp	x4, ffffffffea862000 <__ctor_list>
{
ffffffffea803ea0:	910003fd 	mov	x29, sp
	lk_boot_args[0] = arg0;
ffffffffea803ea4:	f9407c84 	ldr	x4, [x4, #248]
{
ffffffffea803ea8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea803eac:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea803eb0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea803eb4:	f90023f9 	str	x25, [sp, #64]
	while (ctor != &__ctor_end) {
ffffffffea803eb8:	f00002f9 	adrp	x25, ffffffffea862000 <__ctor_list>
	lk_boot_args[1] = arg1;
ffffffffea803ebc:	a9000480 	stp	x0, x1, [x4]
	lk_boot_args[3] = arg3;
ffffffffea803ec0:	a9010c82 	stp	x2, x3, [x4, #16]
	early_tstamps.start = tegra_boot_profiler_get_timestamp();
ffffffffea803ec4:	94000ddf 	bl	ffffffffea807640 <tegra_boot_profiler_get_timestamp>
ffffffffea803ec8:	2a0003f8 	mov	w24, w0
	thread_init_early();
ffffffffea803ecc:	940009a1 	bl	ffffffffea806550 <thread_init_early>
ffffffffea803ed0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea803ed4:	2a0103e0 	mov	w0, w1
ffffffffea803ed8:	529fffe2 	mov	w2, #0xffff                	// #65535
ffffffffea803edc:	97ffff71 	bl	ffffffffea803ca0 <lk_init_level>
	arch_early_init();
ffffffffea803ee0:	97fffafe 	bl	ffffffffea802ad8 <arch_early_init>
	early_tstamps.arch_init = tegra_boot_profiler_get_timestamp();
ffffffffea803ee4:	94000dd7 	bl	ffffffffea807640 <tegra_boot_profiler_get_timestamp>
ffffffffea803ee8:	2a0003f7 	mov	w23, w0
ffffffffea803eec:	12bfffc2 	mov	w2, #0x1ffff               	// #131071
ffffffffea803ef0:	52a00021 	mov	w1, #0x10000               	// #65536
ffffffffea803ef4:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803ef8:	97ffff6a 	bl	ffffffffea803ca0 <lk_init_level>
	platform_early_init();
ffffffffea803efc:	97fff6e1 	bl	ffffffffea801a80 <platform_early_init>
	early_tstamps.platform_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f00:	94000dd0 	bl	ffffffffea807640 <tegra_boot_profiler_get_timestamp>
ffffffffea803f04:	2a0003f6 	mov	w22, w0
ffffffffea803f08:	12bfffa2 	mov	w2, #0x2ffff               	// #196607
ffffffffea803f0c:	52a00041 	mov	w1, #0x20000               	// #131072
ffffffffea803f10:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f14:	97ffff63 	bl	ffffffffea803ca0 <lk_init_level>
	target_early_init();
ffffffffea803f18:	9400333e 	bl	ffffffffea810c10 <target_early_init>
	early_tstamps.target_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f1c:	94000dc9 	bl	ffffffffea807640 <tegra_boot_profiler_get_timestamp>
ffffffffea803f20:	2a0003f5 	mov	w21, w0
	while (ctor != &__ctor_end) {
ffffffffea803f24:	f00002e0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea803f28:	f9403739 	ldr	x25, [x25, #104]
ffffffffea803f2c:	f9407000 	ldr	x0, [x0, #224]
ffffffffea803f30:	eb00033f 	cmp	x25, x0
ffffffffea803f34:	54000180 	b.eq	ffffffffea803f64 <lk_main+0xcc>  // b.none
ffffffffea803f38:	91002334 	add	x20, x25, #0x8
ffffffffea803f3c:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea803f40:	cb140014 	sub	x20, x0, x20
ffffffffea803f44:	927df294 	and	x20, x20, #0xfffffffffffffff8
ffffffffea803f48:	91002294 	add	x20, x20, #0x8
ffffffffea803f4c:	d503201f 	nop
		func();
ffffffffea803f50:	f8796a60 	ldr	x0, [x19, x25]
ffffffffea803f54:	91002273 	add	x19, x19, #0x8
ffffffffea803f58:	d63f0000 	blr	x0
	while (ctor != &__ctor_end) {
ffffffffea803f5c:	eb14027f 	cmp	x19, x20
ffffffffea803f60:	54ffff81 	b.ne	ffffffffea803f50 <lk_main+0xb8>  // b.any
ffffffffea803f64:	12bfff82 	mov	w2, #0x3ffff               	// #262143
ffffffffea803f68:	52a00061 	mov	w1, #0x30000               	// #196608
ffffffffea803f6c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f70:	97ffff4c 	bl	ffffffffea803ca0 <lk_init_level>
	heap_init();
ffffffffea803f74:	94003b57 	bl	ffffffffea812cd0 <heap_init>
ffffffffea803f78:	12bfff42 	mov	w2, #0x5ffff               	// #393215
ffffffffea803f7c:	52a00081 	mov	w1, #0x40000               	// #262144
ffffffffea803f80:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803f84:	97ffff47 	bl	ffffffffea803ca0 <lk_init_level>
	kernel_init();
ffffffffea803f88:	9400062e 	bl	ffffffffea805840 <kernel_init>
	early_tstamps.kernel_init = tegra_boot_profiler_get_timestamp();
ffffffffea803f8c:	94000dad 	bl	ffffffffea807640 <tegra_boot_profiler_get_timestamp>
ffffffffea803f90:	2a0003f3 	mov	w19, w0
ffffffffea803f94:	12bfff22 	mov	w2, #0x6ffff               	// #458751
ffffffffea803f98:	52a000c1 	mov	w1, #0x60000               	// #393216
ffffffffea803f9c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea803fa0:	97ffff40 	bl	ffffffffea803ca0 <lk_init_level>
	tegra_boot_profiler_init(NULL);
ffffffffea803fa4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea803fa8:	94000da2 	bl	ffffffffea807630 <tegra_boot_profiler_init>
	tegra_boot_profiler_prerecorded("lk_main: start", tstamp.start);
ffffffffea803fac:	2a1803e1 	mov	w1, w24
ffffffffea803fb0:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803fb4:	91348000 	add	x0, x0, #0xd20
ffffffffea803fb8:	94000da6 	bl	ffffffffea807650 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: arch_early_init", tstamp.arch_init);
ffffffffea803fbc:	2a1703e1 	mov	w1, w23
ffffffffea803fc0:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803fc4:	9134c000 	add	x0, x0, #0xd30
ffffffffea803fc8:	94000da2 	bl	ffffffffea807650 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: platform_early_init", tstamp.platform_init);
ffffffffea803fcc:	2a1603e1 	mov	w1, w22
ffffffffea803fd0:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803fd4:	91354000 	add	x0, x0, #0xd50
ffffffffea803fd8:	94000d9e 	bl	ffffffffea807650 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: target_early_init", tstamp.target_init);
ffffffffea803fdc:	2a1503e1 	mov	w1, w21
ffffffffea803fe0:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803fe4:	9135c000 	add	x0, x0, #0xd70
ffffffffea803fe8:	94000d9a 	bl	ffffffffea807650 <tegra_boot_profiler_prerecorded>
	tegra_boot_profiler_prerecorded("lk_main: kernel_init", tstamp.kernel_init);
ffffffffea803fec:	2a1303e1 	mov	w1, w19
ffffffffea803ff0:	f0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea803ff4:	91364000 	add	x0, x0, #0xd90
ffffffffea803ff8:	94000d96 	bl	ffffffffea807650 <tegra_boot_profiler_prerecorded>
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea803ffc:	90000001 	adrp	x1, ffffffffea803000 <arch_thread_initialize+0x18>
ffffffffea804000:	91374021 	add	x1, x1, #0xdd0
ffffffffea804004:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea804008:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80400c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea804010:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804014:	9136a000 	add	x0, x0, #0xda8
ffffffffea804018:	94000834 	bl	ffffffffea8060e8 <thread_create>
	t->pinned_cpu = 0;
ffffffffea80401c:	b9003c1f 	str	wzr, [x0, #60]
	thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
ffffffffea804020:	aa0003f3 	mov	x19, x0
	thread_detach(t);
ffffffffea804024:	94000b75 	bl	ffffffffea806df8 <thread_detach>
	thread_resume(t);
ffffffffea804028:	aa1303e0 	mov	x0, x19
ffffffffea80402c:	9400088f 	bl	ffffffffea806268 <thread_resume>
	thread_become_idle();
ffffffffea804030:	94000986 	bl	ffffffffea806648 <thread_become_idle>
ffffffffea804034:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804038 <lk_secondary_cpu_entry>:
{
ffffffffea804038:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80403c:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea804040:	97fffaa4 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea804044:	2a0003e1 	mov	w1, w0
	if (cpu > secondary_bootstrap_thread_count) {
ffffffffea804048:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea80404c:	b9406803 	ldr	w3, [x0, #104]
ffffffffea804050:	6b01007f 	cmp	w3, w1
ffffffffea804054:	540000c2 	b.cs	ffffffffea80406c <lk_secondary_cpu_entry+0x34>  // b.hs, b.nlast
}
ffffffffea804058:	a8c27bfd 	ldp	x29, x30, [sp], #32
		dprintf(CRITICAL, "Invalid secondary cpu num %d, SMP_MAX_CPUS %d, secondary_bootstrap_thread_count %d\n",
ffffffffea80405c:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804060:	52800102 	mov	w2, #0x8                   	// #8
ffffffffea804064:	9136e000 	add	x0, x0, #0xdb8
ffffffffea804068:	140038be 	b	ffffffffea812360 <_dprintf>
ffffffffea80406c:	b9001fa1 	str	w1, [x29, #28]
	thread_secondary_cpu_init_early();
ffffffffea804070:	940009a2 	bl	ffffffffea8066f8 <thread_secondary_cpu_init_early>
	thread_resume(secondary_bootstrap_threads[cpu - 1]);
ffffffffea804074:	b9401fa1 	ldr	w1, [x29, #28]
ffffffffea804078:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea80407c:	9101c000 	add	x0, x0, #0x70
ffffffffea804080:	51000421 	sub	w1, w1, #0x1
ffffffffea804084:	f8617800 	ldr	x0, [x0, x1, lsl #3]
ffffffffea804088:	94000878 	bl	ffffffffea806268 <thread_resume>
	thread_secondary_cpu_entry();
ffffffffea80408c:	940009f1 	bl	ffffffffea806850 <thread_secondary_cpu_entry>

ffffffffea804090 <lk_init_secondary_cpus>:

void lk_init_secondary_cpus(uint secondary_cpu_count)
{
ffffffffea804090:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea804094:	71001c1f 	cmp	w0, #0x7
{
ffffffffea804098:	910003fd 	mov	x29, sp
ffffffffea80409c:	f90013f5 	str	x21, [sp, #32]
ffffffffea8040a0:	2a0003f5 	mov	w21, w0
	if (secondary_cpu_count >= SMP_MAX_CPUS) {
ffffffffea8040a4:	54000468 	b.hi	ffffffffea804130 <lk_init_secondary_cpus+0xa0>  // b.pmore
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
			secondary_cpu_count, SMP_MAX_CPUS);
		secondary_cpu_count = SMP_MAX_CPUS - 1;
	}
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea8040a8:	340003a0 	cbz	w0, ffffffffea80411c <lk_init_secondary_cpus+0x8c>
ffffffffea8040ac:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8040b0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8040b4:	f9001fb8 	str	x24, [x29, #56]
ffffffffea8040b8:	f0fffff8 	adrp	x24, ffffffffea803000 <arch_thread_initialize+0x18>
ffffffffea8040bc:	d0000097 	adrp	x23, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8040c0:	b0000356 	adrp	x22, ffffffffea86d000 <__bss_start>
		dprintf(SPEW, "creating bootstrap completion thread for cpu %d\n", i + 1);
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea8040c4:	9139c318 	add	x24, x24, #0xe70
ffffffffea8040c8:	913422f7 	add	x23, x23, #0xd08
					    &secondary_cpu_bootstrap2, NULL,
					    DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
		t->pinned_cpu = i + 1;
		thread_detach(t);
		secondary_bootstrap_threads[i] = t;
ffffffffea8040cc:	9101c2d6 	add	x22, x22, #0x70
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea8040d0:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea8040d4:	d503201f 	nop
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea8040d8:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea8040dc:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea8040e0:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8040e4:	aa1803e1 	mov	x1, x24
ffffffffea8040e8:	aa1703e0 	mov	x0, x23
ffffffffea8040ec:	940007ff 	bl	ffffffffea8060e8 <thread_create>
		t->pinned_cpu = i + 1;
ffffffffea8040f0:	11000661 	add	w1, w19, #0x1
ffffffffea8040f4:	b9003c01 	str	w1, [x0, #60]
		thread_t *t = thread_create("secondarybootstrap2",
ffffffffea8040f8:	aa0003f4 	mov	x20, x0
		thread_detach(t);
ffffffffea8040fc:	94000b3f 	bl	ffffffffea806df8 <thread_detach>
		secondary_bootstrap_threads[i] = t;
ffffffffea804100:	f8337ad4 	str	x20, [x22, x19, lsl #3]
ffffffffea804104:	91000673 	add	x19, x19, #0x1
	for (uint i = 0; i < secondary_cpu_count; i++) {
ffffffffea804108:	6b1302bf 	cmp	w21, w19
ffffffffea80410c:	54fffe68 	b.hi	ffffffffea8040d8 <lk_init_secondary_cpus+0x48>  // b.pmore
ffffffffea804110:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea804114:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea804118:	f9401fb8 	ldr	x24, [x29, #56]
	}
	secondary_bootstrap_thread_count = secondary_cpu_count;
ffffffffea80411c:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea804120:	b9006815 	str	w21, [x0, #104]
}
ffffffffea804124:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea804128:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80412c:	d65f03c0 	ret
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea804130:	2a0003e1 	mov	w1, w0
ffffffffea804134:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea804138:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80413c:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804140:	52800102 	mov	w2, #0x8                   	// #8
		secondary_cpu_count = SMP_MAX_CPUS - 1;
ffffffffea804144:	528000f5 	mov	w21, #0x7                   	// #7
ffffffffea804148:	f9001fb8 	str	x24, [x29, #56]
		dprintf(CRITICAL, "Invalid secondary_cpu_count %d, SMP_MAX_CPUS %d\n",
ffffffffea80414c:	91334000 	add	x0, x0, #0xcd0
ffffffffea804150:	94003884 	bl	ffffffffea812360 <_dprintf>
ffffffffea804154:	17ffffd9 	b	ffffffffea8040b8 <lk_init_secondary_cpus+0x28>

ffffffffea804158 <app_thread_entry>:
		}
	}
}

static int app_thread_entry(void *arg)
{
ffffffffea804158:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	const struct app_descriptor *app = (const struct app_descriptor *)arg;

	app->entry(app, NULL);
ffffffffea80415c:	d2800001 	mov	x1, #0x0                   	// #0
{
ffffffffea804160:	910003fd 	mov	x29, sp
	app->entry(app, NULL);
ffffffffea804164:	f9400802 	ldr	x2, [x0, #16]
ffffffffea804168:	d63f0040 	blr	x2

	return 0;
}
ffffffffea80416c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea804170:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea804174:	d65f03c0 	ret

ffffffffea804178 <apps_init>:
{
ffffffffea804178:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80417c:	d00002e0 	adrp	x0, ffffffffea862000 <__ctor_list>
{
ffffffffea804180:	910003fd 	mov	x29, sp
ffffffffea804184:	f9000bf3 	str	x19, [sp, #16]
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea804188:	d00002f3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80418c:	f9404400 	ldr	x0, [x0, #136]
ffffffffea804190:	f9405a61 	ldr	x1, [x19, #176]
ffffffffea804194:	eb00003f 	cmp	x1, x0
ffffffffea804198:	54000720 	b.eq	ffffffffea80427c <apps_init+0x104>  // b.none
ffffffffea80419c:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea8041a0:	9100a035 	add	x21, x1, #0x28
ffffffffea8041a4:	d29999a2 	mov	x2, #0xcccd                	// #52429
ffffffffea8041a8:	cb150015 	sub	x21, x0, x21
ffffffffea8041ac:	f2b99982 	movk	x2, #0xcccc, lsl #16
ffffffffea8041b0:	aa0103f4 	mov	x20, x1
ffffffffea8041b4:	f2d99982 	movk	x2, #0xcccc, lsl #32
ffffffffea8041b8:	d343feb5 	lsr	x21, x21, #3
ffffffffea8041bc:	f2e19982 	movk	x2, #0xccc, lsl #48
ffffffffea8041c0:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8041c4:	9b027eb5 	mul	x21, x21, x2
ffffffffea8041c8:	9240f2b5 	and	x21, x21, #0x1fffffffffffffff
ffffffffea8041cc:	910006b5 	add	x21, x21, #0x1
ffffffffea8041d0:	8b150ab5 	add	x21, x21, x21, lsl #2
ffffffffea8041d4:	8b150c35 	add	x21, x1, x21, lsl #3
		if (app->init)
ffffffffea8041d8:	f9400681 	ldr	x1, [x20, #8]
			app->init(app);
ffffffffea8041dc:	aa1403e0 	mov	x0, x20
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041e0:	9100a294 	add	x20, x20, #0x28
		if (app->init)
ffffffffea8041e4:	b4000041 	cbz	x1, ffffffffea8041ec <apps_init+0x74>
			app->init(app);
ffffffffea8041e8:	d63f0020 	blr	x1
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041ec:	eb15029f 	cmp	x20, x21
ffffffffea8041f0:	54ffff41 	b.ne	ffffffffea8041d8 <apps_init+0x60>  // b.any

static void start_app(const struct app_descriptor *app)
{
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

	printf("starting app %s\n", app->name);
ffffffffea8041f4:	d0000096 	adrp	x22, ffffffffea816000 <__fault_handler_table_start>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea8041f8:	90000015 	adrp	x21, ffffffffea804000 <lk_main+0x168>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea8041fc:	f9405a73 	ldr	x19, [x19, #176]
	printf("starting app %s\n", app->name);
ffffffffea804200:	913842d6 	add	x22, x22, #0xe10
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804204:	910562b5 	add	x21, x21, #0x158
ffffffffea804208:	14000004 	b	ffffffffea804218 <apps_init+0xa0>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80420c:	9100a273 	add	x19, x19, #0x28
ffffffffea804210:	eb14027f 	cmp	x19, x20
ffffffffea804214:	54000300 	b.eq	ffffffffea804274 <apps_init+0xfc>  // b.none
		if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
ffffffffea804218:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80421c:	b4ffff80 	cbz	x0, ffffffffea80420c <apps_init+0x94>
ffffffffea804220:	b9401a61 	ldr	w1, [x19, #24]
ffffffffea804224:	3707ff41 	tbnz	w1, #0, ffffffffea80420c <apps_init+0x94>
	printf("starting app %s\n", app->name);
ffffffffea804228:	aa1603e0 	mov	x0, x22
	uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
ffffffffea80422c:	d2820017 	mov	x23, #0x1000                	// #4096
ffffffffea804230:	36080041 	tbz	w1, #1, ffffffffea804238 <apps_init+0xc0>
ffffffffea804234:	b9402277 	ldr	w23, [x19, #32]
	printf("starting app %s\n", app->name);
ffffffffea804238:	f9400261 	ldr	x1, [x19]
ffffffffea80423c:	94003e87 	bl	ffffffffea813c58 <_printf>
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804240:	f9400260 	ldr	x0, [x19]
ffffffffea804244:	aa1703e4 	mov	x4, x23
ffffffffea804248:	aa1303e2 	mov	x2, x19
ffffffffea80424c:	aa1503e1 	mov	x1, x21
ffffffffea804250:	52800203 	mov	w3, #0x10                  	// #16
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea804254:	9100a273 	add	x19, x19, #0x28
	thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
ffffffffea804258:	940007a4 	bl	ffffffffea8060e8 <thread_create>
ffffffffea80425c:	aa0003f7 	mov	x23, x0
	thread_detach(t);
ffffffffea804260:	94000ae6 	bl	ffffffffea806df8 <thread_detach>
	thread_resume(t);
ffffffffea804264:	aa1703e0 	mov	x0, x23
ffffffffea804268:	94000800 	bl	ffffffffea806268 <thread_resume>
	for (app = &__apps_start; app != &__apps_end; app++) {
ffffffffea80426c:	eb14027f 	cmp	x19, x20
ffffffffea804270:	54fffd41 	b.ne	ffffffffea804218 <apps_init+0xa0>  // b.any
ffffffffea804274:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea804278:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea80427c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea804280:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804284:	d65f03c0 	ret

ffffffffea804288 <arm_gic_init_percpu>:
}

static void arm_gic_init_percpu(uint level)
{
#if WITH_LIB_SM
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804288:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea80428c:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804290:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804294:	f2be2801 	movk	x1, #0xf140, lsl #16
#else
	GICREG(0, GICC_CTLR) = 1; // enable GIC0
#endif
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804298:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea80429c:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042a0:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea8042a4:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8042a8:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8042ac:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8042b0:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea8042b4:	b9000001 	str	w1, [x0]
}
ffffffffea8042b8:	d65f03c0 	ret
ffffffffea8042bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8042c0 <update_fiq_targets>:
}

static u_int current_fiq[8] = { 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff };

static bool update_fiq_targets(u_int cpu, bool enable, u_int triggered_fiq, bool resume_gicd)
{
ffffffffea8042c0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea8042c4:	929dff64 	mov	x4, #0xffffffffffff1004    	// #-61436
ffffffffea8042c8:	f2be2804 	movk	x4, #0xf140, lsl #16
{
ffffffffea8042cc:	910003fd 	mov	x29, sp
ffffffffea8042d0:	a90153f3 	stp	x19, x20, [sp, #16]
	u_int i, j;
	u_long mask;
	u_int fiq;
	bool smp = arm_gic_max_cpu() > 0;
	bool ret = false;
ffffffffea8042d4:	52800013 	mov	w19, #0x0                   	// #0
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea8042d8:	b9400094 	ldr	w20, [x4]
{
ffffffffea8042dc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8042e0:	12001c36 	and	w22, w1, #0xff
ffffffffea8042e4:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8042e8:	2a0203f5 	mov	w21, w2
ffffffffea8042ec:	12001c77 	and	w23, w3, #0xff
ffffffffea8042f0:	f90023f9 	str	x25, [sp, #64]
    arch_spin_lock(lock);
ffffffffea8042f4:	b0000358 	adrp	x24, ffffffffea86d000 <__bss_start>
ffffffffea8042f8:	2a0003f9 	mov	w25, w0
ffffffffea8042fc:	91046300 	add	x0, x24, #0x118
ffffffffea804300:	97fff970 	bl	ffffffffea8028c0 <arch_spin_lock>
			fiq = i * BITMAP_BITS_PER_WORD + j;
			if (fiq == triggered_fiq)
				ret = true;
			LTRACEF("cpu %d, irq %i, enable %d\n", cpu, fiq, enable);
			if (smp)
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804304:	5280002d 	mov	w13, #0x1                   	// #1
ffffffffea804308:	b000034e 	adrp	x14, ffffffffea86d000 <__bss_start>
ffffffffea80430c:	1ad921ad 	lsl	w13, w13, w25
			mask &= ~(1UL << j);
ffffffffea804310:	d280002a 	mov	x10, #0x1                   	// #1
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804314:	b00000ab 	adrp	x11, ffffffffea819000 <_mem_phys_base>
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804318:	929fffe9 	mov	x9, #0xffffffffffff0000    	// #-65536
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea80431c:	d3451e94 	ubfx	x20, x20, #5, #3
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804320:	12001dad 	and	w13, w13, #0xff
		mask = enabled_fiq_mask[i];
ffffffffea804324:	9102c1ce 	add	x14, x14, #0xb0
				ret = true;
ffffffffea804328:	2a0a03e2 	mov	w2, w10
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea80432c:	9108e16b 	add	x11, x11, #0x238
				arm_gic_set_target_locked(fiq, 1U << cpu, enable ? ~0 : 0);
ffffffffea804330:	4b1603e1 	neg	w1, w22
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804334:	d2800003 	mov	x3, #0x0                   	// #0
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804338:	f2be2809 	movk	x9, #0xf140, lsl #16
ffffffffea80433c:	d503201f 	nop
		mask = enabled_fiq_mask[i];
ffffffffea804340:	f86379c6 	ldr	x6, [x14, x3, lsl #3]
		while (mask) {
ffffffffea804344:	b4000386 	cbz	x6, ffffffffea8043b4 <update_fiq_targets+0xf4>
ffffffffea804348:	531a646c 	lsl	w12, w3, #6
ffffffffea80434c:	d503201f 	nop
}

/* find first zero bit starting from LSB */
static inline unsigned long _ffz(unsigned long x)
{
	return __builtin_ffsl(~x) - 1;
ffffffffea804350:	dac000c0 	rbit	x0, x6
ffffffffea804354:	f10000df 	cmp	x6, #0x0
ffffffffea804358:	dac01000 	clz	x0, x0
ffffffffea80435c:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
			fiq = i * BITMAP_BITS_PER_WORD + j;
ffffffffea804360:	0b000184 	add	w4, w12, w0
				ret = true;
ffffffffea804364:	6b15009f 	cmp	w4, w21
			mask &= ~(1UL << j);
ffffffffea804368:	9ac02140 	lsl	x0, x10, x0
	u_int reg = irq / 4;
ffffffffea80436c:	53027c87 	lsr	w7, w4, #2
	u_int shift = 8 * (irq % 4);
ffffffffea804370:	531d0488 	ubfiz	w8, w4, #3, #2
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804374:	111800ef 	add	w15, w7, #0x600
			mask &= ~(1UL << j);
ffffffffea804378:	8a2000c6 	bic	x6, x6, x0
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea80437c:	1ac82025 	lsl	w5, w1, w8
				ret = true;
ffffffffea804380:	1a821273 	csel	w19, w19, w2, ne  // ne = any
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804384:	531e75ef 	lsl	w15, w15, #2
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804388:	1ac821a8 	lsl	w8, w13, w8
			if (smp)
ffffffffea80438c:	340002d4 	cbz	w20, ffffffffea8043e4 <update_fiq_targets+0x124>
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804390:	b8677970 	ldr	w16, [x11, x7, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804394:	b86f4920 	ldr	w0, [x9, w15, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804398:	4a1000a0 	eor	w0, w5, w16
ffffffffea80439c:	0a080000 	and	w0, w0, w8
ffffffffea8043a0:	4a100000 	eor	w0, w0, w16
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea8043a4:	b8277960 	str	w0, [x11, x7, lsl #2]
ffffffffea8043a8:	b82f4920 	str	w0, [x9, w15, uxtw]
			if (!smp || resume_gicd)
ffffffffea8043ac:	350001d7 	cbnz	w23, ffffffffea8043e4 <update_fiq_targets+0x124>
		while (mask) {
ffffffffea8043b0:	b5fffd06 	cbnz	x6, ffffffffea804350 <update_fiq_targets+0x90>
ffffffffea8043b4:	91000463 	add	x3, x3, #0x1
	for (i = 0; i < BITMAP_NUM_WORDS(MAX_INT); i++) {
ffffffffea8043b8:	f100347f 	cmp	x3, #0xd
ffffffffea8043bc:	54fffc21 	b.ne	ffffffffea804340 <update_fiq_targets+0x80>  // b.any
    arch_spin_unlock(lock);
ffffffffea8043c0:	91046300 	add	x0, x24, #0x118
ffffffffea8043c4:	97fff947 	bl	ffffffffea8028e0 <arch_spin_unlock>
				gic_set_enable(fiq, enable);
		}
	}
	spin_unlock(&gicd_lock);
	return ret;
}
ffffffffea8043c8:	2a1303e0 	mov	w0, w19
ffffffffea8043cc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8043d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8043d4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8043d8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8043dc:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8043e0:	d65f03c0 	ret
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea8043e4:	12001080 	and	w0, w4, #0x1f
	int reg = vector / 32;
ffffffffea8043e8:	53057c84 	lsr	w4, w4, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea8043ec:	11110085 	add	w5, w4, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea8043f0:	9ac02140 	lsl	x0, x10, x0
	if (enable)
ffffffffea8043f4:	340000b6 	cbz	w22, ffffffffea804408 <update_fiq_targets+0x148>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea8043f8:	531e74a5 	lsl	w5, w5, #2
ffffffffea8043fc:	b825c920 	str	w0, [x9, w5, sxtw]
		while (mask) {
ffffffffea804400:	b5fffa86 	cbnz	x6, ffffffffea804350 <update_fiq_targets+0x90>
ffffffffea804404:	17ffffec 	b	ffffffffea8043b4 <update_fiq_targets+0xf4>
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804408:	11118084 	add	w4, w4, #0x460
ffffffffea80440c:	531e7484 	lsl	w4, w4, #2
ffffffffea804410:	b824c920 	str	w0, [x9, w4, sxtw]
		while (mask) {
ffffffffea804414:	b5fff9e6 	cbnz	x6, ffffffffea804350 <update_fiq_targets+0x90>
ffffffffea804418:	17ffffe7 	b	ffffffffea8043b4 <update_fiq_targets+0xf4>
ffffffffea80441c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804420 <suspend_resume_fiq>:

#if !DISABLE_ARM_GIC_SUSPEND_RESUME
static void suspend_resume_fiq(bool resume_gicc, bool resume_gicd)
{
ffffffffea804420:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804424:	910003fd 	mov	x29, sp
ffffffffea804428:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80442c:	12001c13 	and	w19, w0, #0xff
ffffffffea804430:	f90013f5 	str	x21, [sp, #32]
ffffffffea804434:	12001c34 	and	w20, w1, #0xff
ffffffffea804438:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea80443c:	97fff9a5 	bl	ffffffffea802ad0 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea804440:	71001c1f 	cmp	w0, #0x7
ffffffffea804444:	54000108 	b.hi	ffffffffea804464 <suspend_resume_fiq+0x44>  // b.pmore

	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea804448:	2a1403e3 	mov	w3, w20
ffffffffea80444c:	2a1303e1 	mov	w1, w19
}
ffffffffea804450:	a94153f3 	ldp	x19, x20, [sp, #16]
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea804454:	12800002 	mov	w2, #0xffffffff            	// #-1
}
ffffffffea804458:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80445c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	update_fiq_targets(cpu, resume_gicc, ~0, resume_gicd);
ffffffffea804460:	17ffff98 	b	ffffffffea8042c0 <update_fiq_targets>
	ASSERT(cpu < 8);
ffffffffea804464:	d0000084 	adrp	x4, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804468:	d0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80446c:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804470:	913f2084 	add	x4, x4, #0xfc8
ffffffffea804474:	528046a3 	mov	w3, #0x235                 	// #565
ffffffffea804478:	913f4042 	add	x2, x2, #0xfd0
ffffffffea80447c:	91314021 	add	x1, x1, #0xc50
ffffffffea804480:	aa1503e0 	mov	x0, x21
ffffffffea804484:	9400383f 	bl	ffffffffea812580 <_panic>

ffffffffea804488 <arm_gic_suspend_cpu>:
	suspend_resume_fiq(false, false);
ffffffffea804488:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80448c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea804490:	17ffffe4 	b	ffffffffea804420 <suspend_resume_fiq>
ffffffffea804494:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804498 <register_int_handler>:
{
ffffffffea804498:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80449c:	910003fd 	mov	x29, sp
ffffffffea8044a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8044a4:	2a0003f3 	mov	w19, w0
ffffffffea8044a8:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea8044ac:	aa1e03f4 	mov	x20, x30
ffffffffea8044b0:	aa0103f9 	mov	x25, x1
ffffffffea8044b4:	aa0203f8 	mov	x24, x2
	uint cpu = arch_curr_cpu_num();
ffffffffea8044b8:	97fff986 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea8044bc:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8044c0:	f9001bb7 	str	x23, [x29, #48]
	if (vector >= MAX_INT)
ffffffffea8044c4:	710c7e7f 	cmp	w19, #0x31f
ffffffffea8044c8:	54000688 	b.hi	ffffffffea804598 <register_int_handler+0x100>  // b.pmore
ffffffffea8044cc:	2a0003f5 	mov	w21, w0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8044d0:	d53b4220 	mrs	x0, daif
};

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
ffffffffea8044d4:	52800017 	mov	w23, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8044d8:	363804a0 	tbz	w0, #7, ffffffffea80456c <register_int_handler+0xd4>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8044dc:	d53b4220 	mrs	x0, daif
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
        arch_disable_ints();
    }
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8044e0:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea8044e4:	37300080 	tbnz	w0, #6, ffffffffea8044f4 <register_int_handler+0x5c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8044e8:	321f02f7 	orr	w23, w23, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8044ec:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea8044f0:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea8044f4:	b0000354 	adrp	x20, ffffffffea86d000 <__bss_start>
ffffffffea8044f8:	91046280 	add	x0, x20, #0x118
ffffffffea8044fc:	97fff8f1 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea804500:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea804504:	3942a000 	ldrb	w0, [x0, #168]
ffffffffea804508:	35000380 	cbnz	w0, ffffffffea804578 <register_int_handler+0xe0>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea80450c:	71007e7f 	cmp	w19, #0x1f
ffffffffea804510:	54000248 	b.hi	ffffffffea804558 <register_int_handler+0xc0>  // b.pmore
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804514:	8b334eb3 	add	x19, x21, w19, uxtw #3
ffffffffea804518:	b0000343 	adrp	x3, ffffffffea86d000 <__bss_start>
ffffffffea80451c:	91048063 	add	x3, x3, #0x120
ffffffffea804520:	8b131073 	add	x19, x3, x19, lsl #4
		h->arg = arg;
ffffffffea804524:	a9006279 	stp	x25, x24, [x19]
    arch_spin_unlock(lock);
ffffffffea804528:	91046280 	add	x0, x20, #0x118
ffffffffea80452c:	97fff8ed 	bl	ffffffffea8028e0 <arch_spin_unlock>
}

static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804530:	34000056 	cbz	w22, ffffffffea804538 <register_int_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804534:	d50341ff 	msr	daifclr, #0x1
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804538:	36000057 	tbz	w23, #0, ffffffffea804540 <register_int_handler+0xa8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80453c:	d50342ff 	msr	daifclr, #0x2
ffffffffea804540:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea804544:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804548:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80454c:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea804550:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea804554:	d65f03c0 	ret
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804558:	51008273 	sub	w19, w19, #0x20
ffffffffea80455c:	d0000343 	adrp	x3, ffffffffea86e000 <int_handler_table_per_cpu+0xee0>
ffffffffea804560:	91048063 	add	x3, x3, #0x120
ffffffffea804564:	8b131073 	add	x19, x3, x19, lsl #4
ffffffffea804568:	17ffffef 	b	ffffffffea804524 <register_int_handler+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80456c:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804570:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea804574:	17ffffda 	b	ffffffffea8044dc <register_int_handler+0x44>
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea804578:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80457c:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804580:	2a1303e3 	mov	w3, w19
ffffffffea804584:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea804588:	9138a021 	add	x1, x1, #0xe28
ffffffffea80458c:	913d2000 	add	x0, x0, #0xf48
ffffffffea804590:	94003db2 	bl	ffffffffea813c58 <_printf>
ffffffffea804594:	17ffffe5 	b	ffffffffea804528 <register_int_handler+0x90>
		panic("register_int_handler: vector out of range %d\n", vector);
ffffffffea804598:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80459c:	2a1303e2 	mov	w2, w19
ffffffffea8045a0:	913c6021 	add	x1, x1, #0xf18
ffffffffea8045a4:	aa1403e0 	mov	x0, x20
ffffffffea8045a8:	940037f6 	bl	ffffffffea812580 <_panic>
ffffffffea8045ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8045b0 <arm_gic_init>:
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045b0:	929fffe3 	mov	x3, #0xffffffffffff0000    	// #-65536
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea8045b4:	52800001 	mov	w1, #0x0                   	// #0
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045b8:	f2be2803 	movk	x3, #0xf140, lsl #16
ffffffffea8045bc:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8045c0:	13057c20 	asr	w0, w1, #5
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea8045c4:	11008021 	add	w1, w1, #0x20
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045c8:	11118000 	add	w0, w0, #0x460
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea8045cc:	710c803f 	cmp	w1, #0x320
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045d0:	531e7400 	lsl	w0, w0, #2
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea8045d4:	11040004 	add	w4, w0, #0x100
		GICREG(0, GICD_ICENABLER(i / 32)) = ~0;
ffffffffea8045d8:	b820c862 	str	w2, [x3, w0, sxtw]
		GICREG(0, GICD_ICPENDR(i / 32)) = ~0;
ffffffffea8045dc:	b824c862 	str	w2, [x3, w4, sxtw]
	for (i = 0; i < MAX_INT; i+= 32) {
ffffffffea8045e0:	54ffff01 	b.ne	ffffffffea8045c0 <arm_gic_init+0x10>  // b.any
	return (GICREG(0, GICD_TYPER) >> 5) & 0x7;
ffffffffea8045e4:	929dff60 	mov	x0, #0xffffffffffff1004    	// #-61436
ffffffffea8045e8:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea8045ec:	b9400000 	ldr	w0, [x0]
	if (arm_gic_max_cpu() > 0) {
ffffffffea8045f0:	f27b081f 	tst	x0, #0xe0
ffffffffea8045f4:	540001e0 	b.eq	ffffffffea804630 <arm_gic_init+0x80>  // b.none
ffffffffea8045f8:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea8045fc:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804600:	9108e063 	add	x3, x3, #0x238
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804604:	52800400 	mov	w0, #0x20                  	// #32
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804608:	f2be2804 	movk	x4, #0xf140, lsl #16
ffffffffea80460c:	d503201f 	nop
ffffffffea804610:	13027c02 	asr	w2, w0, #2
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea804614:	11001000 	add	w0, w0, #0x4
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804618:	11180041 	add	w1, w2, #0x600
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80461c:	710c801f 	cmp	w0, #0x320
			GICREG(0, GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
ffffffffea804620:	531e7421 	lsl	w1, w1, #2
ffffffffea804624:	b862d862 	ldr	w2, [x3, w2, sxtw #2]
ffffffffea804628:	b821c882 	str	w2, [x4, w1, sxtw]
		for (i = 32; i < MAX_INT; i += 4) {
ffffffffea80462c:	54ffff21 	b.ne	ffffffffea804610 <arm_gic_init+0x60>  // b.any
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea804630:	929dffe1 	mov	x1, #0xffffffffffff1000    	// #-61440
ffffffffea804634:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea804638:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea80463c:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804640:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea804644:	91074063 	add	x3, x3, #0x1d0
	GICREG(0, GICD_CTLR) = 1; // enable GIC0
ffffffffea804648:	b9000020 	str	w0, [x1]
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea80464c:	52800062 	mov	w2, #0x3                   	// #3
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804650:	f2be2804 	movk	x4, #0xf140, lsl #16
	GICREG(0, GICD_CTLR) = 3; // enable GIC0 ns interrupts
ffffffffea804654:	b9000022 	str	w2, [x1]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea804658:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea80465c:	d503201f 	nop
		u_int reg = i / 32;
ffffffffea804660:	13057c02 	asr	w2, w0, #5
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea804664:	11008000 	add	w0, w0, #0x20
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804668:	11108041 	add	w1, w2, #0x420
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea80466c:	710c801f 	cmp	w0, #0x320
		GICREG(0, GICD_IGROUPR(reg)) = gicd_igroupr[reg];
ffffffffea804670:	531e7421 	lsl	w1, w1, #2
ffffffffea804674:	b8625862 	ldr	w2, [x3, w2, uxtw #2]
ffffffffea804678:	b8214882 	str	w2, [x4, w1, uxtw]
	for (i = 32; i < MAX_INT; i += 32) {
ffffffffea80467c:	54ffff21 	b.ne	ffffffffea804660 <arm_gic_init+0xb0>  // b.any
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804680:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804684:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804688:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea80468c:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804690:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804694:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804698:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea80469c:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea8046a0:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea8046a4:	b9000022 	str	w2, [x1]
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea8046a8:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea8046ac:	b9000001 	str	w1, [x0]
}
ffffffffea8046b0:	d65f03c0 	ret
ffffffffea8046b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8046b8 <arm_gic_resume_cpu>:
{
ffffffffea8046b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8046bc:	910003fd 	mov	x29, sp
ffffffffea8046c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8046c4:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8046c8:	d53b4220 	mrs	x0, daif
ffffffffea8046cc:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8046d0:	37380060 	tbnz	w0, #7, ffffffffea8046dc <arm_gic_resume_cpu+0x24>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8046d4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8046d8:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8046dc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8046e0:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8046e4:	37300080 	tbnz	w0, #6, ffffffffea8046f4 <arm_gic_resume_cpu+0x3c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8046e8:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8046ec:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea8046f0:	52800055 	mov	w21, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea8046f4:	b0000353 	adrp	x19, ffffffffea86d000 <__bss_start>
ffffffffea8046f8:	91046260 	add	x0, x19, #0x118
ffffffffea8046fc:	97fff871 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!(GICREG(0, GICD_CTLR) & 1)) {
ffffffffea804700:	929dffe0 	mov	x0, #0xffffffffffff1000    	// #-61440
ffffffffea804704:	f2be2800 	movk	x0, #0xf140, lsl #16
ffffffffea804708:	b9400000 	ldr	w0, [x0]
ffffffffea80470c:	36000340 	tbz	w0, #0, ffffffffea804774 <arm_gic_resume_cpu+0xbc>
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804710:	929bffe2 	mov	x2, #0xffffffffffff2000    	// #-57344
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804714:	929defe1 	mov	x1, #0xffffffffffff1080    	// #-61312
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804718:	f2be2802 	movk	x2, #0xf140, lsl #16
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea80471c:	f2be2801 	movk	x1, #0xf140, lsl #16
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804720:	929bff60 	mov	x0, #0xffffffffffff2004    	// #-57340
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea804724:	52800163 	mov	w3, #0xb                   	// #11
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea804728:	f2be2800 	movk	x0, #0xf140, lsl #16
	GICREG(0, GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
ffffffffea80472c:	b9000043 	str	w3, [x2]
	GICREG(0, GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
ffffffffea804730:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea804734:	b9000022 	str	w2, [x1]
	bool resume_gicd = false;
ffffffffea804738:	52800016 	mov	w22, #0x0                   	// #0
	GICREG(0, GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
ffffffffea80473c:	52801fe1 	mov	w1, #0xff                  	// #255
ffffffffea804740:	b9000001 	str	w1, [x0]
    arch_spin_unlock(lock);
ffffffffea804744:	91046260 	add	x0, x19, #0x118
ffffffffea804748:	97fff866 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea80474c:	34000055 	cbz	w21, ffffffffea804754 <arm_gic_resume_cpu+0x9c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804750:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804754:	36000054 	tbz	w20, #0, ffffffffea80475c <arm_gic_resume_cpu+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804758:	d50342ff 	msr	daifclr, #0x2
	suspend_resume_fiq(true, resume_gicd);
ffffffffea80475c:	2a1603e1 	mov	w1, w22
ffffffffea804760:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea804764:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804768:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80476c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	suspend_resume_fiq(true, resume_gicd);
ffffffffea804770:	17ffff2c 	b	ffffffffea804420 <suspend_resume_fiq>
		arm_gic_init();
ffffffffea804774:	97ffff8f 	bl	ffffffffea8045b0 <arm_gic_init>
		resume_gicd = true;
ffffffffea804778:	52800036 	mov	w22, #0x1                   	// #1
ffffffffea80477c:	17fffff2 	b	ffffffffea804744 <arm_gic_resume_cpu+0x8c>

ffffffffea804780 <arm_gic_sgi>:
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea804780:	53134823 	lsl	w3, w1, #13
		((cpu_mask & 0xff) << 16) |
ffffffffea804784:	53101c42 	ubfiz	w2, w2, #16, #8
		(irq & 0xf);
ffffffffea804788:	12000c04 	and	w4, w0, #0xf
		((flags & ARM_GIC_SGI_FLAG_TARGET_FILTER_MASK) << 24) |
ffffffffea80478c:	53080421 	ubfiz	w1, w1, #24, #2
		((flags & ARM_GIC_SGI_FLAG_NS) ? (1U << 15) : 0) |
ffffffffea804790:	12110063 	and	w3, w3, #0x8000
	u_int val =
ffffffffea804794:	2a040042 	orr	w2, w2, w4
ffffffffea804798:	2a030021 	orr	w1, w1, w3
	if (irq >= 16)
ffffffffea80479c:	71003c1f 	cmp	w0, #0xf
	u_int val =
ffffffffea8047a0:	2a020021 	orr	w1, w1, w2
	if (irq >= 16)
ffffffffea8047a4:	540000c8 	b.hi	ffffffffea8047bc <arm_gic_sgi+0x3c>  // b.pmore
	GICREG(0, GICD_SGIR) = val;
ffffffffea8047a8:	929c1fe2 	mov	x2, #0xffffffffffff1f00    	// #-57600
	return NO_ERROR;
ffffffffea8047ac:	52800000 	mov	w0, #0x0                   	// #0
	GICREG(0, GICD_SGIR) = val;
ffffffffea8047b0:	f2be2802 	movk	x2, #0xf140, lsl #16
ffffffffea8047b4:	b9000041 	str	w1, [x2]
}
ffffffffea8047b8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea8047bc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea8047c0:	d65f03c0 	ret
ffffffffea8047c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8047c8 <unmask_interrupt>:
	if (vector >= MAX_INT)
ffffffffea8047c8:	710c7c1f 	cmp	w0, #0x31f
ffffffffea8047cc:	54000368 	b.hi	ffffffffea804838 <unmask_interrupt+0x70>  // b.pmore
	if (!arm_gic_non_secure_interrupts_frozen)
ffffffffea8047d0:	b0000341 	adrp	x1, ffffffffea86d000 <__bss_start>
ffffffffea8047d4:	3942a021 	ldrb	w1, [x1, #168]
ffffffffea8047d8:	35000181 	cbnz	w1, ffffffffea804808 <unmask_interrupt+0x40>
	int reg = vector / 32;
ffffffffea8047dc:	53057c01 	lsr	w1, w0, #5
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea8047e0:	929fffe4 	mov	x4, #0xffffffffffff0000    	// #-65536
ffffffffea8047e4:	11110021 	add	w1, w1, #0x440
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea8047e8:	12001003 	and	w3, w0, #0x1f
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea8047ec:	f2be2804 	movk	x4, #0xf140, lsl #16
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea8047f0:	d2800022 	mov	x2, #0x1                   	// #1
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea8047f4:	531e7421 	lsl	w1, w1, #2
	uint32_t mask = 1ULL << (vector % 32);
ffffffffea8047f8:	9ac32043 	lsl	x3, x2, x3
	return NO_ERROR;
ffffffffea8047fc:	52800000 	mov	w0, #0x0                   	// #0
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804800:	b821c883 	str	w3, [x4, w1, sxtw]
ffffffffea804804:	d65f03c0 	ret
{
ffffffffea804808:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80480c:	2a0003e3 	mov	w3, w0
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea804810:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea804814:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
{
ffffffffea804818:	910003fd 	mov	x29, sp
	TRACEF("change to interrupt %d ignored after booting ns\n", irq);
ffffffffea80481c:	9138a021 	add	x1, x1, #0xe28
ffffffffea804820:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804824:	913d2000 	add	x0, x0, #0xf48
ffffffffea804828:	94003d0c 	bl	ffffffffea813c58 <_printf>
	return NO_ERROR;
ffffffffea80482c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea804830:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea804834:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea804838:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80483c:	d65f03c0 	ret

ffffffffea804840 <platform_irq>:
{
ffffffffea804840:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea804844:	929bfae0 	mov	x0, #0xffffffffffff2028    	// #-57304
ffffffffea804848:	f2be2800 	movk	x0, #0xf140, lsl #16
{
ffffffffea80484c:	910003fd 	mov	x29, sp
ffffffffea804850:	a901d7f4 	stp	x20, x21, [sp, #24]
	uint32_t ahppir = GICREG(0, GICC_AHPPIR);
ffffffffea804854:	b9400015 	ldr	w21, [x0]
	uint cpu = arch_curr_cpu_num();
ffffffffea804858:	97fff89e 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	uint32_t pending_irq = ahppir & 0x3ff;
ffffffffea80485c:	120026b4 	and	w20, w21, #0x3ff
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea804860:	710c7e9f 	cmp	w20, #0x31f
ffffffffea804864:	54000948 	b.hi	ffffffffea80498c <platform_irq+0x14c>  // b.pmore
ffffffffea804868:	f9000bb3 	str	x19, [x29, #16]
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea80486c:	71007e9f 	cmp	w20, #0x1f
ffffffffea804870:	54000949 	b.ls	ffffffffea804998 <platform_irq+0x158>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804874:	51008293 	sub	w19, w20, #0x20
ffffffffea804878:	d0000340 	adrp	x0, ffffffffea86e000 <int_handler_table_per_cpu+0xee0>
ffffffffea80487c:	91048000 	add	x0, x0, #0x120
ffffffffea804880:	8b131013 	add	x19, x0, x19, lsl #4
	if (pending_irq < MAX_INT && get_int_handler(pending_irq, cpu)->handler) {
ffffffffea804884:	f9400260 	ldr	x0, [x19]
ffffffffea804888:	b4000800 	cbz	x0, ffffffffea804988 <platform_irq+0x148>
ffffffffea80488c:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea804890:	f9001fb8 	str	x24, [x29, #56]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804894:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804898:	52800018 	mov	w24, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80489c:	37380060 	tbnz	w0, #7, ffffffffea8048a8 <platform_irq+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8048a0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8048a4:	52800038 	mov	w24, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8048a8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8048ac:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea8048b0:	37300080 	tbnz	w0, #6, ffffffffea8048c0 <platform_irq+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8048b4:	321f0318 	orr	w24, w24, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8048b8:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea8048bc:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea8048c0:	b0000356 	adrp	x22, ffffffffea86d000 <__bss_start>
ffffffffea8048c4:	910462d6 	add	x22, x22, #0x118
ffffffffea8048c8:	aa1603e0 	mov	x0, x22
ffffffffea8048cc:	97fff7fd 	bl	ffffffffea8028c0 <arch_spin_lock>
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea8048d0:	121e1e82 	and	w2, w20, #0x3fc
ffffffffea8048d4:	52828000 	mov	w0, #0x1400                	// #5120
ffffffffea8048d8:	929fffe6 	mov	x6, #0xffffffffffff0000    	// #-65536
ffffffffea8048dc:	0b000042 	add	w2, w2, w0
ffffffffea8048e0:	f2be2806 	movk	x6, #0xf140, lsl #16
	u_int shift = 8 * (irq % 4);
ffffffffea8048e4:	531d06a1 	ubfiz	w1, w21, #3, #2
	u_int mask = 0xff << shift;
ffffffffea8048e8:	52801fe4 	mov	w4, #0xff                  	// #255
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea8048ec:	b86248c5 	ldr	w5, [x6, w2, uxtw]
	u_int mask = 0xff << shift;
ffffffffea8048f0:	1ac12084 	lsl	w4, w4, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea8048f4:	b86248c0 	ldr	w0, [x6, w2, uxtw]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea8048f8:	2a2403e4 	mvn	w4, w4
ffffffffea8048fc:	0a040000 	and	w0, w0, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804900:	b82248c0 	str	w0, [x6, w2, uxtw]
		DSB;
ffffffffea804904:	d5033f9f 	dsb	sy
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804908:	929bfbe3 	mov	x3, #0xffffffffffff2020    	// #-57312
	return (GICREG(0, GICD_IPRIORITYR(reg)) >> shift) & 0xff;
ffffffffea80490c:	1ac124a5 	lsr	w5, w5, w1
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804910:	f2be2803 	movk	x3, #0xf140, lsl #16
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804914:	12001ca5 	and	w5, w5, #0xff
    arch_spin_unlock(lock);
ffffffffea804918:	aa1603e0 	mov	x0, x22
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea80491c:	b9400075 	ldr	w21, [x3]
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804920:	1ac120a1 	lsl	w1, w5, w1
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804924:	b86248c7 	ldr	w7, [x6, w2, uxtw]
		irq = GICREG(0, GICC_AIAR) & 0x3ff;
ffffffffea804928:	120026b5 	and	w21, w21, #0x3ff
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea80492c:	0a0400e4 	and	w4, w7, w4
ffffffffea804930:	2a040021 	orr	w1, w1, w4
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804934:	b82248c1 	str	w1, [x6, w2, uxtw]
ffffffffea804938:	97fff7ea 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea80493c:	34000057 	cbz	w23, ffffffffea804944 <platform_irq+0x104>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804940:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804944:	36000058 	tbz	w24, #0, ffffffffea80494c <platform_irq+0x10c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804948:	d50342ff 	msr	daifclr, #0x2
		if (irq < MAX_INT && (h = get_int_handler(pending_irq, cpu))->handler)
ffffffffea80494c:	710c7ebf 	cmp	w21, #0x31f
ffffffffea804950:	54000308 	b.hi	ffffffffea8049b0 <platform_irq+0x170>  // b.pmore
ffffffffea804954:	f9400261 	ldr	x1, [x19]
ffffffffea804958:	b40002c1 	cbz	x1, ffffffffea8049b0 <platform_irq+0x170>
			ret = h->handler(h->arg);
ffffffffea80495c:	f9400660 	ldr	x0, [x19, #8]
ffffffffea804960:	d63f0020 	blr	x1
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea804964:	929bfb61 	mov	x1, #0xffffffffffff2024    	// #-57308
}
ffffffffea804968:	f9400bb3 	ldr	x19, [x29, #16]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea80496c:	f2be2801 	movk	x1, #0xf140, lsl #16
}
ffffffffea804970:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea804974:	a942dfb6 	ldp	x22, x23, [x29, #40]
		GICREG(0, GICC_AEOIR) = irq;
ffffffffea804978:	b9000035 	str	w21, [x1]
}
ffffffffea80497c:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea804980:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804984:	d65f03c0 	ret
ffffffffea804988:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80498c:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea804990:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return sm_handle_irq();
ffffffffea804994:	14000ee9 	b	ffffffffea808538 <sm_handle_irq>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804998:	2a0003f3 	mov	w19, w0
ffffffffea80499c:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea8049a0:	8b344e73 	add	x19, x19, w20, uxtw #3
ffffffffea8049a4:	91048000 	add	x0, x0, #0x120
ffffffffea8049a8:	8b131013 	add	x19, x0, x19, lsl #4
ffffffffea8049ac:	17ffffb6 	b	ffffffffea804884 <platform_irq+0x44>
			TRACEF("unexpected irq %d != %d may get lost\n", irq, pending_irq);
ffffffffea8049b0:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8049b4:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8049b8:	2a1403e4 	mov	w4, w20
ffffffffea8049bc:	2a1503e3 	mov	w3, w21
ffffffffea8049c0:	52803722 	mov	w2, #0x1b9                 	// #441
ffffffffea8049c4:	91394021 	add	x1, x1, #0xe50
ffffffffea8049c8:	913ba000 	add	x0, x0, #0xee8
ffffffffea8049cc:	94003ca3 	bl	ffffffffea813c58 <_printf>
		enum handler_return ret = 0;
ffffffffea8049d0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8049d4:	17ffffe4 	b	ffffffffea804964 <platform_irq+0x124>

ffffffffea8049d8 <platform_fiq>:
	sm_handle_fiq();
ffffffffea8049d8:	14000ef2 	b	ffffffffea8085a0 <sm_handle_fiq>
ffffffffea8049dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8049e0 <smc_intc_get_next_irq>:
{
ffffffffea8049e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8049e4:	910003fd 	mov	x29, sp
ffffffffea8049e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8049ec:	aa0003f3 	mov	x19, x0
ffffffffea8049f0:	a9025bf5 	stp	x21, x22, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8049f4:	d53b4220 	mrs	x0, daif
ffffffffea8049f8:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8049fc:	37380060 	tbnz	w0, #7, ffffffffea804a08 <smc_intc_get_next_irq+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804a00:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804a04:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804a08:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804a0c:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea804a10:	37300080 	tbnz	w0, #6, ffffffffea804a20 <smc_intc_get_next_irq+0x40>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804a14:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804a18:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804a1c:	52800056 	mov	w22, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804a20:	b0000354 	adrp	x20, ffffffffea86d000 <__bss_start>
ffffffffea804a24:	91046280 	add	x0, x20, #0x118
ffffffffea804a28:	97fff7a6 	bl	ffffffffea8028c0 <arch_spin_lock>
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a2c:	b0000341 	adrp	x1, ffffffffea86d000 <__bss_start>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a30:	b9400a60 	ldr	w0, [x19, #8]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a34:	52800022 	mov	w2, #0x1                   	// #1
	ret = arm_gic_get_next_irq_locked(args->params[0], args->params[1]);
ffffffffea804a38:	b9400673 	ldr	w19, [x19, #4]
	arm_gic_non_secure_interrupts_frozen = true;
ffffffffea804a3c:	3902a022 	strb	w2, [x1, #168]
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a40:	35000480 	cbnz	w0, ffffffffea804ad0 <smc_intc_get_next_irq+0xf0>
	uint cpu = arch_curr_cpu_num();
ffffffffea804a44:	97fff823 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804a48:	52806403 	mov	w3, #0x320                 	// #800
	if (!per_cpu && min_irq < GIC_MAX_PER_CPU_INT)
ffffffffea804a4c:	71007e7f 	cmp	w19, #0x1f
ffffffffea804a50:	54000448 	b.hi	ffffffffea804ad8 <smc_intc_get_next_irq+0xf8>  // b.pmore
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804a54:	52800413 	mov	w19, #0x20                  	// #32
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804a58:	d0000345 	adrp	x5, ffffffffea86e000 <int_handler_table_per_cpu+0xee0>
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804a5c:	b0000344 	adrp	x4, ffffffffea86d000 <__bss_start>
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804a60:	910480a5 	add	x5, x5, #0x120
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804a64:	2a0003e0 	mov	w0, w0
ffffffffea804a68:	91048084 	add	x4, x4, #0x120
ffffffffea804a6c:	14000007 	b	ffffffffea804a88 <smc_intc_get_next_irq+0xa8>
ffffffffea804a70:	8b021081 	add	x1, x4, x2, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804a74:	f9400021 	ldr	x1, [x1]
ffffffffea804a78:	b5000161 	cbnz	x1, ffffffffea804aa4 <smc_intc_get_next_irq+0xc4>
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804a7c:	11000673 	add	w19, w19, #0x1
ffffffffea804a80:	6b03027f 	cmp	w19, w3
ffffffffea804a84:	540002e2 	b.cs	ffffffffea804ae0 <smc_intc_get_next_irq+0x100>  // b.hs, b.nlast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804a88:	51008261 	sub	w1, w19, #0x20
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804a8c:	8b334c02 	add	x2, x0, w19, uxtw #3
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804a90:	71007e7f 	cmp	w19, #0x1f
ffffffffea804a94:	54fffee9 	b.ls	ffffffffea804a70 <smc_intc_get_next_irq+0x90>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804a98:	8b0110a1 	add	x1, x5, x1, lsl #4
		if (get_int_handler(irq, cpu)->handler)
ffffffffea804a9c:	f9400021 	ldr	x1, [x1]
ffffffffea804aa0:	b4fffee1 	cbz	x1, ffffffffea804a7c <smc_intc_get_next_irq+0x9c>
ffffffffea804aa4:	2a1303f3 	mov	w19, w19
    arch_spin_unlock(lock);
ffffffffea804aa8:	91046280 	add	x0, x20, #0x118
ffffffffea804aac:	97fff78d 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804ab0:	35000216 	cbnz	w22, ffffffffea804af0 <smc_intc_get_next_irq+0x110>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804ab4:	36000055 	tbz	w21, #0, ffffffffea804abc <smc_intc_get_next_irq+0xdc>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804ab8:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804abc:	aa1303e0 	mov	x0, x19
ffffffffea804ac0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804ac4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804ac8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804acc:	d65f03c0 	ret
	uint cpu = arch_curr_cpu_num();
ffffffffea804ad0:	97fff800 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	u_int max_irq = per_cpu ? GIC_MAX_PER_CPU_INT : MAX_INT;
ffffffffea804ad4:	52800403 	mov	w3, #0x20                  	// #32
	for (irq = min_irq; irq < max_irq; irq++)
ffffffffea804ad8:	6b03027f 	cmp	w19, w3
ffffffffea804adc:	54fffbe3 	b.cc	ffffffffea804a58 <smc_intc_get_next_irq+0x78>  // b.lo, b.ul, b.last
		min_irq = GIC_MAX_PER_CPU_INT;
ffffffffea804ae0:	92800133 	mov	x19, #0xfffffffffffffff6    	// #-10
ffffffffea804ae4:	91046280 	add	x0, x20, #0x118
ffffffffea804ae8:	97fff77e 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804aec:	34fffe56 	cbz	w22, ffffffffea804ab4 <smc_intc_get_next_irq+0xd4>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804af0:	d50341ff 	msr	daifclr, #0x1
ffffffffea804af4:	17fffff0 	b	ffffffffea804ab4 <smc_intc_get_next_irq+0xd4>

ffffffffea804af8 <smc_intc_request_fiq>:
{
ffffffffea804af8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea804afc:	910003fd 	mov	x29, sp
ffffffffea804b00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804b04:	a9025bf5 	stp	x21, x22, [sp, #32]
	u_int fiq = args->params[0];
ffffffffea804b08:	b9400413 	ldr	w19, [x0, #4]
{
ffffffffea804b0c:	f9001bf7 	str	x23, [sp, #48]
	bool enable = args->params[1];
ffffffffea804b10:	b9400817 	ldr	w23, [x0, #8]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804b14:	d53b4220 	mrs	x0, daif
ffffffffea804b18:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804b1c:	37380060 	tbnz	w0, #7, ffffffffea804b28 <smc_intc_request_fiq+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804b20:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804b24:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804b28:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804b2c:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea804b30:	37300080 	tbnz	w0, #6, ffffffffea804b40 <smc_intc_request_fiq+0x48>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804b34:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804b38:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804b3c:	52800055 	mov	w21, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804b40:	b0000356 	adrp	x22, ffffffffea86d000 <__bss_start>
ffffffffea804b44:	910462c0 	add	x0, x22, #0x118
ffffffffea804b48:	97fff75e 	bl	ffffffffea8028c0 <arch_spin_lock>
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804b4c:	12001260 	and	w0, w19, #0x1f
ffffffffea804b50:	d2800028 	mov	x8, #0x1                   	// #1
	int reg = irq / 32;
ffffffffea804b54:	53057e61 	lsr	w1, w19, #5
	if (irq >= MAX_INT)
ffffffffea804b58:	710c7e7f 	cmp	w19, #0x31f
	uint32_t mask = 1ULL << (irq % 32);
ffffffffea804b5c:	9ac02108 	lsl	x8, x8, x0
	if (irq >= MAX_INT)
ffffffffea804b60:	54000188 	b.hi	ffffffffea804b90 <smc_intc_request_fiq+0x98>  // b.pmore
		GICREG(0, GICD_IGROUPR(reg)) = (gicd_igroupr[reg] &= ~mask);
ffffffffea804b64:	93407c24 	sxtw	x4, w1
ffffffffea804b68:	b00000a3 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea804b6c:	11108020 	add	w0, w1, #0x420
ffffffffea804b70:	91074063 	add	x3, x3, #0x1d0
ffffffffea804b74:	929fffe5 	mov	x5, #0xffffffffffff0000    	// #-65536
ffffffffea804b78:	531e7400 	lsl	w0, w0, #2
ffffffffea804b7c:	f2be2805 	movk	x5, #0xf140, lsl #16
ffffffffea804b80:	b8647862 	ldr	w2, [x3, x4, lsl #2]
ffffffffea804b84:	0a280042 	bic	w2, w2, w8
ffffffffea804b88:	b8247862 	str	w2, [x3, x4, lsl #2]
ffffffffea804b8c:	b820c8a2 	str	w2, [x5, w0, sxtw]
	u_int reg = irq / 4;
ffffffffea804b90:	53027e63 	lsr	w3, w19, #2
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804b94:	b00000a7 	adrp	x7, ffffffffea819000 <_mem_phys_base>
ffffffffea804b98:	9108e0e7 	add	x7, x7, #0x238
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804b9c:	11180064 	add	w4, w3, #0x600
	u_int shift = 8 * (irq % 4);
ffffffffea804ba0:	531d0665 	ubfiz	w5, w19, #3, #2
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804ba4:	12800000 	mov	w0, #0xffffffff            	// #-1
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804ba8:	531e7484 	lsl	w4, w4, #2
ffffffffea804bac:	929fffe6 	mov	x6, #0xffffffffffff0000    	// #-65536
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804bb0:	b86378ea 	ldr	w10, [x7, x3, lsl #2]
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804bb4:	f2be2806 	movk	x6, #0xf140, lsl #16
	enable_mask = (enable_mask << shift) & cpu_mask;
ffffffffea804bb8:	1ac52000 	lsl	w0, w0, w5
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804bbc:	52801fe2 	mov	w2, #0xff                  	// #255
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804bc0:	4a0a0000 	eor	w0, w0, w10
	cpu_mask = (cpu_mask & 0xff) << shift;
ffffffffea804bc4:	1ac52042 	lsl	w2, w2, w5
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804bc8:	51100089 	sub	w9, w4, #0x400
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804bcc:	0a020000 	and	w0, w0, w2
	old_val = GICREG(0, GICD_ITARGETSR(reg));
ffffffffea804bd0:	b86448c5 	ldr	w5, [x6, w4, uxtw]
	new_val = (gicd_itargetsr[reg] & ~cpu_mask) | enable_mask;
ffffffffea804bd4:	4a0a0000 	eor	w0, w0, w10
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804bd8:	b82448c0 	str	w0, [x6, w4, uxtw]
ffffffffea804bdc:	b0000345 	adrp	x5, ffffffffea86d000 <__bss_start>
ffffffffea804be0:	9102c0a4 	add	x4, x5, #0xb0
	regval = GICREG(0, GICD_IPRIORITYR(reg));
ffffffffea804be4:	b86948ca 	ldr	w10, [x6, w9, uxtw]
ffffffffea804be8:	53067e65 	lsr	w5, w19, #6
	GICREG(0, GICD_ITARGETSR(reg)) = gicd_itargetsr[reg] = new_val;
ffffffffea804bec:	b82378e0 	str	w0, [x7, x3, lsl #2]
ffffffffea804bf0:	d2800020 	mov	x0, #0x1                   	// #1
	regval = (regval & ~mask) | ((uint32_t)priority << shift);
ffffffffea804bf4:	0a220142 	bic	w2, w10, w2
	GICREG(0, GICD_IPRIORITYR(reg)) = regval;
ffffffffea804bf8:	b82948c2 	str	w2, [x6, w9, uxtw]
ffffffffea804bfc:	9ad32013 	lsl	x19, x0, x19
ffffffffea804c00:	f8657882 	ldr	x2, [x4, x5, lsl #3]
	if (enable)
ffffffffea804c04:	34000257 	cbz	w23, ffffffffea804c4c <smc_intc_request_fiq+0x154>
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c08:	11110021 	add	w1, w1, #0x440
		*bitmap |= mask;
ffffffffea804c0c:	aa020273 	orr	x19, x19, x2
		GICREG(0, GICD_ISENABLER(reg)) = mask;
ffffffffea804c10:	531e7421 	lsl	w1, w1, #2
ffffffffea804c14:	b821c8c8 	str	w8, [x6, w1, sxtw]
		*bitmap |= mask;
ffffffffea804c18:	f8257893 	str	x19, [x4, x5, lsl #3]
    arch_spin_unlock(lock);
ffffffffea804c1c:	910462c0 	add	x0, x22, #0x118
ffffffffea804c20:	97fff730 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804c24:	34000055 	cbz	w21, ffffffffea804c2c <smc_intc_request_fiq+0x134>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804c28:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804c2c:	36000054 	tbz	w20, #0, ffffffffea804c34 <smc_intc_request_fiq+0x13c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804c30:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea804c34:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea804c38:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea804c3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804c40:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea804c44:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804c48:	d65f03c0 	ret
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804c4c:	11118021 	add	w1, w1, #0x460
		*bitmap &= ~mask;
ffffffffea804c50:	8a330053 	bic	x19, x2, x19
		GICREG(0, GICD_ICENABLER(reg)) = mask;
ffffffffea804c54:	531e7421 	lsl	w1, w1, #2
ffffffffea804c58:	b821c8c8 	str	w8, [x6, w1, sxtw]
		*bitmap &= ~mask;
ffffffffea804c5c:	f8257893 	str	x19, [x4, x5, lsl #3]
ffffffffea804c60:	17ffffef 	b	ffffffffea804c1c <smc_intc_request_fiq+0x124>
ffffffffea804c64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804c68 <sm_intc_fiq_enter>:
#endif

status_t sm_intc_fiq_enter(void)
{
ffffffffea804c68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea804c6c:	910003fd 	mov	x29, sp
ffffffffea804c70:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804c74:	f90013f5 	str	x21, [sp, #32]
ffffffffea804c78:	aa1e03f5 	mov	x21, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804c7c:	97fff795 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea804c80:	2a0003f4 	mov	w20, w0
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
ffffffffea804c84:	929bfe61 	mov	x1, #0xffffffffffff200c    	// #-57332
	bool fiq_enabled;

	ASSERT(cpu < 8);
ffffffffea804c88:	71001e9f 	cmp	w20, #0x7
	u_int irq = GICREG(0, GICC_IAR) & 0x3ff;
ffffffffea804c8c:	f2be2801 	movk	x1, #0xf140, lsl #16
ffffffffea804c90:	b9400033 	ldr	w19, [x1]
	ASSERT(cpu < 8);
ffffffffea804c94:	54000308 	b.hi	ffffffffea804cf4 <sm_intc_fiq_enter+0x8c>  // b.pmore
ffffffffea804c98:	12002673 	and	w19, w19, #0x3ff

	LTRACEF("cpu %d, irq %i\n", cpu, irq);

	if (irq >= 1020) {
ffffffffea804c9c:	710fee7f 	cmp	w19, #0x3fb
ffffffffea804ca0:	540003c8 	b.hi	ffffffffea804d18 <sm_intc_fiq_enter+0xb0>  // b.pmore
		LTRACEF("spurious fiq: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_NO_MSG;
	}

	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804ca4:	2a1303e2 	mov	w2, w19
ffffffffea804ca8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea804cac:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804cb0:	97fffd84 	bl	ffffffffea8042c0 <update_fiq_targets>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804cb4:	929bfde2 	mov	x2, #0xffffffffffff2010    	// #-57328

	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804cb8:	b00000a1 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804cbc:	f2be2802 	movk	x2, #0xf140, lsl #16
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804cc0:	9106c021 	add	x1, x1, #0x1b0
	fiq_enabled = update_fiq_targets(cpu, false, irq, false);
ffffffffea804cc4:	12001c00 	and	w0, w0, #0xff
	GICREG(0, GICC_EOIR) = irq;
ffffffffea804cc8:	b9000053 	str	w19, [x2]
	if (current_fiq[cpu] != 0x3ff) {
ffffffffea804ccc:	b8747822 	ldr	w2, [x1, x20, lsl #2]
ffffffffea804cd0:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804cd4:	54000261 	b.ne	ffffffffea804d20 <sm_intc_fiq_enter+0xb8>  // b.any
		dprintf(INFO, "more than one fiq active: cpu %d, old %d, new %d\n", cpu, current_fiq[cpu], irq);
		return ERR_ALREADY_STARTED;
	}

	if (!fiq_enabled) {
ffffffffea804cd8:	34000280 	cbz	w0, ffffffffea804d28 <sm_intc_fiq_enter+0xc0>
		dprintf(INFO, "got disabled fiq: cpu %d, new %d\n", cpu, irq);
		return ERR_NOT_READY;
	}

	current_fiq[cpu] = irq;
ffffffffea804cdc:	b8347833 	str	w19, [x1, x20, lsl #2]

	return 0;
ffffffffea804ce0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea804ce4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804ce8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea804cec:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea804cf0:	d65f03c0 	ret
	ASSERT(cpu < 8);
ffffffffea804cf4:	d0000084 	adrp	x4, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804cf8:	d0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804cfc:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804d00:	913f2084 	add	x4, x4, #0xfc8
ffffffffea804d04:	52804823 	mov	w3, #0x241                 	// #577
ffffffffea804d08:	913f4042 	add	x2, x2, #0xfd0
ffffffffea804d0c:	91314021 	add	x1, x1, #0xc50
ffffffffea804d10:	aa1503e0 	mov	x0, x21
ffffffffea804d14:	9400361b 	bl	ffffffffea812580 <_panic>
		return ERR_NO_MSG;
ffffffffea804d18:	12800060 	mov	w0, #0xfffffffc            	// #-4
ffffffffea804d1c:	17fffff2 	b	ffffffffea804ce4 <sm_intc_fiq_enter+0x7c>
		return ERR_ALREADY_STARTED;
ffffffffea804d20:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea804d24:	17fffff0 	b	ffffffffea804ce4 <sm_intc_fiq_enter+0x7c>
		return ERR_NOT_READY;
ffffffffea804d28:	12800040 	mov	w0, #0xfffffffd            	// #-3
ffffffffea804d2c:	17ffffee 	b	ffffffffea804ce4 <sm_intc_fiq_enter+0x7c>

ffffffffea804d30 <sm_intc_fiq_exit>:

void sm_intc_fiq_exit(void)
{
ffffffffea804d30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea804d34:	910003fd 	mov	x29, sp
ffffffffea804d38:	f9000bf3 	str	x19, [sp, #16]
ffffffffea804d3c:	aa1e03f3 	mov	x19, x30
	u_int cpu = arch_curr_cpu_num();
ffffffffea804d40:	97fff764 	bl	ffffffffea802ad0 <arch_curr_cpu_num>

	ASSERT(cpu < 8);
ffffffffea804d44:	71001c1f 	cmp	w0, #0x7
ffffffffea804d48:	f9000fb4 	str	x20, [x29, #24]
ffffffffea804d4c:	54000208 	b.hi	ffffffffea804d8c <sm_intc_fiq_exit+0x5c>  // b.pmore

	LTRACEF("cpu %d, irq %i\n", cpu, current_fiq[cpu]);
	if (current_fiq[cpu] == 0x3ff) {
ffffffffea804d50:	b00000b4 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea804d54:	2a0003f3 	mov	w19, w0
ffffffffea804d58:	9106c294 	add	x20, x20, #0x1b0
ffffffffea804d5c:	b8737a82 	ldr	w2, [x20, x19, lsl #2]
ffffffffea804d60:	710ffc5f 	cmp	w2, #0x3ff
ffffffffea804d64:	540000c0 	b.eq	ffffffffea804d7c <sm_intc_fiq_exit+0x4c>  // b.none
		dprintf(INFO, "%s: no fiq active, cpu %d\n", __func__, cpu);
		return;
	}
	update_fiq_targets(cpu, true, current_fiq[cpu], false);
ffffffffea804d68:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea804d6c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea804d70:	97fffd54 	bl	ffffffffea8042c0 <update_fiq_targets>
	current_fiq[cpu] = 0x3ff;
ffffffffea804d74:	52807fe0 	mov	w0, #0x3ff                 	// #1023
ffffffffea804d78:	b8337a80 	str	w0, [x20, x19, lsl #2]
ffffffffea804d7c:	f9400fb4 	ldr	x20, [x29, #24]
}
ffffffffea804d80:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea804d84:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea804d88:	d65f03c0 	ret
	ASSERT(cpu < 8);
ffffffffea804d8c:	d0000084 	adrp	x4, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804d90:	d0000082 	adrp	x2, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804d94:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804d98:	913f2084 	add	x4, x4, #0xfc8
ffffffffea804d9c:	52804c03 	mov	w3, #0x260                 	// #608
ffffffffea804da0:	913f4042 	add	x2, x2, #0xfd0
ffffffffea804da4:	91314021 	add	x1, x1, #0xc50
ffffffffea804da8:	aa1303e0 	mov	x0, x19
ffffffffea804dac:	940035f5 	bl	ffffffffea812580 <_panic>

ffffffffea804db0 <arm_gic_sim_irq_handler>:
 *        expired.
 *        The body of this function is a mimic of irq_exception routine in
 *        arch/arm64/exceptions.S
 */
status_t arm_gic_sim_irq_handler(u_int irq)
{
ffffffffea804db0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea804db4:	910003fd 	mov	x29, sp
ffffffffea804db8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea804dbc:	2a0003f4 	mov	w20, w0
	status_t ret = NO_ERROR;
#if WITH_LIB_SM
	uint cpu = arch_curr_cpu_num();
ffffffffea804dc0:	97fff744 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	struct int_handler_struct *h;
	spin_lock_saved_state_t state;

	LTRACEF("irq: %u cpu: %u\n", irq, cpu);

	if (irq >= MAX_INT) {
ffffffffea804dc4:	710c7e9f 	cmp	w20, #0x31f
ffffffffea804dc8:	54000c28 	b.hi	ffffffffea804f4c <arm_gic_sim_irq_handler+0x19c>  // b.pmore
ffffffffea804dcc:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea804dd0:	2a0003f3 	mov	w19, w0
ffffffffea804dd4:	f9001bb7 	str	x23, [x29, #48]
			irq, MAX_INT);
		return ERR_INVALID_ARGS;
	}

	/* Barrier against speculatively loading int_handler_struct addresses */
	platform_arch_speculation_barrier();
ffffffffea804dd8:	97fff512 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804ddc:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804de0:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804de4:	36380520 	tbz	w0, #7, ffffffffea804e88 <arm_gic_sim_irq_handler+0xd8>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804de8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804dec:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea804df0:	37300080 	tbnz	w0, #6, ffffffffea804e00 <arm_gic_sim_irq_handler+0x50>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804df4:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804df8:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea804dfc:	52800057 	mov	w23, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea804e00:	b0000355 	adrp	x21, ffffffffea86d000 <__bss_start>
ffffffffea804e04:	910462a0 	add	x0, x21, #0x118
ffffffffea804e08:	97fff6ae 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (vector < GIC_MAX_PER_CPU_INT)
ffffffffea804e0c:	71007e9f 	cmp	w20, #0x1f
ffffffffea804e10:	54000309 	b.ls	ffffffffea804e70 <arm_gic_sim_irq_handler+0xc0>  // b.plast
		return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
ffffffffea804e14:	51008281 	sub	w1, w20, #0x20
ffffffffea804e18:	d0000340 	adrp	x0, ffffffffea86e000 <int_handler_table_per_cpu+0xee0>
ffffffffea804e1c:	91048000 	add	x0, x0, #0x120
ffffffffea804e20:	8b011001 	add	x1, x0, x1, lsl #4

	spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
	if ((h = get_int_handler(irq, cpu))->handler != NULL) {
ffffffffea804e24:	f9400022 	ldr	x2, [x1]
ffffffffea804e28:	b4000802 	cbz	x2, ffffffffea804f28 <arm_gic_sim_irq_handler+0x178>
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804e2c:	f9400420 	ldr	x0, [x1, #8]
	status_t ret = NO_ERROR;
ffffffffea804e30:	52800013 	mov	w19, #0x0                   	// #0
		if (h->handler(h->arg) == INT_RESCHEDULE) {
ffffffffea804e34:	d63f0040 	blr	x2
ffffffffea804e38:	7100041f 	cmp	w0, #0x1
ffffffffea804e3c:	54000380 	b.eq	ffffffffea804eac <arm_gic_sim_irq_handler+0xfc>  // b.none
    arch_spin_unlock(lock);
ffffffffea804e40:	910462a0 	add	x0, x21, #0x118
ffffffffea804e44:	97fff6a7 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804e48:	34000057 	cbz	w23, ffffffffea804e50 <arm_gic_sim_irq_handler+0xa0>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804e4c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804e50:	36000236 	tbz	w22, #0, ffffffffea804e94 <arm_gic_sim_irq_handler+0xe4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804e54:	d50342ff 	msr	daifclr, #0x2
ffffffffea804e58:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804e5c:	f9401bb7 	ldr	x23, [x29, #48]
	spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);
#else
	ret = ERR_NOT_SUPPORTED;
#endif
	return ret;
}
ffffffffea804e60:	2a1303e0 	mov	w0, w19
ffffffffea804e64:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804e68:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804e6c:	d65f03c0 	ret
		return &int_handler_table_per_cpu[vector][cpu];
ffffffffea804e70:	2a1303e1 	mov	w1, w19
ffffffffea804e74:	b0000340 	adrp	x0, ffffffffea86d000 <__bss_start>
ffffffffea804e78:	8b344c21 	add	x1, x1, w20, uxtw #3
ffffffffea804e7c:	91048000 	add	x0, x0, #0x120
ffffffffea804e80:	8b011001 	add	x1, x0, x1, lsl #4
ffffffffea804e84:	17ffffe8 	b	ffffffffea804e24 <arm_gic_sim_irq_handler+0x74>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804e88:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804e8c:	52800036 	mov	w22, #0x1                   	// #1
ffffffffea804e90:	17ffffd6 	b	ffffffffea804de8 <arm_gic_sim_irq_handler+0x38>
}
ffffffffea804e94:	2a1303e0 	mov	w0, w19
ffffffffea804e98:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea804e9c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea804ea0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea804ea4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea804ea8:	d65f03c0 	ret
ffffffffea804eac:	910462a0 	add	x0, x21, #0x118
ffffffffea804eb0:	97fff68c 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea804eb4:	34000057 	cbz	w23, ffffffffea804ebc <arm_gic_sim_irq_handler+0x10c>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804eb8:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea804ebc:	36000056 	tbz	w22, #0, ffffffffea804ec4 <arm_gic_sim_irq_handler+0x114>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea804ec0:	d50342ff 	msr	daifclr, #0x2
			    thread_preempt();
ffffffffea804ec4:	9400051d 	bl	ffffffffea806338 <thread_preempt>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804ec8:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea804ecc:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea804ed0:	37380060 	tbnz	w0, #7, ffffffffea804edc <arm_gic_sim_irq_handler+0x12c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea804ed4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea804ed8:	52800036 	mov	w22, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea804edc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea804ee0:	37300160 	tbnz	w0, #6, ffffffffea804f0c <arm_gic_sim_irq_handler+0x15c>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea804ee4:	321f02d6 	orr	w22, w22, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea804ee8:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea804eec:	910462b5 	add	x21, x21, #0x118
	status_t ret = NO_ERROR;
ffffffffea804ef0:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea804ef4:	aa1503e0 	mov	x0, x21
ffffffffea804ef8:	97fff672 	bl	ffffffffea8028c0 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea804efc:	aa1503e0 	mov	x0, x21
ffffffffea804f00:	97fff678 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea804f04:	d50341ff 	msr	daifclr, #0x1
ffffffffea804f08:	17ffffd2 	b	ffffffffea804e50 <arm_gic_sim_irq_handler+0xa0>
    arch_spin_lock(lock);
ffffffffea804f0c:	910462b5 	add	x21, x21, #0x118
ffffffffea804f10:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea804f14:	aa1503e0 	mov	x0, x21
ffffffffea804f18:	97fff66a 	bl	ffffffffea8028c0 <arch_spin_lock>
    arch_spin_unlock(lock);
ffffffffea804f1c:	aa1503e0 	mov	x0, x21
ffffffffea804f20:	97fff670 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea804f24:	17ffffcb 	b	ffffffffea804e50 <arm_gic_sim_irq_handler+0xa0>
		ret = ERR_NOT_FOUND;
ffffffffea804f28:	12800033 	mov	w19, #0xfffffffe            	// #-2
		TRACEF("interrupt handler not found. irq: %u\n", irq);
ffffffffea804f2c:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804f30:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804f34:	2a1403e3 	mov	w3, w20
ffffffffea804f38:	52805242 	mov	w2, #0x292                 	// #658
ffffffffea804f3c:	91398021 	add	x1, x1, #0xe60
ffffffffea804f40:	913ae000 	add	x0, x0, #0xeb8
ffffffffea804f44:	94003b45 	bl	ffffffffea813c58 <_printf>
ffffffffea804f48:	17ffffbe 	b	ffffffffea804e40 <arm_gic_sim_irq_handler+0x90>
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea804f4c:	d0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804f50:	d0000080 	adrp	x0, ffffffffea816000 <__fault_handler_table_start>
ffffffffea804f54:	52806404 	mov	w4, #0x320                 	// #800
ffffffffea804f58:	2a1403e3 	mov	w3, w20
ffffffffea804f5c:	52805062 	mov	w2, #0x283                 	// #643
ffffffffea804f60:	91398021 	add	x1, x1, #0xe60
		return ERR_INVALID_ARGS;
ffffffffea804f64:	128000f3 	mov	w19, #0xfffffff8            	// #-8
		TRACEF("Interrupt out of range: vector = %u, MAX_INT = %u\n",
ffffffffea804f68:	9139e000 	add	x0, x0, #0xe78
ffffffffea804f6c:	94003b3b 	bl	ffffffffea813c58 <_printf>
		return ERR_INVALID_ARGS;
ffffffffea804f70:	17ffffbc 	b	ffffffffea804e60 <arm_gic_sim_irq_handler+0xb0>
ffffffffea804f74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804f78 <cntpct_to_lk_time>:
}

static inline uint64_t
mul_u32_u32(uint32_t a, uint32_t b, int a_shift, int b_shift)
{
    uint64_t ret = (uint64_t)a * b;
ffffffffea804f78:	d00002e2 	adrp	x2, ffffffffea862000 <__ctor_list>
ffffffffea804f7c:	92407c01 	and	x1, x0, #0xffffffff
}

static inline uint32_t
u32_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea804f80:	d360fc00 	lsr	x0, x0, #32
    uint64_t ret = (uint64_t)a * b;
ffffffffea804f84:	f9403c42 	ldr	x2, [x2, #120]
ffffffffea804f88:	b9400844 	ldr	w4, [x2, #8]
ffffffffea804f8c:	b9400043 	ldr	w3, [x2]
ffffffffea804f90:	b9400442 	ldr	w2, [x2, #4]
ffffffffea804f94:	9b047c05 	mul	x5, x0, x4
ffffffffea804f98:	9b017c63 	mul	x3, x3, x1
    uint64_t res_l32;
    uint32_t ret;

    /* mul_u32_u32(a_r32, b.l0, 32, 0) does not affect result */
    res_l32 = mul_u32_u32(a_0, b.l0, 0, 0) << 32;
    res_l32 += mul_u32_u32(a_r32, b.l32, 32, -32) << 32;
ffffffffea804f9c:	9b020c00 	madd	x0, x0, x2, x3
ffffffffea804fa0:	9b021422 	madd	x2, x1, x2, x5
    uint64_t ret = (uint64_t)a * b;
ffffffffea804fa4:	9b047c21 	mul	x1, x1, x4
ffffffffea804fa8:	8b008040 	add	x0, x2, x0, lsl #32
    res_l32 += mul_u32_u32(a_0, b.l32, 0, -32);
    res_l32 += mul_u32_u32(a_r32, b.l64, 32, -64);
    res_l32 += mul_u32_u32(a_0, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea804fac:	8b418000 	add	x0, x0, x1, lsr #32
    ret = (res_l32 >> 32) + ((uint32_t)res_l32 >> 31); /* Round to nearest integer */
ffffffffea804fb0:	d360fc01 	lsr	x1, x0, #32
}

static lk_time_t cntpct_to_lk_time(uint64_t cntpct)
{
	return u32_mul_u64_fp32_64(cntpct, ms_per_cntpct);
}
ffffffffea804fb4:	0b407c20 	add	w0, w1, w0, lsr #31
ffffffffea804fb8:	d65f03c0 	ret
ffffffffea804fbc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea804fc0 <platform_tick>:
}

static void write_cntp_ctl(uint32_t cntp_ctl)
{
	LTRACEF_LEVEL(3, "cntp_ctl: 0x%x %x\n", cntp_ctl, read_cntp_ctl());
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea804fc0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea804fc4:	d51fe221 	msr	cntps_ctl_el1, x1
ffffffffea804fc8:	d5033fdf 	isb
}

static enum handler_return platform_tick(void *arg)
{
	write_cntp_ctl(0);
	if (t_callback) {
ffffffffea804fcc:	b0000361 	adrp	x1, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea804fd0:	f9409027 	ldr	x7, [x1, #288]
ffffffffea804fd4:	b4000147 	cbz	x7, ffffffffea804ffc <platform_tick+0x3c>
{
ffffffffea804fd8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea804fdc:	aa0003e6 	mov	x6, x0
ffffffffea804fe0:	910003fd 	mov	x29, sp
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea804fe4:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_bigtime(read_cntpct());
}

lk_time_t current_time(void)
{
	return cntpct_to_lk_time(read_cntpct());
ffffffffea804fe8:	97ffffe4 	bl	ffffffffea804f78 <cntpct_to_lk_time>
		return t_callback(arg, current_time());
ffffffffea804fec:	2a0003e1 	mov	w1, w0
}
ffffffffea804ff0:	a8c17bfd 	ldp	x29, x30, [sp], #16
		return t_callback(arg, current_time());
ffffffffea804ff4:	aa0603e0 	mov	x0, x6
ffffffffea804ff8:	d61f00e0 	br	x7
}
ffffffffea804ffc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805000:	d65f03c0 	ret
ffffffffea805004:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805008 <arm_generic_timer_resume_cpu>:
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea805008:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80500c:	d51fe200 	msr	cntps_tval_el1, x0
ffffffffea805010:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805014:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805018:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea80501c:	d5033fdf 	isb
static void arm_generic_timer_resume_cpu(uint level)
{
	/* Always trigger a timer interrupt on each cpu for now */
	write_cntp_tval(0);
	write_cntp_ctl(1);
}
ffffffffea805020:	d65f03c0 	ret
ffffffffea805024:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805028 <arm_generic_timer_init_secondary_cpu>:
{
ffffffffea805028:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea80502c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea805030:	f0ffffe1 	adrp	x1, ffffffffea804000 <lk_main+0x168>
ffffffffea805034:	913f0021 	add	x1, x1, #0xfc0
{
ffffffffea805038:	910003fd 	mov	x29, sp
ffffffffea80503c:	f9000bf3 	str	x19, [sp, #16]
	register_int_handler(timer_irq, &platform_tick, NULL);
ffffffffea805040:	90000373 	adrp	x19, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805044:	b9412a60 	ldr	w0, [x19, #296]
ffffffffea805048:	97fffd14 	bl	ffffffffea804498 <register_int_handler>
	unmask_interrupt(timer_irq);
ffffffffea80504c:	b9412a60 	ldr	w0, [x19, #296]
}
ffffffffea805050:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea805054:	a8c27bfd 	ldp	x29, x30, [sp], #32
	unmask_interrupt(timer_irq);
ffffffffea805058:	17fffddc 	b	ffffffffea8047c8 <unmask_interrupt>
ffffffffea80505c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805060 <test_cntpct_to_lk_time>:
{
ffffffffea805060:	2a0003e5 	mov	w5, w0
ffffffffea805064:	2a0103e8 	mov	w8, w1
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805068:	d29ef9e1 	mov	x1, #0xf7cf                	// #63439
{
ffffffffea80506c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805070:	f2bc6a61 	movk	x1, #0xe353, lsl #16
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea805074:	b2407fe3 	mov	x3, #0xffffffff            	// #4294967295
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea805078:	9ba87ca0 	umull	x0, w5, w8
ffffffffea80507c:	f2d374a1 	movk	x1, #0x9ba5, lsl #32
ffffffffea805080:	f2e41881 	movk	x1, #0x20c4, lsl #48
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea805084:	9ba27ca4 	umull	x4, w5, w2
{
ffffffffea805088:	910003fd 	mov	x29, sp
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea80508c:	d343fc00 	lsr	x0, x0, #3
{
ffffffffea805090:	aa0503e6 	mov	x6, x5
ffffffffea805094:	aa0803e7 	mov	x7, x8
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea805098:	eb03009f 	cmp	x4, x3
	cntpct = (uint64_t)cntfrq * expected_lk_time / 1000;
ffffffffea80509c:	9bc17c00 	umulh	x0, x0, x1
ffffffffea8050a0:	d344fc00 	lsr	x0, x0, #4
	if ((uint64_t)cntfrq * wrap_count > UINT_MAX)
ffffffffea8050a4:	54000229 	b.ls	ffffffffea8050e8 <test_cntpct_to_lk_time+0x88>  // b.plast
		cntpct += (((uint64_t)cntfrq << 32) / 1000) * wrap_count;
ffffffffea8050a8:	d36388a4 	lsl	x4, x5, #29
ffffffffea8050ac:	2a0203e2 	mov	w2, w2
ffffffffea8050b0:	9bc17c84 	umulh	x4, x4, x1
ffffffffea8050b4:	d344fc84 	lsr	x4, x4, #4
ffffffffea8050b8:	9b020080 	madd	x0, x4, x2, x0
	lk_time = cntpct_to_lk_time(cntpct);
ffffffffea8050bc:	97ffffaf 	bl	ffffffffea804f78 <cntpct_to_lk_time>
	if (a != b) {
ffffffffea8050c0:	eb20411f 	cmp	x8, w0, uxtw
ffffffffea8050c4:	540000e0 	b.eq	ffffffffea8050e0 <test_cntpct_to_lk_time+0x80>  // b.none
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea8050c8:	110f9cc1 	add	w1, w6, #0x3e7
	return (a > 0) ? a : -a;
ffffffffea8050cc:	6b070000 	subs	w0, w0, w7
ffffffffea8050d0:	5a805400 	cneg	w0, w0, mi  // mi = first
	test_time_conversion_check_result(lk_time, expected_lk_time, (1000 + cntfrq - 1) / cntfrq, true);
ffffffffea8050d4:	1ac60826 	udiv	w6, w1, w6
		if (diff <= limit)
ffffffffea8050d8:	6b0000df 	cmp	w6, w0
ffffffffea8050dc:	540000e3 	b.cc	ffffffffea8050f8 <test_cntpct_to_lk_time+0x98>  // b.lo, b.ul, b.last
}
ffffffffea8050e0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8050e4:	d65f03c0 	ret
		cntpct += (((uint64_t)(cntfrq * wrap_count) << 32) / 1000);
ffffffffea8050e8:	d3637c84 	ubfiz	x4, x4, #29, #32
ffffffffea8050ec:	9bc17c84 	umulh	x4, x4, x1
ffffffffea8050f0:	8b441000 	add	x0, x0, x4, lsr #4
ffffffffea8050f4:	17fffff2 	b	ffffffffea8050bc <test_cntpct_to_lk_time+0x5c>
}
ffffffffea8050f8:	a8c17bfd 	ldp	x29, x30, [sp], #16
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea8050fc:	d0000084 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea805100:	93407c03 	sxtw	x3, w0
ffffffffea805104:	d0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea805108:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea80510c:	91000021 	add	x1, x1, #0x0
ffffffffea805110:	91042080 	add	x0, x4, #0x108
ffffffffea805114:	14003ad1 	b	ffffffffea813c58 <_printf>

ffffffffea805118 <test_cntpct_to_lk_bigtime>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea805118:	b00002e5 	adrp	x5, ffffffffea862000 <__ctor_list>
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea80511c:	2a0003e2 	mov	w2, w0
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea805120:	d2884803 	mov	x3, #0x4240                	// #16960
ffffffffea805124:	f9401ca5 	ldr	x5, [x5, #56]
ffffffffea805128:	f2a001e3 	movk	x3, #0xf, lsl #16
	uint64_t cntpct = (uint64_t)cntfrq * expected_s;
ffffffffea80512c:	9b017c42 	mul	x2, x2, x1
	lk_bigtime_t expected_lk_bigtime = expected_s * 1000 * 1000;
ffffffffea805130:	9b037c26 	mul	x6, x1, x3
ffffffffea805134:	92407c48 	and	x8, x2, #0xffffffff
ffffffffea805138:	294090a9 	ldp	w9, w4, [x5, #4]
}

static inline uint64_t
u64_mul_u64_fp32_64(uint64_t a, struct fp_32_64 b)
{
    uint32_t a_r32 = a >> 32;
ffffffffea80513c:	d360fc42 	lsr	x2, x2, #32
    uint64_t ret = (uint64_t)a * b;
ffffffffea805140:	b94000a5 	ldr	w5, [x5]
ffffffffea805144:	9b097d07 	mul	x7, x8, x9
ffffffffea805148:	9b047d01 	mul	x1, x8, x4
ffffffffea80514c:	9b047c44 	mul	x4, x2, x4
ffffffffea805150:	9b057c43 	mul	x3, x2, x5
    tmp = mul_u32_u32(a_0, b.l32, 0, -32);
    res_0 += tmp >> 32;
    res_l32 = (uint32_t)tmp;
    tmp = mul_u32_u32(a_r32, b.l64, 32, -64);
    res_0 += tmp >> 32;
    res_l32 += (uint32_t)tmp;
ffffffffea805154:	92407c8a 	and	x10, x4, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea805158:	9b097c42 	mul	x2, x2, x9
    res_0 += tmp >> 32;
ffffffffea80515c:	d360fce9 	lsr	x9, x7, #32
    res_l32 += (uint32_t)tmp;
ffffffffea805160:	8b274147 	add	x7, x10, w7, uxtw
    tmp = mul_u32_u32(a_0, b.l64, 0, -64); /* Improve rounding accuracy */
    res_l32 += tmp >> 32;
    res_0 += res_l32 >> 32;
    res_l32_32 = res_l32;
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805164:	9b0808a2 	madd	x2, x5, x8, x2
    res_l32 += tmp >> 32;
ffffffffea805168:	8b4180e1 	add	x1, x7, x1, lsr #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80516c:	8b038123 	add	x3, x9, x3, lsl #32
ffffffffea805170:	8b020063 	add	x3, x3, x2
    res_0 += res_l32 >> 32;
ffffffffea805174:	d360fc22 	lsr	x2, x1, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805178:	8b448044 	add	x4, x2, x4, lsr #32
ffffffffea80517c:	531f7c21 	lsr	w1, w1, #31
ffffffffea805180:	8b040063 	add	x3, x3, x4
ffffffffea805184:	8b030023 	add	x3, x1, x3
	if (a != b) {
ffffffffea805188:	eb0300df 	cmp	x6, x3
ffffffffea80518c:	54000100 	b.eq	ffffffffea8051ac <test_cntpct_to_lk_bigtime+0x94>  // b.none
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea805190:	1143d001 	add	w1, w0, #0xf4, lsl #12
	return (a > 0) ? a : -a;
ffffffffea805194:	eb060063 	subs	x3, x3, x6
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea805198:	1108fc21 	add	w1, w1, #0x23f
	return (a > 0) ? a : -a;
ffffffffea80519c:	da835463 	cneg	x3, x3, mi  // mi = first
	test_time_conversion_check_result(lk_bigtime, expected_lk_bigtime, (1000 * 1000 + cntfrq - 1) / cntfrq, false);
ffffffffea8051a0:	1ac00820 	udiv	w0, w1, w0
		if (diff <= limit)
ffffffffea8051a4:	eb03001f 	cmp	x0, x3
ffffffffea8051a8:	54000043 	b.cc	ffffffffea8051b0 <test_cntpct_to_lk_bigtime+0x98>  // b.lo, b.ul, b.last
}
ffffffffea8051ac:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea8051b0:	d0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8051b4:	d0000080 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8051b8:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea8051bc:	91000021 	add	x1, x1, #0x0
ffffffffea8051c0:	91042000 	add	x0, x0, #0x108
ffffffffea8051c4:	14003aa5 	b	ffffffffea813c58 <_printf>

ffffffffea8051c8 <test_lk_time_to_cntpct>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea8051c8:	b00002e5 	adrp	x5, ffffffffea862000 <__ctor_list>
	uint64_t expected_cntpct = ((uint64_t)cntfrq * lk_time + 500) / 1000;
ffffffffea8051cc:	d2803e82 	mov	x2, #0x1f4                 	// #500
ffffffffea8051d0:	d29ef9e6 	mov	x6, #0xf7cf                	// #63439
ffffffffea8051d4:	f94048a5 	ldr	x5, [x5, #144]
ffffffffea8051d8:	9ba10803 	umaddl	x3, w0, w1, x2
ffffffffea8051dc:	f2bc6a66 	movk	x6, #0xe353, lsl #16
ffffffffea8051e0:	f2d374a6 	movk	x6, #0x9ba5, lsl #32
ffffffffea8051e4:	d343fc63 	lsr	x3, x3, #3
ffffffffea8051e8:	f2e41886 	movk	x6, #0x20c4, lsl #48
ffffffffea8051ec:	294080a4 	ldp	w4, w0, [x5, #4]
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea8051f0:	b94000a5 	ldr	w5, [x5]
ffffffffea8051f4:	9bc67c63 	umulh	x3, x3, x6
    uint64_t ret = (uint64_t)a * b;
ffffffffea8051f8:	9ba47c24 	umull	x4, w1, w4
ffffffffea8051fc:	9ba07c20 	umull	x0, w1, w0
ffffffffea805200:	d344fc63 	lsr	x3, x3, #4
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805204:	92407c82 	and	x2, x4, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea805208:	d360fc84 	lsr	x4, x4, #32
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea80520c:	8b408040 	add	x0, x2, x0, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805210:	9ba51021 	umaddl	x1, w1, w5, x4
ffffffffea805214:	531f7c02 	lsr	w2, w0, #31
ffffffffea805218:	8b408040 	add	x0, x2, x0, lsr #32
ffffffffea80521c:	8b000021 	add	x1, x1, x0
	if (a != b) {
ffffffffea805220:	eb01007f 	cmp	x3, x1
ffffffffea805224:	540000a0 	b.eq	ffffffffea805238 <test_lk_time_to_cntpct+0x70>  // b.none
	return (a > 0) ? a : -a;
ffffffffea805228:	eb030021 	subs	x1, x1, x3
ffffffffea80522c:	da815423 	cneg	x3, x1, mi  // mi = first
		if (diff <= limit)
ffffffffea805230:	f100047f 	cmp	x3, #0x1
ffffffffea805234:	54000041 	b.ne	ffffffffea80523c <test_lk_time_to_cntpct+0x74>  // b.any
}
ffffffffea805238:	d65f03c0 	ret
			TRACEF("FAIL, off by %llu\n", diff);
ffffffffea80523c:	d0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea805240:	d0000080 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea805244:	52801f42 	mov	w2, #0xfa                  	// #250
ffffffffea805248:	91000021 	add	x1, x1, #0x0
ffffffffea80524c:	91042000 	add	x0, x0, #0x108
ffffffffea805250:	14003a82 	b	ffffffffea813c58 <_printf>
ffffffffea805254:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805258 <platform_set_oneshot_timer>:
    uint64_t ret = (uint64_t)a * b;
ffffffffea805258:	b00002e5 	adrp	x5, ffffffffea862000 <__ctor_list>
ffffffffea80525c:	f94048a5 	ldr	x5, [x5, #144]
ffffffffea805260:	294010a6 	ldp	w6, w4, [x5]
ffffffffea805264:	b94008a3 	ldr	w3, [x5, #8]
ffffffffea805268:	9ba47c44 	umull	x4, w2, w4
ffffffffea80526c:	9ba37c43 	umull	x3, w2, w3
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805270:	92407c85 	and	x5, x4, #0xffffffff
    res_0 += tmp >> 32;
ffffffffea805274:	d360fc84 	lsr	x4, x4, #32
    res_l32 += mul_u32_u32(a, b.l64, 0, -64) >> 32; /* Improve rounding accuracy */
ffffffffea805278:	8b4380a3 	add	x3, x5, x3, lsr #32
    ret = res_0 + (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80527c:	9ba61042 	umaddl	x2, w2, w6, x4
ffffffffea805280:	531f7c65 	lsr	w5, w3, #31
ffffffffea805284:	8b4380a3 	add	x3, x5, x3, lsr #32
ffffffffea805288:	8b030042 	add	x2, x2, x3
	ASSERT(arg == NULL);
ffffffffea80528c:	b50002c1 	cbnz	x1, ffffffffea8052e4 <platform_set_oneshot_timer+0x8c>
	t_callback = callback;
ffffffffea805290:	90000361 	adrp	x1, ffffffffea871000 <int_handler_table_shared+0x2ee0>
	if (cntpct_interval <= INT_MAX)
ffffffffea805294:	b2407be3 	mov	x3, #0x7fffffff            	// #2147483647
ffffffffea805298:	eb03005f 	cmp	x2, x3
	t_callback = callback;
ffffffffea80529c:	f9009020 	str	x0, [x1, #288]
	if (cntpct_interval <= INT_MAX)
ffffffffea8052a0:	54000149 	b.ls	ffffffffea8052c8 <platform_set_oneshot_timer+0x70>  // b.plast
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea8052a4:	d53be020 	mrs	x0, cntpct_el0
		write_cntp_cval(read_cntpct() + cntpct_interval);
ffffffffea8052a8:	8b000042 	add	x2, x2, x0
	WRITE_TIMER_REG64(TIMER_REG_CVAL, cntp_cval);
ffffffffea8052ac:	d51fe242 	msr	cntps_cval_el1, x2
ffffffffea8052b0:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea8052b4:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8052b8:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea8052bc:	d5033fdf 	isb
}
ffffffffea8052c0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8052c4:	d65f03c0 	ret
	WRITE_TIMER_REG32(TIMER_REG_TVAL, cntp_tval);
ffffffffea8052c8:	d51fe202 	msr	cntps_tval_el1, x2
ffffffffea8052cc:	d5033fdf 	isb
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea8052d0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8052d4:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea8052d8:	d5033fdf 	isb
}
ffffffffea8052dc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8052e0:	d65f03c0 	ret
{
ffffffffea8052e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(arg == NULL);
ffffffffea8052e8:	d0000084 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8052ec:	d0000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8052f0:	b0000081 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
{
ffffffffea8052f4:	910003fd 	mov	x29, sp
ffffffffea8052f8:	aa1e03e0 	mov	x0, x30
	ASSERT(arg == NULL);
ffffffffea8052fc:	9101e084 	add	x4, x4, #0x78
ffffffffea805300:	528019c3 	mov	w3, #0xce                  	// #206
ffffffffea805304:	91022042 	add	x2, x2, #0x88
ffffffffea805308:	91314021 	add	x1, x1, #0xc50
ffffffffea80530c:	9400349d 	bl	ffffffffea812580 <_panic>

ffffffffea805310 <platform_stop_timer>:
	WRITE_TIMER_REG32(TIMER_REG_CTL, cntp_ctl);
ffffffffea805310:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805314:	d51fe220 	msr	cntps_ctl_el1, x0
ffffffffea805318:	d5033fdf 	isb
}
ffffffffea80531c:	d65f03c0 	ret

ffffffffea805320 <current_time_hires>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805320:	d53be023 	mrs	x3, cntpct_el0
    uint64_t ret = (uint64_t)a * b;
ffffffffea805324:	b00002e2 	adrp	x2, ffffffffea862000 <__ctor_list>
    uint32_t a_r32 = a >> 32;
ffffffffea805328:	d360fc64 	lsr	x4, x3, #32
ffffffffea80532c:	92407c63 	and	x3, x3, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea805330:	f9401c42 	ldr	x2, [x2, #56]
ffffffffea805334:	29402046 	ldp	w6, w8, [x2]
ffffffffea805338:	b9400840 	ldr	w0, [x2, #8]
ffffffffea80533c:	9b087c61 	mul	x1, x3, x8
ffffffffea805340:	9b067c82 	mul	x2, x4, x6
ffffffffea805344:	9b007c85 	mul	x5, x4, x0
ffffffffea805348:	9b007c60 	mul	x0, x3, x0
    res_l32 += (uint32_t)tmp;
ffffffffea80534c:	92407ca7 	and	x7, x5, #0xffffffff
    uint64_t ret = (uint64_t)a * b;
ffffffffea805350:	9b087c84 	mul	x4, x4, x8
    res_l32 += (uint32_t)tmp;
ffffffffea805354:	8b2140e7 	add	x7, x7, w1, uxtw
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805358:	9b0310c4 	madd	x4, x6, x3, x4
    res_l32 += tmp >> 32;
ffffffffea80535c:	8b4080e0 	add	x0, x7, x0, lsr #32
    res_0 += tmp >> 32;
ffffffffea805360:	d360fc21 	lsr	x1, x1, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea805364:	8b028021 	add	x1, x1, x2, lsl #32
    res_0 += res_l32 >> 32;
ffffffffea805368:	d360fc02 	lsr	x2, x0, #32
    ret = res_0 +  (res_l32_32 >> 31); /* Round to nearest integer */
ffffffffea80536c:	8b040021 	add	x1, x1, x4
ffffffffea805370:	8b458045 	add	x5, x2, x5, lsr #32
ffffffffea805374:	531f7c00 	lsr	w0, w0, #31
ffffffffea805378:	8b050021 	add	x1, x1, x5
}
ffffffffea80537c:	8b010000 	add	x0, x0, x1
ffffffffea805380:	d65f03c0 	ret
ffffffffea805384:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805388 <current_time>:
	cntpct = READ_TIMER_REG64(TIMER_REG_CT);
ffffffffea805388:	d53be020 	mrs	x0, cntpct_el0
	return cntpct_to_lk_time(read_cntpct());
ffffffffea80538c:	17fffefb 	b	ffffffffea804f78 <cntpct_to_lk_time>

ffffffffea805390 <arm_generic_timer_init>:
{
ffffffffea805390:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea805394:	910003fd 	mov	x29, sp
ffffffffea805398:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80539c:	2a0003f4 	mov	w20, w0
	if (freq_override == 0) {
ffffffffea8053a0:	35001001 	cbnz	w1, ffffffffea8055a0 <arm_generic_timer_init+0x210>
	cntfrq = READ_TIMER_REG32(TIMER_REG_CNTFRQ);
ffffffffea8053a4:	d53be000 	mrs	x0, cntfrq_el0
ffffffffea8053a8:	2a0003f3 	mov	w19, w0
		if (!cntfrq) {
ffffffffea8053ac:	34000fe0 	cbz	w0, ffffffffea8055a8 <arm_generic_timer_init+0x218>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8053b0:	2a1303e5 	mov	w5, w19
ffffffffea8053b4:	d29ef9ed 	mov	x13, #0xf7cf                	// #63439
ffffffffea8053b8:	f2bc6a6d 	movk	x13, #0xe353, lsl #16
ffffffffea8053bc:	d2c84800 	mov	x0, #0x424000000000        	// #72842645340160
ffffffffea8053c0:	d3607cae 	lsl	x14, x5, #32
ffffffffea8053c4:	f2d374ad 	movk	x13, #0x9ba5, lsl #32
ffffffffea8053c8:	f2e4188d 	movk	x13, #0x20c4, lsl #48
ffffffffea8053cc:	f2e001e0 	movk	x0, #0xf, lsl #48
ffffffffea8053d0:	d343fdc6 	lsr	x6, x14, #3
ffffffffea8053d4:	d2c07d04 	mov	x4, #0x3e800000000         	// #4294967296000
ffffffffea8053d8:	9ac5080b 	udiv	x11, x0, x5
    result->l0 = tmp >> 32;
ffffffffea8053dc:	b00002e7 	adrp	x7, ffffffffea862000 <__ctor_list>
ffffffffea8053e0:	b00002e9 	adrp	x9, ffffffffea862000 <__ctor_list>
ffffffffea8053e4:	b00002e8 	adrp	x8, ffffffffea862000 <__ctor_list>
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8053e8:	9bcd7cc6 	umulh	x6, x6, x13
    result->l0 = tmp >> 32;
ffffffffea8053ec:	f94048e7 	ldr	x7, [x7, #144]
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea8053f0:	9ac5088c 	udiv	x12, x4, x5
    result->l0 = tmp >> 32;
ffffffffea8053f4:	f9403d29 	ldr	x9, [x9, #120]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea8053f8:	9b058163 	msub	x3, x11, x5, x0
    result->l0 = tmp >> 32;
ffffffffea8053fc:	f9401d08 	ldr	x8, [x8, #56]
    tmp = ((uint64_t)dividend << 32) / divisor;
ffffffffea805400:	d344fcca 	lsr	x10, x6, #4
    result->l0 = tmp >> 32;
ffffffffea805404:	d360fd6f 	lsr	x15, x11, #32
ffffffffea805408:	d364fcc6 	lsr	x6, x6, #36
	test_lk_time_to_cntpct(cntfrq, 0);
ffffffffea80540c:	2a1303e0 	mov	w0, w19
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805410:	d37be942 	lsl	x2, x10, #5
ffffffffea805414:	9b059184 	msub	x4, x12, x5, x4
ffffffffea805418:	cb0a0042 	sub	x2, x2, x10
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea80541c:	d3607c63 	lsl	x3, x3, #32
    result->l0 = tmp >> 32;
ffffffffea805420:	d360fd90 	lsr	x16, x12, #32
    result->l32 = tmp;
ffffffffea805424:	290028e6 	stp	w6, w10, [x7]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805428:	8b020942 	add	x2, x10, x2, lsl #2
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea80542c:	d3607c84 	lsl	x4, x4, #32
ffffffffea805430:	9ac50863 	udiv	x3, x3, x5
    result->l32 = tmp;
ffffffffea805434:	29002d0f 	stp	w15, w11, [x8]
    rem = ((uint64_t)dividend << 32) % divisor;
ffffffffea805438:	cb020dc2 	sub	x2, x14, x2, lsl #3
    result->l32 = tmp;
ffffffffea80543c:	29003130 	stp	w16, w12, [x9]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805440:	9ac50884 	udiv	x4, x4, x5
ffffffffea805444:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805448:	d3607c42 	lsl	x2, x2, #32
    result->l64 = tmp;
ffffffffea80544c:	b9000903 	str	w3, [x8, #8]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805450:	d343fc42 	lsr	x2, x2, #3
    result->l64 = tmp;
ffffffffea805454:	b9000924 	str	w4, [x9, #8]
    tmp = ((uint64_t)rem << 32) / divisor;
ffffffffea805458:	9bcd7c42 	umulh	x2, x2, x13
ffffffffea80545c:	d344fc42 	lsr	x2, x2, #4
    result->l64 = tmp;
ffffffffea805460:	b90008e2 	str	w2, [x7, #8]
ffffffffea805464:	97ffff59 	bl	ffffffffea8051c8 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, 1);
ffffffffea805468:	2a1303e0 	mov	w0, w19
ffffffffea80546c:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805470:	97ffff56 	bl	ffffffffea8051c8 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX);
ffffffffea805474:	2a1303e0 	mov	w0, w19
ffffffffea805478:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea80547c:	97ffff53 	bl	ffffffffea8051c8 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, INT_MAX + 1U);
ffffffffea805480:	2a1303e0 	mov	w0, w19
ffffffffea805484:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea805488:	97ffff50 	bl	ffffffffea8051c8 <test_lk_time_to_cntpct>
	test_lk_time_to_cntpct(cntfrq, ~0);
ffffffffea80548c:	2a1303e0 	mov	w0, w19
ffffffffea805490:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea805494:	97ffff4d 	bl	ffffffffea8051c8 <test_lk_time_to_cntpct>
	test_cntpct_to_lk_time(cntfrq, 0, 0);
ffffffffea805498:	2a1303e0 	mov	w0, w19
ffffffffea80549c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8054a0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8054a4:	97fffeef 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX, 0);
ffffffffea8054a8:	2a1303e0 	mov	w0, w19
ffffffffea8054ac:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8054b0:	12b00001 	mov	w1, #0x7fffffff            	// #2147483647
ffffffffea8054b4:	97fffeeb 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, INT_MAX + 1U, 0);
ffffffffea8054b8:	2a1303e0 	mov	w0, w19
ffffffffea8054bc:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8054c0:	52b00001 	mov	w1, #0x80000000            	// #-2147483648
ffffffffea8054c4:	97fffee7 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, ~0, 0);
ffffffffea8054c8:	2a1303e0 	mov	w0, w19
ffffffffea8054cc:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8054d0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8054d4:	97fffee3 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 1);
ffffffffea8054d8:	2a1303e0 	mov	w0, w19
ffffffffea8054dc:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea8054e0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8054e4:	97fffedf 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 7);
ffffffffea8054e8:	2a1303e0 	mov	w0, w19
ffffffffea8054ec:	528000e2 	mov	w2, #0x7                   	// #7
ffffffffea8054f0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8054f4:	97fffedb 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 70);
ffffffffea8054f8:	2a1303e0 	mov	w0, w19
ffffffffea8054fc:	528008c2 	mov	w2, #0x46                  	// #70
ffffffffea805500:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805504:	97fffed7 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_time(cntfrq, 0, 700);
ffffffffea805508:	52805782 	mov	w2, #0x2bc                 	// #700
ffffffffea80550c:	2a1303e0 	mov	w0, w19
ffffffffea805510:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805514:	97fffed3 	bl	ffffffffea805060 <test_cntpct_to_lk_time>
	test_cntpct_to_lk_bigtime(cntfrq, 0);
ffffffffea805518:	2a1303e0 	mov	w0, w19
ffffffffea80551c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea805520:	97fffefe 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 1);
ffffffffea805524:	2a1303e0 	mov	w0, w19
ffffffffea805528:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea80552c:	97fffefb 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24);
ffffffffea805530:	d28a3001 	mov	x1, #0x5180                	// #20864
ffffffffea805534:	2a1303e0 	mov	w0, w19
ffffffffea805538:	f2a00021 	movk	x1, #0x1, lsl #16
ffffffffea80553c:	97fffef7 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * 365);
ffffffffea805540:	d2867001 	mov	x1, #0x3380                	// #13184
ffffffffea805544:	2a1303e0 	mov	w0, w19
ffffffffea805548:	f2a03c21 	movk	x1, #0x1e1, lsl #16
ffffffffea80554c:	97fffef3 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60 * 60 * 24 * (365 * 10 + 2));
ffffffffea805550:	d294c001 	mov	x1, #0xa600                	// #42496
ffffffffea805554:	2a1303e0 	mov	w0, w19
ffffffffea805558:	f2a259c1 	movk	x1, #0x12ce, lsl #16
ffffffffea80555c:	97fffeef 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	test_cntpct_to_lk_bigtime(cntfrq, 60ULL * 60 * 24 * (365 * 100 + 2));
ffffffffea805560:	d2982001 	mov	x1, #0xc100                	// #49408
ffffffffea805564:	2a1303e0 	mov	w0, w19
ffffffffea805568:	f2b77f41 	movk	x1, #0xbbfa, lsl #16
ffffffffea80556c:	97fffeeb 	bl	ffffffffea805118 <test_cntpct_to_lk_bigtime>
	register_int_handler(irq, &platform_tick, NULL);
ffffffffea805570:	f0ffffe1 	adrp	x1, ffffffffea804000 <lk_main+0x168>
ffffffffea805574:	913f0021 	add	x1, x1, #0xfc0
ffffffffea805578:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80557c:	2a1403e0 	mov	w0, w20
ffffffffea805580:	97fffbc6 	bl	ffffffffea804498 <register_int_handler>
	unmask_interrupt(irq);
ffffffffea805584:	2a1403e0 	mov	w0, w20
ffffffffea805588:	97fffc90 	bl	ffffffffea8047c8 <unmask_interrupt>
	timer_irq = irq;
ffffffffea80558c:	90000360 	adrp	x0, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805590:	b9012814 	str	w20, [x0, #296]
}
ffffffffea805594:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805598:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80559c:	d65f03c0 	ret
ffffffffea8055a0:	2a0103f3 	mov	w19, w1
ffffffffea8055a4:	17ffff83 	b	ffffffffea8053b0 <arm_generic_timer_init+0x20>
ffffffffea8055a8:	a94153f3 	ldp	x19, x20, [sp, #16]
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea8055ac:	d0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
}
ffffffffea8055b0:	a8c27bfd 	ldp	x29, x30, [sp], #32
			TRACEF("Failed to initialize timer, frequency is 0\n");
ffffffffea8055b4:	d0000080 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8055b8:	52802942 	mov	w2, #0x14a                 	// #330
ffffffffea8055bc:	9100a021 	add	x1, x1, #0x28
ffffffffea8055c0:	91010000 	add	x0, x0, #0x40
ffffffffea8055c4:	140039a5 	b	ffffffffea813c58 <_printf>

ffffffffea8055c8 <event_init>:
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
	*e = (event_t)EVENT_INITIAL_VALUE(*e, initial, flags);
ffffffffea8055c8:	528dce85 	mov	w5, #0x6e74                	// #28276
ffffffffea8055cc:	528d2e84 	mov	w4, #0x6974                	// #26996
ffffffffea8055d0:	72acaec5 	movk	w5, #0x6576, lsl #16
ffffffffea8055d4:	91006003 	add	x3, x0, #0x18
ffffffffea8055d8:	72aeec24 	movk	w4, #0x7761, lsl #16
ffffffffea8055dc:	b9000005 	str	w5, [x0]
ffffffffea8055e0:	39001001 	strb	w1, [x0, #4]
ffffffffea8055e4:	b9000802 	str	w2, [x0, #8]
ffffffffea8055e8:	b9001004 	str	w4, [x0, #16]
ffffffffea8055ec:	a9018c03 	stp	x3, x3, [x0, #24]
ffffffffea8055f0:	b900281f 	str	wzr, [x0, #40]
}
ffffffffea8055f4:	d65f03c0 	ret

ffffffffea8055f8 <event_destroy>:
 * still waiting on the event will be resumed.
 *
 * @param e        Event object to initialize
 */
void event_destroy(event_t *e)
{
ffffffffea8055f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8055fc:	910003fd 	mov	x29, sp
ffffffffea805600:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805604:	aa0003f3 	mov	x19, x0
ffffffffea805608:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80560c:	d53b4220 	mrs	x0, daif
ffffffffea805610:	91004275 	add	x21, x19, #0x10
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805614:	37380260 	tbnz	w0, #7, ffffffffea805660 <event_destroy+0x68>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805618:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80561c:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea805620:	f9406e94 	ldr	x20, [x20, #216]
ffffffffea805624:	aa1403e0 	mov	x0, x20
ffffffffea805628:	97fff4a6 	bl	ffffffffea8028c0 <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	e->magic = 0;
ffffffffea80562c:	b900027f 	str	wzr, [x19]
	e->signalled = false;
	e->flags = 0;
	wait_queue_destroy(&e->wait, true);
ffffffffea805630:	52800021 	mov	w1, #0x1                   	// #1
	e->signalled = false;
ffffffffea805634:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea805638:	aa1503e0 	mov	x0, x21
	e->flags = 0;
ffffffffea80563c:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea805640:	94000668 	bl	ffffffffea806fe0 <wait_queue_destroy>
    arch_spin_unlock(lock);
ffffffffea805644:	aa1403e0 	mov	x0, x20
ffffffffea805648:	97fff4a6 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80564c:	d50342ff 	msr	daifclr, #0x2

	THREAD_UNLOCK(state);
}
ffffffffea805650:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805654:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805658:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80565c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea805660:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea805664:	f9406e94 	ldr	x20, [x20, #216]
ffffffffea805668:	aa1403e0 	mov	x0, x20
ffffffffea80566c:	97fff495 	bl	ffffffffea8028c0 <arch_spin_lock>
	e->magic = 0;
ffffffffea805670:	b900027f 	str	wzr, [x19]
	wait_queue_destroy(&e->wait, true);
ffffffffea805674:	aa1503e0 	mov	x0, x21
	e->signalled = false;
ffffffffea805678:	3900127f 	strb	wzr, [x19, #4]
	wait_queue_destroy(&e->wait, true);
ffffffffea80567c:	52800021 	mov	w1, #0x1                   	// #1
	e->flags = 0;
ffffffffea805680:	b9000a7f 	str	wzr, [x19, #8]
	wait_queue_destroy(&e->wait, true);
ffffffffea805684:	94000657 	bl	ffffffffea806fe0 <wait_queue_destroy>
}
ffffffffea805688:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea80568c:	aa1403e0 	mov	x0, x20
ffffffffea805690:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805694:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805698:	17fff492 	b	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea80569c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8056a0 <event_wait_timeout>:
 *
 * @return  0 on success, ERR_TIMED_OUT on timeout,
 *         other values on other errors.
 */
status_t event_wait_timeout(event_t *e, lk_time_t timeout)
{
ffffffffea8056a0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8056a4:	910003fd 	mov	x29, sp
ffffffffea8056a8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8056ac:	aa0003f3 	mov	x19, x0
ffffffffea8056b0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8056b4:	2a0103f6 	mov	w22, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8056b8:	d53b4220 	mrs	x0, daif
ffffffffea8056bc:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8056c0:	37380060 	tbnz	w0, #7, ffffffffea8056cc <event_wait_timeout+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8056c4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8056c8:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8056cc:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea8056d0:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea8056d4:	97fff47b 	bl	ffffffffea8028c0 <arch_spin_lock>

	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (e->signalled) {
ffffffffea8056d8:	39401260 	ldrb	w0, [x19, #4]
ffffffffea8056dc:	340001e0 	cbz	w0, ffffffffea805718 <event_wait_timeout+0x78>
		/* signalled, we're going to fall through */
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea8056e0:	b9400a60 	ldr	w0, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea8056e4:	52800016 	mov	w22, #0x0                   	// #0
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea8056e8:	37000140 	tbnz	w0, #0, ffffffffea805710 <event_wait_timeout+0x70>
    arch_spin_unlock(lock);
ffffffffea8056ec:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea8056f0:	97fff47c 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8056f4:	34000055 	cbz	w21, ffffffffea8056fc <event_wait_timeout+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8056f8:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return ret;
}
ffffffffea8056fc:	2a1603e0 	mov	w0, w22
ffffffffea805700:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805704:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805708:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80570c:	d65f03c0 	ret
			e->signalled = false;
ffffffffea805710:	3900127f 	strb	wzr, [x19, #4]
ffffffffea805714:	17fffff6 	b	ffffffffea8056ec <event_wait_timeout+0x4c>
		ret = wait_queue_block(&e->wait, timeout);
ffffffffea805718:	2a1603e1 	mov	w1, w22
ffffffffea80571c:	91004260 	add	x0, x19, #0x10
ffffffffea805720:	94000462 	bl	ffffffffea8068a8 <wait_queue_block>
ffffffffea805724:	2a0003f6 	mov	w22, w0
ffffffffea805728:	17fffff1 	b	ffffffffea8056ec <event_wait_timeout+0x4c>
ffffffffea80572c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805730 <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
ffffffffea805730:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805734:	910003fd 	mov	x29, sp
ffffffffea805738:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80573c:	aa0003f3 	mov	x19, x0
ffffffffea805740:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea805744:	12001c35 	and	w21, w1, #0xff
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805748:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80574c:	37380340 	tbnz	w0, #7, ffffffffea8057b4 <event_signal+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805750:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805754:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea805758:	f9406e96 	ldr	x22, [x20, #216]
ffffffffea80575c:	aa1603e0 	mov	x0, x22
ffffffffea805760:	97fff458 	bl	ffffffffea8028c0 <arch_spin_lock>
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	THREAD_LOCK(state);

	if (!e->signalled) {
ffffffffea805764:	39401260 	ldrb	w0, [x19, #4]
ffffffffea805768:	350005c0 	cbnz	w0, ffffffffea805820 <event_signal+0xf0>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80576c:	52800036 	mov	w22, #0x1                   	// #1
		if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
ffffffffea805770:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea805774:	91004260 	add	x0, x19, #0x10
ffffffffea805778:	36000381 	tbz	w1, #0, ffffffffea8057e8 <event_signal+0xb8>
			/* try to release one thread and leave unsignalled if successful */
			if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
ffffffffea80577c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea805780:	2a1503e1 	mov	w1, w21
ffffffffea805784:	940004d3 	bl	ffffffffea806ad0 <wait_queue_wake_one>
ffffffffea805788:	7100001f 	cmp	w0, #0x0
ffffffffea80578c:	5400040d 	b.le	ffffffffea80580c <event_signal+0xdc>
    arch_spin_unlock(lock);
ffffffffea805790:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea805794:	97fff453 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805798:	340001f6 	cbz	w22, ffffffffea8057d4 <event_signal+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80579c:	d50342ff 	msr	daifclr, #0x2
	}

	THREAD_UNLOCK(state);

	return NO_ERROR;
}
ffffffffea8057a0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8057a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8057a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8057ac:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8057b0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8057b4:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea8057b8:	f9406e96 	ldr	x22, [x20, #216]
ffffffffea8057bc:	aa1603e0 	mov	x0, x22
ffffffffea8057c0:	97fff440 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!e->signalled) {
ffffffffea8057c4:	39401260 	ldrb	w0, [x19, #4]
ffffffffea8057c8:	34000280 	cbz	w0, ffffffffea805818 <event_signal+0xe8>
    arch_spin_unlock(lock);
ffffffffea8057cc:	aa1603e0 	mov	x0, x22
ffffffffea8057d0:	97fff444 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea8057d4:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8057d8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8057dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8057e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8057e4:	d65f03c0 	ret
			e->signalled = true;
ffffffffea8057e8:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8057ec:	39001261 	strb	w1, [x19, #4]
			wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
ffffffffea8057f0:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8057f4:	2a1503e1 	mov	w1, w21
ffffffffea8057f8:	94000500 	bl	ffffffffea806bf8 <wait_queue_wake_all>
ffffffffea8057fc:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea805800:	97fff438 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea805804:	35fffcd6 	cbnz	w22, ffffffffea80579c <event_signal+0x6c>
ffffffffea805808:	17fffff3 	b	ffffffffea8057d4 <event_signal+0xa4>
				e->signalled = true;
ffffffffea80580c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805810:	39001260 	strb	w0, [x19, #4]
ffffffffea805814:	17ffffdf 	b	ffffffffea805790 <event_signal+0x60>
    spin_lock_saved_state_t state = 0;
ffffffffea805818:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80581c:	17ffffd5 	b	ffffffffea805770 <event_signal+0x40>
ffffffffea805820:	aa1603e0 	mov	x0, x22
ffffffffea805824:	97fff42f 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea805828:	d50342ff 	msr	daifclr, #0x2
ffffffffea80582c:	17ffffdd 	b	ffffffffea8057a0 <event_signal+0x70>

ffffffffea805830 <event_unsignal>:
 */
status_t event_unsignal(event_t *e)
{
	DEBUG_ASSERT(e->magic == EVENT_MAGIC);

	e->signalled = false;
ffffffffea805830:	3900101f 	strb	wzr, [x0, #4]

	return NO_ERROR;
}
ffffffffea805834:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea805838:	d65f03c0 	ret
ffffffffea80583c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805840 <kernel_init>:
#include <kernel/thread.h>
#include <kernel/timer.h>
#include <kernel/mp.h>

void kernel_init(void)
{
ffffffffea805840:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea805844:	910003fd 	mov	x29, sp
	// if enabled, configure the kernel's event log
	kernel_evlog_init();

	// initialize the threading system
	dprintf(SPEW, "initializing mp\n");
	mp_init();
ffffffffea805848:	9400074c 	bl	ffffffffea807578 <mp_init>

	// initialize the threading system
	dprintf(SPEW, "initializing threads\n");
	thread_init();
ffffffffea80584c:	94000371 	bl	ffffffffea806610 <thread_init>

	// initialize kernel timers
	dprintf(SPEW, "initializing timers\n");
	timer_init();
}
ffffffffea805850:	a8c17bfd 	ldp	x29, x30, [sp], #16
	timer_init();
ffffffffea805854:	1400073d 	b	ffffffffea807548 <timer_init>

ffffffffea805858 <mutex_init>:
/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
	*m = (mutex_t)MUTEX_INITIAL_VALUE(*m);
ffffffffea805858:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea80585c:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea805860:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea805864:	91008001 	add	x1, x0, #0x20
ffffffffea805868:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea80586c:	b9000003 	str	w3, [x0]
ffffffffea805870:	f900041f 	str	xzr, [x0, #8]
ffffffffea805874:	b900101f 	str	wzr, [x0, #16]
ffffffffea805878:	b9001802 	str	w2, [x0, #24]
ffffffffea80587c:	a9020401 	stp	x1, x1, [x0, #32]
ffffffffea805880:	b900301f 	str	wzr, [x0, #48]
}
ffffffffea805884:	d65f03c0 	ret

ffffffffea805888 <mutex_acquire_timeout>:
 *
 * @return  NO_ERROR on success, ERR_TIMED_OUT on timeout,
 * other values on error
 */
status_t mutex_acquire_timeout(mutex_t *m, lk_time_t timeout)
{
ffffffffea805888:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80588c:	910003fd 	mov	x29, sp
ffffffffea805890:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805894:	aa0003f3 	mov	x19, x0
ffffffffea805898:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80589c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea8058a0:	2a0103f7 	mov	w23, w1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8058a4:	d53b4220 	mrs	x0, daif
ffffffffea8058a8:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8058ac:	37380060 	tbnz	w0, #7, ffffffffea8058b8 <mutex_acquire_timeout+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8058b0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8058b4:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8058b8:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
		      get_current_thread(), get_current_thread()->name, m);
#endif

	THREAD_LOCK(state);

	status_t ret = NO_ERROR;
ffffffffea8058bc:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea8058c0:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea8058c4:	97fff3ff 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (unlikely(++m->count > 1)) {
ffffffffea8058c8:	b9401260 	ldr	w0, [x19, #16]
ffffffffea8058cc:	11000400 	add	w0, w0, #0x1
ffffffffea8058d0:	b9001260 	str	w0, [x19, #16]
ffffffffea8058d4:	7100041f 	cmp	w0, #0x1
ffffffffea8058d8:	540001ac 	b.gt	ffffffffea80590c <mutex_acquire_timeout+0x84>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8058dc:	d538d080 	mrs	x0, tpidr_el1
			 */
			goto err;
		}
	}

	m->holder = get_current_thread();
ffffffffea8058e0:	f9000660 	str	x0, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea8058e4:	f9406e80 	ldr	x0, [x20, #216]
ffffffffea8058e8:	97fff3fe 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8058ec:	34000055 	cbz	w21, ffffffffea8058f4 <mutex_acquire_timeout+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8058f0:	d50342ff 	msr	daifclr, #0x2

err:
	THREAD_UNLOCK(state);
	return ret;
}
ffffffffea8058f4:	2a1603e0 	mov	w0, w22
ffffffffea8058f8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea8058fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805900:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805904:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea805908:	d65f03c0 	ret
		ret = wait_queue_block(&m->wait, timeout);
ffffffffea80590c:	2a1703e1 	mov	w1, w23
ffffffffea805910:	91006260 	add	x0, x19, #0x18
ffffffffea805914:	940003e5 	bl	ffffffffea8068a8 <wait_queue_block>
ffffffffea805918:	2a0003f6 	mov	w22, w0
		if (unlikely(ret < NO_ERROR)) {
ffffffffea80591c:	36fffe00 	tbz	w0, #31, ffffffffea8058dc <mutex_acquire_timeout+0x54>
			if (likely(ret == ERR_TIMED_OUT)) {
ffffffffea805920:	3100341f 	cmn	w0, #0xd
ffffffffea805924:	54fffe01 	b.ne	ffffffffea8058e4 <mutex_acquire_timeout+0x5c>  // b.any
				m->count--;
ffffffffea805928:	b9401260 	ldr	w0, [x19, #16]
ffffffffea80592c:	51000400 	sub	w0, w0, #0x1
ffffffffea805930:	b9001260 	str	w0, [x19, #16]
ffffffffea805934:	17ffffec 	b	ffffffffea8058e4 <mutex_acquire_timeout+0x5c>

ffffffffea805938 <mutex_release>:

/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
ffffffffea805938:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80593c:	910003fd 	mov	x29, sp
ffffffffea805940:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805944:	aa0003f3 	mov	x19, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805948:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80594c:	37380260 	tbnz	w0, #7, ffffffffea805998 <mutex_release+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805950:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805954:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea805958:	f9406e94 	ldr	x20, [x20, #216]
ffffffffea80595c:	aa1403e0 	mov	x0, x20
ffffffffea805960:	97fff3d8 	bl	ffffffffea8028c0 <arch_spin_lock>

	THREAD_LOCK(state);

	m->holder = 0;

	if (unlikely(--m->count >= 1)) {
ffffffffea805964:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea805968:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea80596c:	51000400 	sub	w0, w0, #0x1
ffffffffea805970:	b9001260 	str	w0, [x19, #16]
ffffffffea805974:	7100001f 	cmp	w0, #0x0
ffffffffea805978:	540003ac 	b.gt	ffffffffea8059ec <mutex_release+0xb4>
    arch_spin_unlock(lock);
ffffffffea80597c:	aa1403e0 	mov	x0, x20
ffffffffea805980:	97fff3d8 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805984:	d50342ff 	msr	daifclr, #0x2
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
	}

	THREAD_UNLOCK(state);
	return NO_ERROR;
}
ffffffffea805988:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80598c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805990:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805994:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea805998:	b00002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80599c:	f9406e94 	ldr	x20, [x20, #216]
ffffffffea8059a0:	aa1403e0 	mov	x0, x20
ffffffffea8059a4:	97fff3c7 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (unlikely(--m->count >= 1)) {
ffffffffea8059a8:	b9401260 	ldr	w0, [x19, #16]
	m->holder = 0;
ffffffffea8059ac:	f900067f 	str	xzr, [x19, #8]
	if (unlikely(--m->count >= 1)) {
ffffffffea8059b0:	51000400 	sub	w0, w0, #0x1
ffffffffea8059b4:	b9001260 	str	w0, [x19, #16]
ffffffffea8059b8:	7100001f 	cmp	w0, #0x0
ffffffffea8059bc:	540000ec 	b.gt	ffffffffea8059d8 <mutex_release+0xa0>
    arch_spin_unlock(lock);
ffffffffea8059c0:	aa1403e0 	mov	x0, x20
ffffffffea8059c4:	97fff3c7 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea8059c8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8059cc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8059d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8059d4:	d65f03c0 	ret
		wait_queue_wake_one(&m->wait, true, NO_ERROR);
ffffffffea8059d8:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8059dc:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8059e0:	91006260 	add	x0, x19, #0x18
ffffffffea8059e4:	9400043b 	bl	ffffffffea806ad0 <wait_queue_wake_one>
ffffffffea8059e8:	17fffff6 	b	ffffffffea8059c0 <mutex_release+0x88>
ffffffffea8059ec:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8059f0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8059f4:	91006260 	add	x0, x19, #0x18
ffffffffea8059f8:	94000436 	bl	ffffffffea806ad0 <wait_queue_wake_one>
ffffffffea8059fc:	17ffffe0 	b	ffffffffea80597c <mutex_release+0x44>

ffffffffea805a00 <init_thread_struct>:
	list_add_tail(&run_queue[t->priority], &t->queue_node);
	run_queue_bitmap |= (1<<t->priority);
}

static void init_thread_struct(thread_t *t, const char *name)
{
ffffffffea805a00:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	memset(t, 0, sizeof(thread_t));
ffffffffea805a04:	d2805b02 	mov	x2, #0x2d8                 	// #728
{
ffffffffea805a08:	910003fd 	mov	x29, sp
ffffffffea805a0c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805a10:	aa0003f3 	mov	x19, x0
ffffffffea805a14:	aa0103f4 	mov	x20, x1
	memset(t, 0, sizeof(thread_t));
ffffffffea805a18:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805a1c:	940039a7 	bl	ffffffffea8140b8 <memset>
	t->magic = THREAD_MAGIC;
ffffffffea805a20:	528e4c81 	mov	w1, #0x7264                	// #29284
	t->pinned_cpu = -1;
ffffffffea805a24:	12800000 	mov	w0, #0xffffffff            	// #-1
	t->magic = THREAD_MAGIC;
ffffffffea805a28:	72ae8d01 	movk	w1, #0x7468, lsl #16
ffffffffea805a2c:	b9000261 	str	w1, [x19]
	t->pinned_cpu = -1;
ffffffffea805a30:	b9003e60 	str	w0, [x19, #60]
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805a34:	aa1403e1 	mov	x1, x20
ffffffffea805a38:	910ae260 	add	x0, x19, #0x2b8
ffffffffea805a3c:	d2800402 	mov	x2, #0x20                  	// #32
}
ffffffffea805a40:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805a44:	a8c27bfd 	ldp	x29, x30, [sp], #32
	strlcpy(t->name, name, sizeof(t->name));
ffffffffea805a48:	140039de 	b	ffffffffea8141c0 <strlcpy>
ffffffffea805a4c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805a50 <get_top_thread>:
}

static thread_t *get_top_thread(int cpu, bool unlink)
{
	thread_t *newthread;
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805a50:	b000036c 	adrp	x12, ffffffffea872000 <idle_threads+0xeb0>
{
ffffffffea805a54:	2a0003e4 	mov	w4, w0
ffffffffea805a58:	12001c21 	and	w1, w1, #0xff
	uint32_t local_run_queue_bitmap = run_queue_bitmap;
ffffffffea805a5c:	b94b918a 	ldr	w10, [x12, #2960]
	uint next_queue;

	while (local_run_queue_bitmap) {
ffffffffea805a60:	3400056a 	cbz	w10, ffffffffea805b0c <get_top_thread+0xbc>
ffffffffea805a64:	b0000369 	adrp	x9, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805a68:	2a0a03e7 	mov	w7, w10
		/* find the first (remaining) queue with a thread in it */
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
			- (sizeof(run_queue_bitmap) * 8 - NUM_PRIORITIES);

		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805a6c:	91264128 	add	x8, x9, #0x990
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805a70:	528003eb 	mov	w11, #0x1f                  	// #31

				return newthread;
			}
		}

		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805a74:	5280002d 	mov	w13, #0x1                   	// #1
		next_queue = HIGHEST_PRIORITY - __builtin_clz(local_run_queue_bitmap)
ffffffffea805a78:	5ac010e5 	clz	w5, w7
ffffffffea805a7c:	4b050166 	sub	w6, w11, w5
ffffffffea805a80:	aa0603e5 	mov	x5, x6
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805a84:	8b061100 	add	x0, x8, x6, lsl #4
ffffffffea805a88:	8b26d103 	add	x3, x8, w6, sxtw #4
ffffffffea805a8c:	f9400402 	ldr	x2, [x0, #8]
ffffffffea805a90:	d1006040 	sub	x0, x2, #0x18
ffffffffea805a94:	eb02007f 	cmp	x3, x2
ffffffffea805a98:	54000340 	b.eq	ffffffffea805b00 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805a9c:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805aa0:	7100005f 	cmp	w2, #0x0
ffffffffea805aa4:	7a42a084 	ccmp	w4, w2, #0x4, ge  // ge = tcont
ffffffffea805aa8:	54000140 	b.eq	ffffffffea805ad0 <get_top_thread+0x80>  // b.none
ffffffffea805aac:	d503201f 	nop
		list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
ffffffffea805ab0:	f9401002 	ldr	x2, [x0, #32]
ffffffffea805ab4:	d1006040 	sub	x0, x2, #0x18
ffffffffea805ab8:	eb02007f 	cmp	x3, x2
ffffffffea805abc:	54000220 	b.eq	ffffffffea805b00 <get_top_thread+0xb0>  // b.none
			if (newthread->pinned_cpu < 0 || newthread->pinned_cpu == cpu) {
ffffffffea805ac0:	b9403c02 	ldr	w2, [x0, #60]
ffffffffea805ac4:	7100005f 	cmp	w2, #0x0
ffffffffea805ac8:	7a44a044 	ccmp	w2, w4, #0x4, ge  // ge = tcont
ffffffffea805acc:	54ffff21 	b.ne	ffffffffea805ab0 <get_top_thread+0x60>  // b.any
				if (unlink) {
ffffffffea805ad0:	34000161 	cbz	w1, ffffffffea805afc <get_top_thread+0xac>
	item->next->prev = item->prev;
ffffffffea805ad4:	a9418402 	ldp	x2, x1, [x0, #24]
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
	return (list->next == list) ? true : false;
ffffffffea805ad8:	91264129 	add	x9, x9, #0x990
ffffffffea805adc:	8b061126 	add	x6, x9, x6, lsl #4
	item->next->prev = item->prev;
ffffffffea805ae0:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea805ae4:	f9400c02 	ldr	x2, [x0, #24]
ffffffffea805ae8:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea805aec:	a901fc1f 	stp	xzr, xzr, [x0, #24]
					if (list_is_empty(&run_queue[next_queue]))
ffffffffea805af0:	f94004c1 	ldr	x1, [x6, #8]
ffffffffea805af4:	eb03003f 	cmp	x1, x3
ffffffffea805af8:	54000140 	b.eq	ffffffffea805b20 <get_top_thread+0xd0>  // b.none
	}
	/* no threads to run, select the idle thread for this cpu */
	return &idle_threads[cpu];
}
ffffffffea805afc:	d65f03c0 	ret
		local_run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805b00:	1ac521a5 	lsl	w5, w13, w5
	while (local_run_queue_bitmap) {
ffffffffea805b04:	6a2500e7 	bics	w7, w7, w5
ffffffffea805b08:	54fffb81 	b.ne	ffffffffea805a78 <get_top_thread+0x28>  // b.any
	return &idle_threads[cpu];
ffffffffea805b0c:	90000360 	adrp	x0, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805b10:	91054000 	add	x0, x0, #0x150
ffffffffea805b14:	52805b01 	mov	w1, #0x2d8                 	// #728
ffffffffea805b18:	9b210080 	smaddl	x0, w4, w1, x0
}
ffffffffea805b1c:	d65f03c0 	ret
						run_queue_bitmap &= ~(1<<next_queue);
ffffffffea805b20:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805b24:	1ac52025 	lsl	w5, w1, w5
ffffffffea805b28:	0a25014a 	bic	w10, w10, w5
ffffffffea805b2c:	b90b918a 	str	w10, [x12, #2960]
}
ffffffffea805b30:	d65f03c0 	ret
ffffffffea805b34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805b38 <thread_get_mp_reschedule_target.isra.5>:
static mp_cpu_mask_t thread_get_mp_reschedule_target(thread_t *current_thread, thread_t *t)
ffffffffea805b38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805b3c:	910003fd 	mov	x29, sp
ffffffffea805b40:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805b44:	aa0203f3 	mov	x19, x2
ffffffffea805b48:	f90013f5 	str	x21, [sp, #32]
ffffffffea805b4c:	aa0003f4 	mov	x20, x0
ffffffffea805b50:	aa0103f5 	mov	x21, x1
	uint cpu = arch_curr_cpu_num();
ffffffffea805b54:	97fff3df 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805b58:	b9400261 	ldr	w1, [x19]
ffffffffea805b5c:	3100043f 	cmn	w1, #0x1
ffffffffea805b60:	54000280 	b.eq	ffffffffea805bb0 <thread_get_mp_reschedule_target.isra.5+0x78>  // b.none
ffffffffea805b64:	b9400283 	ldr	w3, [x20]
ffffffffea805b68:	2a0003e2 	mov	w2, w0
		return 0;
ffffffffea805b6c:	52800000 	mov	w0, #0x0                   	// #0
	if (t->pinned_cpu != -1 && current_thread->pinned_cpu == t->pinned_cpu)
ffffffffea805b70:	6b03003f 	cmp	w1, w3
ffffffffea805b74:	54000160 	b.eq	ffffffffea805ba0 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->pinned_cpu == -1 || (uint)t->pinned_cpu == cpu)
ffffffffea805b78:	6b01005f 	cmp	w2, w1
ffffffffea805b7c:	54000120 	b.eq	ffffffffea805ba0 <thread_get_mp_reschedule_target.isra.5+0x68>  // b.none
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805b80:	90000362 	adrp	x2, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805b84:	9104c042 	add	x2, x2, #0x130
	return 1UL << target_cpu;
ffffffffea805b88:	d2800020 	mov	x0, #0x1                   	// #1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805b8c:	b94002a3 	ldr	w3, [x21]
	return 1UL << target_cpu;
ffffffffea805b90:	9ac12000 	lsl	x0, x0, x1
	if (t->priority < cpu_priority[target_cpu])
ffffffffea805b94:	b8615841 	ldr	w1, [x2, w1, uxtw #2]
	return 1UL << target_cpu;
ffffffffea805b98:	6b01007f 	cmp	w3, w1
ffffffffea805b9c:	1a80b3e0 	csel	w0, wzr, w0, lt  // lt = tstop
}
ffffffffea805ba0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805ba4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805ba8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805bac:	d65f03c0 	ret
		return 0;
ffffffffea805bb0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805bb4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805bb8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805bbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805bc0:	d65f03c0 	ret
ffffffffea805bc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea805bc8 <thread_mp_reschedule>:
{
ffffffffea805bc8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea805bcc:	aa0103e2 	mov	x2, x1
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805bd0:	9100f042 	add	x2, x2, #0x3c
ffffffffea805bd4:	9100a021 	add	x1, x1, #0x28
{
ffffffffea805bd8:	910003fd 	mov	x29, sp
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805bdc:	9100f000 	add	x0, x0, #0x3c
ffffffffea805be0:	97ffffd6 	bl	ffffffffea805b38 <thread_get_mp_reschedule_target.isra.5>
}
ffffffffea805be4:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(thread_get_mp_reschedule_target(current_thread, t), 0);
ffffffffea805be8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805bec:	14000665 	b	ffffffffea807580 <mp_reschedule>

ffffffffea805bf0 <thread_cond_mp_reschedule.isra.6>:

static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805bf0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
{
	int i;
	uint best_cpu = ~0U;
	int best_cpu_priority = INT_MAX;
	thread_t *t = get_top_thread(-1, false);
ffffffffea805bf4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805bf8:	12800000 	mov	w0, #0xffffffff            	// #-1
static void thread_cond_mp_reschedule(thread_t *current_thread, const char *caller)
ffffffffea805bfc:	910003fd 	mov	x29, sp
	thread_t *t = get_top_thread(-1, false);
ffffffffea805c00:	97ffff94 	bl	ffffffffea805a50 <get_top_thread>
ffffffffea805c04:	b00002e6 	adrp	x6, ffffffffea862000 <__ctor_list>

	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (!(mp.active_cpus & (1 << i)))
			continue;

		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805c08:	90000368 	adrp	x8, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805c0c:	9104c108 	add	x8, x8, #0x130
	thread_t *t = get_top_thread(-1, false);
ffffffffea805c10:	d2800001 	mov	x1, #0x0                   	// #0
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805c14:	f9409cc6 	ldr	x6, [x6, #312]
	uint best_cpu = ~0U;
ffffffffea805c18:	12800003 	mov	w3, #0xffffffff            	// #-1
	int best_cpu_priority = INT_MAX;
ffffffffea805c1c:	12b00002 	mov	w2, #0x7fffffff            	// #2147483647
		if (!(mp.active_cpus & (1 << i)))
ffffffffea805c20:	52800027 	mov	w7, #0x1                   	// #1
ffffffffea805c24:	d503201f 	nop
ffffffffea805c28:	b94000c4 	ldr	w4, [x6]
ffffffffea805c2c:	1ac120e5 	lsl	w5, w7, w1
ffffffffea805c30:	6a0400bf 	tst	w5, w4
ffffffffea805c34:	540000a0 	b.eq	ffffffffea805c48 <thread_cond_mp_reschedule.isra.6+0x58>  // b.none
		if (cpu_priority[i] < best_cpu_priority) {
ffffffffea805c38:	b8617904 	ldr	w4, [x8, x1, lsl #2]
			best_cpu = i;
ffffffffea805c3c:	6b02009f 	cmp	w4, w2
ffffffffea805c40:	1a81a063 	csel	w3, w3, w1, ge  // ge = tcont
ffffffffea805c44:	1a84a042 	csel	w2, w2, w4, ge  // ge = tcont
ffffffffea805c48:	91000421 	add	x1, x1, #0x1
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea805c4c:	f100203f 	cmp	x1, #0x8
ffffffffea805c50:	54fffec1 	b.ne	ffffffffea805c28 <thread_cond_mp_reschedule.isra.6+0x38>  // b.any
			best_cpu_priority = cpu_priority[i];
		}
	}

	if (t->priority <= best_cpu_priority)
ffffffffea805c54:	b9402804 	ldr	w4, [x0, #40]
ffffffffea805c58:	6b02009f 	cmp	w4, w2
ffffffffea805c5c:	5400006c 	b.gt	ffffffffea805c68 <thread_cond_mp_reschedule.isra.6+0x78>
		t->priority, t->name,
		current_thread->priority, current_thread->name);
#endif
	cpu_priority[best_cpu] = t->priority;
	mp_reschedule(1UL << best_cpu, 0);
}
ffffffffea805c60:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea805c64:	d65f03c0 	ret
	cpu_priority[best_cpu] = t->priority;
ffffffffea805c68:	90000362 	adrp	x2, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805c6c:	9104c042 	add	x2, x2, #0x130
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805c70:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea805c74:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea805c78:	9ac32000 	lsl	x0, x0, x3
	cpu_priority[best_cpu] = t->priority;
ffffffffea805c7c:	b8235844 	str	w4, [x2, w3, uxtw #2]
}
ffffffffea805c80:	a8c17bfd 	ldp	x29, x30, [sp], #16
	mp_reschedule(1UL << best_cpu, 0);
ffffffffea805c84:	1400063f 	b	ffffffffea807580 <mp_reschedule>

ffffffffea805c88 <thread_resched>:
 *
 * This is probably not the function you're looking for. See
 * thread_yield() instead.
 */
void thread_resched(void)
{
ffffffffea805c88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805c8c:	910003fd 	mov	x29, sp
ffffffffea805c90:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805c94:	f90013f5 	str	x21, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805c98:	d538d094 	mrs	x20, tpidr_el1
	thread_t *oldthread;
	thread_t *newthread;

	thread_t *current_thread = get_current_thread();
	uint cpu = arch_curr_cpu_num();
ffffffffea805c9c:	97fff38d 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea805ca0:	2a0003f5 	mov	w21, w0
	ASSERT(current_thread->state != THREAD_RUNNING);
#endif

	THREAD_STATS_INC(reschedules);

	newthread = get_top_thread(cpu, true);
ffffffffea805ca4:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea805ca8:	97ffff6a 	bl	ffffffffea805a50 <get_top_thread>
ffffffffea805cac:	aa0003f3 	mov	x19, x0

#if THREAD_CHECKS
	ASSERT(newthread);
#endif

	newthread->state = THREAD_RUNNING;
ffffffffea805cb0:	52800040 	mov	w0, #0x2                   	// #2

	oldthread = current_thread;

	if (newthread == oldthread)
ffffffffea805cb4:	eb14027f 	cmp	x19, x20
	newthread->state = THREAD_RUNNING;
ffffffffea805cb8:	b9002e60 	str	w0, [x19, #44]
	if (newthread == oldthread)
ffffffffea805cbc:	540006a0 	b.eq	ffffffffea805d90 <thread_resched+0x108>  // b.none
		return;

	/* set up quantum for the new thread if it was consumed */
	if (newthread->remaining_quantum <= 0) {
ffffffffea805cc0:	b9403260 	ldr	w0, [x19, #48]
ffffffffea805cc4:	7100001f 	cmp	w0, #0x0
ffffffffea805cc8:	5400052d 	b.le	ffffffffea805d6c <thread_resched+0xe4>
ffffffffea805ccc:	b00002e1 	adrp	x1, ffffffffea862000 <__ctor_list>
		newthread->remaining_quantum = 5; // XXX make this smarter
	}

	/* mark the cpu ownership of the threads */
	oldthread->curr_cpu = -1;
ffffffffea805cd0:	12800000 	mov	w0, #0xffffffff            	// #-1
ffffffffea805cd4:	b9003a80 	str	w0, [x20, #56]
ffffffffea805cd8:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea805cdc:	f9409c21 	ldr	x1, [x1, #312]
ffffffffea805ce0:	9ad52000 	lsl	x0, x0, x21
	newthread->curr_cpu = cpu;

	if (thread_is_idle(newthread)) {
ffffffffea805ce4:	b9403664 	ldr	w4, [x19, #52]
extern struct mp_state mp;

/* must be called with the thread lock held */
static inline void mp_set_cpu_idle(uint cpu)
{
    mp.idle_cpus |= 1UL << cpu;
ffffffffea805ce8:	2a2003e2 	mvn	w2, w0
		mp_set_cpu_idle(cpu);
	} else {
		mp_set_cpu_busy(cpu);
	}

	if (thread_is_realtime(newthread)) {
ffffffffea805cec:	b9402a65 	ldr	w5, [x19, #40]
	newthread->curr_cpu = cpu;
ffffffffea805cf0:	b9003a75 	str	w21, [x19, #56]
ffffffffea805cf4:	29409823 	ldp	w3, w6, [x1, #4]
ffffffffea805cf8:	f27c009f 	tst	x4, #0x10
ffffffffea805cfc:	0a030047 	and	w7, w2, w3
ffffffffea805d00:	2a000063 	orr	w3, w3, w0
ffffffffea805d04:	1a871063 	csel	w3, w3, w7, ne  // ne = any
	return (t->flags & THREAD_FLAG_REAL_TIME) && t->priority > DEFAULT_PRIORITY;
ffffffffea805d08:	f27d009f 	tst	x4, #0x8
    mp.realtime_cpus |= 1UL << cpu;
}

static inline void mp_set_cpu_non_realtime(uint cpu)
{
    mp.realtime_cpus &= ~(1UL << cpu);
ffffffffea805d0c:	7a5018a4 	ccmp	w5, #0x10, #0x4, ne  // ne = any
ffffffffea805d10:	2a0000c0 	orr	w0, w6, w0
ffffffffea805d14:	0a060042 	and	w2, w2, w6
ffffffffea805d18:	1a80d040 	csel	w0, w2, w0, le
ffffffffea805d1c:	29008023 	stp	w3, w0, [x1, #4]
#endif

	KEVLOG_THREAD_SWITCH(oldthread, newthread);

#if PLATFORM_HAS_DYNAMIC_TIMER
	if (thread_is_real_time_or_idle(newthread)) {
ffffffffea805d20:	721d049f 	tst	w4, #0x18
ffffffffea805d24:	540002a1 	b.ne	ffffffffea805d78 <thread_resched+0xf0>  // b.any
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805d28:	b9403680 	ldr	w0, [x20, #52]
			dprintf(ALWAYS, "arch_context_switch: stop preempt, cpu %d, old %p (%s), new %p (%s)\n",
				cpu, oldthread, oldthread->name, newthread, newthread->name);
#endif
			timer_cancel(&preempt_timer[cpu]);
		}
	} else if (thread_is_real_time_or_idle(oldthread)) {
ffffffffea805d2c:	721d041f 	tst	w0, #0x18
ffffffffea805d30:	54000461 	b.ne	ffffffffea805dbc <thread_resched+0x134>  // b.any

	/* set some optional target debug leds */
	target_set_debug_led(0, !thread_is_idle(&idle_threads[cpu]));

	/* do the switch */
	cpu_priority[cpu] = newthread->priority;
ffffffffea805d34:	90000360 	adrp	x0, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea805d38:	9104c000 	add	x0, x0, #0x130
ffffffffea805d3c:	b8355805 	str	w5, [x0, w21, uxtw #2]
}

static inline void set_current_thread(struct thread *t)
{
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea805d40:	d518d093 	msr	tpidr_el1, x19
ffffffffea805d44:	d5033fdf 	isb
		oldthread->flags, newthread, newthread->name,
		newthread->priority, newthread->flags);
#endif

#ifdef WITH_LIB_UTHREAD
	uthread_context_switch(oldthread, newthread);
ffffffffea805d48:	aa1303e1 	mov	x1, x19
ffffffffea805d4c:	aa1403e0 	mov	x0, x20
ffffffffea805d50:	94003ad4 	bl	ffffffffea8148a0 <uthread_context_switch>
#endif
	arch_context_switch(oldthread, newthread);
}
ffffffffea805d54:	f94013f5 	ldr	x21, [sp, #32]
	arch_context_switch(oldthread, newthread);
ffffffffea805d58:	aa1303e1 	mov	x1, x19
ffffffffea805d5c:	aa1403e0 	mov	x0, x20
}
ffffffffea805d60:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805d64:	a8c37bfd 	ldp	x29, x30, [sp], #48
	arch_context_switch(oldthread, newthread);
ffffffffea805d68:	17fff4ba 	b	ffffffffea803050 <arch_context_switch>
		newthread->remaining_quantum = 5; // XXX make this smarter
ffffffffea805d6c:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea805d70:	b9003260 	str	w0, [x19, #48]
ffffffffea805d74:	17ffffd6 	b	ffffffffea805ccc <thread_resched+0x44>
		thread_cond_mp_reschedule(newthread, __func__);
ffffffffea805d78:	97ffff9e 	bl	ffffffffea805bf0 <thread_cond_mp_reschedule.isra.6>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805d7c:	b9403680 	ldr	w0, [x20, #52]
		if (!thread_is_real_time_or_idle(oldthread)) {
ffffffffea805d80:	721d041f 	tst	w0, #0x18
ffffffffea805d84:	540000e0 	b.eq	ffffffffea805da0 <thread_resched+0x118>  // b.none
ffffffffea805d88:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805d8c:	17ffffea 	b	ffffffffea805d34 <thread_resched+0xac>
}
ffffffffea805d90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805d94:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805d98:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805d9c:	d65f03c0 	ret
			timer_cancel(&preempt_timer[cpu]);
ffffffffea805da0:	b0000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805da4:	91204000 	add	x0, x0, #0x810
ffffffffea805da8:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805dac:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805db0:	940005a8 	bl	ffffffffea807450 <timer_cancel>
ffffffffea805db4:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805db8:	17ffffdf 	b	ffffffffea805d34 <thread_resched+0xac>
		timer_set_periodic(&preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);
ffffffffea805dbc:	b0000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805dc0:	91204000 	add	x0, x0, #0x810
ffffffffea805dc4:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea805dc8:	90000002 	adrp	x2, ffffffffea805000 <platform_tick+0x40>
ffffffffea805dcc:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea805dd0:	913a2042 	add	x2, x2, #0xe88
ffffffffea805dd4:	9ba102a0 	umaddl	x0, w21, w1, x0
ffffffffea805dd8:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea805ddc:	94000597 	bl	ffffffffea807438 <timer_set_periodic>
ffffffffea805de0:	b9402a65 	ldr	w5, [x19, #40]
ffffffffea805de4:	17ffffd4 	b	ffffffffea805d34 <thread_resched+0xac>

ffffffffea805de8 <thread_sleep_handler>:
	}
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, lk_time_t now, void *arg)
{
ffffffffea805de8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea805dec:	910003fd 	mov	x29, sp
ffffffffea805df0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805df4:	aa0203f3 	mov	x19, x2
ffffffffea805df8:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805dfc:	d53b4220 	mrs	x0, daif
ffffffffea805e00:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea805e04:	37380060 	tbnz	w0, #7, ffffffffea805e10 <thread_sleep_handler+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805e08:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea805e0c:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea805e10:	b0000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805e14:	912ea294 	add	x20, x20, #0xba8
ffffffffea805e18:	aa1403e0 	mov	x0, x20
ffffffffea805e1c:	97fff2a9 	bl	ffffffffea8028c0 <arch_spin_lock>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805e20:	b9402a62 	ldr	w2, [x19, #40]
	item->next = list->next;
ffffffffea805e24:	b0000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805e28:	91264021 	add	x1, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805e2c:	b0000365 	adrp	x5, ffffffffea872000 <idle_threads+0xeb0>
	ASSERT(t->state == THREAD_SLEEPING);
#endif

	THREAD_LOCK(state);

	t->state = THREAD_READY;
ffffffffea805e30:	52800020 	mov	w0, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea805e34:	91006264 	add	x4, x19, #0x18
ffffffffea805e38:	8b22d021 	add	x1, x1, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea805e3c:	1ac22003 	lsl	w3, w0, w2
ffffffffea805e40:	b94b90a6 	ldr	w6, [x5, #2960]
ffffffffea805e44:	f9400422 	ldr	x2, [x1, #8]
ffffffffea805e48:	a9018a61 	stp	x1, x2, [x19, #24]
ffffffffea805e4c:	2a060062 	orr	w2, w3, w6
ffffffffea805e50:	b90b90a2 	str	w2, [x5, #2960]
	list->next->prev = item;
ffffffffea805e54:	f9400422 	ldr	x2, [x1, #8]
	t->state = THREAD_READY;
ffffffffea805e58:	b9002e60 	str	w0, [x19, #44]
    arch_spin_unlock(lock);
ffffffffea805e5c:	aa1403e0 	mov	x0, x20
ffffffffea805e60:	f9000044 	str	x4, [x2]
	list->next = item;
ffffffffea805e64:	f9000424 	str	x4, [x1, #8]
ffffffffea805e68:	97fff29e 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea805e6c:	34000055 	cbz	w21, ffffffffea805e74 <thread_sleep_handler+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805e70:	d50342ff 	msr	daifclr, #0x2
	insert_in_run_queue_head(t);

	THREAD_UNLOCK(state);

	return INT_RESCHEDULE;
}
ffffffffea805e74:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea805e78:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea805e7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea805e80:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea805e84:	d65f03c0 	ret

ffffffffea805e88 <thread_timer_tick>:
{
ffffffffea805e88:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea805e8c:	910003fd 	mov	x29, sp
ffffffffea805e90:	f9000bf3 	str	x19, [sp, #16]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea805e94:	d538d093 	mrs	x19, tpidr_el1
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea805e98:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_idle(current_thread))
ffffffffea805e9c:	362000a0 	tbz	w0, #4, ffffffffea805eb0 <thread_timer_tick+0x28>
		return INT_NO_RESCHEDULE;
ffffffffea805ea0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea805ea4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea805ea8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805eac:	d65f03c0 	ret
ffffffffea805eb0:	f9000fb4 	str	x20, [x29, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea805eb4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea805eb8:	36380280 	tbz	w0, #7, ffffffffea805f08 <thread_timer_tick+0x80>
    arch_spin_lock(lock);
ffffffffea805ebc:	b0000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805ec0:	912ea294 	add	x20, x20, #0xba8
ffffffffea805ec4:	aa1403e0 	mov	x0, x20
ffffffffea805ec8:	97fff27e 	bl	ffffffffea8028c0 <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea805ecc:	97ffff49 	bl	ffffffffea805bf0 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea805ed0:	aa1403e0 	mov	x0, x20
ffffffffea805ed4:	97fff283 	bl	ffffffffea8028e0 <arch_spin_unlock>
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805ed8:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea805edc:	721d041f 	tst	w0, #0x18
ffffffffea805ee0:	540002c1 	b.ne	ffffffffea805f38 <thread_timer_tick+0xb0>  // b.any
	current_thread->remaining_quantum--;
ffffffffea805ee4:	b9403260 	ldr	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805ee8:	f9400fb4 	ldr	x20, [x29, #24]
	current_thread->remaining_quantum--;
ffffffffea805eec:	51000400 	sub	w0, w0, #0x1
ffffffffea805ef0:	b9003260 	str	w0, [x19, #48]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805ef4:	7100001f 	cmp	w0, #0x0
}
ffffffffea805ef8:	f9400bf3 	ldr	x19, [sp, #16]
	if (current_thread->remaining_quantum <= 0) {
ffffffffea805efc:	1a9fc7e0 	cset	w0, le
}
ffffffffea805f00:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea805f04:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea805f08:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea805f0c:	b0000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea805f10:	912ea294 	add	x20, x20, #0xba8
ffffffffea805f14:	aa1403e0 	mov	x0, x20
ffffffffea805f18:	97fff26a 	bl	ffffffffea8028c0 <arch_spin_lock>
	thread_cond_mp_reschedule(current_thread, __func__);
ffffffffea805f1c:	97ffff35 	bl	ffffffffea805bf0 <thread_cond_mp_reschedule.isra.6>
    arch_spin_unlock(lock);
ffffffffea805f20:	aa1403e0 	mov	x0, x20
ffffffffea805f24:	97fff26f 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea805f28:	d50342ff 	msr	daifclr, #0x2
	return !!(t->flags & (THREAD_FLAG_REAL_TIME | THREAD_FLAG_IDLE));
ffffffffea805f2c:	b9403660 	ldr	w0, [x19, #52]
	if (thread_is_real_time_or_idle(current_thread))
ffffffffea805f30:	721d041f 	tst	w0, #0x18
ffffffffea805f34:	54fffd80 	b.eq	ffffffffea805ee4 <thread_timer_tick+0x5c>  // b.none
ffffffffea805f38:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea805f3c:	17ffffd9 	b	ffffffffea805ea0 <thread_timer_tick+0x18>

ffffffffea805f40 <thread_create_etc>:
{
ffffffffea805f40:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea805f44:	910003fd 	mov	x29, sp
ffffffffea805f48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea805f4c:	aa0003f3 	mov	x19, x0
ffffffffea805f50:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea805f54:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea805f58:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea805f5c:	aa0503f6 	mov	x22, x5
ffffffffea805f60:	f90023f9 	str	x25, [sp, #64]
ffffffffea805f64:	aa0203f8 	mov	x24, x2
ffffffffea805f68:	aa0303f7 	mov	x23, x3
ffffffffea805f6c:	aa0603f5 	mov	x21, x6
ffffffffea805f70:	2a0403f9 	mov	w25, w4
	if (!t) {
ffffffffea805f74:	b4000840 	cbz	x0, ffffffffea80607c <thread_create_etc+0x13c>
	init_thread_struct(t, name);
ffffffffea805f78:	aa1303e0 	mov	x0, x19
ffffffffea805f7c:	97fffea1 	bl	ffffffffea805a00 <init_thread_struct>
 * @defgroup  wait  Wait Queue
 * @{
 */
void wait_queue_init(wait_queue_t *wait)
{
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea805f80:	528d2e81 	mov	w1, #0x6974                	// #26996
	t->curr_cpu = -1;
ffffffffea805f84:	12800002 	mov	w2, #0xffffffff            	// #-1
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea805f88:	72aeec21 	movk	w1, #0x7761, lsl #16
	t->state = THREAD_SUSPENDED;
ffffffffea805f8c:	29057e79 	stp	w25, wzr, [x19, #40]
	t->curr_cpu = -1;
ffffffffea805f90:	b9003a62 	str	w2, [x19, #56]
	t->blocking_wait_queue = NULL;
ffffffffea805f94:	f900227f 	str	xzr, [x19, #64]
	t->wait_queue_block_ret = NO_ERROR;
ffffffffea805f98:	b9004a7f 	str	wzr, [x19, #72]
	t->entry = entry;
ffffffffea805f9c:	f9013e78 	str	x24, [x19, #632]
	t->arg = arg;
ffffffffea805fa0:	f9014277 	str	x23, [x19, #640]
	t->retcode = 0;
ffffffffea805fa4:	b9028a7f 	str	wzr, [x19, #648]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea805fa8:	b9029261 	str	w1, [x19, #656]
ffffffffea805fac:	910a6261 	add	x1, x19, #0x298
ffffffffea805fb0:	f9014e61 	str	x1, [x19, #664]
ffffffffea805fb4:	f9015261 	str	x1, [x19, #672]
ffffffffea805fb8:	b902aa7f 	str	wzr, [x19, #680]
	if (!stack) {
ffffffffea805fbc:	b5000236 	cbnz	x22, ffffffffea806000 <thread_create_etc+0xc0>
		t->stack = malloc(stack_size);
ffffffffea805fc0:	aa1503e0 	mov	x0, x21
ffffffffea805fc4:	94003769 	bl	ffffffffea813d68 <malloc>
ffffffffea805fc8:	f9013660 	str	x0, [x19, #616]
		if (!t->stack) {
ffffffffea805fcc:	b5000180 	cbnz	x0, ffffffffea805ffc <thread_create_etc+0xbc>
			if (flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea805fd0:	35000114 	cbnz	w20, ffffffffea805ff0 <thread_create_etc+0xb0>
}
ffffffffea805fd4:	a94153f3 	ldp	x19, x20, [sp, #16]
			return NULL;
ffffffffea805fd8:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea805fdc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea805fe0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea805fe4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea805fe8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea805fec:	d65f03c0 	ret
				free(t);
ffffffffea805ff0:	aa1303e0 	mov	x0, x19
ffffffffea805ff4:	94003773 	bl	ffffffffea813dc0 <free>
ffffffffea805ff8:	17fffff7 	b	ffffffffea805fd4 <thread_create_etc+0x94>
		flags |= THREAD_FLAG_FREE_STACK;
ffffffffea805ffc:	321f0294 	orr	w20, w20, #0x2
	t->flags = flags;
ffffffffea806000:	b9003674 	str	w20, [x19, #52]
	t->stack_size = stack_size;
ffffffffea806004:	f9013a75 	str	x21, [x19, #624]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806008:	d538d080 	mrs	x0, tpidr_el1
		t->tls[i] = current_thread->tls[i];
ffffffffea80600c:	f9415801 	ldr	x1, [x0, #688]
	arch_thread_initialize(t);
ffffffffea806010:	aa1303e0 	mov	x0, x19
		t->tls[i] = current_thread->tls[i];
ffffffffea806014:	f9015a61 	str	x1, [x19, #688]
	arch_thread_initialize(t);
ffffffffea806018:	97fff3f4 	bl	ffffffffea802fe8 <arch_thread_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80601c:	d53b4220 	mrs	x0, daif
ffffffffea806020:	91002274 	add	x20, x19, #0x8
ffffffffea806024:	373803c0 	tbnz	w0, #7, ffffffffea80609c <thread_create_etc+0x15c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806028:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80602c:	90000375 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806030:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea806034:	aa1503e0 	mov	x0, x21
ffffffffea806038:	97fff222 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea80603c:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806040:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea806044:	aa1503e0 	mov	x0, x21
ffffffffea806048:	f9400422 	ldr	x2, [x1, #8]
ffffffffea80604c:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea806050:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea806054:	f9000434 	str	x20, [x1, #8]
ffffffffea806058:	97fff222 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80605c:	d50342ff 	msr	daifclr, #0x2
ffffffffea806060:	aa1303e0 	mov	x0, x19
}
ffffffffea806064:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea806068:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80606c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806070:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806074:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806078:	d65f03c0 	ret
ffffffffea80607c:	f9002fa1 	str	x1, [x29, #88]
		t = malloc(sizeof(thread_t));
ffffffffea806080:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea806084:	94003739 	bl	ffffffffea813d68 <malloc>
		flags |= THREAD_FLAG_FREE_STRUCT;
ffffffffea806088:	52800094 	mov	w20, #0x4                   	// #4
		t = malloc(sizeof(thread_t));
ffffffffea80608c:	aa0003f3 	mov	x19, x0
		if (!t)
ffffffffea806090:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea806094:	b5fff720 	cbnz	x0, ffffffffea805f78 <thread_create_etc+0x38>
ffffffffea806098:	17ffffcf 	b	ffffffffea805fd4 <thread_create_etc+0x94>
    arch_spin_lock(lock);
ffffffffea80609c:	90000375 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8060a0:	912ea2b5 	add	x21, x21, #0xba8
ffffffffea8060a4:	aa1503e0 	mov	x0, x21
ffffffffea8060a8:	97fff206 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea8060ac:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8060b0:	912e6021 	add	x1, x1, #0xb98
    arch_spin_unlock(lock);
ffffffffea8060b4:	aa1503e0 	mov	x0, x21
ffffffffea8060b8:	f9400422 	ldr	x2, [x1, #8]
ffffffffea8060bc:	a9008a61 	stp	x1, x2, [x19, #8]
	list->next->prev = item;
ffffffffea8060c0:	f9000054 	str	x20, [x2]
	list->next = item;
ffffffffea8060c4:	f9000434 	str	x20, [x1, #8]
ffffffffea8060c8:	97fff206 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea8060cc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8060d0:	aa1303e0 	mov	x0, x19
ffffffffea8060d4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8060d8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8060dc:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8060e0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8060e4:	d65f03c0 	ret

ffffffffea8060e8 <thread_create>:
	return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
ffffffffea8060e8:	aa0403e6 	mov	x6, x4
ffffffffea8060ec:	d2800005 	mov	x5, #0x0                   	// #0
ffffffffea8060f0:	2a0303e4 	mov	w4, w3
ffffffffea8060f4:	aa0203e3 	mov	x3, x2
ffffffffea8060f8:	aa0103e2 	mov	x2, x1
ffffffffea8060fc:	aa0003e1 	mov	x1, x0
ffffffffea806100:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea806104:	17ffff8f 	b	ffffffffea805f40 <thread_create_etc>

ffffffffea806108 <thread_set_real_time>:
	if (!t)
ffffffffea806108:	b4000560 	cbz	x0, ffffffffea8061b4 <thread_set_real_time+0xac>
{
ffffffffea80610c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806110:	910003fd 	mov	x29, sp
ffffffffea806114:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806118:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80611c:	d53b4221 	mrs	x1, daif
    spin_lock_saved_state_t state = 0;
ffffffffea806120:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806124:	36380281 	tbz	w1, #7, ffffffffea806174 <thread_set_real_time+0x6c>
ffffffffea806128:	aa0003f3 	mov	x19, x0
    arch_spin_lock(lock);
ffffffffea80612c:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806130:	912ea280 	add	x0, x20, #0xba8
ffffffffea806134:	97fff1e3 	bl	ffffffffea8028c0 <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806138:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea80613c:	eb00027f 	cmp	x19, x0
ffffffffea806140:	540002c0 	b.eq	ffffffffea806198 <thread_set_real_time+0x90>  // b.none
	t->flags |= THREAD_FLAG_REAL_TIME;
ffffffffea806144:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806148:	912ea280 	add	x0, x20, #0xba8
ffffffffea80614c:	321d0021 	orr	w1, w1, #0x8
ffffffffea806150:	b9003661 	str	w1, [x19, #52]
ffffffffea806154:	97fff1e3 	bl	ffffffffea8028e0 <arch_spin_unlock>
	return NO_ERROR;
ffffffffea806158:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80615c:	34000055 	cbz	w21, ffffffffea806164 <thread_set_real_time+0x5c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806160:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806164:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806168:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80616c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806170:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806174:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806178:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80617c:	aa0003f3 	mov	x19, x0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806180:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea806184:	912ea280 	add	x0, x20, #0xba8
ffffffffea806188:	97fff1ce 	bl	ffffffffea8028c0 <arch_spin_lock>
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80618c:	d538d080 	mrs	x0, tpidr_el1
	if (t == get_current_thread()) {
ffffffffea806190:	eb00027f 	cmp	x19, x0
ffffffffea806194:	54fffd81 	b.ne	ffffffffea806144 <thread_set_real_time+0x3c>  // b.any
		timer_cancel(&preempt_timer[arch_curr_cpu_num()]);
ffffffffea806198:	97fff24e 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea80619c:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8061a0:	91204021 	add	x1, x1, #0x810
ffffffffea8061a4:	52800602 	mov	w2, #0x30                  	// #48
ffffffffea8061a8:	9ba20400 	umaddl	x0, w0, w2, x1
ffffffffea8061ac:	940004a9 	bl	ffffffffea807450 <timer_cancel>
ffffffffea8061b0:	17ffffe5 	b	ffffffffea806144 <thread_set_real_time+0x3c>
		return ERR_INVALID_ARGS;
ffffffffea8061b4:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea8061b8:	d65f03c0 	ret
ffffffffea8061bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8061c0 <thread_yield>:
{
ffffffffea8061c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8061c4:	910003fd 	mov	x29, sp
ffffffffea8061c8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8061cc:	f90013f5 	str	x21, [sp, #32]
ffffffffea8061d0:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8061d4:	d53b4220 	mrs	x0, daif
ffffffffea8061d8:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8061dc:	37380060 	tbnz	w0, #7, ffffffffea8061e8 <thread_yield+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8061e0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8061e4:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea8061e8:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8061ec:	912ea280 	add	x0, x20, #0xba8
ffffffffea8061f0:	97fff1b4 	bl	ffffffffea8028c0 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea8061f4:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea8061f8:	52800020 	mov	w0, #0x1                   	// #1
	current_thread->remaining_quantum = 0;
ffffffffea8061fc:	2905fe60 	stp	w0, wzr, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea806200:	37200221 	tbnz	w1, #4, ffffffffea806244 <thread_yield+0x84>
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806204:	b9402a65 	ldr	w5, [x19, #40]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806208:	90000364 	adrp	x4, ffffffffea872000 <idle_threads+0xeb0>
	item->prev = list->prev;
ffffffffea80620c:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806210:	91264021 	add	x1, x1, #0x990
ffffffffea806214:	b94b9087 	ldr	w7, [x4, #2960]
	list_add_tail(&run_queue[t->priority], &t->queue_node);
ffffffffea806218:	91006263 	add	x3, x19, #0x18
ffffffffea80621c:	937c7ca2 	sbfiz	x2, x5, #4, #32
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806220:	1ac52000 	lsl	w0, w0, w5
ffffffffea806224:	2a070000 	orr	w0, w0, w7
ffffffffea806228:	b90b9080 	str	w0, [x4, #2960]
ffffffffea80622c:	8b020026 	add	x6, x1, x2
ffffffffea806230:	f8626820 	ldr	x0, [x1, x2]
	item->next = list;
ffffffffea806234:	a9019a60 	stp	x0, x6, [x19, #24]
	list->prev->next = item;
ffffffffea806238:	f8626820 	ldr	x0, [x1, x2]
ffffffffea80623c:	f9000403 	str	x3, [x0, #8]
	list->prev = item;
ffffffffea806240:	f8226823 	str	x3, [x1, x2]
	thread_resched();
ffffffffea806244:	97fffe91 	bl	ffffffffea805c88 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806248:	912ea280 	add	x0, x20, #0xba8
ffffffffea80624c:	97fff1a5 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806250:	34000055 	cbz	w21, ffffffffea806258 <thread_yield+0x98>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806254:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806258:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80625c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806260:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806264:	d65f03c0 	ret

ffffffffea806268 <thread_resume>:
{
ffffffffea806268:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80626c:	910003fd 	mov	x29, sp
ffffffffea806270:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806274:	aa0003f3 	mov	x19, x0
ffffffffea806278:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80627c:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806280:	d53b4237 	mrs	x23, daif
ffffffffea806284:	d53b4220 	mrs	x0, daif
ffffffffea806288:	52800016 	mov	w22, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80628c:	37380060 	tbnz	w0, #7, ffffffffea806298 <thread_resume+0x30>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806290:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea806294:	52800036 	mov	w22, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea806298:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80629c:	912ea280 	add	x0, x20, #0xba8
ffffffffea8062a0:	97fff188 	bl	ffffffffea8028c0 <arch_spin_lock>
	bool resched = false;
ffffffffea8062a4:	52800015 	mov	w21, #0x0                   	// #0
	if (t->state == THREAD_SUSPENDED) {
ffffffffea8062a8:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea8062ac:	35000280 	cbnz	w0, ffffffffea8062fc <thread_resume+0x94>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea8062b0:	b9402a64 	ldr	w4, [x19, #40]
	item->next = list->next;
ffffffffea8062b4:	90000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8062b8:	91264000 	add	x0, x0, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8062bc:	90000363 	adrp	x3, ffffffffea872000 <idle_threads+0xeb0>
		t->state = THREAD_READY;
ffffffffea8062c0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8062c4:	b9002e61 	str	w1, [x19, #44]
ffffffffea8062c8:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8062cc:	1ac42021 	lsl	w1, w1, w4
ffffffffea8062d0:	b94b9065 	ldr	w5, [x3, #2960]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea8062d4:	d27902f5 	eor	x21, x23, #0x80
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea8062d8:	91006262 	add	x2, x19, #0x18
ffffffffea8062dc:	f9400404 	ldr	x4, [x0, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8062e0:	2a050021 	orr	w1, w1, w5
ffffffffea8062e4:	a9019260 	stp	x0, x4, [x19, #24]
		if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
ffffffffea8062e8:	53071eb5 	ubfx	w21, w21, #7, #1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8062ec:	b90b9061 	str	w1, [x3, #2960]
	list->next->prev = item;
ffffffffea8062f0:	f9400403 	ldr	x3, [x0, #8]
ffffffffea8062f4:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea8062f8:	f9000402 	str	x2, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8062fc:	d538d080 	mrs	x0, tpidr_el1
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea806300:	aa1303e1 	mov	x1, x19
ffffffffea806304:	97fffe31 	bl	ffffffffea805bc8 <thread_mp_reschedule>
    arch_spin_unlock(lock);
ffffffffea806308:	912ea280 	add	x0, x20, #0xba8
ffffffffea80630c:	97fff175 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806310:	34000056 	cbz	w22, ffffffffea806318 <thread_resume+0xb0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806314:	d50342ff 	msr	daifclr, #0x2
	if (resched)
ffffffffea806318:	34000055 	cbz	w21, ffffffffea806320 <thread_resume+0xb8>
		thread_yield();
ffffffffea80631c:	97ffffa9 	bl	ffffffffea8061c0 <thread_yield>
}
ffffffffea806320:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806324:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806328:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80632c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806330:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806334:	d65f03c0 	ret

ffffffffea806338 <thread_preempt>:
{
ffffffffea806338:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80633c:	910003fd 	mov	x29, sp
ffffffffea806340:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806344:	a9025bf5 	stp	x21, x22, [sp, #32]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806348:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80634c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806350:	373804e0 	tbnz	w0, #7, ffffffffea8063ec <thread_preempt+0xb4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806354:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806358:	90000375 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80635c:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea806360:	aa1603e0 	mov	x0, x22
ffffffffea806364:	97fff157 	bl	ffffffffea8028c0 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea806368:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea80636c:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea806370:	b9002e74 	str	w20, [x19, #44]
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea806374:	37200680 	tbnz	w0, #4, ffffffffea806444 <thread_preempt+0x10c>
ffffffffea806378:	b9402a62 	ldr	w2, [x19, #40]
ffffffffea80637c:	90000364 	adrp	x4, ffffffffea872000 <idle_threads+0xeb0>
		if (current_thread->remaining_quantum > 0)
ffffffffea806380:	b9403266 	ldr	w6, [x19, #48]
ffffffffea806384:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806388:	b94b9087 	ldr	w7, [x4, #2960]
ffffffffea80638c:	91264021 	add	x1, x1, #0x990
ffffffffea806390:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea806394:	937c7c43 	sbfiz	x3, x2, #4, #32
ffffffffea806398:	1ac22000 	lsl	w0, w0, w2
ffffffffea80639c:	91006265 	add	x5, x19, #0x18
ffffffffea8063a0:	8b030022 	add	x2, x1, x3
ffffffffea8063a4:	2a070000 	orr	w0, w0, w7
ffffffffea8063a8:	710000df 	cmp	w6, #0x0
ffffffffea8063ac:	540003ed 	b.le	ffffffffea806428 <thread_preempt+0xf0>
	item->next = list->next;
ffffffffea8063b0:	f9400441 	ldr	x1, [x2, #8]
ffffffffea8063b4:	a9018662 	stp	x2, x1, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea8063b8:	b90b9080 	str	w0, [x4, #2960]
	list->next->prev = item;
ffffffffea8063bc:	f9400440 	ldr	x0, [x2, #8]
ffffffffea8063c0:	f9000005 	str	x5, [x0]
	list->next = item;
ffffffffea8063c4:	f9000445 	str	x5, [x2, #8]
	thread_resched();
ffffffffea8063c8:	97fffe30 	bl	ffffffffea805c88 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea8063cc:	912ea2a0 	add	x0, x21, #0xba8
ffffffffea8063d0:	97fff144 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8063d4:	34000054 	cbz	w20, ffffffffea8063dc <thread_preempt+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8063d8:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8063dc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8063e0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8063e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8063e8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8063ec:	90000375 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8063f0:	912ea2b6 	add	x22, x21, #0xba8
ffffffffea8063f4:	aa1603e0 	mov	x0, x22
ffffffffea8063f8:	97fff132 	bl	ffffffffea8028c0 <arch_spin_lock>
	return !!(t->flags & THREAD_FLAG_IDLE);
ffffffffea8063fc:	b9403660 	ldr	w0, [x19, #52]
	current_thread->state = THREAD_READY;
ffffffffea806400:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806404:	b9002e61 	str	w1, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806408:	52800014 	mov	w20, #0x0                   	// #0
	if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
ffffffffea80640c:	3627fb60 	tbz	w0, #4, ffffffffea806378 <thread_preempt+0x40>
	thread_resched();
ffffffffea806410:	97fffe1e 	bl	ffffffffea805c88 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea806414:	aa1603e0 	mov	x0, x22
}
ffffffffea806418:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80641c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806420:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806424:	17fff12f 	b	ffffffffea8028e0 <arch_spin_unlock>
	item->prev = list->prev;
ffffffffea806428:	f8636826 	ldr	x6, [x1, x3]
	item->next = list;
ffffffffea80642c:	a9018a66 	stp	x6, x2, [x19, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806430:	b90b9080 	str	w0, [x4, #2960]
	list->prev->next = item;
ffffffffea806434:	f8636820 	ldr	x0, [x1, x3]
ffffffffea806438:	f9000405 	str	x5, [x0, #8]
	list->prev = item;
ffffffffea80643c:	f8236825 	str	x5, [x1, x3]
ffffffffea806440:	17ffffe2 	b	ffffffffea8063c8 <thread_preempt+0x90>
	thread_resched();
ffffffffea806444:	97fffe11 	bl	ffffffffea805c88 <thread_resched>
ffffffffea806448:	aa1603e0 	mov	x0, x22
ffffffffea80644c:	97fff125 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea806450:	17ffffe2 	b	ffffffffea8063d8 <thread_preempt+0xa0>
ffffffffea806454:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806458 <thread_sleep>:
{
ffffffffea806458:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80645c:	910003fd 	mov	x29, sp
ffffffffea806460:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806464:	900002f3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea806468:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80646c:	2a0003f7 	mov	w23, w0
ffffffffea806470:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea806474:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea806478:	f9400001 	ldr	x1, [x0]
ffffffffea80647c:	f9003fa1 	str	x1, [x29, #120]
ffffffffea806480:	d2800001 	mov	x1, #0x0                   	// #0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806484:	d538d094 	mrs	x20, tpidr_el1
	timer_initialize(&timer);
ffffffffea806488:	910123b5 	add	x21, x29, #0x48
ffffffffea80648c:	aa1503e0 	mov	x0, x21
ffffffffea806490:	940003dc 	bl	ffffffffea807400 <timer_initialize>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806494:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806498:	37380380 	tbnz	w0, #7, ffffffffea806508 <thread_sleep+0xb0>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80649c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8064a0:	90000376 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8064a4:	912ea2d6 	add	x22, x22, #0xba8
ffffffffea8064a8:	aa1603e0 	mov	x0, x22
ffffffffea8064ac:	97fff105 	bl	ffffffffea8028c0 <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea8064b0:	aa1403e3 	mov	x3, x20
ffffffffea8064b4:	2a1703e1 	mov	w1, w23
ffffffffea8064b8:	aa1503e0 	mov	x0, x21
ffffffffea8064bc:	f0ffffe2 	adrp	x2, ffffffffea805000 <platform_tick+0x40>
ffffffffea8064c0:	9137a042 	add	x2, x2, #0xde8
ffffffffea8064c4:	940003d7 	bl	ffffffffea807420 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea8064c8:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea8064cc:	b9002e80 	str	w0, [x20, #44]
	thread_resched();
ffffffffea8064d0:	97fffdee 	bl	ffffffffea805c88 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea8064d4:	aa1603e0 	mov	x0, x22
ffffffffea8064d8:	97fff102 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8064dc:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8064e0:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea8064e4:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea8064e8:	f9400260 	ldr	x0, [x19]
ffffffffea8064ec:	ca000020 	eor	x0, x1, x0
ffffffffea8064f0:	b50002c0 	cbnz	x0, ffffffffea806548 <thread_sleep+0xf0>
ffffffffea8064f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8064f8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8064fc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806500:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea806504:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806508:	90000376 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80650c:	912ea2d6 	add	x22, x22, #0xba8
ffffffffea806510:	aa1603e0 	mov	x0, x22
ffffffffea806514:	97fff0eb 	bl	ffffffffea8028c0 <arch_spin_lock>
	timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
ffffffffea806518:	aa1403e3 	mov	x3, x20
ffffffffea80651c:	2a1703e1 	mov	w1, w23
ffffffffea806520:	aa1503e0 	mov	x0, x21
ffffffffea806524:	f0ffffe2 	adrp	x2, ffffffffea805000 <platform_tick+0x40>
ffffffffea806528:	9137a042 	add	x2, x2, #0xde8
ffffffffea80652c:	940003bd 	bl	ffffffffea807420 <timer_set_oneshot>
	current_thread->state = THREAD_SLEEPING;
ffffffffea806530:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea806534:	b9002e80 	str	w0, [x20, #44]
	thread_resched();
ffffffffea806538:	97fffdd4 	bl	ffffffffea805c88 <thread_resched>
    arch_spin_unlock(lock);
ffffffffea80653c:	aa1603e0 	mov	x0, x22
ffffffffea806540:	97fff0e8 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea806544:	17ffffe7 	b	ffffffffea8064e0 <thread_sleep+0x88>
}
ffffffffea806548:	940035f8 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80654c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806550 <thread_init_early>:
{
ffffffffea806550:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806554:	90000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806558:	91264000 	add	x0, x0, #0x990
ffffffffea80655c:	910003fd 	mov	x29, sp
ffffffffea806560:	91080001 	add	x1, x0, #0x200
ffffffffea806564:	a90153f3 	stp	x19, x20, [sp, #16]
	list->prev = list->next = list;
ffffffffea806568:	a9000000 	stp	x0, x0, [x0]
ffffffffea80656c:	91004000 	add	x0, x0, #0x10
	for (i=0; i < NUM_PRIORITIES; i++)
ffffffffea806570:	eb01001f 	cmp	x0, x1
ffffffffea806574:	54ffffa1 	b.ne	ffffffffea806568 <thread_init_early+0x18>  // b.any
ffffffffea806578:	90000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80657c:	912e6014 	add	x20, x0, #0xb98
	init_thread_struct(t, "bootstrap");
ffffffffea806580:	f0000353 	adrp	x19, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea806584:	91054273 	add	x19, x19, #0x150
ffffffffea806588:	f905cc14 	str	x20, [x0, #2968]
ffffffffea80658c:	b0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea806590:	aa1303e0 	mov	x0, x19
ffffffffea806594:	91056021 	add	x1, x1, #0x158
ffffffffea806598:	f9000694 	str	x20, [x20, #8]
ffffffffea80659c:	97fffd19 	bl	ffffffffea805a00 <init_thread_struct>
	item->next = list->next;
ffffffffea8065a0:	f9400682 	ldr	x2, [x20, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065a4:	528d2e83 	mov	w3, #0x6974                	// #26996
ffffffffea8065a8:	72aeec23 	movk	w3, #0x7761, lsl #16
	t->priority = HIGHEST_PRIORITY;
ffffffffea8065ac:	528003e1 	mov	w1, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea8065b0:	52800045 	mov	w5, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8065b4:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea8065b8:	a9008a74 	stp	x20, x2, [x19, #8]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065bc:	f0000340 	adrp	x0, ffffffffea871000 <int_handler_table_shared+0x2ee0>
	t->state = THREAD_RUNNING;
ffffffffea8065c0:	29051661 	stp	w1, w5, [x19, #40]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065c4:	910fa000 	add	x0, x0, #0x3e8
	t->flags = THREAD_FLAG_DETACHED;
ffffffffea8065c8:	f8034264 	stur	x4, [x19, #52]
	t->curr_cpu = 0;
ffffffffea8065cc:	b9003e7f 	str	wzr, [x19, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065d0:	b9029263 	str	w3, [x19, #656]
	cpu_priority[0] = t->priority;
ffffffffea8065d4:	f0000343 	adrp	x3, ffffffffea871000 <int_handler_table_shared+0x2ee0>
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea8065d8:	f9014e60 	str	x0, [x19, #664]
ffffffffea8065dc:	f9015260 	str	x0, [x19, #672]
	list->next->prev = item;
ffffffffea8065e0:	f0000340 	adrp	x0, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea8065e4:	b902aa7f 	str	wzr, [x19, #680]
ffffffffea8065e8:	91056000 	add	x0, x0, #0x158
ffffffffea8065ec:	f9000040 	str	x0, [x2]
	cpu_priority[0] = t->priority;
ffffffffea8065f0:	b9013061 	str	w1, [x3, #304]
	list->next = item;
ffffffffea8065f4:	f9000680 	str	x0, [x20, #8]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea8065f8:	d518d093 	msr	tpidr_el1, x19
ffffffffea8065fc:	d5033fdf 	isb
}
ffffffffea806600:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806604:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806608:	d65f03c0 	ret
ffffffffea80660c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806610 <thread_init>:
{
ffffffffea806610:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806614:	910003fd 	mov	x29, sp
ffffffffea806618:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80661c:	90000373 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806620:	91204273 	add	x19, x19, #0x810
ffffffffea806624:	91060274 	add	x20, x19, #0x180
		timer_initialize(&preempt_timer[i]);
ffffffffea806628:	aa1303e0 	mov	x0, x19
ffffffffea80662c:	9100c273 	add	x19, x19, #0x30
ffffffffea806630:	94000374 	bl	ffffffffea807400 <timer_initialize>
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea806634:	eb14027f 	cmp	x19, x20
ffffffffea806638:	54ffff81 	b.ne	ffffffffea806628 <thread_init+0x18>  // b.any
}
ffffffffea80663c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806640:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806644:	d65f03c0 	ret

ffffffffea806648 <thread_become_idle>:
{
ffffffffea806648:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80664c:	900002e0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea806650:	910003fd 	mov	x29, sp
ffffffffea806654:	f9402800 	ldr	x0, [x0, #80]
ffffffffea806658:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80665c:	f9400001 	ldr	x1, [x0]
ffffffffea806660:	f9001fa1 	str	x1, [x29, #56]
ffffffffea806664:	d2800001 	mov	x1, #0x0                   	// #0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806668:	d538d093 	mrs	x19, tpidr_el1
	snprintf(name, sizeof(name), "idle %d", arch_curr_cpu_num());
ffffffffea80666c:	97fff119 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea806670:	9100a3b4 	add	x20, x29, #0x28
ffffffffea806674:	2a0003e3 	mov	w3, w0
ffffffffea806678:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea80667c:	aa1403e0 	mov	x0, x20
ffffffffea806680:	b0000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea806684:	9104a042 	add	x2, x2, #0x128
ffffffffea806688:	9400354a 	bl	ffffffffea813bb0 <snprintf>
ffffffffea80668c:	d538d080 	mrs	x0, tpidr_el1
	strlcpy(current_thread->name, name, sizeof(current_thread->name));
ffffffffea806690:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea806694:	aa1403e1 	mov	x1, x20
ffffffffea806698:	910ae000 	add	x0, x0, #0x2b8
ffffffffea80669c:	940036c9 	bl	ffffffffea8141c0 <strlcpy>
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea8066a0:	b9403660 	ldr	w0, [x19, #52]
	t->priority = IDLE_PRIORITY;
ffffffffea8066a4:	b9002a7f 	str	wzr, [x19, #40]
	t->flags |= THREAD_FLAG_IDLE;
ffffffffea8066a8:	321c0000 	orr	w0, w0, #0x10
ffffffffea8066ac:	b9003660 	str	w0, [x19, #52]
	t->pinned_cpu = arch_curr_cpu_num();
ffffffffea8066b0:	97fff108 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea8066b4:	b9003e60 	str	w0, [x19, #60]
	mp_set_curr_cpu_active(true);
ffffffffea8066b8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea8066bc:	940003c5 	bl	ffffffffea8075d0 <mp_set_curr_cpu_active>
	mp_set_cpu_idle(arch_curr_cpu_num());
ffffffffea8066c0:	97fff104 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
    mp.idle_cpus |= 1UL << cpu;
ffffffffea8066c4:	900002e1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea8066c8:	d2800022 	mov	x2, #0x1                   	// #1
ffffffffea8066cc:	9ac02042 	lsl	x2, x2, x0
ffffffffea8066d0:	f9409c21 	ldr	x1, [x1, #312]
ffffffffea8066d4:	b9400420 	ldr	w0, [x1, #4]
ffffffffea8066d8:	2a020000 	orr	w0, w0, w2
ffffffffea8066dc:	b9000420 	str	w0, [x1, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8066e0:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea8066e4:	97fffeb7 	bl	ffffffffea8061c0 <thread_yield>
		arch_idle();
ffffffffea8066e8:	97fff11e 	bl	ffffffffea802b60 <arch_idle>
ffffffffea8066ec:	97fff11d 	bl	ffffffffea802b60 <arch_idle>
ffffffffea8066f0:	17fffffe 	b	ffffffffea8066e8 <thread_become_idle+0xa0>
ffffffffea8066f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8066f8 <thread_secondary_cpu_init_early>:
{
ffffffffea8066f8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea8066fc:	910003fd 	mov	x29, sp
ffffffffea806700:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806704:	900002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea806708:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80670c:	52805b13 	mov	w19, #0x2d8                 	// #728
ffffffffea806710:	f9402a80 	ldr	x0, [x20, #80]
	thread_t *t = &idle_threads[cpu];
ffffffffea806714:	f0000356 	adrp	x22, ffffffffea871000 <int_handler_table_shared+0x2ee0>
{
ffffffffea806718:	a90363f7 	stp	x23, x24, [sp, #48]
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea80671c:	910163b8 	add	x24, x29, #0x58
{
ffffffffea806720:	f9400001 	ldr	x1, [x0]
ffffffffea806724:	f90037a1 	str	x1, [x29, #104]
ffffffffea806728:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80672c:	a9046bf9 	stp	x25, x26, [sp, #64]
	thread_t *t = &idle_threads[cpu];
ffffffffea806730:	910542da 	add	x26, x22, #0x150
	uint cpu = arch_curr_cpu_num();
ffffffffea806734:	97fff0e7 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea806738:	2a0003f9 	mov	w25, w0
	snprintf(name, sizeof(name), "idle %d", cpu);
ffffffffea80673c:	2a1903e3 	mov	w3, w25
ffffffffea806740:	b0000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea806744:	9104a042 	add	x2, x2, #0x128
ffffffffea806748:	aa1803e0 	mov	x0, x24
ffffffffea80674c:	9bb37f33 	umull	x19, w25, w19
ffffffffea806750:	d2800201 	mov	x1, #0x10                  	// #16
ffffffffea806754:	94003517 	bl	ffffffffea813bb0 <snprintf>
	thread_t *t = &idle_threads[cpu];
ffffffffea806758:	8b1a0275 	add	x21, x19, x26
	init_thread_struct(t, name);
ffffffffea80675c:	aa1803e1 	mov	x1, x24
ffffffffea806760:	aa1503e0 	mov	x0, x21
ffffffffea806764:	97fffca7 	bl	ffffffffea805a00 <init_thread_struct>
	t->pinned_cpu = cpu;
ffffffffea806768:	d2805b00 	mov	x0, #0x2d8                 	// #728
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea80676c:	910a6261 	add	x1, x19, #0x298
ffffffffea806770:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea806774:	8b1a0021 	add	x1, x1, x26
	t->pinned_cpu = cpu;
ffffffffea806778:	9b006b20 	madd	x0, x25, x0, x26
	t->priority = HIGHEST_PRIORITY;
ffffffffea80677c:	528003e5 	mov	w5, #0x1f                  	// #31
	t->state = THREAD_RUNNING;
ffffffffea806780:	52800044 	mov	w4, #0x2                   	// #2
	t->flags = THREAD_FLAG_DETACHED | THREAD_FLAG_IDLE;
ffffffffea806784:	52800223 	mov	w3, #0x11                  	// #17
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806788:	72aeec22 	movk	w2, #0x7761, lsl #16
	t->state = THREAD_RUNNING;
ffffffffea80678c:	29051005 	stp	w5, w4, [x0, #40]
	t->curr_cpu = cpu;
ffffffffea806790:	2906e403 	stp	w3, w25, [x0, #52]
	t->pinned_cpu = cpu;
ffffffffea806794:	b9003c19 	str	w25, [x0, #60]
	*wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
ffffffffea806798:	b9029002 	str	w2, [x0, #656]
ffffffffea80679c:	f9014c01 	str	x1, [x0, #664]
ffffffffea8067a0:	f9015001 	str	x1, [x0, #672]
ffffffffea8067a4:	b902a81f 	str	wzr, [x0, #680]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8067a8:	d53b4220 	mrs	x0, daif
ffffffffea8067ac:	52800018 	mov	w24, #0x0                   	// #0
ffffffffea8067b0:	37380060 	tbnz	w0, #7, ffffffffea8067bc <thread_secondary_cpu_init_early+0xc4>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8067b4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8067b8:	52800038 	mov	w24, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea8067bc:	90000377 	adrp	x23, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8067c0:	912ea2f7 	add	x23, x23, #0xba8
ffffffffea8067c4:	aa1703e0 	mov	x0, x23
	list_add_head(&thread_list, &t->thread_list_node);
ffffffffea8067c8:	910542d6 	add	x22, x22, #0x150
ffffffffea8067cc:	97fff03d 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea8067d0:	91002273 	add	x19, x19, #0x8
	item->next = list->next;
ffffffffea8067d4:	d2805b00 	mov	x0, #0x2d8                 	// #728
ffffffffea8067d8:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8067dc:	912e6021 	add	x1, x1, #0xb98
ffffffffea8067e0:	8b160273 	add	x19, x19, x22
ffffffffea8067e4:	9b005b20 	madd	x0, x25, x0, x22
	cpu_priority[cpu] = t->priority;
ffffffffea8067e8:	f0000342 	adrp	x2, ffffffffea871000 <int_handler_table_shared+0x2ee0>
ffffffffea8067ec:	9104c042 	add	x2, x2, #0x130
ffffffffea8067f0:	f9400423 	ldr	x3, [x1, #8]
ffffffffea8067f4:	a9008c01 	stp	x1, x3, [x0, #8]
	list->next->prev = item;
ffffffffea8067f8:	f9000073 	str	x19, [x3]
	list->next = item;
ffffffffea8067fc:	f9000433 	str	x19, [x1, #8]
ffffffffea806800:	b9402800 	ldr	w0, [x0, #40]
ffffffffea806804:	b8397840 	str	w0, [x2, x25, lsl #2]
    ARM64_WRITE_SYSREG(tpidr_el1, (uint64_t)t);
ffffffffea806808:	d518d095 	msr	tpidr_el1, x21
ffffffffea80680c:	d5033fdf 	isb
    arch_spin_unlock(lock);
ffffffffea806810:	aa1703e0 	mov	x0, x23
ffffffffea806814:	97fff033 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806818:	34000058 	cbz	w24, ffffffffea806820 <thread_secondary_cpu_init_early+0x128>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80681c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806820:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea806824:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea806828:	f9400280 	ldr	x0, [x20]
ffffffffea80682c:	ca000020 	eor	x0, x1, x0
ffffffffea806830:	b50000e0 	cbnz	x0, ffffffffea80684c <thread_secondary_cpu_init_early+0x154>
ffffffffea806834:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806838:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80683c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806840:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea806844:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea806848:	d65f03c0 	ret
ffffffffea80684c:	94003537 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea806850 <thread_secondary_cpu_entry>:
{
ffffffffea806850:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806854:	910003fd 	mov	x29, sp
ffffffffea806858:	f9000bf3 	str	x19, [sp, #16]
	uint cpu = arch_curr_cpu_num();
ffffffffea80685c:	97fff09d 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea806860:	2a0003f3 	mov	w19, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806864:	d538d080 	mrs	x0, tpidr_el1
	t->priority = IDLE_PRIORITY;
ffffffffea806868:	b900281f 	str	wzr, [x0, #40]
	mp_set_curr_cpu_active(true);
ffffffffea80686c:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea806870:	94000358 	bl	ffffffffea8075d0 <mp_set_curr_cpu_active>
ffffffffea806874:	900002e0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea806878:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea80687c:	9ad32022 	lsl	x2, x1, x19
ffffffffea806880:	f9409c00 	ldr	x0, [x0, #312]
ffffffffea806884:	b9400401 	ldr	w1, [x0, #4]
ffffffffea806888:	2a020021 	orr	w1, w1, w2
ffffffffea80688c:	b9000401 	str	w1, [x0, #4]
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806890:	d50342ff 	msr	daifclr, #0x2
	thread_yield();
ffffffffea806894:	97fffe4b 	bl	ffffffffea8061c0 <thread_yield>
		arch_idle();
ffffffffea806898:	97fff0b2 	bl	ffffffffea802b60 <arch_idle>
ffffffffea80689c:	97fff0b1 	bl	ffffffffea802b60 <arch_idle>
ffffffffea8068a0:	17fffffe 	b	ffffffffea806898 <thread_secondary_cpu_entry+0x48>
ffffffffea8068a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8068a8 <wait_queue_block>:
 *
 * @return ERR_TIMED_OUT on timeout, else returns the return
 * value specified when the queue was woken by wait_queue_wake_one().
 */
status_t wait_queue_block(wait_queue_t *wait, lk_time_t timeout)
{
ffffffffea8068a8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea8068ac:	910003fd 	mov	x29, sp
ffffffffea8068b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8068b4:	900002f4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea8068b8:	f90013f5 	str	x21, [sp, #32]
ffffffffea8068bc:	2a0103f5 	mov	w21, w1
ffffffffea8068c0:	f9402a81 	ldr	x1, [x20, #80]
ffffffffea8068c4:	f9400022 	ldr	x2, [x1]
ffffffffea8068c8:	f90037a2 	str	x2, [x29, #104]
ffffffffea8068cc:	d2800002 	mov	x2, #0x0                   	// #0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea8068d0:	d538d093 	mrs	x19, tpidr_el1
	ASSERT(current_thread->state == THREAD_RUNNING);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (timeout == 0)
ffffffffea8068d4:	34000575 	cbz	w21, ffffffffea806980 <wait_queue_block+0xd8>
	item->prev = list->prev;
ffffffffea8068d8:	aa0003e4 	mov	x4, x0
		return ERR_TIMED_OUT;

	list_add_tail(&wait->list, &current_thread->queue_node);
	wait->count++;
ffffffffea8068dc:	b9401803 	ldr	w3, [x0, #24]
	list_add_tail(&wait->list, &current_thread->queue_node);
ffffffffea8068e0:	91006262 	add	x2, x19, #0x18
	current_thread->state = THREAD_BLOCKED;
ffffffffea8068e4:	52800061 	mov	w1, #0x3                   	// #3
	wait->count++;
ffffffffea8068e8:	11000463 	add	w3, w3, #0x1
	current_thread->blocking_wait_queue = wait;
	current_thread->wait_queue_block_ret = NO_ERROR;

	/* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
	if (timeout != INFINITE_TIME) {
ffffffffea8068ec:	310006bf 	cmn	w21, #0x1
ffffffffea8068f0:	f8408c85 	ldr	x5, [x4, #8]!
	item->next = list;
ffffffffea8068f4:	a9019265 	stp	x5, x4, [x19, #24]
	list->prev->next = item;
ffffffffea8068f8:	f9400404 	ldr	x4, [x0, #8]
ffffffffea8068fc:	f9000482 	str	x2, [x4, #8]
	list->prev = item;
ffffffffea806900:	f9000402 	str	x2, [x0, #8]
	wait->count++;
ffffffffea806904:	b9001803 	str	w3, [x0, #24]
	current_thread->state = THREAD_BLOCKED;
ffffffffea806908:	b9002e61 	str	w1, [x19, #44]
	current_thread->blocking_wait_queue = wait;
ffffffffea80690c:	f9002260 	str	x0, [x19, #64]
	current_thread->wait_queue_block_ret = NO_ERROR;
ffffffffea806910:	b9004a7f 	str	wzr, [x19, #72]
	if (timeout != INFINITE_TIME) {
ffffffffea806914:	54000181 	b.ne	ffffffffea806944 <wait_queue_block+0x9c>  // b.any
		timer_initialize(&timer);
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
	}

	thread_resched();
ffffffffea806918:	97fffcdc 	bl	ffffffffea805c88 <thread_resched>
	/* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
	if (timeout != INFINITE_TIME) {
		timer_cancel(&timer);
	}

	return current_thread->wait_queue_block_ret;
ffffffffea80691c:	b9404a60 	ldr	w0, [x19, #72]
}
ffffffffea806920:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea806924:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea806928:	f9400281 	ldr	x1, [x20]
ffffffffea80692c:	ca010041 	eor	x1, x2, x1
ffffffffea806930:	b50002c1 	cbnz	x1, ffffffffea806988 <wait_queue_block+0xe0>
ffffffffea806934:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806938:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80693c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea806940:	d65f03c0 	ret
ffffffffea806944:	f90017b6 	str	x22, [x29, #40]
		timer_initialize(&timer);
ffffffffea806948:	9100e3b6 	add	x22, x29, #0x38
ffffffffea80694c:	aa1603e0 	mov	x0, x22
ffffffffea806950:	940002ac 	bl	ffffffffea807400 <timer_initialize>
		timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
ffffffffea806954:	aa1603e0 	mov	x0, x22
ffffffffea806958:	aa1303e3 	mov	x3, x19
ffffffffea80695c:	2a1503e1 	mov	w1, w21
ffffffffea806960:	b0000002 	adrp	x2, ffffffffea807000 <wait_queue_destroy+0x20>
ffffffffea806964:	9102c042 	add	x2, x2, #0xb0
ffffffffea806968:	940002ae 	bl	ffffffffea807420 <timer_set_oneshot>
	thread_resched();
ffffffffea80696c:	97fffcc7 	bl	ffffffffea805c88 <thread_resched>
		timer_cancel(&timer);
ffffffffea806970:	aa1603e0 	mov	x0, x22
ffffffffea806974:	940002b7 	bl	ffffffffea807450 <timer_cancel>
ffffffffea806978:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80697c:	17ffffe8 	b	ffffffffea80691c <wait_queue_block+0x74>
		return ERR_TIMED_OUT;
ffffffffea806980:	12800180 	mov	w0, #0xfffffff3            	// #-13
ffffffffea806984:	17ffffe7 	b	ffffffffea806920 <wait_queue_block+0x78>
ffffffffea806988:	f90017b6 	str	x22, [x29, #40]
}
ffffffffea80698c:	940034e7 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea806990 <thread_join>:
{
ffffffffea806990:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea806994:	910003fd 	mov	x29, sp
ffffffffea806998:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80699c:	aa0003f3 	mov	x19, x0
ffffffffea8069a0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8069a4:	2a0203f4 	mov	w20, w2
ffffffffea8069a8:	aa0103f5 	mov	x21, x1
ffffffffea8069ac:	f9001bf7 	str	x23, [sp, #48]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8069b0:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8069b4:	37380540 	tbnz	w0, #7, ffffffffea806a5c <thread_join+0xcc>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8069b8:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8069bc:	90000376 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8069c0:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea8069c4:	aa1703e0 	mov	x0, x23
ffffffffea8069c8:	97ffefbe 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea8069cc:	b9403660 	ldr	w0, [x19, #52]
ffffffffea8069d0:	370006e0 	tbnz	w0, #0, ffffffffea806aac <thread_join+0x11c>
	if (t->state != THREAD_DEATH) {
ffffffffea8069d4:	b9402e60 	ldr	w0, [x19, #44]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8069d8:	52800037 	mov	w23, #0x1                   	// #1
ffffffffea8069dc:	7100141f 	cmp	w0, #0x5
ffffffffea8069e0:	54000521 	b.ne	ffffffffea806a84 <thread_join+0xf4>  // b.any
ffffffffea8069e4:	d503201f 	nop
	if (retcode)
ffffffffea8069e8:	b4000075 	cbz	x21, ffffffffea8069f4 <thread_join+0x64>
		*retcode = t->retcode;
ffffffffea8069ec:	b9428a60 	ldr	w0, [x19, #648]
ffffffffea8069f0:	b90002a0 	str	w0, [x21]
	item->next->prev = item->prev;
ffffffffea8069f4:	a9408662 	ldp	x2, x1, [x19, #8]
    arch_spin_unlock(lock);
ffffffffea8069f8:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea8069fc:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea806a00:	f9400662 	ldr	x2, [x19, #8]
ffffffffea806a04:	f9000441 	str	x1, [x2, #8]
	t->magic = 0;
ffffffffea806a08:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea806a0c:	a900fe7f 	stp	xzr, xzr, [x19, #8]
ffffffffea806a10:	97ffefb4 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806a14:	34000057 	cbz	w23, ffffffffea806a1c <thread_join+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806a18:	d50342ff 	msr	daifclr, #0x2
	if (t->flags & THREAD_FLAG_FREE_STACK && t->stack)
ffffffffea806a1c:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806a20:	360800a1 	tbz	w1, #1, ffffffffea806a34 <thread_join+0xa4>
ffffffffea806a24:	f9413660 	ldr	x0, [x19, #616]
ffffffffea806a28:	b4000060 	cbz	x0, ffffffffea806a34 <thread_join+0xa4>
		free(t->stack);
ffffffffea806a2c:	940034e5 	bl	ffffffffea813dc0 <free>
ffffffffea806a30:	b9403661 	ldr	w1, [x19, #52]
	return NO_ERROR;
ffffffffea806a34:	52800014 	mov	w20, #0x0                   	// #0
	if (t->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806a38:	36100061 	tbz	w1, #2, ffffffffea806a44 <thread_join+0xb4>
		free(t);
ffffffffea806a3c:	aa1303e0 	mov	x0, x19
ffffffffea806a40:	940034e0 	bl	ffffffffea813dc0 <free>
}
ffffffffea806a44:	2a1403e0 	mov	w0, w20
ffffffffea806a48:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea806a4c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806a50:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea806a54:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea806a58:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea806a5c:	90000376 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806a60:	912ea2d7 	add	x23, x22, #0xba8
ffffffffea806a64:	aa1703e0 	mov	x0, x23
ffffffffea806a68:	97ffef96 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (t->flags & THREAD_FLAG_DETACHED) {
ffffffffea806a6c:	b9403660 	ldr	w0, [x19, #52]
ffffffffea806a70:	37000280 	tbnz	w0, #0, ffffffffea806ac0 <thread_join+0x130>
	if (t->state != THREAD_DEATH) {
ffffffffea806a74:	b9402e60 	ldr	w0, [x19, #44]
    spin_lock_saved_state_t state = 0;
ffffffffea806a78:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea806a7c:	7100141f 	cmp	w0, #0x5
ffffffffea806a80:	54fffb40 	b.eq	ffffffffea8069e8 <thread_join+0x58>  // b.none
		status_t err = wait_queue_block(&t->retcode_wait_queue, timeout);
ffffffffea806a84:	2a1403e1 	mov	w1, w20
ffffffffea806a88:	910a4260 	add	x0, x19, #0x290
ffffffffea806a8c:	97ffff87 	bl	ffffffffea8068a8 <wait_queue_block>
ffffffffea806a90:	2a0003f4 	mov	w20, w0
		if (err < 0) {
ffffffffea806a94:	36fffaa0 	tbz	w0, #31, ffffffffea8069e8 <thread_join+0x58>
    arch_spin_unlock(lock);
ffffffffea806a98:	912ea2c0 	add	x0, x22, #0xba8
ffffffffea806a9c:	97ffef91 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea806aa0:	34fffd37 	cbz	w23, ffffffffea806a44 <thread_join+0xb4>
ffffffffea806aa4:	d50342ff 	msr	daifclr, #0x2
ffffffffea806aa8:	17ffffe7 	b	ffffffffea806a44 <thread_join+0xb4>
ffffffffea806aac:	aa1703e0 	mov	x0, x23
ffffffffea806ab0:	97ffef8c 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea806ab4:	d50342ff 	msr	daifclr, #0x2
		return ERR_THREAD_DETACHED;
ffffffffea806ab8:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806abc:	17ffffe2 	b	ffffffffea806a44 <thread_join+0xb4>
ffffffffea806ac0:	aa1703e0 	mov	x0, x23
ffffffffea806ac4:	12800434 	mov	w20, #0xffffffde            	// #-34
ffffffffea806ac8:	97ffef86 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea806acc:	17ffffde 	b	ffffffffea806a44 <thread_join+0xb4>

ffffffffea806ad0 <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806ad0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea806ad4:	910003fd 	mov	x29, sp
ffffffffea806ad8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806adc:	12001c34 	and	w20, w1, #0xff
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806ae0:	d538d086 	mrs	x6, tpidr_el1
	if (list->next != list) {
ffffffffea806ae4:	f9400801 	ldr	x1, [x0, #16]
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	t = list_remove_head_type(&wait->list, thread_t, queue_node);
ffffffffea806ae8:	91002003 	add	x3, x0, #0x8
ffffffffea806aec:	eb03003f 	cmp	x1, x3
ffffffffea806af0:	54000780 	b.eq	ffffffffea806be0 <wait_queue_wake_one+0x110>  // b.none
	item->next->prev = item->prev;
ffffffffea806af4:	a9401025 	ldp	x5, x4, [x1]
	item->prev = item->next = 0;
ffffffffea806af8:	aa0103e3 	mov	x3, x1
	if (t) {
ffffffffea806afc:	f100603f 	cmp	x1, #0x18
	item->next->prev = item->prev;
ffffffffea806b00:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806b04:	f9400025 	ldr	x5, [x1]
ffffffffea806b08:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806b0c:	f900043f 	str	xzr, [x1, #8]
ffffffffea806b10:	f81e847f 	str	xzr, [x3], #-24
ffffffffea806b14:	54000660 	b.eq	ffffffffea806be0 <wait_queue_wake_one+0x110>  // b.none
		wait->count--;
ffffffffea806b18:	b9401804 	ldr	w4, [x0, #24]
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806b1c:	52800025 	mov	w5, #0x1                   	// #1
ffffffffea806b20:	90000368 	adrp	x8, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806b24:	90000361 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
		wait->count--;
ffffffffea806b28:	51000484 	sub	w4, w4, #0x1
ffffffffea806b2c:	b9001804 	str	w4, [x0, #24]
		t->state = THREAD_READY;
ffffffffea806b30:	b9002c65 	str	w5, [x3, #44]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;
ffffffffea806b34:	f900207f 	str	xzr, [x3, #64]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806b38:	b9004862 	str	w2, [x3, #72]
ffffffffea806b3c:	b94b9109 	ldr	w9, [x8, #2960]

		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened thread gets a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		if (reschedule) {
ffffffffea806b40:	340001b4 	cbz	w20, ffffffffea806b74 <wait_queue_wake_one+0xa4>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b44:	b94028c4 	ldr	w4, [x6, #40]
	item->next = list->next;
ffffffffea806b48:	91264020 	add	x0, x1, #0x990
			current_thread->state = THREAD_READY;
ffffffffea806b4c:	b9002cc5 	str	w5, [x6, #44]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b50:	910060c2 	add	x2, x6, #0x18
ffffffffea806b54:	8b24d000 	add	x0, x0, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b58:	1ac420a5 	lsl	w5, w5, w4
ffffffffea806b5c:	2a050129 	orr	w9, w9, w5
ffffffffea806b60:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806b64:	a90190c0 	stp	x0, x4, [x6, #24]
	list->next->prev = item;
ffffffffea806b68:	f9400404 	ldr	x4, [x0, #8]
ffffffffea806b6c:	f9000082 	str	x2, [x4]
	list->next = item;
ffffffffea806b70:	f9000402 	str	x2, [x0, #8]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b74:	b9402864 	ldr	w4, [x3, #40]
	item->next = list->next;
ffffffffea806b78:	91264022 	add	x2, x1, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b7c:	52800025 	mov	w5, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806b80:	91006067 	add	x7, x3, #0x18
			insert_in_run_queue_head(current_thread);
		}
		insert_in_run_queue_head(t);
		thread_mp_reschedule(current_thread, t);
ffffffffea806b84:	aa0303e1 	mov	x1, x3
ffffffffea806b88:	aa0603e0 	mov	x0, x6
ffffffffea806b8c:	8b24d042 	add	x2, x2, w4, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806b90:	1ac420a4 	lsl	w4, w5, w4
ffffffffea806b94:	2a090084 	orr	w4, w4, w9
ffffffffea806b98:	b90b9104 	str	w4, [x8, #2960]
		if (reschedule) {
			thread_resched();
		}
		ret = 1;
ffffffffea806b9c:	2a0503f3 	mov	w19, w5
ffffffffea806ba0:	f9400444 	ldr	x4, [x2, #8]
ffffffffea806ba4:	a9019062 	stp	x2, x4, [x3, #24]
	list->next->prev = item;
ffffffffea806ba8:	f9400443 	ldr	x3, [x2, #8]
ffffffffea806bac:	f9000067 	str	x7, [x3]
	list->next = item;
ffffffffea806bb0:	f9000447 	str	x7, [x2, #8]
		thread_mp_reschedule(current_thread, t);
ffffffffea806bb4:	97fffc05 	bl	ffffffffea805bc8 <thread_mp_reschedule>
		if (reschedule) {
ffffffffea806bb8:	350000b4 	cbnz	w20, ffffffffea806bcc <wait_queue_wake_one+0xfc>

	}

	return ret;
}
ffffffffea806bbc:	2a1303e0 	mov	w0, w19
ffffffffea806bc0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806bc4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806bc8:	d65f03c0 	ret
			thread_resched();
ffffffffea806bcc:	97fffc2f 	bl	ffffffffea805c88 <thread_resched>
}
ffffffffea806bd0:	2a1303e0 	mov	w0, w19
ffffffffea806bd4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806bd8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806bdc:	d65f03c0 	ret
	int ret = 0;
ffffffffea806be0:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806be4:	2a1303e0 	mov	w0, w19
ffffffffea806be8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806bec:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea806bf0:	d65f03c0 	ret
ffffffffea806bf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806bf8 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
ffffffffea806bf8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea806bfc:	910003fd 	mov	x29, sp
ffffffffea806c00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806c04:	f90013f5 	str	x21, [sp, #32]
ffffffffea806c08:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea806c0c:	12001c38 	and	w24, w1, #0xff
ffffffffea806c10:	f90027fa 	str	x26, [sp, #72]
ffffffffea806c14:	d538d095 	mrs	x21, tpidr_el1
ffffffffea806c18:	91002017 	add	x23, x0, #0x8
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (reschedule && wait->count > 0) {
ffffffffea806c1c:	340002b8 	cbz	w24, ffffffffea806c70 <wait_queue_wake_all+0x78>
ffffffffea806c20:	b9401801 	ldr	w1, [x0, #24]
ffffffffea806c24:	7100003f 	cmp	w1, #0x0
ffffffffea806c28:	54000bcd 	b.le	ffffffffea806da0 <wait_queue_wake_all+0x1a8>
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806c2c:	b9402aa4 	ldr	w4, [x21, #40]
	item->next = list->next;
ffffffffea806c30:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806c34:	91264294 	add	x20, x20, #0x990
		/* if we're instructed to reschedule, stick the current thread on the head
		 * of the run queue first, so that the newly awakened threads get a chance to run
		 * before the current one, but the current one doesn't get unnecessarilly punished.
		 */
		current_thread->state = THREAD_READY;
ffffffffea806c38:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea806c3c:	b9002ea1 	str	w1, [x21, #44]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c40:	9000037a 	adrp	x26, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806c44:	8b24d294 	add	x20, x20, w4, sxtw #4
ffffffffea806c48:	1ac42021 	lsl	w1, w1, w4
ffffffffea806c4c:	b94b9345 	ldr	w5, [x26, #2960]
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806c50:	910062a3 	add	x3, x21, #0x18
ffffffffea806c54:	f9400684 	ldr	x4, [x20, #8]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806c58:	2a050021 	orr	w1, w1, w5
ffffffffea806c5c:	a90192b4 	stp	x20, x4, [x21, #24]
ffffffffea806c60:	b90b9341 	str	w1, [x26, #2960]
	list->next->prev = item;
ffffffffea806c64:	f9400684 	ldr	x4, [x20, #8]
ffffffffea806c68:	f9000083 	str	x3, [x4]
	list->next = item;
ffffffffea806c6c:	f9000683 	str	x3, [x20, #8]
	if (list->next != list) {
ffffffffea806c70:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806c74:	eb0302ff 	cmp	x23, x3
ffffffffea806c78:	540009a0 	b.eq	ffffffffea806dac <wait_queue_wake_all+0x1b4>  // b.none
	item->next->prev = item->prev;
ffffffffea806c7c:	a9401065 	ldp	x5, x4, [x3]
	item->prev = item->next = 0;
ffffffffea806c80:	aa0303e1 	mov	x1, x3
		insert_in_run_queue_head(current_thread);
	}

	/* pop all the threads off the wait queue into the run queue */
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806c84:	f100607f 	cmp	x3, #0x18
	item->next->prev = item->prev;
ffffffffea806c88:	f9000085 	str	x5, [x4]
	item->prev->next = item->next;
ffffffffea806c8c:	f9400065 	ldr	x5, [x3]
ffffffffea806c90:	f90004a4 	str	x4, [x5, #8]
	item->prev = item->next = 0;
ffffffffea806c94:	f900047f 	str	xzr, [x3, #8]
ffffffffea806c98:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806c9c:	54000880 	b.eq	ffffffffea806dac <wait_queue_wake_all+0x1b4>  // b.none
ffffffffea806ca0:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806ca4:	9000037a 	adrp	x26, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806ca8:	f90017b6 	str	x22, [x29, #40]
ffffffffea806cac:	9100f2b5 	add	x21, x21, #0x3c
ffffffffea806cb0:	f90023b9 	str	x25, [x29, #64]
	item->next = list->next;
ffffffffea806cb4:	91264294 	add	x20, x20, #0x990
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806cb8:	912e435a 	add	x26, x26, #0xb90
ffffffffea806cbc:	2a0203f6 	mov	w22, w2
ffffffffea806cc0:	aa0003f9 	mov	x25, x0
ffffffffea806cc4:	a90573bb 	stp	x27, x28, [x29, #80]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806cc8:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea806ccc:	5280001b 	mov	w27, #0x0                   	// #0
		wait->count--;
#if THREAD_CHECKS
		ASSERT(t->state == THREAD_BLOCKED);
#endif
		t->state = THREAD_READY;
ffffffffea806cd0:	5280003c 	mov	w28, #0x1                   	// #1
ffffffffea806cd4:	d503201f 	nop
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea806cd8:	b9402823 	ldr	w3, [x1, #40]
ffffffffea806cdc:	91006025 	add	x5, x1, #0x18
		wait->count--;
ffffffffea806ce0:	b9401b22 	ldr	w2, [x25, #24]
		t->wait_queue_block_ret = wait_queue_error;
		t->blocking_wait_queue = NULL;

		insert_in_run_queue_head(t);
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
		ret++;
ffffffffea806ce4:	11000673 	add	w19, w19, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806ce8:	b9400340 	ldr	w0, [x26]
ffffffffea806cec:	8b23d284 	add	x4, x20, w3, sxtw #4
		wait->count--;
ffffffffea806cf0:	51000442 	sub	w2, w2, #0x1
	run_queue_bitmap |= (1<<t->priority);
ffffffffea806cf4:	1ac32383 	lsl	w3, w28, w3
ffffffffea806cf8:	2a000063 	orr	w3, w3, w0
ffffffffea806cfc:	b9000343 	str	w3, [x26]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806d00:	aa1503e0 	mov	x0, x21
ffffffffea806d04:	f9400486 	ldr	x6, [x4, #8]
		wait->count--;
ffffffffea806d08:	b9001b22 	str	w2, [x25, #24]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806d0c:	9100f022 	add	x2, x1, #0x3c
ffffffffea806d10:	a9019824 	stp	x4, x6, [x1, #24]
ffffffffea806d14:	9100a021 	add	x1, x1, #0x28
		t->state = THREAD_READY;
ffffffffea806d18:	b900043c 	str	w28, [x1, #4]
	list->next->prev = item;
ffffffffea806d1c:	f9400483 	ldr	x3, [x4, #8]
		t->blocking_wait_queue = NULL;
ffffffffea806d20:	f9000c3f 	str	xzr, [x1, #24]
		t->wait_queue_block_ret = wait_queue_error;
ffffffffea806d24:	b9002036 	str	w22, [x1, #32]
ffffffffea806d28:	f9000065 	str	x5, [x3]
	list->next = item;
ffffffffea806d2c:	f9000485 	str	x5, [x4, #8]
		mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
ffffffffea806d30:	97fffb82 	bl	ffffffffea805b38 <thread_get_mp_reschedule_target.isra.5>
ffffffffea806d34:	2a00037b 	orr	w27, w27, w0
	if (list->next != list) {
ffffffffea806d38:	f9400b23 	ldr	x3, [x25, #16]
	item->prev = item->next = 0;
ffffffffea806d3c:	aa0303e1 	mov	x1, x3
	if (list->next != list) {
ffffffffea806d40:	eb17007f 	cmp	x3, x23
ffffffffea806d44:	54000120 	b.eq	ffffffffea806d68 <wait_queue_wake_all+0x170>  // b.none
	item->next->prev = item->prev;
ffffffffea806d48:	a9400062 	ldp	x2, x0, [x3]
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806d4c:	f100607f 	cmp	x3, #0x18
ffffffffea806d50:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806d54:	f9400062 	ldr	x2, [x3]
ffffffffea806d58:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea806d5c:	f900047f 	str	xzr, [x3, #8]
ffffffffea806d60:	f81e843f 	str	xzr, [x1], #-24
ffffffffea806d64:	54fffba1 	b.ne	ffffffffea806cd8 <wait_queue_wake_all+0xe0>  // b.any
#if THREAD_CHECKS
	ASSERT(wait->count == 0);
#endif

	if (ret > 0) {
		mp_reschedule(mp_reschedule_target, 0);
ffffffffea806d68:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806d6c:	2a1b03e0 	mov	w0, w27
ffffffffea806d70:	94000204 	bl	ffffffffea807580 <mp_reschedule>
		if (reschedule) {
ffffffffea806d74:	350002d8 	cbnz	w24, ffffffffea806dcc <wait_queue_wake_all+0x1d4>
			thread_resched();
		}
	}

	return ret;
}
ffffffffea806d78:	2a1303e0 	mov	w0, w19
ffffffffea806d7c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea806d80:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806d84:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea806d88:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806d8c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806d90:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806d94:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806d98:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806d9c:	d65f03c0 	ret
	if (list->next != list) {
ffffffffea806da0:	f9400803 	ldr	x3, [x0, #16]
ffffffffea806da4:	eb17007f 	cmp	x3, x23
ffffffffea806da8:	54fff6a1 	b.ne	ffffffffea806c7c <wait_queue_wake_all+0x84>  // b.any
	while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
ffffffffea806dac:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea806db0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806db4:	2a1303e0 	mov	w0, w19
ffffffffea806db8:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806dbc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806dc0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806dc4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806dc8:	d65f03c0 	ret
			thread_resched();
ffffffffea806dcc:	97fffbaf 	bl	ffffffffea805c88 <thread_resched>
	return ret;
ffffffffea806dd0:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea806dd4:	2a1303e0 	mov	w0, w19
	return ret;
ffffffffea806dd8:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea806ddc:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea806de0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806de4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806de8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea806dec:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea806df0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea806df4:	d65f03c0 	ret

ffffffffea806df8 <thread_detach>:
{
ffffffffea806df8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806dfc:	910003fd 	mov	x29, sp
ffffffffea806e00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806e04:	aa0003f3 	mov	x19, x0
ffffffffea806e08:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806e0c:	d53b4220 	mrs	x0, daif
ffffffffea806e10:	910a4275 	add	x21, x19, #0x290
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea806e14:	37380340 	tbnz	w0, #7, ffffffffea806e7c <thread_detach+0x84>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806e18:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806e1c:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806e20:	912ea294 	add	x20, x20, #0xba8
ffffffffea806e24:	aa1403e0 	mov	x0, x20
ffffffffea806e28:	97ffeea6 	bl	ffffffffea8028c0 <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806e2c:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806e30:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806e34:	aa1503e0 	mov	x0, x21
ffffffffea806e38:	97ffff70 	bl	ffffffffea806bf8 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806e3c:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806e40:	7100141f 	cmp	w0, #0x5
ffffffffea806e44:	54000461 	b.ne	ffffffffea806ed0 <thread_detach+0xd8>  // b.any
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806e48:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806e4c:	aa1403e0 	mov	x0, x20
ffffffffea806e50:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806e54:	b9003661 	str	w1, [x19, #52]
ffffffffea806e58:	97ffeea2 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea806e5c:	d50342ff 	msr	daifclr, #0x2
		return thread_join(t, NULL, 0);
ffffffffea806e60:	aa1303e0 	mov	x0, x19
}
ffffffffea806e64:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806e68:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806e6c:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806e70:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806e74:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea806e78:	17fffec6 	b	ffffffffea806990 <thread_join>
    arch_spin_lock(lock);
ffffffffea806e7c:	90000374 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806e80:	912ea294 	add	x20, x20, #0xba8
ffffffffea806e84:	aa1403e0 	mov	x0, x20
ffffffffea806e88:	97ffee8e 	bl	ffffffffea8028c0 <arch_spin_lock>
	wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
ffffffffea806e8c:	12800422 	mov	w2, #0xffffffde            	// #-34
ffffffffea806e90:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806e94:	aa1503e0 	mov	x0, x21
ffffffffea806e98:	97ffff58 	bl	ffffffffea806bf8 <wait_queue_wake_all>
	if (t->state == THREAD_DEATH) {
ffffffffea806e9c:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea806ea0:	7100141f 	cmp	w0, #0x5
ffffffffea806ea4:	540002c0 	b.eq	ffffffffea806efc <thread_detach+0x104>  // b.none
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806ea8:	b9403661 	ldr	w1, [x19, #52]
    arch_spin_unlock(lock);
ffffffffea806eac:	aa1403e0 	mov	x0, x20
ffffffffea806eb0:	32000021 	orr	w1, w1, #0x1
ffffffffea806eb4:	b9003661 	str	w1, [x19, #52]
ffffffffea806eb8:	97ffee8a 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea806ebc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806ec0:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806ec4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806ec8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806ecc:	d65f03c0 	ret
		t->flags |= THREAD_FLAG_DETACHED;
ffffffffea806ed0:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806ed4:	aa1403e0 	mov	x0, x20
ffffffffea806ed8:	32000021 	orr	w1, w1, #0x1
ffffffffea806edc:	b9003661 	str	w1, [x19, #52]
ffffffffea806ee0:	97ffee80 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea806ee4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea806ee8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea806eec:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea806ef0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea806ef4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea806ef8:	d65f03c0 	ret
		t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
ffffffffea806efc:	b9403661 	ldr	w1, [x19, #52]
ffffffffea806f00:	aa1403e0 	mov	x0, x20
ffffffffea806f04:	121f7821 	and	w1, w1, #0xfffffffe
ffffffffea806f08:	b9003661 	str	w1, [x19, #52]
ffffffffea806f0c:	97ffee75 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea806f10:	f94013f5 	ldr	x21, [sp, #32]
		return thread_join(t, NULL, 0);
ffffffffea806f14:	aa1303e0 	mov	x0, x19
ffffffffea806f18:	52800002 	mov	w2, #0x0                   	// #0
}
ffffffffea806f1c:	a94153f3 	ldp	x19, x20, [sp, #16]
		return thread_join(t, NULL, 0);
ffffffffea806f20:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea806f24:	a8c37bfd 	ldp	x29, x30, [sp], #48
		return thread_join(t, NULL, 0);
ffffffffea806f28:	17fffe9a 	b	ffffffffea806990 <thread_join>
ffffffffea806f2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806f30 <thread_exit>:
{
ffffffffea806f30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea806f34:	910003fd 	mov	x29, sp
ffffffffea806f38:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea806f3c:	aa1e03f4 	mov	x20, x30
ffffffffea806f40:	f90013f5 	str	x21, [sp, #32]
ffffffffea806f44:	2a0003f5 	mov	w21, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea806f48:	d538d093 	mrs	x19, tpidr_el1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea806f4c:	d53b4220 	mrs	x0, daif
ffffffffea806f50:	37380040 	tbnz	w0, #7, ffffffffea806f58 <thread_exit+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea806f54:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea806f58:	90000360 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea806f5c:	912ea000 	add	x0, x0, #0xba8
ffffffffea806f60:	97ffee58 	bl	ffffffffea8028c0 <arch_spin_lock>
	current_thread->retcode = retcode;
ffffffffea806f64:	b9028a75 	str	w21, [x19, #648]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806f68:	b9403661 	ldr	w1, [x19, #52]
	current_thread->state = THREAD_DEATH;
ffffffffea806f6c:	528000a0 	mov	w0, #0x5                   	// #5
ffffffffea806f70:	b9002e60 	str	w0, [x19, #44]
	if (current_thread->flags & THREAD_FLAG_DETACHED) {
ffffffffea806f74:	360002a1 	tbz	w1, #0, ffffffffea806fc8 <thread_exit+0x98>
	item->next->prev = item->prev;
ffffffffea806f78:	a9408262 	ldp	x2, x0, [x19, #8]
ffffffffea806f7c:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea806f80:	f9400662 	ldr	x2, [x19, #8]
ffffffffea806f84:	f9000440 	str	x0, [x2, #8]
		current_thread->magic = 0;
ffffffffea806f88:	b900027f 	str	wzr, [x19]
	item->prev = item->next = 0;
ffffffffea806f8c:	a900fe7f 	stp	xzr, xzr, [x19, #8]
		if (current_thread->flags & THREAD_FLAG_FREE_STACK && current_thread->stack)
ffffffffea806f90:	360800a1 	tbz	w1, #1, ffffffffea806fa4 <thread_exit+0x74>
ffffffffea806f94:	f9413660 	ldr	x0, [x19, #616]
ffffffffea806f98:	b4000060 	cbz	x0, ffffffffea806fa4 <thread_exit+0x74>
			heap_delayed_free(current_thread->stack);
ffffffffea806f9c:	94002f21 	bl	ffffffffea812c20 <heap_delayed_free>
ffffffffea806fa0:	b9403661 	ldr	w1, [x19, #52]
		if (current_thread->flags & THREAD_FLAG_FREE_STRUCT)
ffffffffea806fa4:	371000c1 	tbnz	w1, #2, ffffffffea806fbc <thread_exit+0x8c>
	thread_resched();
ffffffffea806fa8:	97fffb38 	bl	ffffffffea805c88 <thread_resched>
	panic("somehow fell through thread_exit()\n");
ffffffffea806fac:	b0000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea806fb0:	aa1403e0 	mov	x0, x20
ffffffffea806fb4:	9104c021 	add	x1, x1, #0x130
ffffffffea806fb8:	94002d72 	bl	ffffffffea812580 <_panic>
			heap_delayed_free(current_thread);
ffffffffea806fbc:	aa1303e0 	mov	x0, x19
ffffffffea806fc0:	94002f18 	bl	ffffffffea812c20 <heap_delayed_free>
ffffffffea806fc4:	17fffff9 	b	ffffffffea806fa8 <thread_exit+0x78>
		wait_queue_wake_all(&current_thread->retcode_wait_queue, false, 0);
ffffffffea806fc8:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea806fcc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea806fd0:	910a4260 	add	x0, x19, #0x290
ffffffffea806fd4:	97ffff09 	bl	ffffffffea806bf8 <wait_queue_wake_all>
ffffffffea806fd8:	17fffff4 	b	ffffffffea806fa8 <thread_exit+0x78>
ffffffffea806fdc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea806fe0 <wait_queue_destroy>:
 * @brief  Free all resources allocated in wait_queue_init()
 *
 * If any threads were waiting on this queue, they are all woken.
 */
void wait_queue_destroy(wait_queue_t *wait, bool reschedule)
{
ffffffffea806fe0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
#if THREAD_CHECKS
	ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea806fe4:	12800142 	mov	w2, #0xfffffff5            	// #-11
{
ffffffffea806fe8:	910003fd 	mov	x29, sp
ffffffffea806fec:	f9000bf3 	str	x19, [sp, #16]
ffffffffea806ff0:	aa0003f3 	mov	x19, x0
	wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
ffffffffea806ff4:	97ffff01 	bl	ffffffffea806bf8 <wait_queue_wake_all>
	wait->magic = 0;
ffffffffea806ff8:	b900027f 	str	wzr, [x19]
}
ffffffffea806ffc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea807000:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807004:	d65f03c0 	ret

ffffffffea807008 <thread_unblock_from_wait_queue>:
	ASSERT(t->magic == THREAD_MAGIC);
	ASSERT(arch_ints_disabled());
	ASSERT(spin_lock_held(&thread_lock));
#endif

	if (t->state != THREAD_BLOCKED)
ffffffffea807008:	b9402c02 	ldr	w2, [x0, #44]
ffffffffea80700c:	71000c5f 	cmp	w2, #0x3
ffffffffea807010:	540004c1 	b.ne	ffffffffea8070a8 <thread_unblock_from_wait_queue+0xa0>  // b.any
ffffffffea807014:	2a0103e3 	mov	w3, w1
ffffffffea807018:	aa0003e1 	mov	x1, x0
{
ffffffffea80701c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	run_queue_bitmap |= (1<<t->priority);
ffffffffea807020:	f0000348 	adrp	x8, ffffffffea872000 <idle_threads+0xeb0>
	item->next = list->next;
ffffffffea807024:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807028:	91264000 	add	x0, x0, #0x990
{
ffffffffea80702c:	910003fd 	mov	x29, sp
	item->next->prev = item->prev;
ffffffffea807030:	a941a424 	ldp	x4, x9, [x1, #24]
#endif

	list_delete(&t->queue_node);
	t->blocking_wait_queue->count--;
	t->blocking_wait_queue = NULL;
	t->state = THREAD_READY;
ffffffffea807034:	52800026 	mov	w6, #0x1                   	// #1
	list_add_head(&run_queue[t->priority], &t->queue_node);
ffffffffea807038:	b9402822 	ldr	w2, [x1, #40]
	list_delete(&t->queue_node);
ffffffffea80703c:	91006025 	add	x5, x1, #0x18
	t->blocking_wait_queue->count--;
ffffffffea807040:	f9402027 	ldr	x7, [x1, #64]
ffffffffea807044:	f9000124 	str	x4, [x9]
	item->next = list->next;
ffffffffea807048:	8b22d000 	add	x0, x0, w2, sxtw #4
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80704c:	b94b910a 	ldr	w10, [x8, #2960]
	item->prev->next = item->next;
ffffffffea807050:	f9400c2b 	ldr	x11, [x1, #24]
ffffffffea807054:	1ac220c2 	lsl	w2, w6, w2
	t->blocking_wait_queue->count--;
ffffffffea807058:	b94018e4 	ldr	w4, [x7, #24]
	run_queue_bitmap |= (1<<t->priority);
ffffffffea80705c:	2a0a0042 	orr	w2, w2, w10
ffffffffea807060:	b90b9102 	str	w2, [x8, #2960]
ffffffffea807064:	f9000569 	str	x9, [x11, #8]
	t->blocking_wait_queue->count--;
ffffffffea807068:	51000484 	sub	w4, w4, #0x1
	item->prev = item->next = 0;
ffffffffea80706c:	f900103f 	str	xzr, [x1, #32]
	item->next = list->next;
ffffffffea807070:	f9400402 	ldr	x2, [x0, #8]
ffffffffea807074:	b90018e4 	str	w4, [x7, #24]
ffffffffea807078:	a9018820 	stp	x0, x2, [x1, #24]
	t->state = THREAD_READY;
ffffffffea80707c:	b9002c26 	str	w6, [x1, #44]
	list->next->prev = item;
ffffffffea807080:	f9400402 	ldr	x2, [x0, #8]
	t->blocking_wait_queue = NULL;
ffffffffea807084:	f900203f 	str	xzr, [x1, #64]
	t->wait_queue_block_ret = wait_queue_error;
ffffffffea807088:	b9004823 	str	w3, [x1, #72]
ffffffffea80708c:	f9000045 	str	x5, [x2]
	list->next = item;
ffffffffea807090:	f9000405 	str	x5, [x0, #8]
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea807094:	d538d080 	mrs	x0, tpidr_el1
	insert_in_run_queue_head(t);
	thread_mp_reschedule(get_current_thread(), t);
ffffffffea807098:	97fffacc 	bl	ffffffffea805bc8 <thread_mp_reschedule>

	return NO_ERROR;
ffffffffea80709c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea8070a0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8070a4:	d65f03c0 	ret
		return ERR_NOT_BLOCKED;
ffffffffea8070a8:	12800160 	mov	w0, #0xfffffff4            	// #-12
}
ffffffffea8070ac:	d65f03c0 	ret

ffffffffea8070b0 <wait_queue_timeout_handler>:
{
ffffffffea8070b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8070b4:	910003fd 	mov	x29, sp
ffffffffea8070b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8070bc:	f0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8070c0:	912ea273 	add	x19, x19, #0xba8
ffffffffea8070c4:	aa0203f4 	mov	x20, x2
ffffffffea8070c8:	aa1303e0 	mov	x0, x19
ffffffffea8070cc:	97ffedfd 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (thread_unblock_from_wait_queue(thread, ERR_TIMED_OUT) >= NO_ERROR) {
ffffffffea8070d0:	12800181 	mov	w1, #0xfffffff3            	// #-13
ffffffffea8070d4:	aa1403e0 	mov	x0, x20
ffffffffea8070d8:	97ffffcc 	bl	ffffffffea807008 <thread_unblock_from_wait_queue>
ffffffffea8070dc:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea8070e0:	aa1303e0 	mov	x0, x19
ffffffffea8070e4:	97ffedff 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8070e8:	2a3403e0 	mvn	w0, w20
}
ffffffffea8070ec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8070f0:	531f7c00 	lsr	w0, w0, #31
ffffffffea8070f4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8070f8:	d65f03c0 	ret
ffffffffea8070fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807100 <insert_timer_in_queue>:

	DEBUG_ASSERT(arch_ints_disabled());

	LTRACEF("timer %p, cpu %u, scheduled %u, periodic %u\n", timer, cpu, timer->scheduled_time, timer->periodic_time);

	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea807100:	2a0003e0 	mov	w0, w0
ffffffffea807104:	f0000347 	adrp	x7, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807108:	912f00e5 	add	x5, x7, #0xbc0
ffffffffea80710c:	8b0014a5 	add	x5, x5, x0, lsl #5
ffffffffea807110:	f94004a2 	ldr	x2, [x5, #8]
ffffffffea807114:	aa0203e4 	mov	x4, x2
ffffffffea807118:	d1002042 	sub	x2, x2, #0x8
ffffffffea80711c:	eb0400bf 	cmp	x5, x4
ffffffffea807120:	54000200 	b.eq	ffffffffea807160 <insert_timer_in_queue+0x60>  // b.none
		if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
ffffffffea807124:	b9401826 	ldr	w6, [x1, #24]
ffffffffea807128:	b9401843 	ldr	w3, [x2, #24]
ffffffffea80712c:	4b060063 	sub	w3, w3, w6
ffffffffea807130:	7100007f 	cmp	w3, #0x0
ffffffffea807134:	540000cd 	b.le	ffffffffea80714c <insert_timer_in_queue+0x4c>
ffffffffea807138:	14000013 	b	ffffffffea807184 <insert_timer_in_queue+0x84>
ffffffffea80713c:	b9401843 	ldr	w3, [x2, #24]
ffffffffea807140:	4b060063 	sub	w3, w3, w6
ffffffffea807144:	7100007f 	cmp	w3, #0x0
ffffffffea807148:	540001ec 	b.gt	ffffffffea807184 <insert_timer_in_queue+0x84>
	list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
ffffffffea80714c:	f9400842 	ldr	x2, [x2, #16]
ffffffffea807150:	aa0203e4 	mov	x4, x2
ffffffffea807154:	d1002042 	sub	x2, x2, #0x8
ffffffffea807158:	eb05009f 	cmp	x4, x5
ffffffffea80715c:	54ffff01 	b.ne	ffffffffea80713c <insert_timer_in_queue+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea807160:	912f00e7 	add	x7, x7, #0xbc0
ffffffffea807164:	d37be800 	lsl	x0, x0, #5
			return;
		}
	}

	/* walked off the end of the list */
	list_add_tail(&timers[cpu].timer_queue, &timer->node);
ffffffffea807168:	91002022 	add	x2, x1, #0x8
ffffffffea80716c:	f86068e3 	ldr	x3, [x7, x0]
	item->next = list;
ffffffffea807170:	a9009423 	stp	x3, x5, [x1, #8]
	list->prev->next = item;
ffffffffea807174:	f86068e1 	ldr	x1, [x7, x0]
ffffffffea807178:	f9000422 	str	x2, [x1, #8]
	list->prev = item;
ffffffffea80717c:	f82068e2 	str	x2, [x7, x0]
}
ffffffffea807180:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea807184:	f9400440 	ldr	x0, [x2, #8]
	item->next = list;
ffffffffea807188:	a9009020 	stp	x0, x4, [x1, #8]
			list_add_before(&entry->node, &timer->node);
ffffffffea80718c:	91002021 	add	x1, x1, #0x8
	list->prev->next = item;
ffffffffea807190:	f9400440 	ldr	x0, [x2, #8]
ffffffffea807194:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea807198:	f9000441 	str	x1, [x2, #8]
}
ffffffffea80719c:	d65f03c0 	ret

ffffffffea8071a0 <timer_tick>:
	spin_unlock_irqrestore(&timer_lock, state);
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, lk_time_t now)
{
ffffffffea8071a0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea8071a4:	910003fd 	mov	x29, sp
ffffffffea8071a8:	a9025bf5 	stp	x21, x22, [sp, #32]
    arch_spin_lock(lock);
ffffffffea8071ac:	f00002d5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea8071b0:	a90153f3 	stp	x19, x20, [sp, #16]

	spin_lock(&timer_lock);

	for (;;) {
		/* see if there's an event to process */
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8071b4:	f0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
{
ffffffffea8071b8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8071bc:	2a0103f8 	mov	w24, w1
ffffffffea8071c0:	a9046bf9 	stp	x25, x26, [sp, #64]
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8071c4:	912f0273 	add	x19, x19, #0xbc0
{
ffffffffea8071c8:	f9002bfb 	str	x27, [sp, #80]
	uint cpu = arch_curr_cpu_num();
ffffffffea8071cc:	97ffee41 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea8071d0:	f94092b4 	ldr	x20, [x21, #288]
ffffffffea8071d4:	2a0003f7 	mov	w23, w0
	enum handler_return ret = INT_NO_RESCHEDULE;
ffffffffea8071d8:	52800016 	mov	w22, #0x0                   	// #0
		bool periodic = timer->periodic_time > 0;

		LTRACEF("timer %p firing callback %p, arg %p\n", timer, timer->callback, timer->arg);
		KEVLOG_TIMER_CALL(timer->callback, timer->arg);
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
			ret = INT_RESCHEDULE;
ffffffffea8071dc:	52800039 	mov	w25, #0x1                   	// #1
ffffffffea8071e0:	aa1403e0 	mov	x0, x20
ffffffffea8071e4:	97ffedb7 	bl	ffffffffea8028c0 <arch_spin_lock>
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8071e8:	d37b7ee0 	ubfiz	x0, x23, #5, #32
ffffffffea8071ec:	aa1403fb 	mov	x27, x20
ffffffffea8071f0:	8b000273 	add	x19, x19, x0
	if (list->next != list) {
ffffffffea8071f4:	aa1303fa 	mov	x26, x19
ffffffffea8071f8:	f9400740 	ldr	x0, [x26, #8]
ffffffffea8071fc:	eb00027f 	cmp	x19, x0
ffffffffea807200:	540000e0 	b.eq	ffffffffea80721c <timer_tick+0x7c>  // b.none
ffffffffea807204:	f9002fbc 	str	x28, [x29, #88]
		if (likely(timer == 0))
ffffffffea807208:	f100201f 	cmp	x0, #0x8
		timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea80720c:	d100201c 	sub	x28, x0, #0x8
ffffffffea807210:	b4000040 	cbz	x0, ffffffffea807218 <timer_tick+0x78>
		if (likely(timer == 0))
ffffffffea807214:	54000181 	b.ne	ffffffffea807244 <timer_tick+0xa4>  // b.any
ffffffffea807218:	f9402fbc 	ldr	x28, [x29, #88]
    arch_spin_unlock(lock);
ffffffffea80721c:	f94092a0 	ldr	x0, [x21, #288]
ffffffffea807220:	97ffedb0 	bl	ffffffffea8028e0 <arch_spin_unlock>
	if (thread_timer_tick() == INT_RESCHEDULE)
		ret = INT_RESCHEDULE;
#endif

	return ret;
}
ffffffffea807224:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea807228:	2a1603e0 	mov	w0, w22
ffffffffea80722c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807230:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea807234:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea807238:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80723c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea807240:	d65f03c0 	ret
		if (likely(TIME_LT(now, timer->scheduled_time)))
ffffffffea807244:	b9401b82 	ldr	w2, [x28, #24]
ffffffffea807248:	4b020300 	sub	w0, w24, w2
ffffffffea80724c:	36f80100 	tbz	w0, #31, ffffffffea80726c <timer_tick+0xcc>
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807250:	90000000 	adrp	x0, ffffffffea807000 <wait_queue_destroy+0x20>
ffffffffea807254:	4b180042 	sub	w2, w2, w24
ffffffffea807258:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80725c:	91068000 	add	x0, x0, #0x1a0
ffffffffea807260:	97fff7fe 	bl	ffffffffea805258 <platform_set_oneshot_timer>
ffffffffea807264:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea807268:	17ffffed 	b	ffffffffea80721c <timer_tick+0x7c>
	item->next->prev = item->prev;
ffffffffea80726c:	a9408782 	ldp	x2, x1, [x28, #8]
ffffffffea807270:	aa1403e0 	mov	x0, x20
ffffffffea807274:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea807278:	f9400782 	ldr	x2, [x28, #8]
ffffffffea80727c:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea807280:	a900ff9f 	stp	xzr, xzr, [x28, #8]
ffffffffea807284:	97ffed97 	bl	ffffffffea8028e0 <arch_spin_unlock>
		bool periodic = timer->periodic_time > 0;
ffffffffea807288:	b9401f83 	ldr	w3, [x28, #28]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
ffffffffea80728c:	2a1803e1 	mov	w1, w24
ffffffffea807290:	a9420b84 	ldp	x4, x2, [x28, #32]
		bool periodic = timer->periodic_time > 0;
ffffffffea807294:	b9006fa3 	str	w3, [x29, #108]
		if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
ffffffffea807298:	aa1c03e0 	mov	x0, x28
ffffffffea80729c:	d63f0080 	blr	x4
			ret = INT_RESCHEDULE;
ffffffffea8072a0:	7100041f 	cmp	w0, #0x1
ffffffffea8072a4:	1a9912d6 	csel	w22, w22, w25, ne  // ne = any
    arch_spin_lock(lock);
ffffffffea8072a8:	aa1b03e0 	mov	x0, x27
ffffffffea8072ac:	97ffed85 	bl	ffffffffea8028c0 <arch_spin_lock>
		if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
ffffffffea8072b0:	b9406fa3 	ldr	w3, [x29, #108]
ffffffffea8072b4:	34000063 	cbz	w3, ffffffffea8072c0 <timer_tick+0x120>
	if (item->prev == 0 && item->next == 0)
ffffffffea8072b8:	f9400780 	ldr	x0, [x28, #8]
ffffffffea8072bc:	b4000060 	cbz	x0, ffffffffea8072c8 <timer_tick+0x128>
ffffffffea8072c0:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea8072c4:	17ffffcd 	b	ffffffffea8071f8 <timer_tick+0x58>
ffffffffea8072c8:	f9400b80 	ldr	x0, [x28, #16]
ffffffffea8072cc:	b5ffffa0 	cbnz	x0, ffffffffea8072c0 <timer_tick+0x120>
ffffffffea8072d0:	b9401f80 	ldr	w0, [x28, #28]
ffffffffea8072d4:	34ffff60 	cbz	w0, ffffffffea8072c0 <timer_tick+0x120>
			timer->scheduled_time = now + timer->periodic_time;
ffffffffea8072d8:	0b180000 	add	w0, w0, w24
ffffffffea8072dc:	b9001b80 	str	w0, [x28, #24]
			insert_timer_in_queue(cpu, timer);
ffffffffea8072e0:	aa1c03e1 	mov	x1, x28
ffffffffea8072e4:	2a1703e0 	mov	w0, w23
ffffffffea8072e8:	97ffff86 	bl	ffffffffea807100 <insert_timer_in_queue>
ffffffffea8072ec:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea8072f0:	17ffffc2 	b	ffffffffea8071f8 <timer_tick+0x58>
ffffffffea8072f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8072f8 <timer_set>:
{
ffffffffea8072f8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8072fc:	910003fd 	mov	x29, sp
ffffffffea807300:	f90013f5 	str	x21, [sp, #32]
ffffffffea807304:	2a0103f5 	mov	w21, w1
ffffffffea807308:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80730c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea807310:	aa0003f3 	mov	x19, x0
ffffffffea807314:	b5000681 	cbnz	x1, ffffffffea8073e4 <timer_set+0xec>
ffffffffea807318:	f9400801 	ldr	x1, [x0, #16]
ffffffffea80731c:	b5000641 	cbnz	x1, ffffffffea8073e4 <timer_set+0xec>
ffffffffea807320:	f9000fb4 	str	x20, [x29, #24]
ffffffffea807324:	aa0403f4 	mov	x20, x4
ffffffffea807328:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80732c:	2a0203f7 	mov	w23, w2
ffffffffea807330:	aa0303f6 	mov	x22, x3
	now = current_time();
ffffffffea807334:	97fff815 	bl	ffffffffea805388 <current_time>
	timer->arg = arg;
ffffffffea807338:	a9025276 	stp	x22, x20, [x19, #32]
	timer->scheduled_time = now + delay;
ffffffffea80733c:	0b150000 	add	w0, w0, w21
	timer->periodic_time = period;
ffffffffea807340:	29035e60 	stp	w0, w23, [x19, #24]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807344:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea807348:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80734c:	36380340 	tbz	w0, #7, ffffffffea8073b4 <timer_set+0xbc>
ffffffffea807350:	f00002d6 	adrp	x22, ffffffffea862000 <__ctor_list>
ffffffffea807354:	f94092c0 	ldr	x0, [x22, #288]
ffffffffea807358:	97ffed5a 	bl	ffffffffea8028c0 <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea80735c:	97ffeddd 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea807360:	2a0003e8 	mov	w8, w0
	insert_timer_in_queue(cpu, timer);
ffffffffea807364:	aa1303e1 	mov	x1, x19
ffffffffea807368:	97ffff66 	bl	ffffffffea807100 <insert_timer_in_queue>
	if (list->next != list) {
ffffffffea80736c:	d37b7d08 	ubfiz	x8, x8, #5, #32
ffffffffea807370:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807374:	912f0000 	add	x0, x0, #0xbc0
ffffffffea807378:	8b080000 	add	x0, x0, x8
ffffffffea80737c:	f9400401 	ldr	x1, [x0, #8]
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea807380:	f100003f 	cmp	x1, #0x0
ffffffffea807384:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea807388:	540001c1 	b.ne	ffffffffea8073c0 <timer_set+0xc8>  // b.any
    arch_spin_unlock(lock);
ffffffffea80738c:	f94092c0 	ldr	x0, [x22, #288]
ffffffffea807390:	97ffed54 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807394:	34000054 	cbz	w20, ffffffffea80739c <timer_set+0xa4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea807398:	d50342ff 	msr	daifclr, #0x2
ffffffffea80739c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea8073a0:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea8073a4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8073a8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8073ac:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8073b0:	d65f03c0 	ret
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8073b4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8073b8:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea8073bc:	17ffffe5 	b	ffffffffea807350 <timer_set+0x58>
	if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
ffffffffea8073c0:	d1002021 	sub	x1, x1, #0x8
ffffffffea8073c4:	eb01027f 	cmp	x19, x1
ffffffffea8073c8:	54fffe21 	b.ne	ffffffffea80738c <timer_set+0x94>  // b.any
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea8073cc:	90000000 	adrp	x0, ffffffffea807000 <wait_queue_destroy+0x20>
ffffffffea8073d0:	2a1503e2 	mov	w2, w21
ffffffffea8073d4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8073d8:	91068000 	add	x0, x0, #0x1a0
ffffffffea8073dc:	97fff79f 	bl	ffffffffea805258 <platform_set_oneshot_timer>
ffffffffea8073e0:	17ffffeb 	b	ffffffffea80738c <timer_set+0x94>
		panic("timer %p already in list\n", timer);
ffffffffea8073e4:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8073e8:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea8073ec:	aa1303e2 	mov	x2, x19
ffffffffea8073f0:	9105a021 	add	x1, x1, #0x168
ffffffffea8073f4:	aa1e03e0 	mov	x0, x30
ffffffffea8073f8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8073fc:	94002c61 	bl	ffffffffea812580 <_panic>

ffffffffea807400 <timer_initialize>:
	*timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
ffffffffea807400:	528dae41 	mov	w1, #0x6d72                	// #28018
ffffffffea807404:	a900fc1f 	stp	xzr, xzr, [x0, #8]
ffffffffea807408:	72ae8d21 	movk	w1, #0x7469, lsl #16
ffffffffea80740c:	b9000001 	str	w1, [x0]
ffffffffea807410:	a901fc1f 	stp	xzr, xzr, [x0, #24]
ffffffffea807414:	f900141f 	str	xzr, [x0, #40]
}
ffffffffea807418:	d65f03c0 	ret
ffffffffea80741c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807420 <timer_set_oneshot>:
		delay = 1;
ffffffffea807420:	7100003f 	cmp	w1, #0x0
	timer_set(timer, delay, 0, callback, arg);
ffffffffea807424:	aa0303e4 	mov	x4, x3
ffffffffea807428:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
ffffffffea80742c:	aa0203e3 	mov	x3, x2
ffffffffea807430:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea807434:	17ffffb1 	b	ffffffffea8072f8 <timer_set>

ffffffffea807438 <timer_set_periodic>:
		period = 1;
ffffffffea807438:	7100003f 	cmp	w1, #0x0
	timer_set(timer, period, period, callback, arg);
ffffffffea80743c:	aa0303e4 	mov	x4, x3
		period = 1;
ffffffffea807440:	1a9f1421 	csinc	w1, w1, wzr, ne  // ne = any
	timer_set(timer, period, period, callback, arg);
ffffffffea807444:	aa0203e3 	mov	x3, x2
ffffffffea807448:	2a0103e2 	mov	w2, w1
ffffffffea80744c:	17ffffab 	b	ffffffffea8072f8 <timer_set>

ffffffffea807450 <timer_cancel>:
{
ffffffffea807450:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea807454:	910003fd 	mov	x29, sp
ffffffffea807458:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80745c:	aa0003f3 	mov	x19, x0
ffffffffea807460:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807464:	d53b4220 	mrs	x0, daif
ffffffffea807468:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80746c:	37380060 	tbnz	w0, #7, ffffffffea807478 <timer_cancel+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807470:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807474:	52800035 	mov	w21, #0x1                   	// #1
    arch_spin_lock(lock);
ffffffffea807478:	f00002d4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80747c:	f9409280 	ldr	x0, [x20, #288]
ffffffffea807480:	97ffed10 	bl	ffffffffea8028c0 <arch_spin_lock>
	uint cpu = arch_curr_cpu_num();
ffffffffea807484:	97ffed93 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	timer_t *oldhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea807488:	2a0003e0 	mov	w0, w0
ffffffffea80748c:	f0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807490:	912f0041 	add	x1, x2, #0xbc0
ffffffffea807494:	8b001421 	add	x1, x1, x0, lsl #5
ffffffffea807498:	a9409666 	ldp	x6, x5, [x19, #8]
ffffffffea80749c:	f9400423 	ldr	x3, [x1, #8]
ffffffffea8074a0:	f100007f 	cmp	x3, #0x0
ffffffffea8074a4:	d1002064 	sub	x4, x3, #0x8
ffffffffea8074a8:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea8074ac:	9a9f1084 	csel	x4, x4, xzr, ne  // ne = any
	if (item->prev == 0 && item->next == 0)
ffffffffea8074b0:	b4000486 	cbz	x6, ffffffffea807540 <timer_cancel+0xf0>
	item->next->prev = item->prev;
ffffffffea8074b4:	f90000a6 	str	x6, [x5]
	item->prev->next = item->next;
ffffffffea8074b8:	f9400663 	ldr	x3, [x19, #8]
ffffffffea8074bc:	f9000465 	str	x5, [x3, #8]
	item->prev = item->next = 0;
ffffffffea8074c0:	a900fe7f 	stp	xzr, xzr, [x19, #8]
	if (list->next != list) {
ffffffffea8074c4:	912f0042 	add	x2, x2, #0xbc0
ffffffffea8074c8:	8b001440 	add	x0, x2, x0, lsl #5
ffffffffea8074cc:	f9400400 	ldr	x0, [x0, #8]
	timer->periodic_time = 0;
ffffffffea8074d0:	b9001e7f 	str	wzr, [x19, #28]
	timer->arg = NULL;
ffffffffea8074d4:	a9027e7f 	stp	xzr, xzr, [x19, #32]
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8074d8:	f100001f 	cmp	x0, #0x0
ffffffffea8074dc:	fa401024 	ccmp	x1, x0, #0x4, ne  // ne = any
ffffffffea8074e0:	540001e0 	b.eq	ffffffffea80751c <timer_cancel+0xcc>  // b.none
	if (newhead == NULL) {
ffffffffea8074e4:	f100201f 	cmp	x0, #0x8
ffffffffea8074e8:	540001a0 	b.eq	ffffffffea80751c <timer_cancel+0xcc>  // b.none
	timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
ffffffffea8074ec:	d1002013 	sub	x19, x0, #0x8
	} else if (newhead != oldhead) {
ffffffffea8074f0:	eb13009f 	cmp	x4, x19
ffffffffea8074f4:	54000160 	b.eq	ffffffffea807520 <timer_cancel+0xd0>  // b.none
		lk_time_t now = current_time();
ffffffffea8074f8:	97fff7a4 	bl	ffffffffea805388 <current_time>
		if (TIME_LT(newhead->scheduled_time, now))
ffffffffea8074fc:	b9401a62 	ldr	w2, [x19, #24]
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea807500:	90000003 	adrp	x3, ffffffffea807000 <wait_queue_destroy+0x20>
ffffffffea807504:	d2800001 	mov	x1, #0x0                   	// #0
			delay = 0;
ffffffffea807508:	6b000042 	subs	w2, w2, w0
		platform_set_oneshot_timer(timer_tick, NULL, delay);
ffffffffea80750c:	91068060 	add	x0, x3, #0x1a0
ffffffffea807510:	1a9f5042 	csel	w2, w2, wzr, pl  // pl = nfrst
ffffffffea807514:	97fff751 	bl	ffffffffea805258 <platform_set_oneshot_timer>
ffffffffea807518:	14000002 	b	ffffffffea807520 <timer_cancel+0xd0>
		platform_stop_timer();
ffffffffea80751c:	97fff77d 	bl	ffffffffea805310 <platform_stop_timer>
    arch_spin_unlock(lock);
ffffffffea807520:	f9409280 	ldr	x0, [x20, #288]
ffffffffea807524:	97ffecef 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea807528:	34000055 	cbz	w21, ffffffffea807530 <timer_cancel+0xe0>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80752c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea807530:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807534:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807538:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80753c:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea807540:	b5fffba5 	cbnz	x5, ffffffffea8074b4 <timer_cancel+0x64>
ffffffffea807544:	17ffffe0 	b	ffffffffea8074c4 <timer_cancel+0x74>

ffffffffea807548 <timer_init>:

void timer_init(void)
{
	timer_lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea807548:	f00002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
ffffffffea80754c:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807550:	912f0000 	add	x0, x0, #0xbc0
ffffffffea807554:	f9409042 	ldr	x2, [x2, #288]
ffffffffea807558:	91040001 	add	x1, x0, #0x100
ffffffffea80755c:	f900005f 	str	xzr, [x2]
	list->prev = list->next = list;
ffffffffea807560:	a9000000 	stp	x0, x0, [x0]
ffffffffea807564:	91008000 	add	x0, x0, #0x20
	for (uint i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea807568:	eb01001f 	cmp	x0, x1
ffffffffea80756c:	54ffffa1 	b.ne	ffffffffea807560 <timer_init+0x18>  // b.any
	}
#if !PLATFORM_HAS_DYNAMIC_TIMER
	/* register for a periodic timer tick */
	platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
#endif
}
ffffffffea807570:	d65f03c0 	ret
ffffffffea807574:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807578 <mp_init>:
/* a global state structure, aligned on cpu cache line to minimize aliasing */
struct mp_state mp __CPU_ALIGN;

void mp_init(void)
{
}
ffffffffea807578:	d65f03c0 	ret
ffffffffea80757c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807580 <mp_reschedule>:

void mp_reschedule(mp_cpu_mask_t target, uint flags)
{
ffffffffea807580:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea807584:	910003fd 	mov	x29, sp
ffffffffea807588:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80758c:	2a0003f4 	mov	w20, w0
ffffffffea807590:	2a0103f3 	mov	w19, w1
#if WITH_SMP
	uint local_cpu = arch_curr_cpu_num();
ffffffffea807594:	97ffed4f 	bl	ffffffffea802ad0 <arch_curr_cpu_num>

	LTRACEF("local %d, target 0x%x\n", local_cpu, target);

	/* mask out cpus that are not active and the local cpu */
	target &= mp.active_cpus;
ffffffffea807598:	f00002c4 	adrp	x4, ffffffffea862000 <__ctor_list>
ffffffffea80759c:	f9409c84 	ldr	x4, [x4, #312]
ffffffffea8075a0:	b9400082 	ldr	w2, [x4]
ffffffffea8075a4:	0a140042 	and	w2, w2, w20

	/* mask out cpus that are currently running realtime code */
	if ((flags & MP_RESCHEDULE_FLAG_REALTIME) == 0) {
ffffffffea8075a8:	37000073 	tbnz	w19, #0, ffffffffea8075b4 <mp_reschedule+0x34>
		target &= ~mp.realtime_cpus;
ffffffffea8075ac:	b9400881 	ldr	w1, [x4, #8]
ffffffffea8075b0:	0a210042 	bic	w2, w2, w1

	LTRACEF("local %d, post mask target now 0x%x\n", local_cpu, target);

	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
#endif
}
ffffffffea8075b4:	a94153f3 	ldp	x19, x20, [sp, #16]
	target &= ~(1U << local_cpu);
ffffffffea8075b8:	52800023 	mov	w3, #0x1                   	// #1
}
ffffffffea8075bc:	a8c27bfd 	ldp	x29, x30, [sp], #32
	target &= ~(1U << local_cpu);
ffffffffea8075c0:	1ac02060 	lsl	w0, w3, w0
	arch_mp_send_ipi(target, MP_IPI_RESCHEDULE);
ffffffffea8075c4:	2a0303e1 	mov	w1, w3
ffffffffea8075c8:	0a200040 	bic	w0, w2, w0
ffffffffea8075cc:	17ffef37 	b	ffffffffea8032a8 <arch_mp_send_ipi>

ffffffffea8075d0 <mp_set_curr_cpu_active>:

void mp_set_curr_cpu_active(bool active)
{
ffffffffea8075d0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8075d4:	910003fd 	mov	x29, sp
	atomic_or((volatile int *)&mp.active_cpus, 1U << arch_curr_cpu_num());
ffffffffea8075d8:	97ffed3e 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea8075dc:	f00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea8075e0:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea8075e4:	1ac02040 	lsl	w0, w2, w0
ffffffffea8075e8:	f9409c21 	ldr	x1, [x1, #312]
ffffffffea8075ec:	885f7c22 	ldxr	w2, [x1]
ffffffffea8075f0:	2a000042 	orr	w2, w2, w0
ffffffffea8075f4:	88037c22 	stxr	w3, w2, [x1]
ffffffffea8075f8:	35ffffa3 	cbnz	w3, ffffffffea8075ec <mp_set_curr_cpu_active+0x1c>
}
ffffffffea8075fc:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea807600:	d65f03c0 	ret
ffffffffea807604:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807608 <mp_mbx_reschedule_irq>:

#if WITH_SMP
enum handler_return mp_mbx_reschedule_irq(void)
{
ffffffffea807608:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80760c:	910003fd 	mov	x29, sp
	uint cpu = arch_curr_cpu_num();
ffffffffea807610:	97ffed30 	bl	ffffffffea802ad0 <arch_curr_cpu_num>

	LTRACEF("cpu %u\n", cpu);

	THREAD_STATS_INC(reschedule_ipis);

	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea807614:	f00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
}
ffffffffea807618:	a8c17bfd 	ldp	x29, x30, [sp], #16
	return (mp.active_cpus & (1U << cpu)) ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
ffffffffea80761c:	f9409c21 	ldr	x1, [x1, #312]
ffffffffea807620:	b9400021 	ldr	w1, [x1]
ffffffffea807624:	1ac02420 	lsr	w0, w1, w0
}
ffffffffea807628:	12000000 	and	w0, w0, #0x1
ffffffffea80762c:	d65f03c0 	ret

ffffffffea807630 <tegra_boot_profiler_init>:
 * If the profiler is not enabled then we just turn all of the profiler
 * functions into no-ops.
 * The '(void)' statements are to silence compiler
 * warnings */

long tegra_boot_profiler_init(paddr_t boot_arg){ return 0L; }
ffffffffea807630:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea807634:	d65f03c0 	ret

ffffffffea807638 <tegra_boot_profiler_deinit>:

void tegra_boot_profiler_deinit(void){ ; }
ffffffffea807638:	d65f03c0 	ret
ffffffffea80763c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807640 <tegra_boot_profiler_get_timestamp>:

uint32_t tegra_boot_profiler_get_timestamp(void) { return 0U; }
ffffffffea807640:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea807644:	d65f03c0 	ret

ffffffffea807648 <tegra_boot_profiler_record>:

/* If TOS boot profiler is NOT enabled no records will be added */
void tegra_boot_profiler_record(const char *str) {
	(void)str;
}
ffffffffea807648:	d65f03c0 	ret
ffffffffea80764c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807650 <tegra_boot_profiler_prerecorded>:

void tegra_boot_profiler_prerecorded(const char *str, uint32_t tstamp) {
	(void)str;
	(void)tstamp;
}
ffffffffea807650:	d65f03c0 	ret
ffffffffea807654:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807658 <memlog_init>:
static smc32_entity_t log_sm_entity = {
	.stdcall_handler = memlog_stdcall,
};

static void memlog_init(uint level)
{
ffffffffea807658:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea80765c:	d0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea807660:	52800660 	mov	w0, #0x33                  	// #51
ffffffffea807664:	9115a021 	add	x1, x1, #0x568
{
ffffffffea807668:	910003fd 	mov	x29, sp
	err = sm_register_entity(SMC_ENTITY_LOGGING, &log_sm_entity);
ffffffffea80766c:	9400052f 	bl	ffffffffea808b28 <sm_register_entity>
	if (err) {
ffffffffea807670:	35000060 	cbnz	w0, ffffffffea80767c <memlog_init+0x24>
		printf("trusty error register entity: %d\n", err);
	}
}
ffffffffea807674:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea807678:	d65f03c0 	ret
ffffffffea80767c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		printf("trusty error register entity: %d\n", err);
ffffffffea807680:	90000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807684:	2a0003e1 	mov	w1, w0
ffffffffea807688:	91072040 	add	x0, x2, #0x1c8
ffffffffea80768c:	14003173 	b	ffffffffea813c58 <_printf>

ffffffffea807690 <memlog_print_callback>:
{
ffffffffea807690:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea807694:	910003fd 	mov	x29, sp
ffffffffea807698:	a90153f3 	stp	x19, x20, [sp, #16]
	struct memlog *log = containerof(cb, struct memlog, cb);
ffffffffea80769c:	d1008014 	sub	x20, x0, #0x20
{
ffffffffea8076a0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8076a4:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8076a8:	aa0003f7 	mov	x23, x0
ffffffffea8076ac:	f90023f9 	str	x25, [sp, #64]
ffffffffea8076b0:	aa0103f8 	mov	x24, x1
ffffffffea8076b4:	aa0203f9 	mov	x25, x2
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8076b8:	d53b4220 	mrs	x0, daif
ffffffffea8076bc:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8076c0:	37380060 	tbnz	w0, #7, ffffffffea8076cc <memlog_print_callback+0x3c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8076c4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8076c8:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8076cc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8076d0:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea8076d4:	37300080 	tbnz	w0, #6, ffffffffea8076e4 <memlog_print_callback+0x54>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8076d8:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8076dc:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea8076e0:	52800053 	mov	w19, #0x2                   	// #2
    arch_spin_lock(lock);
ffffffffea8076e4:	f0000356 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8076e8:	913302c0 	add	x0, x22, #0xcc0
ffffffffea8076ec:	97ffec75 	bl	ffffffffea8028c0 <arch_spin_lock>
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea8076f0:	d347ff2a 	lsr	x10, x25, #7
ffffffffea8076f4:	b40003ea 	cbz	x10, ffffffffea807770 <memlog_print_callback+0xe0>
ffffffffea8076f8:	d379e14a 	lsl	x10, x10, #7
ffffffffea8076fc:	aa1803e7 	mov	x7, x24
ffffffffea807700:	8b180149 	add	x9, x10, x24
ffffffffea807704:	d503201f 	nop
		__memlog_write(log, &str[i * chunk_size], chunk_size);
ffffffffea807708:	f9400286 	ldr	x6, [x20]
	log_offset = rb->alloc;
ffffffffea80770c:	b94000c8 	ldr	w8, [x6]
	rb->alloc += len;
ffffffffea807710:	b94000c0 	ldr	w0, [x6]
ffffffffea807714:	11020000 	add	w0, w0, #0x80
ffffffffea807718:	b90000c0 	str	w0, [x6]
	wmb();
ffffffffea80771c:	d5033e9f 	dsb	st
	for (i = 0; i < len; i++) {
ffffffffea807720:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea807724:	d503201f 	nop
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807728:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80772c:	0b030105 	add	w5, w8, w3
		*ptr = str[i];
ffffffffea807730:	386368e4 	ldrb	w4, [x7, x3]
	for (i = 0; i < len; i++) {
ffffffffea807734:	91000463 	add	x3, x3, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807738:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea80773c:	f102007f 	cmp	x3, #0x80
		*ptr = str[i];
ffffffffea807740:	0a050000 	and	w0, w0, w5
ffffffffea807744:	8b0000c0 	add	x0, x6, x0
ffffffffea807748:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea80774c:	54fffee1 	b.ne	ffffffffea807728 <memlog_print_callback+0x98>  // b.any
	wmb();
ffffffffea807750:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea807754:	b94004c0 	ldr	w0, [x6, #4]
ffffffffea807758:	910200e7 	add	x7, x7, #0x80
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea80775c:	eb07013f 	cmp	x9, x7
	rb->put += len;
ffffffffea807760:	11020000 	add	w0, w0, #0x80
ffffffffea807764:	b90004c0 	str	w0, [x6, #4]
	for (i = 0; i < len / chunk_size; i++) {
ffffffffea807768:	54fffd01 	b.ne	ffffffffea807708 <memlog_print_callback+0x78>  // b.any
ffffffffea80776c:	cb0a0339 	sub	x25, x25, x10
	if (rem) {
ffffffffea807770:	b4000319 	cbz	x25, ffffffffea8077d0 <memlog_print_callback+0x140>
		__memlog_write(log, &str[i * chunk_size], rem);
ffffffffea807774:	f85e02e3 	ldur	x3, [x23, #-32]
	rb->alloc += len;
ffffffffea807778:	2a1903e7 	mov	w7, w25
	log_offset = rb->alloc;
ffffffffea80777c:	b9400066 	ldr	w6, [x3]
	rb->alloc += len;
ffffffffea807780:	b9400060 	ldr	w0, [x3]
ffffffffea807784:	0b190000 	add	w0, w0, w25
ffffffffea807788:	b9000060 	str	w0, [x3]
	wmb();
ffffffffea80778c:	d5033e9f 	dsb	st
ffffffffea807790:	8b180149 	add	x9, x10, x24
	for (i = 0; i < len; i++) {
ffffffffea807794:	d2800001 	mov	x1, #0x0                   	// #0
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea807798:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80779c:	0b0100c5 	add	w5, w6, w1
		*ptr = str[i];
ffffffffea8077a0:	38616924 	ldrb	w4, [x9, x1]
	for (i = 0; i < len; i++) {
ffffffffea8077a4:	91000421 	add	x1, x1, #0x1
		uint32_t offset = (log_offset + i) & (log->rb_sz - 1);
ffffffffea8077a8:	51000400 	sub	w0, w0, #0x1
	for (i = 0; i < len; i++) {
ffffffffea8077ac:	eb19003f 	cmp	x1, x25
		*ptr = str[i];
ffffffffea8077b0:	0a050000 	and	w0, w0, w5
ffffffffea8077b4:	8b000060 	add	x0, x3, x0
ffffffffea8077b8:	39003004 	strb	w4, [x0, #12]
	for (i = 0; i < len; i++) {
ffffffffea8077bc:	54fffee1 	b.ne	ffffffffea807798 <memlog_print_callback+0x108>  // b.any
	wmb();
ffffffffea8077c0:	d5033e9f 	dsb	st
	rb->put += len;
ffffffffea8077c4:	b9400460 	ldr	w0, [x3, #4]
ffffffffea8077c8:	0b0000e0 	add	w0, w7, w0
ffffffffea8077cc:	b9000460 	str	w0, [x3, #4]
    arch_spin_unlock(lock);
ffffffffea8077d0:	913302c0 	add	x0, x22, #0xcc0
ffffffffea8077d4:	97ffec43 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
ffffffffea8077d8:	34000053 	cbz	w19, ffffffffea8077e0 <memlog_print_callback+0x150>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8077dc:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8077e0:	36000055 	tbz	w21, #0, ffffffffea8077e8 <memlog_print_callback+0x158>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8077e4:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8077e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8077ec:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8077f0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8077f4:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8077f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea8077fc:	d65f03c0 	ret

ffffffffea807800 <memlog_add>:
{
ffffffffea807800:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea807804:	910003fd 	mov	x29, sp
ffffffffea807808:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80780c:	f00002d7 	adrp	x23, ffffffffea862000 <__ctor_list>
ffffffffea807810:	aa0003f6 	mov	x22, x0
ffffffffea807814:	f9000ff4 	str	x20, [sp, #24]
ffffffffea807818:	f9402ae0 	ldr	x0, [x23, #80]
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea80781c:	d0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea807820:	91156284 	add	x4, x20, #0x558
{
ffffffffea807824:	f9001ff8 	str	x24, [sp, #56]
ffffffffea807828:	aa0103f8 	mov	x24, x1
ffffffffea80782c:	f9400001 	ldr	x1, [x0]
ffffffffea807830:	f90037a1 	str	x1, [x29, #104]
ffffffffea807834:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea807838:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80783c:	2a0203fb 	mov	w27, w2
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807840:	f9400480 	ldr	x0, [x4, #8]
ffffffffea807844:	eb00009f 	cmp	x4, x0
ffffffffea807848:	54000340 	b.eq	ffffffffea8078b0 <memlog_add+0xb0>  // b.none
ffffffffea80784c:	d100e003 	sub	x3, x0, #0x38
ffffffffea807850:	8b1802c1 	add	x1, x22, x24
		if (pa + sz <= log->buf_pa) {
ffffffffea807854:	f9400860 	ldr	x0, [x3, #16]
ffffffffea807858:	eb01001f 	cmp	x0, x1
ffffffffea80785c:	54000222 	b.cs	ffffffffea8078a0 <memlog_add+0xa0>  // b.hs, b.nlast
		if (pa >= log->buf_pa + log->buf_sz){
ffffffffea807860:	f9400c65 	ldr	x5, [x3, #24]
ffffffffea807864:	8b050000 	add	x0, x0, x5
ffffffffea807868:	eb0002df 	cmp	x22, x0
ffffffffea80786c:	540001a2 	b.cs	ffffffffea8078a0 <memlog_add+0xa0>  // b.hs, b.nlast
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807870:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807874:	f9402af7 	ldr	x23, [x23, #80]
ffffffffea807878:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80787c:	f94002e1 	ldr	x1, [x23]
ffffffffea807880:	ca010041 	eor	x1, x2, x1
ffffffffea807884:	b5000b21 	cbnz	x1, ffffffffea8079e8 <memlog_add+0x1e8>
ffffffffea807888:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80788c:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea807890:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea807894:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea807898:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80789c:	d65f03c0 	ret
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8078a0:	f9402060 	ldr	x0, [x3, #64]
ffffffffea8078a4:	d100e003 	sub	x3, x0, #0x38
ffffffffea8078a8:	eb00009f 	cmp	x4, x0
ffffffffea8078ac:	54fffd41 	b.ne	ffffffffea807854 <memlog_add+0x54>  // b.any
ffffffffea8078b0:	f9000bb3 	str	x19, [x29, #16]
	log = malloc(sizeof(*log));
ffffffffea8078b4:	d2800900 	mov	x0, #0x48                  	// #72
ffffffffea8078b8:	9400312c 	bl	ffffffffea813d68 <malloc>
ffffffffea8078bc:	aa0003f3 	mov	x19, x0
	if (!log) {
ffffffffea8078c0:	b40008e0 	cbz	x0, ffffffffea8079dc <memlog_add+0x1dc>
ffffffffea8078c4:	f90013b5 	str	x21, [x29, #32]
	sz = ROUNDUP((sz + offset), mb);
ffffffffea8078c8:	b2404fe1 	mov	x1, #0xfffff               	// #1048575
ffffffffea8078cc:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea8078d0:	8b010315 	add	x21, x24, x1
	offset = pa & (mb - 1);
ffffffffea8078d4:	92404ed9 	and	x25, x22, #0xfffff
	pa = ROUNDDOWN(pa, mb);
ffffffffea8078d8:	926caeda 	and	x26, x22, #0xfffffffffff00000
	sz = ROUNDUP((sz + offset), mb);
ffffffffea8078dc:	8b1902b5 	add	x21, x21, x25
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea8078e0:	2a1b03e2 	mov	w2, w27
	sz = ROUNDUP((sz + offset), mb);
ffffffffea8078e4:	926caeb5 	and	x21, x21, #0xfffffffffff00000
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea8078e8:	aa1a03e0 	mov	x0, x26
	log->buf_sz = sz;
ffffffffea8078ec:	a9016276 	stp	x22, x24, [x19, #16]
	err = trusty_hyp_check_guest_pa_valid(pa, sz, guest);
ffffffffea8078f0:	aa1503e1 	mov	x1, x21
ffffffffea8078f4:	97ffebc3 	bl	ffffffffea802800 <trusty_hyp_check_guest_pa_valid>
	if (err != NO_ERROR) {
ffffffffea8078f8:	35000580 	cbnz	w0, ffffffffea8079a8 <memlog_add+0x1a8>
	err = vmm_alloc_physical(vmm_get_kernel_aspace(),
ffffffffea8078fc:	f00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea807900:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807904:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807908:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80790c:	f9408400 	ldr	x0, [x0, #264]
ffffffffea807910:	aa1a03e5 	mov	x5, x26
ffffffffea807914:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807918:	910183a3 	add	x3, x29, #0x60
ffffffffea80791c:	aa1503e2 	mov	x2, x21
ffffffffea807920:	91070021 	add	x1, x1, #0x1c0
ffffffffea807924:	940028b5 	bl	ffffffffea811bf8 <vmm_alloc_physical>
	if (err) {
ffffffffea807928:	350004c0 	cbnz	w0, ffffffffea8079c0 <memlog_add+0x1c0>
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80792c:	f9400e60 	ldr	x0, [x19, #24]
	item->next = list->next;
ffffffffea807930:	91156294 	add	x20, x20, #0x558
	*va += offset;
ffffffffea807934:	f94033a5 	ldr	x5, [x29, #96]
	return 1u << (31 - __builtin_clz(v));
ffffffffea807938:	528003e3 	mov	w3, #0x1f                  	// #31
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea80793c:	51003000 	sub	w0, w0, #0xc
	return 1u << (31 - __builtin_clz(v));
ffffffffea807940:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807944:	5ac01000 	clz	w0, w0
	*va += offset;
ffffffffea807948:	8b050321 	add	x1, x25, x5
	return 1u << (31 - __builtin_clz(v));
ffffffffea80794c:	4b000060 	sub	w0, w3, w0
ffffffffea807950:	f9400684 	ldr	x4, [x20, #8]
	*va += offset;
ffffffffea807954:	f90033a1 	str	x1, [x29, #96]
	list_add_head(&log_list, &log->entry);
ffffffffea807958:	9100e263 	add	x3, x19, #0x38
	return 1u << (31 - __builtin_clz(v));
ffffffffea80795c:	1ac02042 	lsl	w2, w2, w0
	log->rb_sz = lower_pow2(log->buf_sz - offsetof(struct log_rb, data));
ffffffffea807960:	a9000a61 	stp	x1, x2, [x19]
	return 1u << (31 - __builtin_clz(v));
ffffffffea807964:	aa0203e0 	mov	x0, x2
	rb->sz = log->rb_sz;
ffffffffea807968:	b9000820 	str	w0, [x1, #8]
	rb->alloc = 0;
ffffffffea80796c:	b8256b3f 	str	wzr, [x25, x5]
	log->cb.print = memlog_print_callback;
ffffffffea807970:	90000002 	adrp	x2, ffffffffea807000 <wait_queue_destroy+0x20>
	rb->put = 0;
ffffffffea807974:	b900043f 	str	wzr, [x1, #4]
	log->cb.print = memlog_print_callback;
ffffffffea807978:	911a4042 	add	x2, x2, #0x690
ffffffffea80797c:	a9039274 	stp	x20, x4, [x19, #56]
	register_print_callback(&log->cb);
ffffffffea807980:	91008260 	add	x0, x19, #0x20
	list->next->prev = item;
ffffffffea807984:	f9000083 	str	x3, [x4]
	log->cb.print = memlog_print_callback;
ffffffffea807988:	f9001a62 	str	x2, [x19, #48]
	list->next = item;
ffffffffea80798c:	f9000683 	str	x3, [x20, #8]
	register_print_callback(&log->cb);
ffffffffea807990:	94002980 	bl	ffffffffea811f90 <register_print_callback>
	return 0;
ffffffffea807994:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea807998:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80799c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8079a0:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8079a4:	17ffffb4 	b	ffffffffea807874 <memlog_add+0x74>
		dprintf(ALWAYS, "%s: check_guest_pa_valid failed, error = %d",
ffffffffea8079a8:	90000083 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8079ac:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8079b0:	2a0003e2 	mov	w2, w0
ffffffffea8079b4:	91062021 	add	x1, x1, #0x188
ffffffffea8079b8:	91064060 	add	x0, x3, #0x190
ffffffffea8079bc:	94002a69 	bl	ffffffffea812360 <_dprintf>
	free(log);
ffffffffea8079c0:	aa1303e0 	mov	x0, x19
ffffffffea8079c4:	940030ff 	bl	ffffffffea813dc0 <free>
	return status;
ffffffffea8079c8:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea8079cc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8079d0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea8079d4:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8079d8:	17ffffa7 	b	ffffffffea807874 <memlog_add+0x74>
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea8079dc:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea8079e0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8079e4:	17ffffa4 	b	ffffffffea807874 <memlog_add+0x74>
ffffffffea8079e8:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8079ec:	f90013b5 	str	x21, [x29, #32]
ffffffffea8079f0:	a9046bb9 	stp	x25, x26, [x29, #64]
}
ffffffffea8079f4:	940030cd 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea8079f8 <memlog_rm>:
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea8079f8:	d0000082 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea8079fc:	91156042 	add	x2, x2, #0x558
ffffffffea807a00:	f9400441 	ldr	x1, [x2, #8]
ffffffffea807a04:	eb01005f 	cmp	x2, x1
ffffffffea807a08:	54000500 	b.eq	ffffffffea807aa8 <memlog_rm+0xb0>  // b.none
{
ffffffffea807a0c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea807a10:	910003fd 	mov	x29, sp
ffffffffea807a14:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807a18:	d100e033 	sub	x19, x1, #0x38
		if (log->buf_pa == pa) {
ffffffffea807a1c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea807a20:	eb01001f 	cmp	x0, x1
ffffffffea807a24:	540000a1 	b.ne	ffffffffea807a38 <memlog_rm+0x40>  // b.any
ffffffffea807a28:	1400000c 	b	ffffffffea807a58 <memlog_rm+0x60>
ffffffffea807a2c:	f85d8021 	ldur	x1, [x1, #-40]
ffffffffea807a30:	eb01001f 	cmp	x0, x1
ffffffffea807a34:	54000120 	b.eq	ffffffffea807a58 <memlog_rm+0x60>  // b.none
	list_for_every_entry(&log_list, log, struct memlog, entry) {
ffffffffea807a38:	f9402261 	ldr	x1, [x19, #64]
ffffffffea807a3c:	eb01005f 	cmp	x2, x1
ffffffffea807a40:	d100e033 	sub	x19, x1, #0x38
ffffffffea807a44:	54ffff41 	b.ne	ffffffffea807a2c <memlog_rm+0x34>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807a48:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807a4c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807a50:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807a54:	d65f03c0 	ret
	unregister_print_callback(&log->cb);
ffffffffea807a58:	91008260 	add	x0, x19, #0x20
ffffffffea807a5c:	9400297d 	bl	ffffffffea812050 <unregister_print_callback>
	item->next->prev = item->prev;
ffffffffea807a60:	a9438a63 	ldp	x3, x2, [x19, #56]
	result = vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)log->rb);
ffffffffea807a64:	f00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea807a68:	f9400261 	ldr	x1, [x19]
ffffffffea807a6c:	f9408400 	ldr	x0, [x0, #264]
ffffffffea807a70:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea807a74:	f9401e63 	ldr	x3, [x19, #56]
ffffffffea807a78:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea807a7c:	a903fe7f 	stp	xzr, xzr, [x19, #56]
ffffffffea807a80:	940028c0 	bl	ffffffffea811d80 <vmm_free_region>
ffffffffea807a84:	2a0003f4 	mov	w20, w0
	free(log);
ffffffffea807a88:	aa1303e0 	mov	x0, x19
ffffffffea807a8c:	940030cd 	bl	ffffffffea813dc0 <free>
	return 0;
ffffffffea807a90:	7100029f 	cmp	w20, #0x0
ffffffffea807a94:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
}
ffffffffea807a98:	a94153f3 	ldp	x19, x20, [sp, #16]
	return 0;
ffffffffea807a9c:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
}
ffffffffea807aa0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea807aa4:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea807aa8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
}
ffffffffea807aac:	d65f03c0 	ret

ffffffffea807ab0 <memlog_stdcall>:
	switch (args->smc_nr) {
ffffffffea807ab0:	b9400001 	ldr	w1, [x0]
ffffffffea807ab4:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807ab8:	72a66002 	movk	w2, #0x3300, lsl #16
ffffffffea807abc:	6b02003f 	cmp	w1, w2
ffffffffea807ac0:	54000120 	b.eq	ffffffffea807ae4 <memlog_stdcall+0x34>  // b.none
ffffffffea807ac4:	11000442 	add	w2, w2, #0x1
ffffffffea807ac8:	6b02003f 	cmp	w1, w2
ffffffffea807acc:	54000140 	b.eq	ffffffffea807af4 <memlog_stdcall+0x44>  // b.none
ffffffffea807ad0:	52a66000 	mov	w0, #0x33000000            	// #855638016
		return SM_ERR_UNDEFINED_SMC;
ffffffffea807ad4:	6b00003f 	cmp	w1, w0
ffffffffea807ad8:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea807adc:	9a9f1400 	csinc	x0, x0, xzr, ne  // ne = any
}
ffffffffea807ae0:	d65f03c0 	ret
		return memlog_add(args_get_pa(args), args_get_sz(args), args_get_guest(args));
ffffffffea807ae4:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea807ae8:	b9401c02 	ldr	w2, [x0, #28]
ffffffffea807aec:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807af0:	17ffff44 	b	ffffffffea807800 <memlog_add>
		return memlog_rm(args_get_pa(args));
ffffffffea807af4:	f8404000 	ldur	x0, [x0, #4]
ffffffffea807af8:	17ffffc0 	b	ffffffffea8079f8 <memlog_rm>
ffffffffea807afc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807b00 <sm_sched_nonsecure>:
#include <lib/sm/sm_err.h>

#include <kernel/vm.h>

FUNCTION(sm_sched_nonsecure)
	push	x1, x30
ffffffffea807b00:	a9bf7be1 	stp	x1, x30, [sp, #-16]!
.Lfastcall_complete:
	mov	x1, x0
ffffffffea807b04:	aa0003e1 	mov	x1, x0
.Lreturn_sm_err:
	ldr	x0, =SMC_SC_NS_RETURN
ffffffffea807b08:	58000500 	ldr	x0, ffffffffea807ba8 <smc_fastcall_secure_monitor+0x30>
	mov	x2, xzr
ffffffffea807b0c:	aa1f03e2 	mov	x2, xzr
	mov	x3, xzr
ffffffffea807b10:	aa1f03e3 	mov	x3, xzr
	smc	#0
ffffffffea807b14:	d4000003 	smc	#0x0

	tbnz	x0, #30, .Lsm_err_not_supported /* Check calling convention */
ffffffffea807b18:	37f00280 	tbnz	w0, #30, ffffffffea807b68 <sm_sched_nonsecure+0x68>
	tbz	x0, #31, .Lnot_fast_call
ffffffffea807b1c:	36f801a0 	tbz	w0, #31, ffffffffea807b50 <sm_sched_nonsecure+0x50>

	/* fastcall */
	sub	sp, sp, #(4 * SMC_NUM_ARGS) /* allocate smc32_args_t on stack */
ffffffffea807b20:	d10083ff 	sub	sp, sp, #0x20
	stp	w0, w1, [sp]
ffffffffea807b24:	290007e0 	stp	w0, w1, [sp]
	stp	w2, w3, [sp, #4 * 2]
ffffffffea807b28:	29010fe2 	stp	w2, w3, [sp, #8]
	stp	w4, w5, [sp, #4 * 4]
ffffffffea807b2c:	290217e4 	stp	w4, w5, [sp, #16]
	stp	w6, w7, [sp, #4 * 6]
ffffffffea807b30:	29031fe6 	stp	w6, w7, [sp, #24]

	ubfx	x0, x0, #24, #6		/* x0 = entity */
ffffffffea807b34:	d3587400 	ubfx	x0, x0, #24, #6
	ldr	x9, =sm_fastcall_table
ffffffffea807b38:	580003c9 	ldr	x9, ffffffffea807bb0 <smc_fastcall_secure_monitor+0x38>
	ldr	x9, [x9, x0, lsl #3]
ffffffffea807b3c:	f8607929 	ldr	x9, [x9, x0, lsl #3]

	mov	x0, sp			/* x0 = smc_args_t* args */
ffffffffea807b40:	910003e0 	mov	x0, sp
	blr	x9
ffffffffea807b44:	d63f0120 	blr	x9
	add	sp, sp, #(4 * SMC_NUM_ARGS)
ffffffffea807b48:	910083ff 	add	sp, sp, #0x20
	b	.Lfastcall_complete
ffffffffea807b4c:	17ffffee 	b	ffffffffea807b04 <sm_sched_nonsecure+0x4>

.Lnot_fast_call:
	pop	x9, x30
ffffffffea807b50:	a8c17be9 	ldp	x9, x30, [sp], #16
	stp	w0, w1, [x9], #8
ffffffffea807b54:	28810520 	stp	w0, w1, [x9], #8
	stp	w2, w3, [x9], #8
ffffffffea807b58:	28810d22 	stp	w2, w3, [x9], #8
	stp	w4, w5, [x9], #8
ffffffffea807b5c:	28811524 	stp	w4, w5, [x9], #8
	stp	w6, w7, [x9], #8
ffffffffea807b60:	28811d26 	stp	w6, w7, [x9], #8
	ret
ffffffffea807b64:	d65f03c0 	ret

.Lsm_err_not_supported:
	mov	x1, #SM_ERR_NOT_SUPPORTED
ffffffffea807b68:	928000e1 	mov	x1, #0xfffffffffffffff8    	// #-8
	b	.Lreturn_sm_err
ffffffffea807b6c:	17ffffe7 	b	ffffffffea807b08 <sm_sched_nonsecure+0x8>

.Lsm_err_busy:
	mov	x1, #SM_ERR_BUSY
ffffffffea807b70:	92800081 	mov	x1, #0xfffffffffffffffb    	// #-5
	b	.Lreturn_sm_err
ffffffffea807b74:	17ffffe5 	b	ffffffffea807b08 <sm_sched_nonsecure+0x8>

ffffffffea807b78 <smc_fastcall_secure_monitor>:

FUNCTION(smc_fastcall_secure_monitor)
	ldrh	w1, [x0]	/* r1 = function# */
ffffffffea807b78:	79400001 	ldrh	w1, [x0]
	ldr	x2, =sm_nr_fastcall_functions
ffffffffea807b7c:	580001e2 	ldr	x2, ffffffffea807bb8 <smc_fastcall_secure_monitor+0x40>
	ldr	w2, [x2]
ffffffffea807b80:	b9400042 	ldr	w2, [x2]
	cmp	w1, w2
ffffffffea807b84:	6b02003f 	cmp	w1, w2
	bhs	.Lfastcall_smc_undefined
ffffffffea807b88:	540000a2 	b.cs	ffffffffea807b9c <smc_fastcall_secure_monitor+0x24>  // b.hs, b.nlast
	ldr	x2, =sm_fastcall_function_table
ffffffffea807b8c:	580001a2 	ldr	x2, ffffffffea807bc0 <smc_fastcall_secure_monitor+0x48>
	ldr	x2, [x2, x1, lsl#3]
ffffffffea807b90:	f8617842 	ldr	x2, [x2, x1, lsl #3]
	cbz	x2, .Lfastcall_smc_undefined
ffffffffea807b94:	b4000042 	cbz	x2, ffffffffea807b9c <smc_fastcall_secure_monitor+0x24>
	br	x2
ffffffffea807b98:	d61f0040 	br	x2
.Lfastcall_smc_undefined:
	ldr	x2, =smc_undefined
ffffffffea807b9c:	58000162 	ldr	x2, ffffffffea807bc8 <smc_fastcall_secure_monitor+0x50>
	br	x2
ffffffffea807ba0:	d61f0040 	br	x2
ffffffffea807ba4:	00000000 	.inst	0x00000000 ; undefined
ffffffffea807ba8:	3c000000 	.word	0x3c000000
ffffffffea807bac:	00000000 	.word	0x00000000
ffffffffea807bb0:	ea819af8 	.word	0xea819af8
ffffffffea807bb4:	ffffffff 	.word	0xffffffff
ffffffffea807bb8:	ea819cf8 	.word	0xea819cf8
ffffffffea807bbc:	ffffffff 	.word	0xffffffff
ffffffffea807bc0:	ea819a88 	.word	0xea819a88
ffffffffea807bc4:	ffffffff 	.word	0xffffffff
ffffffffea807bc8:	ea808810 	.word	0xea808810
ffffffffea807bcc:	ffffffff 	.word	0xffffffff

ffffffffea807bd0 <platform_halt>:
#include <lib/sm/sm_err.h>
#include <platform.h>

void platform_halt(platform_halt_action suggested_action,
                   platform_halt_reason reason)
{
ffffffffea807bd0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea807bd4:	f00002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);

    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807bd8:	90000080 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807bdc:	9107e000 	add	x0, x0, #0x1f8
{
ffffffffea807be0:	910003fd 	mov	x29, sp
ffffffffea807be4:	f9402842 	ldr	x2, [x2, #80]
ffffffffea807be8:	f9400043 	ldr	x3, [x2]
ffffffffea807bec:	f90027a3 	str	x3, [x29, #72]
ffffffffea807bf0:	d2800003 	mov	x3, #0x0                   	// #0
    smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea807bf4:	a902ffbf 	stp	xzr, xzr, [x29, #40]
ffffffffea807bf8:	a903ffbf 	stp	xzr, xzr, [x29, #56]
{
ffffffffea807bfc:	f9000bf3 	str	x19, [sp, #16]
    dprintf(ALWAYS, "HALT: (reason = %d)\n", reason);
ffffffffea807c00:	940029d8 	bl	ffffffffea812360 <_dprintf>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807c04:	d50342df 	msr	daifset, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807c08:	d50341df 	msr	daifset, #0x1
    CF;
ffffffffea807c0c:	9100a3b3 	add	x19, x29, #0x28
    arch_disable_ints();
    arch_disable_fiqs();
    while(true) {
        sm_sched_nonsecure(SM_ERR_PANIC, &args);
ffffffffea807c10:	aa1303e1 	mov	x1, x19
ffffffffea807c14:	92800140 	mov	x0, #0xfffffffffffffff5    	// #-11
ffffffffea807c18:	97ffffba 	bl	ffffffffea807b00 <sm_sched_nonsecure>
ffffffffea807c1c:	17fffffd 	b	ffffffffea807c10 <platform_halt+0x40>

ffffffffea807c20 <sm_secondary_init>:
LK_INIT_HOOK_FLAGS(libsm_mon_perrcpu, sm_mon_percpu_init,
		   LK_INIT_LEVEL_PLATFORM - 3, LK_INIT_FLAG_ALL_CPUS);
#endif

static void sm_secondary_init(uint level)
{
ffffffffea807c20:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea807c24:	910003fd 	mov	x29, sp
ffffffffea807c28:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea807c2c:	f00002d5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea807c30:	a90153f3 	stp	x19, x20, [sp, #16]
	char name[32];
	int cpu = arch_curr_cpu_num();

	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);

	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
ffffffffea807c34:	910123b4 	add	x20, x29, #0x48
{
ffffffffea807c38:	f9402aa0 	ldr	x0, [x21, #80]
ffffffffea807c3c:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea807c40:	aa1e03f8 	mov	x24, x30
ffffffffea807c44:	f9400001 	ldr	x1, [x0]
ffffffffea807c48:	f90037a1 	str	x1, [x29, #104]
ffffffffea807c4c:	d2800001 	mov	x1, #0x0                   	// #0
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807c50:	f0000357 	adrp	x23, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807c54:	913aa2f7 	add	x23, x23, #0xea8
	int cpu = arch_curr_cpu_num();
ffffffffea807c58:	97ffeb9e 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea807c5c:	93407c16 	sxtw	x22, w0
	event_init(&nsirqevent[cpu], false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea807c60:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807c64:	9134a000 	add	x0, x0, #0xd28
ffffffffea807c68:	52800603 	mov	w3, #0x30                  	// #48
ffffffffea807c6c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea807c70:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea807c74:	9b2302c0 	smaddl	x0, w22, w3, x0
ffffffffea807c78:	97fff654 	bl	ffffffffea8055c8 <event_init>
	snprintf(name, sizeof(name), "irq-ns-switch-%d", cpu);
ffffffffea807c7c:	2a1603e3 	mov	w3, w22
ffffffffea807c80:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807c84:	90000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807c88:	aa1403e0 	mov	x0, x20
ffffffffea807c8c:	9113c042 	add	x2, x2, #0x4f0
ffffffffea807c90:	94002fc8 	bl	ffffffffea813bb0 <snprintf>
	nsirqthreads[cpu] = thread_create(name, sm_irq_loop, (void *)(uintptr_t)cpu,
ffffffffea807c94:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x68>
ffffffffea807c98:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807c9c:	528003e3 	mov	w3, #0x1f                  	// #31
ffffffffea807ca0:	aa1603e2 	mov	x2, x22
ffffffffea807ca4:	910e6021 	add	x1, x1, #0x398
ffffffffea807ca8:	aa1403e0 	mov	x0, x20
ffffffffea807cac:	97fff90f 	bl	ffffffffea8060e8 <thread_create>
ffffffffea807cb0:	f8367ae0 	str	x0, [x23, x22, lsl #3]
					  HIGHEST_PRIORITY, DEFAULT_STACK_SIZE);
	if (!nsirqthreads[cpu]) {
ffffffffea807cb4:	b40005c0 	cbz	x0, ffffffffea807d6c <sm_secondary_init+0x14c>
ffffffffea807cb8:	aa0003e1 	mov	x1, x0
		panic("failed to create irq NS switcher thread for cpu %d!\n", cpu);
	}
	nsirqthreads[cpu]->pinned_cpu = cpu;
ffffffffea807cbc:	b9003c36 	str	w22, [x1, #60]
	thread_set_real_time(nsirqthreads[cpu]);
ffffffffea807cc0:	97fff912 	bl	ffffffffea806108 <thread_set_real_time>

	snprintf(name, sizeof(name), "idle-ns-switch-%d", cpu);
ffffffffea807cc4:	2a1603e3 	mov	w3, w22
ffffffffea807cc8:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea807ccc:	aa1403e0 	mov	x0, x20
ffffffffea807cd0:	90000082 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807cd4:	91150042 	add	x2, x2, #0x540
ffffffffea807cd8:	94002fb6 	bl	ffffffffea813bb0 <snprintf>
	nsidlethreads[cpu] = thread_create(name,
ffffffffea807cdc:	aa1403e0 	mov	x0, x20
ffffffffea807ce0:	f0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807ce4:	9133a294 	add	x20, x20, #0xce8
ffffffffea807ce8:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x68>
ffffffffea807cec:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807cf0:	91094021 	add	x1, x1, #0x250
ffffffffea807cf4:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea807cf8:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807cfc:	97fff8fb 	bl	ffffffffea8060e8 <thread_create>
ffffffffea807d00:	f8367a80 	str	x0, [x20, x22, lsl #3]
ffffffffea807d04:	aa0003e1 	mov	x1, x0
			(thread_start_routine)sm_wait_for_smcall,
			NULL, LOWEST_PRIORITY + 1, DEFAULT_STACK_SIZE);
	if (!nsidlethreads[cpu]) {
ffffffffea807d08:	b4000280 	cbz	x0, ffffffffea807d58 <sm_secondary_init+0x138>
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
	}
	nsidlethreads[cpu]->pinned_cpu = cpu;
ffffffffea807d0c:	b9003c36 	str	w22, [x1, #60]
	thread_set_real_time(nsidlethreads[cpu]);
ffffffffea807d10:	97fff8fe 	bl	ffffffffea806108 <thread_set_real_time>

	if (ns_threads_started) {
ffffffffea807d14:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807d18:	39738000 	ldrb	w0, [x0, #3296]
ffffffffea807d1c:	340000a0 	cbz	w0, ffffffffea807d30 <sm_secondary_init+0x110>
		thread_resume(nsirqthreads[cpu]);
ffffffffea807d20:	f8767ae0 	ldr	x0, [x23, x22, lsl #3]
ffffffffea807d24:	97fff951 	bl	ffffffffea806268 <thread_resume>
		thread_resume(nsidlethreads[cpu]);
ffffffffea807d28:	f8767a80 	ldr	x0, [x20, x22, lsl #3]
ffffffffea807d2c:	97fff94f 	bl	ffffffffea806268 <thread_resume>
	}
}
ffffffffea807d30:	f9402ab5 	ldr	x21, [x21, #80]
ffffffffea807d34:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea807d38:	f94002a0 	ldr	x0, [x21]
ffffffffea807d3c:	ca000020 	eor	x0, x1, x0
ffffffffea807d40:	b5000200 	cbnz	x0, ffffffffea807d80 <sm_secondary_init+0x160>
ffffffffea807d44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807d48:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea807d4c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea807d50:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea807d54:	d65f03c0 	ret
		panic("failed to create idle NS switcher thread for cpu %d!\n", cpu);
ffffffffea807d58:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807d5c:	2a1603e2 	mov	w2, w22
ffffffffea807d60:	91156021 	add	x1, x1, #0x558
ffffffffea807d64:	aa1803e0 	mov	x0, x24
ffffffffea807d68:	94002a06 	bl	ffffffffea812580 <_panic>
		panic("failed to create irq NS switcher thread for cpu %d!\n", cpu);
ffffffffea807d6c:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807d70:	2a1603e2 	mov	w2, w22
ffffffffea807d74:	91142021 	add	x1, x1, #0x508
ffffffffea807d78:	aa1803e0 	mov	x0, x24
ffffffffea807d7c:	94002a01 	bl	ffffffffea812580 <_panic>
}
ffffffffea807d80:	94002fea 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea807d84:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807d88 <resume_nsthreads>:
	mutex_release(&boot_args_lock);
	return err;
}

static void resume_nsthreads(void)
{
ffffffffea807d88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	int i;

	ns_threads_started = true;
ffffffffea807d8c:	f0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807d90:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea807d94:	910003fd 	mov	x29, sp
ffffffffea807d98:	a90153f3 	stp	x19, x20, [sp, #16]
	ns_threads_started = true;
ffffffffea807d9c:	39338001 	strb	w1, [x0, #3296]
{
ffffffffea807da0:	f90013f5 	str	x21, [sp, #32]
	smp_wmb();
ffffffffea807da4:	d5033abf 	dmb	ishst
ffffffffea807da8:	f0000355 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807dac:	f0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
		if (nsirqthreads[i]) {
ffffffffea807db0:	913aa2b5 	add	x21, x21, #0xea8
			thread_resume(nsirqthreads[i]);
		}
		if (nsidlethreads[i]) {
ffffffffea807db4:	9133a294 	add	x20, x20, #0xce8
	smp_wmb();
ffffffffea807db8:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea807dbc:	d503201f 	nop
		if (nsirqthreads[i]) {
ffffffffea807dc0:	f8756a61 	ldr	x1, [x19, x21]
			thread_resume(nsirqthreads[i]);
ffffffffea807dc4:	aa0103e0 	mov	x0, x1
		if (nsirqthreads[i]) {
ffffffffea807dc8:	b4000041 	cbz	x1, ffffffffea807dd0 <resume_nsthreads+0x48>
			thread_resume(nsirqthreads[i]);
ffffffffea807dcc:	97fff927 	bl	ffffffffea806268 <thread_resume>
		if (nsidlethreads[i]) {
ffffffffea807dd0:	f8746a61 	ldr	x1, [x19, x20]
ffffffffea807dd4:	91002273 	add	x19, x19, #0x8
			thread_resume(nsidlethreads[i]);
ffffffffea807dd8:	aa0103e0 	mov	x0, x1
		if (nsidlethreads[i]) {
ffffffffea807ddc:	b4000041 	cbz	x1, ffffffffea807de4 <resume_nsthreads+0x5c>
			thread_resume(nsidlethreads[i]);
ffffffffea807de0:	97fff922 	bl	ffffffffea806268 <thread_resume>
	for (i = 0; i < SMP_MAX_CPUS; i++) {
ffffffffea807de4:	f101027f 	cmp	x19, #0x40
ffffffffea807de8:	54fffec1 	b.ne	ffffffffea807dc0 <resume_nsthreads+0x38>  // b.any
		}
	}
}
ffffffffea807dec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807df0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea807df4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807df8:	d65f03c0 	ret
ffffffffea807dfc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea807e00 <sm_init>:
{
ffffffffea807e00:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
void mutex_destroy(mutex_t *);
status_t mutex_acquire_timeout(mutex_t *, lk_time_t); /* try to acquire the mutex with a timeout value */
status_t mutex_release(mutex_t *);

static inline status_t mutex_acquire(mutex_t *m) {
	return mutex_acquire_timeout(m, INFINITE_TIME);
ffffffffea807e04:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea807e08:	910003fd 	mov	x29, sp
ffffffffea807e0c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea807e10:	f00002d4 	adrp	x20, ffffffffea862000 <__ctor_list>
	if (lk_boot_args[1] && lk_boot_args[2]) {
ffffffffea807e14:	f00002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
{
ffffffffea807e18:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea807e1c:	f9402a82 	ldr	x2, [x20, #80]
ffffffffea807e20:	aa1e03f6 	mov	x22, x30
ffffffffea807e24:	d0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea807e28:	911602a0 	add	x0, x21, #0x580
ffffffffea807e2c:	f9400043 	ldr	x3, [x2]
ffffffffea807e30:	f90027a3 	str	x3, [x29, #72]
ffffffffea807e34:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea807e38:	97fff694 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (lk_boot_args[1] && lk_boot_args[2]) {
ffffffffea807e3c:	f9407e60 	ldr	x0, [x19, #248]
ffffffffea807e40:	f9400405 	ldr	x5, [x0, #8]
ffffffffea807e44:	b4000065 	cbz	x5, ffffffffea807e50 <sm_init+0x50>
ffffffffea807e48:	f9400802 	ldr	x2, [x0, #16]
ffffffffea807e4c:	b50004e2 	cbnz	x2, ffffffffea807ee8 <sm_init+0xe8>
	if ((void *)lk_boot_args[3] != NULL){
ffffffffea807e50:	f9407e73 	ldr	x19, [x19, #248]
ffffffffea807e54:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea807e58:	b5000340 	cbnz	x0, ffffffffea807ec0 <sm_init+0xc0>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807e5c:	f0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
	mutex_release(&boot_args_lock);
ffffffffea807e60:	911602a0 	add	x0, x21, #0x580
ffffffffea807e64:	97fff6b5 	bl	ffffffffea805938 <mutex_release>
	stdcallthread = thread_create("sm-stdcall", sm_stdcall_loop, NULL,
ffffffffea807e68:	b0000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x68>
ffffffffea807e6c:	90000080 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807e70:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea807e74:	52800043 	mov	w3, #0x2                   	// #2
ffffffffea807e78:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea807e7c:	910fa021 	add	x1, x1, #0x3e8
ffffffffea807e80:	910f2000 	add	x0, x0, #0x3c8
ffffffffea807e84:	97fff899 	bl	ffffffffea8060e8 <thread_create>
ffffffffea807e88:	f9078260 	str	x0, [x19, #3840]
	if (!stdcallthread) {
ffffffffea807e8c:	b4000780 	cbz	x0, ffffffffea807f7c <sm_init+0x17c>
	thread_set_real_time(stdcallthread);
ffffffffea807e90:	97fff89e 	bl	ffffffffea806108 <thread_set_real_time>
	thread_resume(stdcallthread);
ffffffffea807e94:	f9478260 	ldr	x0, [x19, #3840]
ffffffffea807e98:	97fff8f4 	bl	ffffffffea806268 <thread_resume>
}
ffffffffea807e9c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea807ea0:	f94027a1 	ldr	x1, [x29, #72]
ffffffffea807ea4:	f9400280 	ldr	x0, [x20]
ffffffffea807ea8:	ca000020 	eor	x0, x1, x0
ffffffffea807eac:	b5000720 	cbnz	x0, ffffffffea807f90 <sm_init+0x190>
ffffffffea807eb0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807eb4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea807eb8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea807ebc:	d65f03c0 	ret
		ret = tegra_boot_profiler_init(lk_boot_args[3]);
ffffffffea807ec0:	97fffddc 	bl	ffffffffea807630 <tegra_boot_profiler_init>
		if(ret) {
ffffffffea807ec4:	34fffcc0 	cbz	w0, ffffffffea807e5c <sm_init+0x5c>
			TRACEF("Error mapping Profiler boot parameter block: %d\n", ret);
ffffffffea807ec8:	90000084 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807ecc:	2a0003e3 	mov	w3, w0
ffffffffea807ed0:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807ed4:	528035c2 	mov	w2, #0x1ae                 	// #430
ffffffffea807ed8:	91090021 	add	x1, x1, #0x240
ffffffffea807edc:	910e4080 	add	x0, x4, #0x390
ffffffffea807ee0:	94002f5e 	bl	ffffffffea813c58 <_printf>
ffffffffea807ee4:	17ffffde 	b	ffffffffea807e5c <sm_init+0x5c>
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807ee8:	f00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea807eec:	f9001bb7 	str	x23, [x29, #48]
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807ef0:	913ffc42 	add	x2, x2, #0xfff
		ulong offset = lk_boot_args[1] & (PAGE_SIZE - 1);
ffffffffea807ef4:	92402cb7 	and	x23, x5, #0xfff
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807ef8:	f9408400 	ldr	x0, [x0, #264]
		size_t size   = ROUNDUP(lk_boot_args[2] + offset, PAGE_SIZE);
ffffffffea807efc:	8b170042 	add	x2, x2, x23
		err = vmm_alloc_physical(vmm_get_kernel_aspace(), "sm",
ffffffffea807f00:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807f04:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea807f08:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea807f0c:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea807f10:	910103a3 	add	x3, x29, #0x40
ffffffffea807f14:	910d4021 	add	x1, x1, #0x350
ffffffffea807f18:	9274cca5 	and	x5, x5, #0xfffffffffffff000
ffffffffea807f1c:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea807f20:	94002736 	bl	ffffffffea811bf8 <vmm_alloc_physical>
		if (!err) {
ffffffffea807f24:	35000160 	cbnz	w0, ffffffffea807f50 <sm_init+0x150>
			boot_args_refcnt++;
ffffffffea807f28:	f0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f2c:	f0000343 	adrp	x3, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807f30:	f94023a1 	ldr	x1, [x29, #64]
			boot_args_refcnt++;
ffffffffea807f34:	b94cd040 	ldr	w0, [x2, #3280]
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f38:	8b170021 	add	x1, x1, x23
ffffffffea807f3c:	f9401bb7 	ldr	x23, [x29, #48]
			boot_args_refcnt++;
ffffffffea807f40:	11000400 	add	w0, w0, #0x1
			boot_args = (uint8_t *)vptr + offset;
ffffffffea807f44:	f9066461 	str	x1, [x3, #3272]
			boot_args_refcnt++;
ffffffffea807f48:	b90cd040 	str	w0, [x2, #3280]
ffffffffea807f4c:	17ffffc1 	b	ffffffffea807e50 <sm_init+0x50>
			boot_args = NULL;
ffffffffea807f50:	f0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807f54:	90000084 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807f58:	2a0003e3 	mov	w3, w0
ffffffffea807f5c:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
			boot_args = NULL;
ffffffffea807f60:	f906645f 	str	xzr, [x2, #3272]
			TRACEF("Error mapping initial boot parameter block: %d\n", err);
ffffffffea807f64:	91090021 	add	x1, x1, #0x240
ffffffffea807f68:	52803422 	mov	w2, #0x1a1                 	// #417
ffffffffea807f6c:	910d6080 	add	x0, x4, #0x358
ffffffffea807f70:	94002f3a 	bl	ffffffffea813c58 <_printf>
ffffffffea807f74:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea807f78:	17ffffb6 	b	ffffffffea807e50 <sm_init+0x50>
		panic("failed to create sm-stdcall thread!\n");
ffffffffea807f7c:	90000081 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea807f80:	aa1603e0 	mov	x0, x22
ffffffffea807f84:	910f6021 	add	x1, x1, #0x3d8
ffffffffea807f88:	f9001bb7 	str	x23, [x29, #48]
ffffffffea807f8c:	9400297d 	bl	ffffffffea812580 <_panic>
ffffffffea807f90:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea807f94:	94002f65 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea807f98 <sm_get_api_version>:
{
ffffffffea807f98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea807f9c:	910003fd 	mov	x29, sp
ffffffffea807fa0:	a90153f3 	stp	x19, x20, [sp, #16]
	if (!sm_api_version_locked) {
ffffffffea807fa4:	f0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807fa8:	f0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807fac:	397be260 	ldrb	w0, [x19, #3832]
ffffffffea807fb0:	340000a0 	cbz	w0, ffffffffea807fc4 <sm_get_api_version+0x2c>
	return sm_api_version;
ffffffffea807fb4:	b94eea80 	ldr	w0, [x20, #3816]
}
ffffffffea807fb8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea807fbc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea807fc0:	d65f03c0 	ret
ffffffffea807fc4:	a9025bb5 	stp	x21, x22, [x29, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807fc8:	d53b4220 	mrs	x0, daif
    spin_lock_saved_state_t state = 0;
ffffffffea807fcc:	52800015 	mov	w21, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea807fd0:	37380060 	tbnz	w0, #7, ffffffffea807fdc <sm_get_api_version+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea807fd4:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea807fd8:	52800035 	mov	w21, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea807fdc:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea807fe0:	37300360 	tbnz	w0, #6, ffffffffea80804c <sm_get_api_version+0xb4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea807fe4:	321f02b5 	orr	w21, w21, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea807fe8:	d50341df 	msr	daifset, #0x1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea807fec:	f0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
    arch_spin_lock(lock);
ffffffffea807ff0:	f0000356 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea807ff4:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea807ff8:	aa1603e0 	mov	x0, x22
ffffffffea807ffc:	97ffea31 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea808000:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea808004:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808008:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80800c:	9108a021 	add	x1, x1, #0x228
ffffffffea808010:	52800e42 	mov	w2, #0x72                  	// #114
		sm_api_version_locked = true;
ffffffffea808014:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808018:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80801c:	910b2000 	add	x0, x0, #0x2c8
ffffffffea808020:	94002f0e 	bl	ffffffffea813c58 <_printf>
    arch_spin_unlock(lock);
ffffffffea808024:	aa1603e0 	mov	x0, x22
ffffffffea808028:	97ffea2e 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea80802c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea808030:	36000315 	tbz	w21, #0, ffffffffea808090 <sm_get_api_version+0xf8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808034:	d50342ff 	msr	daifclr, #0x2
	return sm_api_version;
ffffffffea808038:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea80803c:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea808040:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808044:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808048:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80804c:	d0000356 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808050:	d0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808054:	913bc2d6 	add	x22, x22, #0xef0
ffffffffea808058:	aa1603e0 	mov	x0, x22
ffffffffea80805c:	97ffea19 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea808060:	b94eea83 	ldr	w3, [x20, #3816]
		sm_api_version_locked = true;
ffffffffea808064:	52800024 	mov	w4, #0x1                   	// #1
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea808068:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80806c:	9108a021 	add	x1, x1, #0x228
ffffffffea808070:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea808074:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
		sm_api_version_locked = true;
ffffffffea808078:	393be264 	strb	w4, [x19, #3832]
		TRACEF("lock api version %d\n", sm_api_version);
ffffffffea80807c:	910b2000 	add	x0, x0, #0x2c8
ffffffffea808080:	94002ef6 	bl	ffffffffea813c58 <_printf>
    arch_spin_unlock(lock);
ffffffffea808084:	aa1603e0 	mov	x0, x22
ffffffffea808088:	97ffea16 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea80808c:	3707fd55 	tbnz	w21, #0, ffffffffea808034 <sm_get_api_version+0x9c>
	return sm_api_version;
ffffffffea808090:	b94eea80 	ldr	w0, [x20, #3816]
ffffffffea808094:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea808098:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80809c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8080a0:	d65f03c0 	ret
ffffffffea8080a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8080a8 <sm_return_and_wait_for_next_stdcall.isra.1>:
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea8080a8:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea8080ac:	910003fd 	mov	x29, sp
ffffffffea8080b0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8080b4:	d00002d7 	adrp	x23, ffffffffea862000 <__ctor_list>
ffffffffea8080b8:	a90153f3 	stp	x19, x20, [sp, #16]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea8080bc:	52800074 	mov	w20, #0x3                   	// #3
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea8080c0:	f9402ae1 	ldr	x1, [x23, #80]
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8080c4:	f0000078 	adrp	x24, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea8080c8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8080cc:	910163b3 	add	x19, x29, #0x58
    arch_spin_lock(lock);
ffffffffea8080d0:	b0000096 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea8080d4:	f9400022 	ldr	x2, [x1]
ffffffffea8080d8:	f9003fa2 	str	x2, [x29, #120]
ffffffffea8080dc:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea8080e0:	9116e2d5 	add	x21, x22, #0x5b8
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8080e4:	910a6318 	add	x24, x24, #0x298
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea8080e8:	a905ffbf 	stp	xzr, xzr, [x29, #88]
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea8080ec:	72a78014 	movk	w20, #0x3c00, lsl #16
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea8080f0:	a906ffbf 	stp	xzr, xzr, [x29, #104]
static void sm_return_and_wait_for_next_stdcall(long ret, int cpu)
ffffffffea8080f4:	f90023f9 	str	x25, [sp, #64]
ffffffffea8080f8:	14000009 	b	ffffffffea80811c <sm_return_and_wait_for_next_stdcall.isra.1+0x74>
			ret = sm_nopcall_table[SMC_ENTITY(args.params[0])](&args);
ffffffffea8080fc:	d00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea808100:	39417fa2 	ldrb	w2, [x29, #95]
ffffffffea808104:	aa1303e0 	mov	x0, x19
ffffffffea808108:	f9407821 	ldr	x1, [x1, #240]
ffffffffea80810c:	92401442 	and	x2, x2, #0x3f
ffffffffea808110:	f8627821 	ldr	x1, [x1, x2, lsl #3]
ffffffffea808114:	d63f0020 	blr	x1
	} while (ret);
ffffffffea808118:	b4000380 	cbz	x0, ffffffffea808188 <sm_return_and_wait_for_next_stdcall.isra.1+0xe0>
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea80811c:	d50341df 	msr	daifset, #0x1
		sm_sched_nonsecure(ret, &args);
ffffffffea808120:	aa1303e1 	mov	x1, x19
ffffffffea808124:	97fffe77 	bl	ffffffffea807b00 <sm_sched_nonsecure>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea808128:	d50341ff 	msr	daifclr, #0x1
		if (args.smc_nr == SMC_SC_NOP) {
ffffffffea80812c:	b9405ba0 	ldr	w0, [x29, #88]
ffffffffea808130:	6b14001f 	cmp	w0, w20
ffffffffea808134:	54fffe40 	b.eq	ffffffffea8080fc <sm_return_and_wait_for_next_stdcall.isra.1+0x54>  // b.none
	uint cpu = arch_curr_cpu_num();
ffffffffea808138:	97ffea66 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea80813c:	2a0003f9 	mov	w25, w0
ffffffffea808140:	aa1503e0 	mov	x0, x21
ffffffffea808144:	97ffe9df 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea808148:	394032a0 	ldrb	w0, [x21, #12]
ffffffffea80814c:	34000340 	cbz	w0, ffffffffea8081b4 <sm_return_and_wait_for_next_stdcall.isra.1+0x10c>
ffffffffea808150:	b9405ba0 	ldr	w0, [x29, #88]
		if (args->smc_nr == SMC_SC_RESTART_LAST && stdcallstate.active_cpu == -1) {
ffffffffea808154:	52a78001 	mov	w1, #0x3c000000            	// #1006632960
ffffffffea808158:	6b01001f 	cmp	w0, w1
ffffffffea80815c:	54000501 	b.ne	ffffffffea8081fc <sm_return_and_wait_for_next_stdcall.isra.1+0x154>  // b.any
ffffffffea808160:	b94066a0 	ldr	w0, [x21, #100]
ffffffffea808164:	3100041f 	cmn	w0, #0x1
ffffffffea808168:	540004a1 	b.ne	ffffffffea8081fc <sm_return_and_wait_for_next_stdcall.isra.1+0x154>  // b.any
			stdcallstate.restart_count++;
ffffffffea80816c:	b94072a0 	ldr	w0, [x21, #112]
ffffffffea808170:	11000400 	add	w0, w0, #0x1
ffffffffea808174:	b90072a0 	str	w0, [x21, #112]
	stdcallstate.active_cpu = cpu;
ffffffffea808178:	9116e2d6 	add	x22, x22, #0x5b8
    arch_spin_unlock(lock);
ffffffffea80817c:	aa1603e0 	mov	x0, x22
ffffffffea808180:	b90066d9 	str	w25, [x22, #100]
ffffffffea808184:	97ffe9d7 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea808188:	f9402af7 	ldr	x23, [x23, #80]
ffffffffea80818c:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea808190:	f94002e0 	ldr	x0, [x23]
ffffffffea808194:	ca000020 	eor	x0, x1, x0
ffffffffea808198:	b5000580 	cbnz	x0, ffffffffea808248 <sm_return_and_wait_for_next_stdcall.isra.1+0x1a0>
ffffffffea80819c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8081a0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8081a4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8081a8:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea8081ac:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea8081b0:	d65f03c0 	ret
	if (stdcallstate.event.signalled || stdcallstate.done) {
ffffffffea8081b4:	394182a1 	ldrb	w1, [x21, #96]
ffffffffea8081b8:	b9405ba0 	ldr	w0, [x29, #88]
ffffffffea8081bc:	35fffcc1 	cbnz	w1, ffffffffea808154 <sm_return_and_wait_for_next_stdcall.isra.1+0xac>
		if (args->smc_nr == SMC_SC_RESTART_LAST) {
ffffffffea8081c0:	52a78001 	mov	w1, #0x3c000000            	// #1006632960
ffffffffea8081c4:	6b01001f 	cmp	w0, w1
ffffffffea8081c8:	540002c0 	b.eq	ffffffffea808220 <sm_return_and_wait_for_next_stdcall.isra.1+0x178>  // b.none
	stdcallstate.args = *args;
ffffffffea8081cc:	a9401664 	ldp	x4, x5, [x19]
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea8081d0:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
	stdcallstate.args = *args;
ffffffffea8081d4:	a9410e62 	ldp	x2, x3, [x19, #16]
ffffffffea8081d8:	a90396a4 	stp	x4, x5, [x21, #56]
ffffffffea8081dc:	a9048ea2 	stp	x2, x3, [x21, #72]
	event_signal(&stdcallstate.event, false);
ffffffffea8081e0:	52800001 	mov	w1, #0x0                   	// #0
	stdcallstate.ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea8081e4:	f9002ea0 	str	x0, [x21, #88]
	event_signal(&stdcallstate.event, false);
ffffffffea8081e8:	910022a0 	add	x0, x21, #0x8
	stdcallstate.initial_cpu = cpu;
ffffffffea8081ec:	b9006ab9 	str	w25, [x21, #104]
	stdcallstate.restart_count = 0;
ffffffffea8081f0:	b90072bf 	str	wzr, [x21, #112]
	event_signal(&stdcallstate.event, false);
ffffffffea8081f4:	97fff54f 	bl	ffffffffea805730 <event_signal>
ffffffffea8081f8:	17ffffe0 	b	ffffffffea808178 <sm_return_and_wait_for_next_stdcall.isra.1+0xd0>
		dprintf(CRITICAL, "%s: cpu %d, std call busy\n", __func__, cpu);
ffffffffea8081fc:	2a1903e2 	mov	w2, w25
ffffffffea808200:	aa1803e1 	mov	x1, x24
ffffffffea808204:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808208:	91126000 	add	x0, x0, #0x498
ffffffffea80820c:	94002855 	bl	ffffffffea812360 <_dprintf>
ffffffffea808210:	aa1503e0 	mov	x0, x21
ffffffffea808214:	97ffe9b3 	bl	ffffffffea8028e0 <arch_spin_unlock>
		ret = SM_ERR_BUSY;
ffffffffea808218:	92800080 	mov	x0, #0xfffffffffffffffb    	// #-5
ffffffffea80821c:	17ffffc0 	b	ffffffffea80811c <sm_return_and_wait_for_next_stdcall.isra.1+0x74>
			dprintf(CRITICAL, "%s: cpu %d, unexpected restart, no std call active\n",
ffffffffea808220:	97ffea2c 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea808224:	2a0003e2 	mov	w2, w0
ffffffffea808228:	aa1803e1 	mov	x1, x24
ffffffffea80822c:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808230:	9112e000 	add	x0, x0, #0x4b8
ffffffffea808234:	9400284b 	bl	ffffffffea812360 <_dprintf>
ffffffffea808238:	aa1503e0 	mov	x0, x21
ffffffffea80823c:	97ffe9a9 	bl	ffffffffea8028e0 <arch_spin_unlock>
			ret = SM_ERR_UNEXPECTED_RESTART;
ffffffffea808240:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea808244:	17ffffb6 	b	ffffffffea80811c <sm_return_and_wait_for_next_stdcall.isra.1+0x74>
}
ffffffffea808248:	94002eb8 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80824c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808250 <sm_wait_for_smcall>:
{
ffffffffea808250:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea808254:	910003fd 	mov	x29, sp
ffffffffea808258:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80825c:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea808260:	a9025bf5 	stp	x21, x22, [sp, #32]
		if (cpu == stdcallstate.active_cpu) {
ffffffffea808264:	9116e273 	add	x19, x19, #0x5b8
{
ffffffffea808268:	a90363f7 	stp	x23, x24, [sp, #48]
	stdcallstate.active_cpu = -1;
ffffffffea80826c:	12800015 	mov	w21, #0xffffffff            	// #-1
ffffffffea808270:	f0000078 	adrp	x24, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808274:	f0000077 	adrp	x23, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
			ret = SM_ERR_INTERRUPTED;
ffffffffea808278:	92800096 	mov	x22, #0xfffffffffffffffb    	// #-5
ffffffffea80827c:	14000004 	b	ffffffffea80828c <sm_wait_for_smcall+0x3c>
		sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808280:	aa1403e0 	mov	x0, x20
ffffffffea808284:	97ffff89 	bl	ffffffffea8080a8 <sm_return_and_wait_for_next_stdcall.isra.1>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea808288:	d50342ff 	msr	daifclr, #0x2
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80828c:	d50342df 	msr	daifset, #0x2
		thread_yield();
ffffffffea808290:	97fff7cc 	bl	ffffffffea8061c0 <thread_yield>
			ret = SM_ERR_NOP_DONE;
ffffffffea808294:	928001d4 	mov	x20, #0xfffffffffffffff1    	// #-15
		cpu = arch_curr_cpu_num();
ffffffffea808298:	97ffea0e 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
		if (cpu == stdcallstate.active_cpu) {
ffffffffea80829c:	b9406661 	ldr	w1, [x19, #100]
ffffffffea8082a0:	6b00003f 	cmp	w1, w0
ffffffffea8082a4:	54fffee1 	b.ne	ffffffffea808280 <sm_wait_for_smcall+0x30>  // b.any
	uint cpu = arch_curr_cpu_num();
ffffffffea8082a8:	97ffea0a 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea8082ac:	2a0003f4 	mov	w20, w0
    arch_spin_lock(lock);
ffffffffea8082b0:	aa1303e0 	mov	x0, x19
ffffffffea8082b4:	97ffe983 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (stdcallstate.active_cpu != (int)cpu) {
ffffffffea8082b8:	b9406662 	ldr	w2, [x19, #100]
ffffffffea8082bc:	6b14005f 	cmp	w2, w20
ffffffffea8082c0:	54000241 	b.ne	ffffffffea808308 <sm_wait_for_smcall+0xb8>  // b.any
	if (stdcallstate.done) {
ffffffffea8082c4:	39418260 	ldrb	w0, [x19, #96]
	stdcallstate.active_cpu = -1;
ffffffffea8082c8:	b9006675 	str	w21, [x19, #100]
	stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea8082cc:	b9006e62 	str	w2, [x19, #108]
	if (stdcallstate.done) {
ffffffffea8082d0:	340000c0 	cbz	w0, ffffffffea8082e8 <sm_wait_for_smcall+0x98>
		ret = stdcallstate.ret;
ffffffffea8082d4:	f9402e74 	ldr	x20, [x19, #88]
		stdcallstate.done = false;
ffffffffea8082d8:	3901827f 	strb	wzr, [x19, #96]
    arch_spin_unlock(lock);
ffffffffea8082dc:	aa1303e0 	mov	x0, x19
ffffffffea8082e0:	97ffe980 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8082e4:	17ffffe7 	b	ffffffffea808280 <sm_wait_for_smcall+0x30>
		if (sm_get_api_version() >= TRUSTY_API_VERSION_SMP) {/* ns using new api */
ffffffffea8082e8:	97ffff2c 	bl	ffffffffea807f98 <sm_get_api_version>
ffffffffea8082ec:	7100041f 	cmp	w0, #0x1
ffffffffea8082f0:	540001a8 	b.hi	ffffffffea808324 <sm_wait_for_smcall+0xd4>  // b.pmore
		} else if (stdcallstate.restart_count) {
ffffffffea8082f4:	b9407260 	ldr	w0, [x19, #112]
			ret = SM_ERR_INTERRUPTED;
ffffffffea8082f8:	92800054 	mov	x20, #0xfffffffffffffffd    	// #-3
ffffffffea8082fc:	7100001f 	cmp	w0, #0x0
ffffffffea808300:	9a9412d4 	csel	x20, x22, x20, ne  // ne = any
ffffffffea808304:	17fffff6 	b	ffffffffea8082dc <sm_wait_for_smcall+0x8c>
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea808308:	294d1265 	ldp	w5, w4, [x19, #104]
ffffffffea80830c:	2a1403e3 	mov	w3, w20
ffffffffea808310:	910ac301 	add	x1, x24, #0x2b0
ffffffffea808314:	911642e0 	add	x0, x23, #0x590
		ret = SM_ERR_INTERNAL_FAILURE;
ffffffffea808318:	928000d4 	mov	x20, #0xfffffffffffffff9    	// #-7
		dprintf(CRITICAL, "%s: stdcallcpu, a%d != curr-cpu %d, l%d, i%d\n",
ffffffffea80831c:	94002811 	bl	ffffffffea812360 <_dprintf>
ffffffffea808320:	17ffffef 	b	ffffffffea8082dc <sm_wait_for_smcall+0x8c>
			ret = SM_ERR_CPU_IDLE;
ffffffffea808324:	92800194 	mov	x20, #0xfffffffffffffff3    	// #-13
ffffffffea808328:	17ffffed 	b	ffffffffea8082dc <sm_wait_for_smcall+0x8c>
ffffffffea80832c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808330 <sm_irq_return_ns>:
{
ffffffffea808330:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808334:	910003fd 	mov	x29, sp
ffffffffea808338:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea80833c:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea808340:	9116e293 	add	x19, x20, #0x5b8
ffffffffea808344:	a9025bf5 	stp	x21, x22, [sp, #32]
	cpu = arch_curr_cpu_num();
ffffffffea808348:	97ffe9e2 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
ffffffffea80834c:	2a0003f6 	mov	w22, w0
ffffffffea808350:	aa1303e0 	mov	x0, x19
ffffffffea808354:	97ffe95b 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (stdcallstate.active_cpu == cpu) {
ffffffffea808358:	b9406660 	ldr	w0, [x19, #100]
ffffffffea80835c:	928001b5 	mov	x21, #0xfffffffffffffff2    	// #-14
ffffffffea808360:	6b16001f 	cmp	w0, w22
ffffffffea808364:	540000a1 	b.ne	ffffffffea808378 <sm_irq_return_ns+0x48>  // b.any
		stdcallstate.active_cpu = -1;
ffffffffea808368:	12800001 	mov	w1, #0xffffffff            	// #-1
		ret = SM_ERR_INTERRUPTED;
ffffffffea80836c:	92800055 	mov	x21, #0xfffffffffffffffd    	// #-3
		stdcallstate.active_cpu = -1;
ffffffffea808370:	b9006661 	str	w1, [x19, #100]
		stdcallstate.last_cpu = stdcallstate.active_cpu;
ffffffffea808374:	b9006e60 	str	w0, [x19, #108]
    arch_spin_unlock(lock);
ffffffffea808378:	9116e280 	add	x0, x20, #0x5b8
ffffffffea80837c:	97ffe959 	bl	ffffffffea8028e0 <arch_spin_unlock>
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808380:	aa1503e0 	mov	x0, x21
}
ffffffffea808384:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808388:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80838c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	sm_return_and_wait_for_next_stdcall(ret, cpu);
ffffffffea808390:	17ffff46 	b	ffffffffea8080a8 <sm_return_and_wait_for_next_stdcall.isra.1>
ffffffffea808394:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808398 <sm_irq_loop>:
{
ffffffffea808398:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80839c:	910003fd 	mov	x29, sp
ffffffffea8083a0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8083a4:	aa0003f3 	mov	x19, x0
ffffffffea8083a8:	d50342df 	msr	daifset, #0x2
	irq_thread_ready[eventcpu] = true;
ffffffffea8083ac:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8083b0:	91336000 	add	x0, x0, #0xcd8
ffffffffea8083b4:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea8083b8:	3833c801 	strb	w1, [x0, w19, sxtw]
	cpu = arch_curr_cpu_num();
ffffffffea8083bc:	97ffe9c5 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
		event_wait(&nsirqevent[eventcpu]);
ffffffffea8083c0:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8083c4:	9134a000 	add	x0, x0, #0xd28
ffffffffea8083c8:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea8083cc:	9b210273 	smaddl	x19, w19, w1, x0
static inline bool event_initialized(event_t *e) {
	return e->magic == EVENT_MAGIC;
}

static inline status_t event_wait(event_t *e) {
	return event_wait_timeout(e, INFINITE_TIME);
ffffffffea8083d0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8083d4:	aa1303e0 	mov	x0, x19
ffffffffea8083d8:	97fff4b2 	bl	ffffffffea8056a0 <event_wait_timeout>
		sm_irq_return_ns();
ffffffffea8083dc:	97ffffd5 	bl	ffffffffea808330 <sm_irq_return_ns>
ffffffffea8083e0:	17fffffc 	b	ffffffffea8083d0 <sm_irq_loop+0x38>
ffffffffea8083e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8083e8 <sm_stdcall_loop>:
{
ffffffffea8083e8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8083ec:	910003fd 	mov	x29, sp
ffffffffea8083f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8083f4:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea8083f8:	9116e273 	add	x19, x19, #0x5b8
ffffffffea8083fc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea808400:	91002274 	add	x20, x19, #0x8
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea808404:	9100e276 	add	x22, x19, #0x38
{
ffffffffea808408:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80840c:	d00002d8 	adrp	x24, ffffffffea862000 <__ctor_list>
		stdcallstate.done = true;
ffffffffea808410:	52800037 	mov	w23, #0x1                   	// #1
{
ffffffffea808414:	f90023f9 	str	x25, [sp, #64]
		ret = sm_stdcall_table[SMC_ENTITY(stdcallstate.args.smc_nr)](&stdcallstate.args);
ffffffffea808418:	f9402715 	ldr	x21, [x24, #72]
ffffffffea80841c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808420:	aa1403e0 	mov	x0, x20
ffffffffea808424:	97fff49f 	bl	ffffffffea8056a0 <event_wait_timeout>
ffffffffea808428:	3940ee61 	ldrb	w1, [x19, #59]
ffffffffea80842c:	aa1603e0 	mov	x0, x22
ffffffffea808430:	92401421 	and	x1, x1, #0x3f
ffffffffea808434:	f8617aa1 	ldr	x1, [x21, x1, lsl #3]
ffffffffea808438:	d63f0020 	blr	x1
ffffffffea80843c:	aa0003f9 	mov	x25, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea808440:	d53b4221 	mrs	x1, daif
    arch_spin_lock(lock);
ffffffffea808444:	aa1303e0 	mov	x0, x19
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea808448:	37380161 	tbnz	w1, #7, ffffffffea808474 <sm_stdcall_loop+0x8c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80844c:	d50342df 	msr	daifset, #0x2
ffffffffea808450:	97ffe91c 	bl	ffffffffea8028c0 <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea808454:	f9002e79 	str	x25, [x19, #88]
		event_unsignal(&stdcallstate.event);
ffffffffea808458:	aa1403e0 	mov	x0, x20
		stdcallstate.done = true;
ffffffffea80845c:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808460:	97fff4f4 	bl	ffffffffea805830 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea808464:	aa1303e0 	mov	x0, x19
ffffffffea808468:	97ffe91e 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80846c:	d50342ff 	msr	daifclr, #0x2
ffffffffea808470:	17ffffea 	b	ffffffffea808418 <sm_stdcall_loop+0x30>
    arch_spin_lock(lock);
ffffffffea808474:	97ffe913 	bl	ffffffffea8028c0 <arch_spin_lock>
		stdcallstate.ret = ret;
ffffffffea808478:	f9002e79 	str	x25, [x19, #88]
		stdcallstate.done = true;
ffffffffea80847c:	39018277 	strb	w23, [x19, #96]
		event_unsignal(&stdcallstate.event);
ffffffffea808480:	aa1403e0 	mov	x0, x20
ffffffffea808484:	97fff4eb 	bl	ffffffffea805830 <event_unsignal>
    arch_spin_unlock(lock);
ffffffffea808488:	aa1303e0 	mov	x0, x19
ffffffffea80848c:	97ffe915 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea808490:	17ffffe3 	b	ffffffffea80841c <sm_stdcall_loop+0x34>
ffffffffea808494:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808498 <smc_sm_api_version>:
{
ffffffffea808498:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80849c:	910003fd 	mov	x29, sp
ffffffffea8084a0:	a90153f3 	stp	x19, x20, [sp, #16]
    arch_spin_lock(lock);
ffffffffea8084a4:	d0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
	uint32_t api_version = args->params[0];
ffffffffea8084a8:	b9400413 	ldr	w19, [x0, #4]
ffffffffea8084ac:	913bc280 	add	x0, x20, #0xef0
ffffffffea8084b0:	97ffe904 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!sm_api_version_locked) {
ffffffffea8084b4:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8084b8:	397be000 	ldrb	w0, [x0, #3832]
ffffffffea8084bc:	35000180 	cbnz	w0, ffffffffea8084ec <smc_sm_api_version+0x54>
ffffffffea8084c0:	71000e7f 	cmp	w19, #0x3
ffffffffea8084c4:	52800063 	mov	w3, #0x3                   	// #3
		sm_api_version = api_version;
ffffffffea8084c8:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8084cc:	1a839273 	csel	w19, w19, w3, ls  // ls = plast
ffffffffea8084d0:	b90ee813 	str	w19, [x0, #3816]
    arch_spin_unlock(lock);
ffffffffea8084d4:	913bc280 	add	x0, x20, #0xef0
ffffffffea8084d8:	97ffe902 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea8084dc:	2a1303e0 	mov	w0, w19
ffffffffea8084e0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8084e4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8084e8:	d65f03c0 	ret
ffffffffea8084ec:	f90013b5 	str	x21, [x29, #32]
		TRACEF("ERROR: Tried to select api version %d after use, current version %d\n",
ffffffffea8084f0:	d0000355 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8084f4:	2a1303e3 	mov	w3, w19
ffffffffea8084f8:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8084fc:	b94eeaa4 	ldr	w4, [x21, #3816]
ffffffffea808500:	91084021 	add	x1, x1, #0x210
ffffffffea808504:	52800ba2 	mov	w2, #0x5d                  	// #93
ffffffffea808508:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80850c:	91170000 	add	x0, x0, #0x5c0
ffffffffea808510:	94002dd2 	bl	ffffffffea813c58 <_printf>
		api_version = sm_api_version;
ffffffffea808514:	b94eeab3 	ldr	w19, [x21, #3816]
ffffffffea808518:	913bc280 	add	x0, x20, #0xef0
ffffffffea80851c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea808520:	97ffe8f0 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea808524:	2a1303e0 	mov	w0, w19
ffffffffea808528:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80852c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808530:	d65f03c0 	ret
ffffffffea808534:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808538 <sm_handle_irq>:
{
ffffffffea808538:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80853c:	910003fd 	mov	x29, sp
	int cpu = arch_curr_cpu_num();
ffffffffea808540:	97ffe964 	bl	ffffffffea802ad0 <arch_curr_cpu_num>
	if (irq_thread_ready[cpu]) {
ffffffffea808544:	d0000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808548:	91336021 	add	x1, x1, #0xcd8
ffffffffea80854c:	3860c821 	ldrb	w1, [x1, w0, sxtw]
ffffffffea808550:	35000161 	cbnz	w1, ffffffffea80857c <sm_handle_irq+0x44>
		TRACEF("warning: got ns irq before irq thread is ready\n");
ffffffffea808554:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808558:	91092021 	add	x1, x1, #0x248
ffffffffea80855c:	528038a2 	mov	w2, #0x1c5                 	// #453
ffffffffea808560:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808564:	910c6000 	add	x0, x0, #0x318
ffffffffea808568:	94002dbc 	bl	ffffffffea813c58 <_printf>
		sm_irq_return_ns();
ffffffffea80856c:	97ffff71 	bl	ffffffffea808330 <sm_irq_return_ns>
}
ffffffffea808570:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea808574:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808578:	d65f03c0 	ret
		event_signal(&nsirqevent[cpu], false);
ffffffffea80857c:	d0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808580:	9134a042 	add	x2, x2, #0xd28
ffffffffea808584:	52800603 	mov	w3, #0x30                  	// #48
ffffffffea808588:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80858c:	9b230800 	smaddl	x0, w0, w3, x2
ffffffffea808590:	97fff468 	bl	ffffffffea805730 <event_signal>
}
ffffffffea808594:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea808598:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80859c:	d65f03c0 	ret

ffffffffea8085a0 <sm_handle_fiq>:
{
ffffffffea8085a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea8085a4:	910003fd 	mov	x29, sp
ffffffffea8085a8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8085ac:	d00002d4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea8085b0:	f9402a80 	ldr	x0, [x20, #80]
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea8085b4:	a903ffbf 	stp	xzr, xzr, [x29, #56]
{
ffffffffea8085b8:	f9400001 	ldr	x1, [x0]
ffffffffea8085bc:	f9002fa1 	str	x1, [x29, #88]
ffffffffea8085c0:	d2800001 	mov	x1, #0x0                   	// #0
	smc32_args_t args = SMC32_ARGS_INITIAL_VALUE(args);
ffffffffea8085c4:	a904ffbf 	stp	xzr, xzr, [x29, #72]
{
ffffffffea8085c8:	f90013f5 	str	x21, [sp, #32]
	if (sm_get_api_version() >= TRUSTY_API_VERSION_RESTART_FIQ) {
ffffffffea8085cc:	97fffe73 	bl	ffffffffea807f98 <sm_get_api_version>
ffffffffea8085d0:	34000460 	cbz	w0, ffffffffea80865c <sm_handle_fiq+0xbc>
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea8085d4:	9100e3b5 	add	x21, x29, #0x38
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea8085d8:	52800053 	mov	w19, #0x2                   	// #2
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea8085dc:	92800160 	mov	x0, #0xfffffffffffffff4    	// #-12
ffffffffea8085e0:	aa1503e1 	mov	x1, x21
		expected_return = SMC_SC_RESTART_FIQ;
ffffffffea8085e4:	72a78013 	movk	w19, #0x3c00, lsl #16
		sm_sched_nonsecure(SM_ERR_FIQ_INTERRUPTED, &args);
ffffffffea8085e8:	97fffd46 	bl	ffffffffea807b00 <sm_sched_nonsecure>
	if (args.smc_nr != expected_return) {
ffffffffea8085ec:	b9403ba3 	ldr	w3, [x29, #56]
ffffffffea8085f0:	6b13007f 	cmp	w3, w19
ffffffffea8085f4:	54000220 	b.eq	ffffffffea808638 <sm_handle_fiq+0x98>  // b.none
		TRACEF("got bad restart smc %x, expected %x\n",
ffffffffea8085f8:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8085fc:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808600:	2a1303e4 	mov	w4, w19
ffffffffea808604:	52803b22 	mov	w2, #0x1d9                 	// #473
ffffffffea808608:	91096021 	add	x1, x1, #0x258
ffffffffea80860c:	910ba000 	add	x0, x0, #0x2e8
ffffffffea808610:	94002d92 	bl	ffffffffea813c58 <_printf>
		while (args.smc_nr != expected_return)
ffffffffea808614:	b9403ba0 	ldr	w0, [x29, #56]
ffffffffea808618:	6b00027f 	cmp	w19, w0
ffffffffea80861c:	540000e0 	b.eq	ffffffffea808638 <sm_handle_fiq+0x98>  // b.none
			sm_sched_nonsecure(SM_ERR_INTERLEAVED_SMC, &args);
ffffffffea808620:	928000a0 	mov	x0, #0xfffffffffffffffa    	// #-6
ffffffffea808624:	aa1503e1 	mov	x1, x21
ffffffffea808628:	97fffd36 	bl	ffffffffea807b00 <sm_sched_nonsecure>
		while (args.smc_nr != expected_return)
ffffffffea80862c:	b9403ba0 	ldr	w0, [x29, #56]
ffffffffea808630:	6b13001f 	cmp	w0, w19
ffffffffea808634:	54ffff61 	b.ne	ffffffffea808620 <sm_handle_fiq+0x80>  // b.any
}
ffffffffea808638:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80863c:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea808640:	f9400280 	ldr	x0, [x20]
ffffffffea808644:	ca000020 	eor	x0, x1, x0
ffffffffea808648:	b5000160 	cbnz	x0, ffffffffea808674 <sm_handle_fiq+0xd4>
ffffffffea80864c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808650:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808654:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea808658:	d65f03c0 	ret
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea80865c:	9100e3b5 	add	x21, x29, #0x38
		expected_return = SMC_SC_RESTART_LAST;
ffffffffea808660:	52a78013 	mov	w19, #0x3c000000            	// #1006632960
		sm_sched_nonsecure(SM_ERR_INTERRUPTED, &args);
ffffffffea808664:	aa1503e1 	mov	x1, x21
ffffffffea808668:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea80866c:	97fffd25 	bl	ffffffffea807b00 <sm_sched_nonsecure>
ffffffffea808670:	17ffffdf 	b	ffffffffea8085ec <sm_handle_fiq+0x4c>
}
ffffffffea808674:	94002dad 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea808678 <sm_get_boot_args>:
{
ffffffffea808678:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	if (!boot_argsp || !args_sizep) {
ffffffffea80867c:	f100001f 	cmp	x0, #0x0
ffffffffea808680:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea808684:	910003fd 	mov	x29, sp
ffffffffea808688:	f90017f6 	str	x22, [sp, #40]
	if (!boot_argsp || !args_sizep) {
ffffffffea80868c:	540003e0 	b.eq	ffffffffea808708 <sm_get_boot_args+0x90>  // b.none
ffffffffea808690:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea808694:	aa0103f4 	mov	x20, x1
ffffffffea808698:	f90013b5 	str	x21, [x29, #32]
ffffffffea80869c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8086a0:	aa0003f3 	mov	x19, x0
ffffffffea8086a4:	b0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea8086a8:	911602a0 	add	x0, x21, #0x580
ffffffffea8086ac:	97fff477 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (!boot_args) {
ffffffffea8086b0:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
		err = ERR_NOT_CONFIGURED;
ffffffffea8086b4:	128004b6 	mov	w22, #0xffffffda            	// #-38
	if (!boot_args) {
ffffffffea8086b8:	f9466401 	ldr	x1, [x0, #3272]
ffffffffea8086bc:	b4000161 	cbz	x1, ffffffffea8086e8 <sm_get_boot_args+0x70>
	*args_sizep = lk_boot_args[2];
ffffffffea8086c0:	d00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
	boot_args_refcnt++;
ffffffffea8086c4:	d0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
	status_t err = NO_ERROR;
ffffffffea8086c8:	52800016 	mov	w22, #0x0                   	// #0
	*args_sizep = lk_boot_args[2];
ffffffffea8086cc:	f9407c00 	ldr	x0, [x0, #248]
ffffffffea8086d0:	f9400800 	ldr	x0, [x0, #16]
	*boot_argsp = boot_args;
ffffffffea8086d4:	f9000261 	str	x1, [x19]
	boot_args_refcnt++;
ffffffffea8086d8:	b94cd041 	ldr	w1, [x2, #3280]
	*args_sizep = lk_boot_args[2];
ffffffffea8086dc:	f9000280 	str	x0, [x20]
	boot_args_refcnt++;
ffffffffea8086e0:	11000421 	add	w1, w1, #0x1
ffffffffea8086e4:	b90cd041 	str	w1, [x2, #3280]
	mutex_release(&boot_args_lock);
ffffffffea8086e8:	911602a0 	add	x0, x21, #0x580
ffffffffea8086ec:	97fff493 	bl	ffffffffea805938 <mutex_release>
	return err;
ffffffffea8086f0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea8086f4:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea8086f8:	2a1603e0 	mov	w0, w22
ffffffffea8086fc:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea808700:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808704:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea808708:	128000f6 	mov	w22, #0xfffffff8            	// #-8
ffffffffea80870c:	17fffffb 	b	ffffffffea8086f8 <sm_get_boot_args+0x80>

ffffffffea808710 <sm_put_boot_args>:

void sm_put_boot_args(void)
{
ffffffffea808710:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808714:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808718:	910003fd 	mov	x29, sp
ffffffffea80871c:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&boot_args_lock);

	if (!boot_args) {
ffffffffea808720:	d0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808724:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea808728:	91160260 	add	x0, x19, #0x580
ffffffffea80872c:	97fff457 	bl	ffffffffea805888 <mutex_acquire_timeout>
ffffffffea808730:	f9466681 	ldr	x1, [x20, #3272]
ffffffffea808734:	b40001e1 	cbz	x1, ffffffffea808770 <sm_put_boot_args+0x60>
		TRACEF("WARNING: caller does not own "
			"a reference to boot parameters\n");
		goto unlock;
	}

	boot_args_refcnt--;
ffffffffea808738:	d0000342 	adrp	x2, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80873c:	b94cd040 	ldr	w0, [x2, #3280]
ffffffffea808740:	51000400 	sub	w0, w0, #0x1
ffffffffea808744:	b90cd040 	str	w0, [x2, #3280]
	if (boot_args_refcnt == 0) {
ffffffffea808748:	350000c0 	cbnz	w0, ffffffffea808760 <sm_put_boot_args+0x50>
		vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)boot_args);
ffffffffea80874c:	d00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea808750:	f9408400 	ldr	x0, [x0, #264]
ffffffffea808754:	9400258b 	bl	ffffffffea811d80 <vmm_free_region>
		boot_args = NULL;
ffffffffea808758:	f906669f 	str	xzr, [x20, #3272]
		resume_nsthreads();
ffffffffea80875c:	97fffd8b 	bl	ffffffffea807d88 <resume_nsthreads>
	}
unlock:
	mutex_release(&boot_args_lock);
ffffffffea808760:	91160260 	add	x0, x19, #0x580
}
ffffffffea808764:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808768:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea80876c:	17fff473 	b	ffffffffea805938 <mutex_release>
		TRACEF("WARNING: caller does not own "
ffffffffea808770:	52804162 	mov	w2, #0x20b                 	// #523
ffffffffea808774:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808778:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80877c:	9109a021 	add	x1, x1, #0x268
ffffffffea808780:	91100000 	add	x0, x0, #0x400
ffffffffea808784:	94002d35 	bl	ffffffffea813c58 <_printf>
	mutex_release(&boot_args_lock);
ffffffffea808788:	91160260 	add	x0, x19, #0x580
}
ffffffffea80878c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808790:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&boot_args_lock);
ffffffffea808794:	17fff469 	b	ffffffffea805938 <mutex_release>

ffffffffea808798 <sm_release_boot_args>:

static void sm_release_boot_args(uint level)
{
ffffffffea808798:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80879c:	910003fd 	mov	x29, sp
ffffffffea8087a0:	f9000bf3 	str	x19, [sp, #16]
	if (boot_args) {
ffffffffea8087a4:	d0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8087a8:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea8087ac:	b40001e0 	cbz	x0, ffffffffea8087e8 <sm_release_boot_args+0x50>
		sm_put_boot_args();
ffffffffea8087b0:	97ffffd8 	bl	ffffffffea808710 <sm_put_boot_args>
		 * the boot loader didn't pass bootargs
		 */
		resume_nsthreads();
	}

	if (boot_args) {
ffffffffea8087b4:	f9466660 	ldr	x0, [x19, #3272]
ffffffffea8087b8:	b4000120 	cbz	x0, ffffffffea8087dc <sm_release_boot_args+0x44>
		TRACEF("WARNING: outstanding reference to boot args"
				"at the end of initialzation!\n");
	}
}
ffffffffea8087bc:	f9400bf3 	ldr	x19, [sp, #16]
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea8087c0:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
}
ffffffffea8087c4:	a8c27bfd 	ldp	x29, x30, [sp], #32
		TRACEF("WARNING: outstanding reference to boot args"
ffffffffea8087c8:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8087cc:	528044c2 	mov	w2, #0x226                 	// #550
ffffffffea8087d0:	910a0021 	add	x1, x1, #0x280
ffffffffea8087d4:	91112000 	add	x0, x0, #0x448
ffffffffea8087d8:	14002d20 	b	ffffffffea813c58 <_printf>
}
ffffffffea8087dc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8087e0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8087e4:	d65f03c0 	ret
		resume_nsthreads();
ffffffffea8087e8:	97fffd68 	bl	ffffffffea807d88 <resume_nsthreads>
ffffffffea8087ec:	17fffff2 	b	ffffffffea8087b4 <sm_release_boot_args+0x1c>

ffffffffea8087f0 <smc_nop_stdcall>:
 * context switch that will perform other secure work.
 */
static long smc_nop_stdcall(smc32_args_t *args)
{
	return 0;
}
ffffffffea8087f0:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8087f4:	d65f03c0 	ret

ffffffffea8087f8 <smc_nop_secure_monitor>:
/*
 * parameterized nop call handler
 */
static long smc_nop_secure_monitor(smc32_args_t *args)
{
	return (!args->params[0]) ? 0 : SM_ERR_UNDEFINED_SMC;
ffffffffea8087f8:	b9400401 	ldr	w1, [x0, #4]
ffffffffea8087fc:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea808800:	7100003f 	cmp	w1, #0x0
}
ffffffffea808804:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea808808:	d65f03c0 	ret
ffffffffea80880c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808810 <smc_undefined>:
{
ffffffffea808810:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea808814:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808818:	f0000063 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80881c:	911a6063 	add	x3, x3, #0x698
{
ffffffffea808820:	910003fd 	mov	x29, sp
ffffffffea808824:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea808828:	aa0003f4 	mov	x20, x0
ffffffffea80882c:	f0000073 	adrp	x19, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808830:	9118e273 	add	x19, x19, #0x638
{
ffffffffea808834:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Undefined monitor call!", args);
ffffffffea808838:	aa1303e1 	mov	x1, x19
ffffffffea80883c:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808840:	911ac000 	add	x0, x0, #0x6b0
ffffffffea808844:	94002d05 	bl	ffffffffea813c58 <_printf>
ffffffffea808848:	f0000075 	adrp	x21, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80884c:	b8404683 	ldr	w3, [x20], #4
ffffffffea808850:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808854:	f0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808858:	911a4021 	add	x1, x1, #0x690
ffffffffea80885c:	7100007f 	cmp	w3, #0x0
ffffffffea808860:	911a0084 	add	x4, x4, #0x680
ffffffffea808864:	911bc2b5 	add	x21, x21, #0x6f0
ffffffffea808868:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea80886c:	aa1303f6 	mov	x22, x19
ffffffffea808870:	aa1303e1 	mov	x1, x19
ffffffffea808874:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea808878:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80887c:	12003c66 	and	w6, w3, #0xffff
ffffffffea808880:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea808884:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea808888:	911b0000 	add	x0, x0, #0x6c0
ffffffffea80888c:	94002cf3 	bl	ffffffffea813c58 <_printf>
ffffffffea808890:	b8404684 	ldr	w4, [x20], #4
ffffffffea808894:	2a1303e3 	mov	w3, w19
ffffffffea808898:	52800842 	mov	w2, #0x42                  	// #66
ffffffffea80889c:	aa1603e1 	mov	x1, x22
ffffffffea8088a0:	aa1503e0 	mov	x0, x21
ffffffffea8088a4:	11000673 	add	w19, w19, #0x1
ffffffffea8088a8:	94002cec 	bl	ffffffffea813c58 <_printf>
ffffffffea8088ac:	71001e7f 	cmp	w19, #0x7
ffffffffea8088b0:	54ffff01 	b.ne	ffffffffea808890 <smc_undefined+0x80>  // b.any
}
ffffffffea8088b4:	b2407fe0 	mov	x0, #0xffffffff            	// #4294967295
ffffffffea8088b8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8088bc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8088c0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8088c4:	d65f03c0 	ret

ffffffffea8088c8 <smc_restart_stdcall>:
{
ffffffffea8088c8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea8088cc:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea8088d0:	f0000063 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8088d4:	91198063 	add	x3, x3, #0x660
{
ffffffffea8088d8:	910003fd 	mov	x29, sp
ffffffffea8088dc:	a90153f3 	stp	x19, x20, [sp, #16]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea8088e0:	aa0003f4 	mov	x20, x0
ffffffffea8088e4:	f0000073 	adrp	x19, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8088e8:	91192273 	add	x19, x19, #0x648
{
ffffffffea8088ec:	a9025bf5 	stp	x21, x22, [sp, #32]
	TRACE_SMC("Unexpected stdcall restart!", args);
ffffffffea8088f0:	aa1303e1 	mov	x1, x19
ffffffffea8088f4:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8088f8:	911ac000 	add	x0, x0, #0x6b0
ffffffffea8088fc:	94002cd7 	bl	ffffffffea813c58 <_printf>
ffffffffea808900:	f0000075 	adrp	x21, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808904:	b8404683 	ldr	w3, [x20], #4
ffffffffea808908:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80890c:	f0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808910:	911a4021 	add	x1, x1, #0x690
ffffffffea808914:	7100007f 	cmp	w3, #0x0
ffffffffea808918:	911a0084 	add	x4, x4, #0x680
ffffffffea80891c:	911bc2b5 	add	x21, x21, #0x6f0
ffffffffea808920:	9a81b084 	csel	x4, x4, x1, lt  // lt = tstop
ffffffffea808924:	aa1303f6 	mov	x22, x19
ffffffffea808928:	aa1303e1 	mov	x1, x19
ffffffffea80892c:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea808930:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808934:	12003c66 	and	w6, w3, #0xffff
ffffffffea808938:	d3587465 	ubfx	x5, x3, #24, #6
ffffffffea80893c:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea808940:	911b0000 	add	x0, x0, #0x6c0
ffffffffea808944:	94002cc5 	bl	ffffffffea813c58 <_printf>
ffffffffea808948:	b8404684 	ldr	w4, [x20], #4
ffffffffea80894c:	2a1303e3 	mov	w3, w19
ffffffffea808950:	52800922 	mov	w2, #0x49                  	// #73
ffffffffea808954:	aa1603e1 	mov	x1, x22
ffffffffea808958:	aa1503e0 	mov	x0, x21
ffffffffea80895c:	11000673 	add	w19, w19, #0x1
ffffffffea808960:	94002cbe 	bl	ffffffffea813c58 <_printf>
ffffffffea808964:	71001e7f 	cmp	w19, #0x7
ffffffffea808968:	54ffff01 	b.ne	ffffffffea808948 <smc_restart_stdcall+0x80>  // b.any
}
ffffffffea80896c:	92800060 	mov	x0, #0xfffffffffffffffc    	// #-4
ffffffffea808970:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808974:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea808978:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80897c:	d65f03c0 	ret

ffffffffea808980 <smc_fiq_exit>:
	}
	return handler_fn(args);
}

long smc_fiq_exit(smc32_args_t *args)
{
ffffffffea808980:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea808984:	910003fd 	mov	x29, sp
	sm_intc_fiq_exit();
ffffffffea808988:	97fff0ea 	bl	ffffffffea804d30 <sm_intc_fiq_exit>
	return 1; /* 0: reeenter fiq handler, 1: return */
}
ffffffffea80898c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea808990:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808994:	d65f03c0 	ret

ffffffffea808998 <smc_register_ns_dram_ranges>:
#endif

#if !defined(DISABLE_NS_DRAM_RANGE_CHECK)
static long smc_register_ns_dram_ranges(smc32_args_t *args)
{
	if (!args)
ffffffffea808998:	b4000080 	cbz	x0, ffffffffea8089a8 <smc_register_ns_dram_ranges+0x10>
		return ERR_INVALID_ARGS;

	ns_addr_t ns_base =  ((uint64_t)args->params[1] << 32) | args->params[0];

	return platform_register_ns_dram_ranges(ns_base, args->params[2]);
ffffffffea80899c:	b9400c01 	ldr	w1, [x0, #12]
ffffffffea8089a0:	f8404000 	ldur	x0, [x0, #4]
ffffffffea8089a4:	17ffe623 	b	ffffffffea802230 <platform_register_ns_dram_ranges>
}
ffffffffea8089a8:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea8089ac:	d65f03c0 	ret

ffffffffea8089b0 <smc_get_version_str>:
{
ffffffffea8089b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8089b4:	910003fd 	mov	x29, sp
ffffffffea8089b8:	a90153f3 	stp	x19, x20, [sp, #16]
	size_t version_len = strlen(lk_version);
ffffffffea8089bc:	d00002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
	int32_t index = args->params[0];
ffffffffea8089c0:	b9400414 	ldr	w20, [x0, #4]
	size_t version_len = strlen(lk_version);
ffffffffea8089c4:	f9409673 	ldr	x19, [x19, #296]
ffffffffea8089c8:	aa1303e0 	mov	x0, x19
ffffffffea8089cc:	94002e1d 	bl	ffffffffea814240 <strlen>
	if (index == -1) {
ffffffffea8089d0:	3100069f 	cmn	w20, #0x1
ffffffffea8089d4:	54000080 	b.eq	ffffffffea8089e4 <smc_get_version_str+0x34>  // b.none
	if ((size_t)index >= version_len) {
ffffffffea8089d8:	eb34c01f 	cmp	x0, w20, sxtw
ffffffffea8089dc:	540000a9 	b.ls	ffffffffea8089f0 <smc_get_version_str+0x40>  // b.plast
	return lk_version[index];
ffffffffea8089e0:	3874ca60 	ldrb	w0, [x19, w20, sxtw]
}
ffffffffea8089e4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8089e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8089ec:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8089f0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea8089f4:	17fffffc 	b	ffffffffea8089e4 <smc_get_version_str+0x34>

ffffffffea8089f8 <smc_fiq_enter>:
{
ffffffffea8089f8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea8089fc:	910003fd 	mov	x29, sp
	return sm_intc_fiq_enter();
ffffffffea808a00:	97fff09a 	bl	ffffffffea804c68 <sm_intc_fiq_enter>
}
ffffffffea808a04:	93407c00 	sxtw	x0, w0
ffffffffea808a08:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea808a0c:	d65f03c0 	ret

ffffffffea808a10 <smc_stdcall_secure_monitor>:
{
ffffffffea808a10:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808a14:	910003fd 	mov	x29, sp
ffffffffea808a18:	f9000bf3 	str	x19, [sp, #16]
	u_int function = SMC_FUNCTION(args->smc_nr);
ffffffffea808a1c:	79400013 	ldrh	w19, [x0]
	if (function < countof(sm_stdcall_function_table)) {
ffffffffea808a20:	71000e7f 	cmp	w19, #0x3
ffffffffea808a24:	540000c9 	b.ls	ffffffffea808a3c <smc_stdcall_secure_monitor+0x2c>  // b.plast
}
ffffffffea808a28:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		handler_fn = smc_undefined;
ffffffffea808a30:	90000001 	adrp	x1, ffffffffea808000 <sm_get_api_version+0x68>
ffffffffea808a34:	91204021 	add	x1, x1, #0x810
	return handler_fn(args);
ffffffffea808a38:	d61f0020 	br	x1
ffffffffea808a3c:	f90017a0 	str	x0, [x29, #40]
		platform_arch_speculation_barrier();
ffffffffea808a40:	97ffe5f8 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
		handler_fn = sm_stdcall_function_table[function];
ffffffffea808a44:	b0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea808a48:	9129a021 	add	x1, x1, #0xa68
	if (!handler_fn) {
ffffffffea808a4c:	f94017a0 	ldr	x0, [x29, #40]
		handler_fn = sm_stdcall_function_table[function];
ffffffffea808a50:	f8737821 	ldr	x1, [x1, x19, lsl #3]
	if (!handler_fn) {
ffffffffea808a54:	b4fffea1 	cbz	x1, ffffffffea808a28 <smc_stdcall_secure_monitor+0x18>
}
ffffffffea808a58:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a5c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	return handler_fn(args);
ffffffffea808a60:	d61f0020 	br	x1
ffffffffea808a64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808a68 <smc_cpu_resume>:
{
ffffffffea808a68:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
}

static inline void lk_init_level_all(enum lk_init_flags flags) {
	lk_init_level(flags, LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_LAST);
ffffffffea808a6c:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808a70:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808a74:	910003fd 	mov	x29, sp
ffffffffea808a78:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808a7c:	aa0003f3 	mov	x19, x0
ffffffffea808a80:	52800100 	mov	w0, #0x8                   	// #8
ffffffffea808a84:	97ffec87 	bl	ffffffffea803ca0 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808a88:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808a8c:	7100081f 	cmp	w0, #0x2
ffffffffea808a90:	540000a0 	b.eq	ffffffffea808aa4 <smc_cpu_resume+0x3c>  // b.none
}
ffffffffea808a94:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808a98:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808a9c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808aa0:	d65f03c0 	ret
ffffffffea808aa4:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808aa8:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808aac:	52800400 	mov	w0, #0x20                  	// #32
ffffffffea808ab0:	97ffec7c 	bl	ffffffffea803ca0 <lk_init_level>
ffffffffea808ab4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808ab8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808abc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808ac0:	d65f03c0 	ret
ffffffffea808ac4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808ac8 <smc_cpu_suspend>:
{
ffffffffea808ac8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808acc:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808ad0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808ad4:	910003fd 	mov	x29, sp
ffffffffea808ad8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808adc:	aa0003f3 	mov	x19, x0
ffffffffea808ae0:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea808ae4:	97ffec6f 	bl	ffffffffea803ca0 <lk_init_level>
	if (args->params[0] == MPIDR_MAX_AFFLVL)
ffffffffea808ae8:	b9400660 	ldr	w0, [x19, #4]
ffffffffea808aec:	7100081f 	cmp	w0, #0x2
ffffffffea808af0:	540000a0 	b.eq	ffffffffea808b04 <smc_cpu_suspend+0x3c>  // b.none
}
ffffffffea808af4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808af8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808afc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808b00:	d65f03c0 	ret
ffffffffea808b04:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea808b08:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808b0c:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea808b10:	97ffec64 	bl	ffffffffea803ca0 <lk_init_level>
ffffffffea808b14:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea808b18:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808b1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808b20:	d65f03c0 	ret
ffffffffea808b24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808b28 <sm_register_entity>:
	[SMC_ENTITY_SECURE_MONITOR] = smc_stdcall_secure_monitor,
	[SMC_ENTITY_SECURE_MONITOR + 1 ... SMC_NUM_ENTITIES - 1] = smc_undefined
};

status_t sm_register_entity(uint entity_nr, smc32_entity_t *entity)
{
ffffffffea808b28:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t err = NO_ERROR;

	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea808b2c:	7100fc1f 	cmp	w0, #0x3f
{
ffffffffea808b30:	910003fd 	mov	x29, sp
ffffffffea808b34:	f9000bf3 	str	x19, [sp, #16]
	if (entity_nr >= SMC_NUM_ENTITIES) {
ffffffffea808b38:	54000728 	b.hi	ffffffffea808c1c <sm_register_entity+0xf4>  // b.pmore
		return ERR_INVALID_ARGS;
	}
	if (entity_nr >= SMC_ENTITY_RESERVED && entity_nr < SMC_ENTITY_TRUSTED_APP) {
ffffffffea808b3c:	51001402 	sub	w2, w0, #0x5
ffffffffea808b40:	7100a85f 	cmp	w2, #0x2a
ffffffffea808b44:	54000709 	b.ls	ffffffffea808c24 <sm_register_entity+0xfc>  // b.plast
		return ERR_NOT_ALLOWED;
	}
	if (!entity) {
ffffffffea808b48:	b40006a1 	cbz	x1, ffffffffea808c1c <sm_register_entity+0xf4>
		return ERR_INVALID_ARGS;
	}
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea808b4c:	f9400022 	ldr	x2, [x1]
ffffffffea808b50:	b4000302 	cbz	x2, ffffffffea808bb0 <sm_register_entity+0x88>
ffffffffea808b54:	2a0003f3 	mov	w19, w0
ffffffffea808b58:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea808b5c:	aa0103f4 	mov	x20, x1
ffffffffea808b60:	b0000095 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea808b64:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808b68:	9128c2a0 	add	x0, x21, #0xa30
ffffffffea808b6c:	97fff347 	bl	ffffffffea805888 <mutex_acquire_timeout>
	}

	mutex_acquire(&smc_table_lock);

	/* Check if entity is already claimed */
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808b70:	2a1303e0 	mov	w0, w19
ffffffffea808b74:	b0000081 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea808b78:	912be021 	add	x1, x1, #0xaf8
ffffffffea808b7c:	90000002 	adrp	x2, ffffffffea808000 <sm_get_api_version+0x68>
ffffffffea808b80:	91204042 	add	x2, x2, #0x810
		sm_nopcall_table[entity_nr] != smc_undefined ||
		sm_stdcall_table[entity_nr] != smc_undefined) {
		err = ERR_ALREADY_EXISTS;
ffffffffea808b84:	128001b3 	mov	w19, #0xfffffff2            	// #-14
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808b88:	f8607823 	ldr	x3, [x1, x0, lsl #3]
ffffffffea808b8c:	eb02007f 	cmp	x3, x2
ffffffffea808b90:	54000180 	b.eq	ffffffffea808bc0 <sm_register_entity+0x98>  // b.none
	}
	if (entity->stdcall_handler) {
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
	}
unlock:
	mutex_release(&smc_table_lock);
ffffffffea808b94:	9128c2a0 	add	x0, x21, #0xa30
ffffffffea808b98:	97fff368 	bl	ffffffffea805938 <mutex_release>
	return err;
ffffffffea808b9c:	a941d7b4 	ldp	x20, x21, [x29, #24]
}
ffffffffea808ba0:	2a1303e0 	mov	w0, w19
ffffffffea808ba4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808ba8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808bac:	d65f03c0 	ret
	if (!entity->fastcall_handler && !entity->stdcall_handler){
ffffffffea808bb0:	f9400822 	ldr	x2, [x1, #16]
ffffffffea808bb4:	b5fffd02 	cbnz	x2, ffffffffea808b54 <sm_register_entity+0x2c>
		return ERR_NOT_VALID;
ffffffffea808bb8:	128000d3 	mov	w19, #0xfffffff9            	// #-7
ffffffffea808bbc:	17fffff9 	b	ffffffffea808ba0 <sm_register_entity+0x78>
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808bc0:	b0000084 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea808bc4:	9118c082 	add	x2, x4, #0x630
	if (sm_fastcall_table[entity_nr] != smc_undefined ||
ffffffffea808bc8:	f8607842 	ldr	x2, [x2, x0, lsl #3]
ffffffffea808bcc:	eb03005f 	cmp	x2, x3
ffffffffea808bd0:	54fffe21 	b.ne	ffffffffea808b94 <sm_register_entity+0x6c>  // b.any
		sm_stdcall_table[entity_nr] != smc_undefined) {
ffffffffea808bd4:	b0000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea808bd8:	9120c065 	add	x5, x3, #0x830
		sm_nopcall_table[entity_nr] != smc_undefined ||
ffffffffea808bdc:	f86078a5 	ldr	x5, [x5, x0, lsl #3]
ffffffffea808be0:	eb0200bf 	cmp	x5, x2
ffffffffea808be4:	54fffd81 	b.ne	ffffffffea808b94 <sm_register_entity+0x6c>  // b.any
	if (entity->fastcall_handler) {
ffffffffea808be8:	f9400282 	ldr	x2, [x20]
ffffffffea808bec:	b4000042 	cbz	x2, ffffffffea808bf4 <sm_register_entity+0xcc>
		sm_fastcall_table[entity_nr] = entity->fastcall_handler;
ffffffffea808bf0:	f8207822 	str	x2, [x1, x0, lsl #3]
	if (entity->nopcall_handler) {
ffffffffea808bf4:	f9400681 	ldr	x1, [x20, #8]
ffffffffea808bf8:	b4000061 	cbz	x1, ffffffffea808c04 <sm_register_entity+0xdc>
		sm_nopcall_table[entity_nr] = entity->nopcall_handler;
ffffffffea808bfc:	9118c084 	add	x4, x4, #0x630
ffffffffea808c00:	f8207881 	str	x1, [x4, x0, lsl #3]
	if (entity->stdcall_handler) {
ffffffffea808c04:	f9400a81 	ldr	x1, [x20, #16]
	status_t err = NO_ERROR;
ffffffffea808c08:	52800013 	mov	w19, #0x0                   	// #0
	if (entity->stdcall_handler) {
ffffffffea808c0c:	b4fffc41 	cbz	x1, ffffffffea808b94 <sm_register_entity+0x6c>
		sm_stdcall_table[entity_nr] = entity->stdcall_handler;
ffffffffea808c10:	9120c063 	add	x3, x3, #0x830
ffffffffea808c14:	f8207861 	str	x1, [x3, x0, lsl #3]
ffffffffea808c18:	17ffffdf 	b	ffffffffea808b94 <sm_register_entity+0x6c>
		return ERR_INVALID_ARGS;
ffffffffea808c1c:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea808c20:	17ffffe0 	b	ffffffffea808ba0 <sm_register_entity+0x78>
		return ERR_NOT_ALLOWED;
ffffffffea808c24:	12800213 	mov	w19, #0xffffffef            	// #-17
ffffffffea808c28:	17ffffde 	b	ffffffffea808ba0 <sm_register_entity+0x78>
ffffffffea808c2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808c30 <sm_decode_ns_memory_attr>:
status_t sm_decode_ns_memory_attr(struct ns_page_info *pinf,
				  ns_addr_t *ppa, uint *pmmu)
{
	uint mmu_flags = 0;

	if(!pinf) {
ffffffffea808c30:	b4000420 	cbz	x0, ffffffffea808cb4 <sm_decode_ns_memory_attr+0x84>
		pinf->attr,
		NS_PTE_PHYSADDR(pinf->attr),
		(uint)NS_PTE_ATTR_MAIR(pinf->attr),
		(uint)NS_PTE_ATTR_SHAREABLE(pinf->attr));

	if (ppa) {
ffffffffea808c34:	b4000081 	cbz	x1, ffffffffea808c44 <sm_decode_ns_memory_attr+0x14>
		*ppa = (ns_addr_t)NS_PTE_PHYSADDR(pinf->attr);
ffffffffea808c38:	f9400003 	ldr	x3, [x0]
ffffffffea808c3c:	92748c63 	and	x3, x3, #0xfffffffff000
ffffffffea808c40:	f9000023 	str	x3, [x1]
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;

		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
	}

	return NO_ERROR;
ffffffffea808c44:	52800003 	mov	w3, #0x0                   	// #0
	if (pmmu) {
ffffffffea808c48:	b4000282 	cbz	x2, ffffffffea808c98 <sm_decode_ns_memory_attr+0x68>
		switch ((uint)NS_PTE_ATTR_MAIR(pinf->attr)) {
ffffffffea808c4c:	f9400000 	ldr	x0, [x0]
ffffffffea808c50:	d370dc01 	ubfx	x1, x0, #48, #8
ffffffffea808c54:	7101103f 	cmp	w1, #0x44
ffffffffea808c58:	54000240 	b.eq	ffffffffea808ca0 <sm_decode_ns_memory_attr+0x70>  // b.none
ffffffffea808c5c:	7103fc3f 	cmp	w1, #0xff
ffffffffea808c60:	54000241 	b.ne	ffffffffea808ca8 <sm_decode_ns_memory_attr+0x78>  // b.any
			if(NS_PTE_ATTR_SHAREABLE(pinf->attr) != NS_INNER_SHAREABLE) {
ffffffffea808c64:	d3482401 	ubfx	x1, x0, #8, #2
ffffffffea808c68:	f1000c3f 	cmp	x1, #0x3
ffffffffea808c6c:	540001e1 	b.ne	ffffffffea808ca8 <sm_decode_ns_memory_attr+0x78>  // b.any
				mmu_flags |= ARCH_MMU_FLAG_CACHED;
ffffffffea808c70:	52800001 	mov	w1, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_USER;
ffffffffea808c74:	f27a001f 	tst	x0, #0x40
ffffffffea808c78:	321e0023 	orr	w3, w1, #0x4
ffffffffea808c7c:	1a811061 	csel	w1, w3, w1, ne  // ne = any
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808c80:	f279001f 	tst	x0, #0x80
ffffffffea808c84:	321d0020 	orr	w0, w1, #0x8
	return NO_ERROR;
ffffffffea808c88:	52800003 	mov	w3, #0x0                   	// #0
			mmu_flags |= ARCH_MMU_FLAG_PERM_RO;
ffffffffea808c8c:	1a811001 	csel	w1, w0, w1, ne  // ne = any
		*pmmu = mmu_flags | ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE;
ffffffffea808c90:	321c0421 	orr	w1, w1, #0x30
ffffffffea808c94:	b9000041 	str	w1, [x2]
}
ffffffffea808c98:	2a0303e0 	mov	w0, w3
ffffffffea808c9c:	d65f03c0 	ret
				mmu_flags |= ARCH_MMU_FLAG_UNCACHED;
ffffffffea808ca0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea808ca4:	17fffff4 	b	ffffffffea808c74 <sm_decode_ns_memory_attr+0x44>
				return ERR_NOT_SUPPORTED;
ffffffffea808ca8:	128002e3 	mov	w3, #0xffffffe8            	// #-24
}
ffffffffea808cac:	2a0303e0 	mov	w0, w3
ffffffffea808cb0:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea808cb4:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea808cb8:	17fffff8 	b	ffffffffea808c98 <sm_decode_ns_memory_attr+0x68>
ffffffffea808cbc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808cc0 <smc32_decode_mem_buf_info>:


/* Helper function to get NS memory buffer info out of smc32 call params */
status_t smc32_decode_mem_buf_info(struct smc32_args *args, ns_addr_t *ppa,
                                   ns_size_t *psz, uint *pmmu)
{
ffffffffea808cc0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808cc4:	aa0003e5 	mov	x5, x0
ffffffffea808cc8:	d00002c4 	adrp	x4, ffffffffea862000 <__ctor_list>
ffffffffea808ccc:	aa0203e7 	mov	x7, x2
ffffffffea808cd0:	910003fd 	mov	x29, sp

	DEBUG_ASSERT(args);

	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];

	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808cd4:	aa0303e2 	mov	x2, x3
	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];
ffffffffea808cd8:	910083a0 	add	x0, x29, #0x20
{
ffffffffea808cdc:	f9402883 	ldr	x3, [x4, #80]
	pi.attr = ((uint64_t)args->params[1] << 32) | args->params[0];
ffffffffea808ce0:	f84040a6 	ldur	x6, [x5, #4]
ffffffffea808ce4:	f81f0c06 	str	x6, [x0, #-16]!
{
ffffffffea808ce8:	f9400066 	ldr	x6, [x3]
ffffffffea808cec:	f9000fa6 	str	x6, [x29, #24]
ffffffffea808cf0:	d2800006 	mov	x6, #0x0                   	// #0
	res = sm_decode_ns_memory_attr(&pi, ppa, pmmu);
ffffffffea808cf4:	97ffffcf 	bl	ffffffffea808c30 <sm_decode_ns_memory_attr>
	if (res != NO_ERROR)
ffffffffea808cf8:	35000080 	cbnz	w0, ffffffffea808d08 <smc32_decode_mem_buf_info+0x48>
		return res;

	if (psz)
ffffffffea808cfc:	b4000067 	cbz	x7, ffffffffea808d08 <smc32_decode_mem_buf_info+0x48>
		*psz = (ns_size_t)args->params[2];
ffffffffea808d00:	b9400ca1 	ldr	w1, [x5, #12]
ffffffffea808d04:	b90000e1 	str	w1, [x7]

	return NO_ERROR;
}
ffffffffea808d08:	f9402884 	ldr	x4, [x4, #80]
ffffffffea808d0c:	f9400fa2 	ldr	x2, [x29, #24]
ffffffffea808d10:	f9400081 	ldr	x1, [x4]
ffffffffea808d14:	ca010041 	eor	x1, x2, x1
ffffffffea808d18:	b5000061 	cbnz	x1, ffffffffea808d24 <smc32_decode_mem_buf_info+0x64>
ffffffffea808d1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808d20:	d65f03c0 	ret
ffffffffea808d24:	94002c01 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea808d28 <trusty_init>:

static void trusty_init(uint level)
{
	dprintf(INFO, "initializing trusty (%s)\n", lk_version);

	trusty_app_init();
ffffffffea808d28:	14000094 	b	ffffffffea808f78 <trusty_app_init>
ffffffffea808d2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808d30 <start_apps>:
		fn(ta, data);
	}
}

static void start_apps(uint level)
{
ffffffffea808d30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	trusty_app_t *trusty_app;
	u_int i;
	int ret;

	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808d34:	d0000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
{
ffffffffea808d38:	910003fd 	mov	x29, sp
ffffffffea808d3c:	f90013f5 	str	x21, [sp, #32]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808d40:	d0000355 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
{
ffffffffea808d44:	f9000bf3 	str	x19, [sp, #16]
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea808d48:	b94f12a0 	ldr	w0, [x21, #3856]
ffffffffea808d4c:	f9479833 	ldr	x19, [x1, #3888]
ffffffffea808d50:	340002e0 	cbz	w0, ffffffffea808dac <start_apps+0x7c>
ffffffffea808d54:	f9000fb4 	str	x20, [x29, #24]
ffffffffea808d58:	913c42b5 	add	x21, x21, #0xf10
ffffffffea808d5c:	f90017b6 	str	x22, [x29, #40]
ffffffffea808d60:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea808d64:	aa1e03f6 	mov	x22, x30
ffffffffea808d68:	14000006 	b	ffffffffea808d80 <start_apps+0x50>
ffffffffea808d6c:	b94002a0 	ldr	w0, [x21]
ffffffffea808d70:	11000694 	add	w20, w20, #0x1
ffffffffea808d74:	9101a273 	add	x19, x19, #0x68
ffffffffea808d78:	6b14001f 	cmp	w0, w20
ffffffffea808d7c:	54000149 	b.ls	ffffffffea808da4 <start_apps+0x74>  // b.plast
		if (trusty_app->ut->entry) {
ffffffffea808d80:	f9402e60 	ldr	x0, [x19, #88]
ffffffffea808d84:	f9400401 	ldr	x1, [x0, #8]
ffffffffea808d88:	b4ffff21 	cbz	x1, ffffffffea808d6c <start_apps+0x3c>
			ret = uthread_start(trusty_app->ut);
ffffffffea808d8c:	94002ea5 	bl	ffffffffea814820 <uthread_start>
			if (ret) {
ffffffffea808d90:	34fffee0 	cbz	w0, ffffffffea808d6c <start_apps+0x3c>
				panic("Cannot start Trusty app!\n");
ffffffffea808d94:	f0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808d98:	aa1603e0 	mov	x0, x22
ffffffffea808d9c:	911da021 	add	x1, x1, #0x768
ffffffffea808da0:	940025f8 	bl	ffffffffea812580 <_panic>
ffffffffea808da4:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea808da8:	f94017b6 	ldr	x22, [x29, #40]
			}
		}
	}
	tegra_boot_profiler_record("start_apps: Done");
ffffffffea808dac:	f0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea808db0:	911e2000 	add	x0, x0, #0x788
ffffffffea808db4:	97fffa25 	bl	ffffffffea807648 <tegra_boot_profiler_record>
	/* Debug only: Prints all profiler records to UART during boot */
	/* tegra_boot_profiler_data_printnow(); */
	tegra_boot_profiler_deinit();
}
ffffffffea808db8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808dbc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808dc0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	tegra_boot_profiler_deinit();
ffffffffea808dc4:	17fffa1d 	b	ffffffffea807638 <tegra_boot_profiler_deinit>

ffffffffea808dc8 <trusty_register_app_notifier>:
{
ffffffffea808dc8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808dcc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808dd0:	910003fd 	mov	x29, sp
ffffffffea808dd4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808dd8:	aa0003f3 	mov	x19, x0
ffffffffea808ddc:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea808de0:	f90013f5 	str	x21, [sp, #32]
ffffffffea808de4:	91344280 	add	x0, x20, #0xd10
ffffffffea808de8:	97fff2a8 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808dec:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808df0:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808df4:	35000220 	cbnz	w0, ffffffffea808e38 <trusty_register_app_notifier+0x70>
	item->prev = list->prev;
ffffffffea808df8:	b0000080 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea808dfc:	91340001 	add	x1, x0, #0xd00
	item->next = list;
ffffffffea808e00:	f9000661 	str	x1, [x19, #8]
	status_t ret = NO_ERROR;
ffffffffea808e04:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea808e08:	f9468001 	ldr	x1, [x0, #3328]
ffffffffea808e0c:	f9000261 	str	x1, [x19]
	list->prev->next = item;
ffffffffea808e10:	f9468001 	ldr	x1, [x0, #3328]
	list->prev = item;
ffffffffea808e14:	f9068013 	str	x19, [x0, #3328]
	list->prev->next = item;
ffffffffea808e18:	f9000433 	str	x19, [x1, #8]
	mutex_release(&apps_lock);
ffffffffea808e1c:	91344280 	add	x0, x20, #0xd10
ffffffffea808e20:	97fff2c6 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea808e24:	2a1503e0 	mov	w0, w21
ffffffffea808e28:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea808e2c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808e30:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808e34:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808e38:	128000b5 	mov	w21, #0xfffffffa            	// #-6
ffffffffea808e3c:	17fffff8 	b	ffffffffea808e1c <trusty_register_app_notifier+0x54>

ffffffffea808e40 <trusty_als_alloc_slot>:
{
ffffffffea808e40:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea808e44:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808e48:	910003fd 	mov	x29, sp
ffffffffea808e4c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea808e50:	b0000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea808e54:	91344280 	add	x0, x20, #0xd10
ffffffffea808e58:	97fff28c 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (!apps_started) {
ffffffffea808e5c:	d0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808e60:	397c2000 	ldrb	w0, [x0, #3848]
ffffffffea808e64:	350001a0 	cbnz	w0, ffffffffea808e98 <trusty_als_alloc_slot+0x58>
		ret = ++als_slot_cnt;
ffffffffea808e68:	d00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea808e6c:	f9406421 	ldr	x1, [x1, #200]
ffffffffea808e70:	b9400020 	ldr	w0, [x1]
ffffffffea808e74:	11000400 	add	w0, w0, #0x1
ffffffffea808e78:	b9000020 	str	w0, [x1]
ffffffffea808e7c:	2a0003f3 	mov	w19, w0
	mutex_release(&apps_lock);
ffffffffea808e80:	91344280 	add	x0, x20, #0xd10
ffffffffea808e84:	97fff2ad 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea808e88:	2a1303e0 	mov	w0, w19
ffffffffea808e8c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea808e90:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea808e94:	d65f03c0 	ret
		ret = ERR_ALREADY_STARTED;
ffffffffea808e98:	128000b3 	mov	w19, #0xfffffffa            	// #-6
ffffffffea808e9c:	17fffff9 	b	ffffffffea808e80 <trusty_als_alloc_slot+0x40>

ffffffffea808ea0 <trusty_app_setup_mmio>:
{
ffffffffea808ea0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea808ea4:	910003fd 	mov	x29, sp
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808ea8:	b9404008 	ldr	w8, [x0, #64]
{
ffffffffea808eac:	f9000bf3 	str	x19, [sp, #16]
ffffffffea808eb0:	d00002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea808eb4:	f9402a64 	ldr	x4, [x19, #80]
ffffffffea808eb8:	f9400085 	ldr	x5, [x4]
ffffffffea808ebc:	f90017a5 	str	x5, [x29, #40]
ffffffffea808ec0:	d2800005 	mov	x5, #0x0                   	// #0
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808ec4:	34000148 	cbz	w8, ffffffffea808eec <trusty_app_setup_mmio+0x4c>
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808ec8:	f9402407 	ldr	x7, [x0, #72]
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808ecc:	52800004 	mov	w4, #0x0                   	// #0
		if (trusty_app->props.config_blob[i] == TRUSTY_APP_CONFIG_KEY_MAP_MEM) {
ffffffffea808ed0:	b86458e6 	ldr	w6, [x7, w4, uxtw #2]
ffffffffea808ed4:	11000485 	add	w5, w4, #0x1
ffffffffea808ed8:	71000cdf 	cmp	w6, #0x3
ffffffffea808edc:	540000c0 	b.eq	ffffffffea808ef4 <trusty_app_setup_mmio+0x54>  // b.none
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea808ee0:	110004a4 	add	w4, w5, #0x1
ffffffffea808ee4:	6b04011f 	cmp	w8, w4
ffffffffea808ee8:	54ffff48 	b.hi	ffffffffea808ed0 <trusty_app_setup_mmio+0x30>  // b.pmore
	return ERR_NOT_FOUND;
ffffffffea808eec:	12800020 	mov	w0, #0xfffffffe            	// #-2
ffffffffea808ef0:	14000016 	b	ffffffffea808f48 <trusty_app_setup_mmio+0xa8>
			id = trusty_app->props.config_blob[++i];
ffffffffea808ef4:	b86558e6 	ldr	w6, [x7, w5, uxtw #2]
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808ef8:	11000c85 	add	w5, w4, #0x3
			if (id != mmio_id) {
ffffffffea808efc:	6b0100df 	cmp	w6, w1
ffffffffea808f00:	54ffff01 	b.ne	ffffffffea808ee0 <trusty_app_setup_mmio+0x40>  // b.any
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808f04:	b86558e5 	ldr	w5, [x7, w5, uxtw #2]
			map_size = ROUNDUP(map_size, PAGE_SIZE);
ffffffffea808f08:	113ffc63 	add	w3, w3, #0xfff
ffffffffea808f0c:	12144c63 	and	w3, w3, #0xfffff000
			size = ROUNDUP(trusty_app->props.config_blob[++i],
ffffffffea808f10:	113ffca5 	add	w5, w5, #0xfff
ffffffffea808f14:	12144ca5 	and	w5, w5, #0xfffff000
			if (map_size > size) {
ffffffffea808f18:	6b0300bf 	cmp	w5, w3
ffffffffea808f1c:	54000263 	b.cc	ffffffffea808f68 <trusty_app_setup_mmio+0xc8>  // b.lo, b.ul, b.last
			offset = trusty_app->props.config_blob[++i];
ffffffffea808f20:	11000886 	add	w6, w4, #0x2
			return uthread_map_contig(trusty_app->ut, vaddr, offset,
ffffffffea808f24:	9100c3a8 	add	x8, x29, #0x30
ffffffffea808f28:	f9402c00 	ldr	x0, [x0, #88]
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea808f2c:	aa0203e1 	mov	x1, x2
ffffffffea808f30:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea808f34:	52801464 	mov	w4, #0xa3                  	// #163
ffffffffea808f38:	b86678e6 	ldr	w6, [x7, x6, lsl #2]
ffffffffea808f3c:	f81f0d06 	str	x6, [x8, #-16]!
ffffffffea808f40:	aa0803e2 	mov	x2, x8
ffffffffea808f44:	94002e5b 	bl	ffffffffea8148b0 <uthread_map>
}
ffffffffea808f48:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea808f4c:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea808f50:	f9400261 	ldr	x1, [x19]
ffffffffea808f54:	ca010041 	eor	x1, x2, x1
ffffffffea808f58:	b50000c1 	cbnz	x1, ffffffffea808f70 <trusty_app_setup_mmio+0xd0>
ffffffffea808f5c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea808f60:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea808f64:	d65f03c0 	ret
				return ERR_INVALID_ARGS;
ffffffffea808f68:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea808f6c:	17fffff7 	b	ffffffffea808f48 <trusty_app_setup_mmio+0xa8>
}
ffffffffea808f70:	94002b6e 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea808f74:	00000000 	.inst	0x00000000 ; undefined

ffffffffea808f78 <trusty_app_init>:
{
ffffffffea808f78:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
ffffffffea808f7c:	d00002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808f80:	d00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808f84:	d00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
{
ffffffffea808f88:	910003fd 	mov	x29, sp
ffffffffea808f8c:	f9402842 	ldr	x2, [x2, #80]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808f90:	f9402c00 	ldr	x0, [x0, #88]
{
ffffffffea808f94:	f9400043 	ldr	x3, [x2]
ffffffffea808f98:	f9008fa3 	str	x3, [x29, #280]
ffffffffea808f9c:	d2800003 	mov	x3, #0x0                   	// #0
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808fa0:	f9402021 	ldr	x1, [x1, #64]
ffffffffea808fa4:	d0000343 	adrp	x3, ffffffffea872000 <idle_threads+0xeb0>
{
ffffffffea808fa8:	f9000ff4 	str	x20, [sp, #24]
ffffffffea808fac:	f9002ffc 	str	x28, [sp, #88]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808fb0:	d0000354 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808fb4:	d000035c 	adrp	x28, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808fb8:	cb000022 	sub	x2, x1, x0
	trusty_app_image_end = (char *)&__trusty_app_end;
ffffffffea808fbc:	f9078c61 	str	x1, [x3, #3864]
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808fc0:	f2402c1f 	tst	x0, #0xfff
ffffffffea808fc4:	f9000bb3 	str	x19, [x29, #16]
ffffffffea808fc8:	f9003fbe 	str	x30, [x29, #120]
	trusty_app_image_start = (char *)&__trusty_app_start;
ffffffffea808fcc:	f9079680 	str	x0, [x20, #3880]
	trusty_app_image_size = (trusty_app_image_end - trusty_app_image_start);
ffffffffea808fd0:	b90f2382 	str	w2, [x28, #3872]
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea808fd4:	54003921 	b.ne	ffffffffea8096f8 <trusty_app_init+0x780>  // b.any
ffffffffea808fd8:	b0000093 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea808fdc:	91344273 	add	x19, x19, #0xd10
ffffffffea808fe0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea808fe4:	aa1303e0 	mov	x0, x19
ffffffffea808fe8:	f9002bbb 	str	x27, [x29, #80]
ffffffffea808fec:	97fff227 	bl	ffffffffea805888 <mutex_acquire_timeout>
	apps_started = true;
ffffffffea808ff0:	d0000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea808ff4:	52800022 	mov	w2, #0x1                   	// #1
	mutex_release(&apps_lock);
ffffffffea808ff8:	aa1303e0 	mov	x0, x19
ffffffffea808ffc:	d0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
	apps_started = true;
ffffffffea809000:	393c2022 	strb	w2, [x1, #3848]
	mutex_release(&apps_lock);
ffffffffea809004:	97fff24d 	bl	ffffffffea805938 <mutex_release>
	if (trusty_app_image_size) {
ffffffffea809008:	b94f2380 	ldr	w0, [x28, #3872]
ffffffffea80900c:	35001480 	cbnz	w0, ffffffffea80929c <trusty_app_init+0x324>
	platform_app_bootloader_epilog();
ffffffffea809010:	97ffe280 	bl	ffffffffea801a10 <platform_app_bootloader_epilog>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809014:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea809018:	b0000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80901c:	f947983b 	ldr	x27, [x1, #3888]
ffffffffea809020:	34001260 	cbz	w0, ffffffffea80926c <trusty_app_init+0x2f4>
ffffffffea809024:	910283a0 	add	x0, x29, #0xa0
ffffffffea809028:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80902c:	f9004ba0 	str	x0, [x29, #144]
ffffffffea809030:	9102e3b6 	add	x22, x29, #0xb8
ffffffffea809034:	9102a3a0 	add	x0, x29, #0xa8
ffffffffea809038:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80903c:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea809040:	b9008bbf 	str	wzr, [x29, #136]
ffffffffea809044:	f9004fa0 	str	x0, [x29, #152]
ffffffffea809048:	9102c3a0 	add	x0, x29, #0xb0
ffffffffea80904c:	f90043a0 	str	x0, [x29, #128]
		snprintf(name, sizeof(name), "trusty_app_%d_%08x-%04x-%04x",
ffffffffea809050:	79404f66 	ldrh	w6, [x27, #38]
ffffffffea809054:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809058:	79404b65 	ldrh	w5, [x27, #36]
ffffffffea80905c:	912c6002 	add	x2, x0, #0xb18
ffffffffea809060:	b9402364 	ldr	w4, [x27, #32]
ffffffffea809064:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea809068:	b9408ba3 	ldr	w3, [x29, #136]
ffffffffea80906c:	aa1603e0 	mov	x0, x22
ffffffffea809070:	94002ad0 	bl	ffffffffea813bb0 <snprintf>
		uthread = uthread_create(name, elf_hdr->e_entry,
ffffffffea809074:	f9402b60 	ldr	x0, [x27, #80]
ffffffffea809078:	aa1b03e5 	mov	x5, x27
ffffffffea80907c:	b9403764 	ldr	w4, [x27, #52]
ffffffffea809080:	d2a02003 	mov	x3, #0x1000000             	// #16777216
ffffffffea809084:	52800202 	mov	w2, #0x10                  	// #16
ffffffffea809088:	b9401801 	ldr	w1, [x0, #24]
ffffffffea80908c:	aa1603e0 	mov	x0, x22
ffffffffea809090:	94002e54 	bl	ffffffffea8149e0 <uthread_create>
ffffffffea809094:	aa0003f4 	mov	x20, x0
		if (uthread == NULL) {
ffffffffea809098:	b4004c80 	cbz	x0, ffffffffea809a28 <trusty_app_init+0xab0>
		tegra_boot_profiler_record("app_init: uthread allocated");
ffffffffea80909c:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8090a0:	912d6000 	add	x0, x0, #0xb58
ffffffffea8090a4:	97fff969 	bl	ffffffffea807648 <tegra_boot_profiler_record>
	Elf32_Ehdr *elf_hdr = trusty_app->app_img;
ffffffffea8090a8:	f9402b7c 	ldr	x28, [x27, #80]
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea8090ac:	79405b81 	ldrh	w1, [x28, #44]
		trusty_app->ut = uthread;
ffffffffea8090b0:	f9002f74 	str	x20, [x27, #88]
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea8090b4:	340007e1 	cbz	w1, ffffffffea8091b0 <trusty_app_init+0x238>
ffffffffea8090b8:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea8090bc:	52800019 	mov	w25, #0x0                   	// #0
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea8090c0:	528ffffa 	mov	w26, #0x7fff                	// #32767
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea8090c4:	52a02017 	mov	w23, #0x1000000             	// #16777216
		prg_hdr = (Elf32_Phdr *)(trusty_app_image + elf_hdr->e_phoff +
ffffffffea8090c8:	b9401f80 	ldr	w0, [x28, #28]
ffffffffea8090cc:	8b180000 	add	x0, x0, x24
ffffffffea8090d0:	8b000395 	add	x21, x28, x0
		if (prg_hdr->p_type != PT_LOAD) {
ffffffffea8090d4:	b8606b80 	ldr	w0, [x28, x0]
ffffffffea8090d8:	7100041f 	cmp	w0, #0x1
ffffffffea8090dc:	54000621 	b.ne	ffffffffea8091a0 <trusty_app_init+0x228>  // b.any
		if ((prg_hdr->p_vaddr < TRUSTY_APP_START_ADDR) ||
ffffffffea8090e0:	b9400aa0 	ldr	w0, [x21, #8]
ffffffffea8090e4:	6b1a001f 	cmp	w0, w26
ffffffffea8090e8:	540005c9 	b.ls	ffffffffea8091a0 <trusty_app_init+0x228>  // b.plast
ffffffffea8090ec:	f9400362 	ldr	x2, [x27]
ffffffffea8090f0:	eb20405f 	cmp	x2, w0, uxtw
ffffffffea8090f4:	54000569 	b.ls	ffffffffea8091a0 <trusty_app_init+0x228>  // b.plast
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea8090f8:	f2402c1f 	tst	x0, #0xfff
ffffffffea8090fc:	540039a1 	b.ne	ffffffffea809830 <trusty_app_init+0x8b8>  // b.any
ffffffffea809100:	b94006a1 	ldr	w1, [x21, #4]
ffffffffea809104:	2a0103e0 	mov	w0, w1
ffffffffea809108:	f2402c3f 	tst	x1, #0xfff
ffffffffea80910c:	54003921 	b.ne	ffffffffea809830 <trusty_app_init+0x8b8>  // b.any
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809110:	b94016b4 	ldr	w20, [x21, #20]
/* physical to virtual */
void *paddr_to_kvaddr(paddr_t pa);

/* virtual to physical */
paddr_t kvaddr_to_paddr(void *va);
static inline paddr_t vaddr_to_paddr(void *ptr) { return kvaddr_to_paddr(ptr); }
ffffffffea809114:	8b000380 	add	x0, x28, x0
ffffffffea809118:	94002166 	bl	ffffffffea8116b0 <kvaddr_to_paddr>
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea80911c:	b9401aa1 	ldr	w1, [x21, #24]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809120:	913ffe94 	add	x20, x20, #0xfff
		ret = uthread_map_contig(trusty_app->ut, &vaddr, paddr, size,
ffffffffea809124:	f9402f62 	ldr	x2, [x27, #88]
		size_t size = (prg_hdr->p_memsz + PAGE_MASK) & ~PAGE_MASK;
ffffffffea809128:	9274ce94 	and	x20, x20, #0xfffffffffffff000
		vaddr_t vaddr = prg_hdr->p_vaddr;
ffffffffea80912c:	b9400aa3 	ldr	w3, [x21, #8]
ffffffffea809130:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea809134:	a90a0fa0 	stp	x0, x3, [x29, #160]
		u_int flags = PF_TO_UTM_FLAGS(prg_hdr->p_flags) | UTM_FIXED;
ffffffffea809138:	531e0023 	ubfiz	w3, w1, #2, #1
ffffffffea80913c:	aa0203e0 	mov	x0, x2
ffffffffea809140:	d3420822 	ubfx	x2, x1, #2, #1
ffffffffea809144:	121f0021 	and	w1, w1, #0x2
ffffffffea809148:	2a030042 	orr	w2, w2, w3
ffffffffea80914c:	32180021 	orr	w1, w1, #0x100
ffffffffea809150:	aa1403e3 	mov	x3, x20
ffffffffea809154:	2a010041 	orr	w1, w2, w1
ffffffffea809158:	321b0024 	orr	w4, w1, #0x20
ffffffffea80915c:	a94907a2 	ldp	x2, x1, [x29, #144]
ffffffffea809160:	94002dd4 	bl	ffffffffea8148b0 <uthread_map>
		if (ret) {
ffffffffea809164:	35004180 	cbnz	w0, ffffffffea809994 <trusty_app_init+0xa1c>
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea809168:	b9403761 	ldr	w1, [x27, #52]
		if (stack_bot < vaddr + size) {
ffffffffea80916c:	f94057a0 	ldr	x0, [x29, #168]
		vaddr_t stack_bot = TRUSTY_APP_STACK_TOP - trusty_app->props.min_stack_size;
ffffffffea809170:	4b0102e1 	sub	w1, w23, w1
		if (stack_bot < vaddr + size) {
ffffffffea809174:	8b000280 	add	x0, x20, x0
ffffffffea809178:	eb00003f 	cmp	x1, x0
ffffffffea80917c:	540041a3 	b.cc	ffffffffea8099b0 <trusty_app_init+0xa38>  // b.lo, b.ul, b.last
		first = prg_hdr->p_vaddr;
ffffffffea809180:	b9400aa1 	ldr	w1, [x21, #8]
		last_mem = prg_hdr->p_vaddr + prg_hdr->p_memsz;
ffffffffea809184:	b94016a0 	ldr	w0, [x21, #20]
		if (last_mem > trusty_app->start_brk) {
ffffffffea809188:	f9400762 	ldr	x2, [x27, #8]
		last_mem = prg_hdr->p_vaddr + prg_hdr->p_memsz;
ffffffffea80918c:	0b000023 	add	w3, w1, w0
		if (last_mem > trusty_app->start_brk) {
ffffffffea809190:	eb02007f 	cmp	x3, x2
ffffffffea809194:	54003388 	b.hi	ffffffffea809804 <trusty_app_init+0x88c>  // b.pmore
ffffffffea809198:	79405b81 	ldrh	w1, [x28, #44]
ffffffffea80919c:	d503201f 	nop
	for (i = 0; i < elf_hdr->e_phnum; i++) {
ffffffffea8091a0:	11000739 	add	w25, w25, #0x1
ffffffffea8091a4:	91008318 	add	x24, x24, #0x20
ffffffffea8091a8:	6b01033f 	cmp	w25, w1
ffffffffea8091ac:	54fff8e3 	b.cc	ffffffffea8090c8 <trusty_app_init+0x150>  // b.lo, b.ul, b.last
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea8091b0:	f9400762 	ldr	x2, [x27, #8]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea8091b4:	f9400f60 	ldr	x0, [x27, #24]
	    trusty_app->props.min_heap_size) {
ffffffffea8091b8:	b9403b61 	ldr	w1, [x27, #56]
	trusty_app->cur_brk = trusty_app->start_brk;
ffffffffea8091bc:	f9000b62 	str	x2, [x27, #16]
	if ((trusty_app->end_brk - trusty_app->start_brk) >=
ffffffffea8091c0:	cb020000 	sub	x0, x0, x2
ffffffffea8091c4:	eb01001f 	cmp	x0, x1
ffffffffea8091c8:	54003ac3 	b.cc	ffffffffea809920 <trusty_app_init+0x9a8>  // b.lo, b.ul, b.last
		trusty_app->als = calloc(1, als_slot_cnt * sizeof(void*));
ffffffffea8091cc:	b00002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea8091d0:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea8091d4:	f9406421 	ldr	x1, [x1, #200]
ffffffffea8091d8:	b9400021 	ldr	w1, [x1]
ffffffffea8091dc:	d37df021 	lsl	x1, x1, #3
ffffffffea8091e0:	94002ae8 	bl	ffffffffea813d80 <calloc>
ffffffffea8091e4:	f9003360 	str	x0, [x27, #96]
		if (!trusty_app->als) {
ffffffffea8091e8:	b4004100 	cbz	x0, ffffffffea809a08 <trusty_app_init+0xa90>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea8091ec:	90000094 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea8091f0:	91340294 	add	x20, x20, #0xd00
ffffffffea8091f4:	f9400697 	ldr	x23, [x20, #8]
ffffffffea8091f8:	eb1402ff 	cmp	x23, x20
ffffffffea8091fc:	54000120 	b.eq	ffffffffea809220 <trusty_app_init+0x2a8>  // b.none
			if (n->startup) {
ffffffffea809200:	f9400ae1 	ldr	x1, [x23, #16]
ffffffffea809204:	b4000081 	cbz	x1, ffffffffea809214 <trusty_app_init+0x29c>
				ret = n->startup(trusty_app);
ffffffffea809208:	aa1b03e0 	mov	x0, x27
ffffffffea80920c:	d63f0020 	blr	x1
				if (ret != NO_ERROR) {
ffffffffea809210:	35003f20 	cbnz	w0, ffffffffea8099f4 <trusty_app_init+0xa7c>
		list_for_every_entry(&app_notifier_list, n, trusty_app_notifier_t, node) {
ffffffffea809214:	f94006f7 	ldr	x23, [x23, #8]
ffffffffea809218:	eb1402ff 	cmp	x23, x20
ffffffffea80921c:	54ffff21 	b.ne	ffffffffea809200 <trusty_app_init+0x288>  // b.any
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809220:	b9408ba0 	ldr	w0, [x29, #136]
		snprintf(profiler_print, sizeof(profiler_print), "Loaded app: %s", name);
ffffffffea809224:	aa1603e3 	mov	x3, x22
ffffffffea809228:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80922c:	91334042 	add	x2, x2, #0xcd0
ffffffffea809230:	d2800801 	mov	x1, #0x40                  	// #64
ffffffffea809234:	910363b4 	add	x20, x29, #0xd8
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809238:	11000415 	add	w21, w0, #0x1
		snprintf(profiler_print, sizeof(profiler_print), "Loaded app: %s", name);
ffffffffea80923c:	aa1403e0 	mov	x0, x20
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809240:	b9008bb5 	str	w21, [x29, #136]
		snprintf(profiler_print, sizeof(profiler_print), "Loaded app: %s", name);
ffffffffea809244:	94002a5b 	bl	ffffffffea813bb0 <snprintf>
		tegra_boot_profiler_record(profiler_print);
ffffffffea809248:	aa1403e0 	mov	x0, x20
ffffffffea80924c:	97fff8ff 	bl	ffffffffea807648 <tegra_boot_profiler_record>
	for (i = 0, trusty_app = trusty_app_list; i < trusty_app_count; i++, trusty_app++) {
ffffffffea809250:	b94f1260 	ldr	w0, [x19, #3856]
ffffffffea809254:	9101a37b 	add	x27, x27, #0x68
ffffffffea809258:	6b15001f 	cmp	w0, w21
ffffffffea80925c:	54ffefa8 	b.hi	ffffffffea809050 <trusty_app_init+0xd8>  // b.pmore
ffffffffea809260:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809264:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea809268:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80926c:	b00002c0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea809270:	f9402800 	ldr	x0, [x0, #80]
ffffffffea809274:	f9408fa1 	ldr	x1, [x29, #280]
ffffffffea809278:	f9400000 	ldr	x0, [x0]
ffffffffea80927c:	ca000020 	eor	x0, x1, x0
ffffffffea809280:	b5003b20 	cbnz	x0, ffffffffea8099e4 <trusty_app_init+0xa6c>
ffffffffea809284:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809288:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80928c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809290:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea809294:	a8d27bfd 	ldp	x29, x30, [sp], #288
ffffffffea809298:	d65f03c0 	ret
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea80929c:	d2820001 	mov	x1, #0x1000                	// #4096
ffffffffea8092a0:	f9001bb7 	str	x23, [x29, #48]
ffffffffea8092a4:	aa0103e0 	mov	x0, x1
	trusty_app_image_addr = trusty_app_image_start;
ffffffffea8092a8:	f9479694 	ldr	x20, [x20, #3880]
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea8092ac:	94002ab1 	bl	ffffffffea813d70 <memalign>
ffffffffea8092b0:	aa0003f7 	mov	x23, x0
ffffffffea8092b4:	b0000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea8092b8:	d2820002 	mov	x2, #0x1000                	// #4096
		trusty_app_list = (trusty_app_t *)memalign(PAGE_SIZE, PAGE_SIZE);
ffffffffea8092bc:	f9079820 	str	x0, [x1, #3888]
		memset(trusty_app, 0, PAGE_SIZE);
ffffffffea8092c0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8092c4:	94002b7d 	bl	ffffffffea8140b8 <memset>
	while (trusty_app_image_size > 0) {
ffffffffea8092c8:	b94f2380 	ldr	w0, [x28, #3872]
ffffffffea8092cc:	34003b60 	cbz	w0, ffffffffea809a38 <trusty_app_init+0xac0>
		guest_count++;
ffffffffea8092d0:	b0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8092d4:	910082f7 	add	x23, x23, #0x20
ffffffffea8092d8:	913c3000 	add	x0, x0, #0xf0c
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8092dc:	d000007b 	adrp	x27, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8092e0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8092e4:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea8092e8:	f90027ba 	str	x26, [x29, #72]
		guest_count++;
ffffffffea8092ec:	f90033a0 	str	x0, [x29, #96]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8092f0:	91230360 	add	x0, x27, #0x8c0
	while (trusty_app_image_size > 0) {
ffffffffea8092f4:	b9006fbf 	str	wzr, [x29, #108]
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea8092f8:	f9004ba0 	str	x0, [x29, #144]
	if (!strcmp(*task_image_addr, NV_GUEST_TASK_MAGIC_STR)) {
ffffffffea8092fc:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809300:	91200001 	add	x1, x0, #0x800
ffffffffea809304:	aa1403e0 	mov	x0, x20
ffffffffea809308:	94002b8c 	bl	ffffffffea814138 <strcmp>
ffffffffea80930c:	35000340 	cbnz	w0, ffffffffea809374 <trusty_app_init+0x3fc>
		guest_count++;
ffffffffea809310:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea809314:	b9400020 	ldr	w0, [x1]
ffffffffea809318:	11000400 	add	w0, w0, #0x1
ffffffffea80931c:	b9000020 	str	w0, [x1]
		if (guest_count == 1) {
ffffffffea809320:	7100041f 	cmp	w0, #0x1
ffffffffea809324:	54001e60 	b.eq	ffffffffea8096f0 <trusty_app_init+0x778>  // b.none
		*task_vmid = strtoul(task_header, &endp, 0);
ffffffffea809328:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80932c:	9102c3a1 	add	x1, x29, #0xb0
ffffffffea809330:	91003280 	add	x0, x20, #0xc
ffffffffea809334:	94002687 	bl	ffffffffea812d50 <strtoul>
ffffffffea809338:	b9006fa0 	str	w0, [x29, #108]
		if (*endp) {
ffffffffea80933c:	f9405ba0 	ldr	x0, [x29, #176]
ffffffffea809340:	39400000 	ldrb	w0, [x0]
ffffffffea809344:	35002e00 	cbnz	w0, ffffffffea809904 <trusty_app_init+0x98c>
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809348:	b0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea80934c:	b94f2382 	ldr	w2, [x28, #3872]
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809350:	b0000344 	adrp	x4, ffffffffea872000 <idle_threads+0xeb0>
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea809354:	91008281 	add	x1, x20, #0x20
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809358:	f9478c03 	ldr	x3, [x0, #3864]
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea80935c:	51008042 	sub	w2, w2, #0x20
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea809360:	aa1403e0 	mov	x0, x20
		trusty_app_image_size -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809364:	b90f2382 	str	w2, [x28, #3872]
		trusty_app_image_end -= NV_GUEST_TASK_HEAD_SIZE;
ffffffffea809368:	d1008063 	sub	x3, x3, #0x20
ffffffffea80936c:	f9078c83 	str	x3, [x4, #3864]
		memmove(*task_image_addr, new_task_image_addr, trusty_app_image_size);
ffffffffea809370:	94002ad6 	bl	ffffffffea813ec8 <memmove>
		if (strncmp((char *)ehdr->e_ident, ELFMAG, SELFMAG)) {
ffffffffea809374:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809378:	d2800082 	mov	x2, #0x4                   	// #4
ffffffffea80937c:	91216021 	add	x1, x1, #0x858
ffffffffea809380:	aa1403e0 	mov	x0, x20
ffffffffea809384:	94002bc3 	bl	ffffffffea814290 <strncmp>
ffffffffea809388:	35002ae0 	cbnz	w0, ffffffffea8098e4 <trusty_app_init+0x96c>
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea80938c:	b9402282 	ldr	w2, [x20, #32]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea809390:	52800516 	mov	w22, #0x28                  	// #40
ffffffffea809394:	79406681 	ldrh	w1, [x20, #50]
		shdr = (Elf32_Shdr *) ((intptr_t)ehdr + ehdr->e_shoff);
ffffffffea809398:	8b140042 	add	x2, x2, x20
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea80939c:	79406280 	ldrh	w0, [x20, #48]
		shstbl = (char *)((intptr_t)ehdr + shdr[ehdr->e_shstrndx].sh_offset);
ffffffffea8093a0:	9bb60821 	umaddl	x1, w1, w22, x2
ffffffffea8093a4:	b9401038 	ldr	w24, [x1, #16]
ffffffffea8093a8:	8b140301 	add	x1, x24, x20
ffffffffea8093ac:	f9004fa1 	str	x1, [x29, #152]
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea8093b0:	34001720 	cbz	w0, ffffffffea809694 <trusty_app_init+0x71c>
ffffffffea8093b4:	9100a041 	add	x1, x2, #0x28
ffffffffea8093b8:	51000400 	sub	w0, w0, #0x1
ffffffffea8093bc:	aa0203fb 	mov	x27, x2
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea8093c0:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8093c4:	91232082 	add	x2, x4, #0x8c8
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8093c8:	d0000063 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea8093cc:	a9087fa2 	stp	x2, xzr, [x29, #128]
ffffffffea8093d0:	d2800019 	mov	x25, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8093d4:	91236062 	add	x2, x3, #0x8d8
ffffffffea8093d8:	9bb60416 	umaddl	x22, w0, w22, x1
		bss_shdr = bss_pad_shdr = manifest_shdr = NULL;
ffffffffea8093dc:	d280001a 	mov	x26, #0x0                   	// #0
		trusty_app_max_extent = 0;
ffffffffea8093e0:	52800015 	mov	w21, #0x0                   	// #0
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea8093e4:	f9003ba2 	str	x2, [x29, #112]
ffffffffea8093e8:	1400000f 	b	ffffffffea809424 <trusty_app_init+0x4ac>
				trusty_app->end_bss = bss_shdr->sh_addr + bss_shdr->sh_size;
ffffffffea8093ec:	b9400f60 	ldr	w0, [x27, #12]
ffffffffea8093f0:	aa1b03fa 	mov	x26, x27
ffffffffea8093f4:	b9401761 	ldr	w1, [x27, #20]
ffffffffea8093f8:	0b010000 	add	w0, w0, w1
ffffffffea8093fc:	f81e02e0 	stur	x0, [x23, #-32]
			if (shdr[i].sh_type != SHT_NOBITS) {
ffffffffea809400:	7100231f 	cmp	w24, #0x8
ffffffffea809404:	540000a0 	b.eq	ffffffffea809418 <trusty_app_init+0x4a0>  // b.none
				extent = shdr[i].sh_offset + shdr[i].sh_size;
ffffffffea809408:	29420760 	ldp	w0, w1, [x27, #16]
ffffffffea80940c:	0b010000 	add	w0, w0, w1
ffffffffea809410:	6b0002bf 	cmp	w21, w0
ffffffffea809414:	1a8022b5 	csel	w21, w21, w0, cs  // cs = hs, nlast
ffffffffea809418:	9100a37b 	add	x27, x27, #0x28
		for (i = 0; i < ehdr->e_shnum; i++) {
ffffffffea80941c:	eb1b02df 	cmp	x22, x27
ffffffffea809420:	540002a0 	b.eq	ffffffffea809474 <trusty_app_init+0x4fc>  // b.none
			if (shdr[i].sh_type == SHT_NULL) {
ffffffffea809424:	b9400778 	ldr	w24, [x27, #4]
ffffffffea809428:	34ffff98 	cbz	w24, ffffffffea809418 <trusty_app_init+0x4a0>
			if (!strcmp((shstbl + shdr[i].sh_name), ".bss")) {
ffffffffea80942c:	a94903a1 	ldp	x1, x0, [x29, #144]
ffffffffea809430:	b9400373 	ldr	w19, [x27]
ffffffffea809434:	8b130013 	add	x19, x0, x19
ffffffffea809438:	aa1303e0 	mov	x0, x19
ffffffffea80943c:	94002b3f 	bl	ffffffffea814138 <strcmp>
ffffffffea809440:	34fffd60 	cbz	w0, ffffffffea8093ec <trusty_app_init+0x474>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea809444:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea809448:	aa1303e0 	mov	x0, x19
ffffffffea80944c:	94002b3b 	bl	ffffffffea814138 <strcmp>
ffffffffea809450:	340000e0 	cbz	w0, ffffffffea80946c <trusty_app_init+0x4f4>
			else if (!strcmp((shstbl + shdr[i].sh_name),
ffffffffea809454:	f9403ba1 	ldr	x1, [x29, #112]
ffffffffea809458:	aa1303e0 	mov	x0, x19
ffffffffea80945c:	94002b37 	bl	ffffffffea814138 <strcmp>
ffffffffea809460:	7100001f 	cmp	w0, #0x0
ffffffffea809464:	9a9b1339 	csel	x25, x25, x27, ne  // ne = any
ffffffffea809468:	17ffffe6 	b	ffffffffea809400 <trusty_app_init+0x488>
			else if (!strcmp((shstbl + shdr[i].sh_name), ".bss-pad")) {
ffffffffea80946c:	f90047bb 	str	x27, [x29, #136]
ffffffffea809470:	17ffffe4 	b	ffffffffea809400 <trusty_app_init+0x488>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea809474:	f94047a0 	ldr	x0, [x29, #136]
ffffffffea809478:	f100035f 	cmp	x26, #0x0
ffffffffea80947c:	fa401804 	ccmp	x0, #0x0, #0x4, ne  // ne = any
ffffffffea809480:	fa401b24 	ccmp	x25, #0x0, #0x4, ne  // ne = any
ffffffffea809484:	54001080 	b.eq	ffffffffea809694 <trusty_app_init+0x71c>  // b.none
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea809488:	29420b40 	ldp	w0, w2, [x26, #16]
ffffffffea80948c:	0b020001 	add	w1, w0, w2
ffffffffea809490:	6b15003f 	cmp	w1, w21
ffffffffea809494:	540014c8 	b.hi	ffffffffea80972c <trusty_app_init+0x7b4>  // b.pmore
		memset((uint8_t *)trusty_app_image_addr + bss_shdr->sh_offset, 0, bss_shdr->sh_size);
ffffffffea809498:	2a0203e2 	mov	w2, w2
ffffffffea80949c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8094a0:	8b204280 	add	x0, x20, w0, uxtw
ffffffffea8094a4:	94002b05 	bl	ffffffffea8140b8 <memset>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea8094a8:	29420323 	ldp	w3, w0, [x25, #16]
ffffffffea8094ac:	71003c1f 	cmp	w0, #0xf
ffffffffea8094b0:	54001509 	b.ls	ffffffffea809750 <trusty_app_init+0x7d8>  // b.plast
	trusty_app->props.vmid = task_vmid;
ffffffffea8094b4:	b9406fa2 	ldr	w2, [x29, #108]
	trusty_app->props.min_heap_size = 4 * PAGE_SIZE;
ffffffffea8094b8:	52880000 	mov	w0, #0x4000                	// #16384
	trusty_app->props.min_stack_size = DEFAULT_STACK_SIZE;
ffffffffea8094bc:	52820001 	mov	w1, #0x1000                	// #4096
ffffffffea8094c0:	290206e2 	stp	w2, w1, [x23, #16]
	trusty_app->props.min_heap_size = 4 * PAGE_SIZE;
ffffffffea8094c4:	b9001ae0 	str	w0, [x23, #24]
	manifest_data = (char *)(trusty_app_image_addr + shdr->sh_offset);
ffffffffea8094c8:	8b234293 	add	x19, x20, w3, uxtw
	memcpy(&trusty_app->props.uuid,
ffffffffea8094cc:	aa1303e1 	mov	x1, x19
ffffffffea8094d0:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea8094d4:	aa1703e0 	mov	x0, x23
ffffffffea8094d8:	94002a3c 	bl	ffffffffea813dc8 <memcpy>
	config_blob_size = (shdr->sh_size - sizeof(uuid_t));
ffffffffea8094dc:	b9401721 	ldr	w1, [x25, #20]
ffffffffea8094e0:	51004021 	sub	w1, w1, #0x10
	trusty_app->props.config_entry_cnt = config_blob_size / sizeof (u_int);
ffffffffea8094e4:	53027c21 	lsr	w1, w1, #2
ffffffffea8094e8:	b90022e1 	str	w1, [x23, #32]
	if (trusty_app->props.config_entry_cnt == 0) {
ffffffffea8094ec:	340004e1 	cbz	w1, ffffffffea809588 <trusty_app_init+0x610>
	manifest_data += sizeof(trusty_app->props.uuid);
ffffffffea8094f0:	91004263 	add	x3, x19, #0x10
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea8094f4:	52800000 	mov	w0, #0x0                   	// #0
	trusty_app->props.config_blob = config_blob;
ffffffffea8094f8:	f90016e3 	str	x3, [x23, #40]
ffffffffea8094fc:	d503201f 	nop
		switch (config_blob[i]) {
ffffffffea809500:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809504:	7100085f 	cmp	w2, #0x2
ffffffffea809508:	54000260 	b.eq	ffffffffea809554 <trusty_app_init+0x5dc>  // b.none
ffffffffea80950c:	71000c5f 	cmp	w2, #0x3
ffffffffea809510:	54000b20 	b.eq	ffffffffea809674 <trusty_app_init+0x6fc>  // b.none
ffffffffea809514:	7100045f 	cmp	w2, #0x1
ffffffffea809518:	540008a0 	b.eq	ffffffffea80962c <trusty_app_init+0x6b4>  // b.none
			dprintf(CRITICAL,
ffffffffea80951c:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809520:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809524:	911d4021 	add	x1, x1, #0x750
ffffffffea809528:	91282000 	add	x0, x0, #0xa08
ffffffffea80952c:	9400238d 	bl	ffffffffea812360 <_dprintf>
			ASSERT(0);
ffffffffea809530:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809534:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809538:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80953c:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809540:	52801be3 	mov	w3, #0xdf                  	// #223
ffffffffea809544:	9128a084 	add	x4, x4, #0xa28
ffffffffea809548:	911f6042 	add	x2, x2, #0x7d8
ffffffffea80954c:	91314021 	add	x1, x1, #0xc50
ffffffffea809550:	9400240c 	bl	ffffffffea812580 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809554:	4b000022 	sub	w2, w1, w0
ffffffffea809558:	7100045f 	cmp	w2, #0x1
ffffffffea80955c:	540010c9 	b.ls	ffffffffea809774 <trusty_app_init+0x7fc>  // b.plast
			trusty_app->props.min_heap_size =
ffffffffea809560:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea809564:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809568:	113ffc42 	add	w2, w2, #0xfff
ffffffffea80956c:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_heap_size =
ffffffffea809570:	b9001ae2 	str	w2, [x23, #24]
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea809574:	34001362 	cbz	w2, ffffffffea8097e0 <trusty_app_init+0x868>
	for (i = 0; i < trusty_app->props.config_entry_cnt; i++) {
ffffffffea809578:	11000400 	add	w0, w0, #0x1
ffffffffea80957c:	6b00003f 	cmp	w1, w0
ffffffffea809580:	54fffc08 	b.hi	ffffffffea809500 <trusty_app_init+0x588>  // b.pmore
ffffffffea809584:	d503201f 	nop
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809588:	b9402280 	ldr	w0, [x20, #32]
ffffffffea80958c:	11000eb5 	add	w21, w21, #0x3
		trusty_app->app_img = ehdr;
ffffffffea809590:	f9001af4 	str	x20, [x23, #48]
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809594:	121e76b5 	and	w21, w21, #0xfffffffc
ffffffffea809598:	6b0002bf 	cmp	w21, w0
ffffffffea80959c:	540015c1 	b.ne	ffffffffea809854 <trusty_app_init+0x8dc>  // b.any
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea8095a0:	79406281 	ldrh	w1, [x20, #48]
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea8095a4:	b0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea8095a8:	79405e82 	ldrh	w2, [x20, #46]
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea8095ac:	f9478c00 	ldr	x0, [x0, #3864]
	max_extent = (elf_hdr->e_shoff + (elf_hdr->e_shnum * elf_hdr->e_shentsize)) - 1;
ffffffffea8095b0:	1b025435 	madd	w21, w1, w2, w21
ffffffffea8095b4:	510006b6 	sub	w22, w21, #0x1
ffffffffea8095b8:	aa1603f5 	mov	x21, x22
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea8095bc:	910006d6 	add	x22, x22, #0x1
ffffffffea8095c0:	8b160281 	add	x1, x20, x22
ffffffffea8095c4:	eb00003f 	cmp	x1, x0
ffffffffea8095c8:	54001588 	b.hi	ffffffffea809878 <trusty_app_init+0x900>  // b.pmore
	next_trusty_app_align_start = trusty_app_image_addr + pad_hdr->sh_offset + pad_hdr->sh_size;
ffffffffea8095cc:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea8095d0:	29420858 	ldp	w24, w2, [x2, #16]
ffffffffea8095d4:	8b020318 	add	x24, x24, x2
ffffffffea8095d8:	8b180294 	add	x20, x20, x24
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea8095dc:	eb14003f 	cmp	x1, x20
ffffffffea8095e0:	540015e3 	b.cc	ffffffffea80989c <trusty_app_init+0x924>  // b.lo, b.ul, b.last
	copy_size = trusty_app_image_end - next_trusty_app_fsize_start;
ffffffffea8095e4:	cb010000 	sub	x0, x0, x1
	if (copy_size) {
ffffffffea8095e8:	35000680 	cbnz	w0, ffffffffea8096b8 <trusty_app_init+0x740>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8095ec:	b94f2380 	ldr	w0, [x28, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8095f0:	b0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8095f4:	51000400 	sub	w0, w0, #0x1
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8095f8:	b94f1261 	ldr	w1, [x19, #3856]
	trusty_app_image_size -= (max_extent + 1);
ffffffffea8095fc:	4b150015 	sub	w21, w0, w21
ffffffffea809600:	b90f2395 	str	w21, [x28, #3872]
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea809604:	11000420 	add	w0, w1, #0x1
ffffffffea809608:	7100981f 	cmp	w0, #0x26
ffffffffea80960c:	540015a8 	b.hi	ffffffffea8098c0 <trusty_app_init+0x948>  // b.pmore
		trusty_app_count++;
ffffffffea809610:	b90f1260 	str	w0, [x19, #3856]
ffffffffea809614:	9101a2f7 	add	x23, x23, #0x68
	while (trusty_app_image_size > 0) {
ffffffffea809618:	35ffe735 	cbnz	w21, ffffffffea8092fc <trusty_app_init+0x384>
ffffffffea80961c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809620:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea809624:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea809628:	17fffe7a 	b	ffffffffea809010 <trusty_app_init+0x98>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea80962c:	4b000022 	sub	w2, w1, w0
ffffffffea809630:	7100045f 	cmp	w2, #0x1
ffffffffea809634:	54000c49 	b.ls	ffffffffea8097bc <trusty_app_init+0x844>  // b.plast
			trusty_app->props.min_stack_size =
ffffffffea809638:	11000400 	add	w0, w0, #0x1
				ROUNDUP(config_blob[++i], 4096);
ffffffffea80963c:	b8605862 	ldr	w2, [x3, w0, uxtw #2]
ffffffffea809640:	113ffc42 	add	w2, w2, #0xfff
ffffffffea809644:	12144c42 	and	w2, w2, #0xfffff000
			trusty_app->props.min_stack_size =
ffffffffea809648:	b90016e2 	str	w2, [x23, #20]
			ASSERT(trusty_app->props.min_stack_size > 0);
ffffffffea80964c:	35fff962 	cbnz	w2, ffffffffea809578 <trusty_app_init+0x600>
ffffffffea809650:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809654:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809658:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80965c:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809660:	91262084 	add	x4, x4, #0x988
ffffffffea809664:	52801983 	mov	w3, #0xcc                  	// #204
ffffffffea809668:	911f6042 	add	x2, x2, #0x7d8
ffffffffea80966c:	91314021 	add	x1, x1, #0xc50
ffffffffea809670:	940023c4 	bl	ffffffffea812580 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea809674:	4b000022 	sub	w2, w1, w0
ffffffffea809678:	71000c5f 	cmp	w2, #0x3
ffffffffea80967c:	540008e9 	b.ls	ffffffffea809798 <trusty_app_init+0x820>  // b.plast
			trusty_app->props.map_io_mem_cnt++;
ffffffffea809680:	b9401ee2 	ldr	w2, [x23, #28]
			i += 3;
ffffffffea809684:	11000c00 	add	w0, w0, #0x3
			trusty_app->props.map_io_mem_cnt++;
ffffffffea809688:	11000442 	add	w2, w2, #0x1
ffffffffea80968c:	b9001ee2 	str	w2, [x23, #28]
ffffffffea809690:	17ffffba 	b	ffffffffea809578 <trusty_app_init+0x600>
		ASSERT(bss_shdr && bss_pad_shdr && manifest_shdr);
ffffffffea809694:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809698:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80969c:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8096a0:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8096a4:	91224084 	add	x4, x4, #0x890
ffffffffea8096a8:	52804723 	mov	w3, #0x239                 	// #569
ffffffffea8096ac:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8096b0:	91314021 	add	x1, x1, #0xc50
ffffffffea8096b4:	940023b3 	bl	ffffffffea812580 <_panic>
		memcpy(next_trusty_app_align_start, next_trusty_app_fsize_start, copy_size);
ffffffffea8096b8:	92407c13 	and	x19, x0, #0xffffffff
ffffffffea8096bc:	aa1403e0 	mov	x0, x20
ffffffffea8096c0:	aa1303e2 	mov	x2, x19
ffffffffea8096c4:	940029c1 	bl	ffffffffea813dc8 <memcpy>
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea8096c8:	aa1403e0 	mov	x0, x20
ffffffffea8096cc:	aa1303e1 	mov	x1, x19
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea8096d0:	cb1802d6 	sub	x22, x22, x24
		arch_sync_cache_range((addr_t)next_trusty_app_align_start,
ffffffffea8096d4:	97ffe0cd 	bl	ffffffffea801a08 <arch_sync_cache_range>
		trusty_app_image_end -= (next_trusty_app_fsize_start - next_trusty_app_align_start);
ffffffffea8096d8:	b0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8096dc:	f9478c00 	ldr	x0, [x0, #3864]
ffffffffea8096e0:	cb160016 	sub	x22, x0, x22
ffffffffea8096e4:	b0000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8096e8:	f9078c16 	str	x22, [x0, #3864]
ffffffffea8096ec:	17ffffc0 	b	ffffffffea8095ec <trusty_app_init+0x674>
			platform_disable_debug_intf();
ffffffffea8096f0:	97ffe2b6 	bl	ffffffffea8021c8 <platform_disable_debug_intf>
ffffffffea8096f4:	17ffff0d 	b	ffffffffea809328 <trusty_app_init+0x3b0>
	ASSERT(!((uintptr_t)trusty_app_image_start & PAGE_MASK));
ffffffffea8096f8:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8096fc:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809700:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809704:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea809708:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80970c:	911e8084 	add	x4, x4, #0x7a0
ffffffffea809710:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea809714:	52804f23 	mov	w3, #0x279                 	// #633
ffffffffea809718:	911f6042 	add	x2, x2, #0x7d8
ffffffffea80971c:	91314021 	add	x1, x1, #0xc50
ffffffffea809720:	aa1e03e0 	mov	x0, x30
ffffffffea809724:	f9002bbb 	str	x27, [x29, #80]
ffffffffea809728:	94002396 	bl	ffffffffea812580 <_panic>
		ASSERT((bss_shdr->sh_offset + bss_shdr->sh_size) <= trusty_app_max_extent);
ffffffffea80972c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809730:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809734:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809738:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80973c:	9123c084 	add	x4, x4, #0x8f0
ffffffffea809740:	52804783 	mov	w3, #0x23c                 	// #572
ffffffffea809744:	911f6042 	add	x2, x2, #0x7d8
ffffffffea809748:	91314021 	add	x1, x1, #0xc50
ffffffffea80974c:	9400238d 	bl	ffffffffea812580 <_panic>
	ASSERT(shdr->sh_size >= sizeof(uuid_t));
ffffffffea809750:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809754:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809758:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80975c:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809760:	9124e084 	add	x4, x4, #0x938
ffffffffea809764:	528013e3 	mov	w3, #0x9f                  	// #159
ffffffffea809768:	911f6042 	add	x2, x2, #0x7d8
ffffffffea80976c:	91314021 	add	x1, x1, #0xc50
ffffffffea809770:	94002384 	bl	ffffffffea812580 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea809774:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809778:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80977c:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809780:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809784:	91256084 	add	x4, x4, #0x958
ffffffffea809788:	52801a03 	mov	w3, #0xd0                  	// #208
ffffffffea80978c:	911f6042 	add	x2, x2, #0x7d8
ffffffffea809790:	91314021 	add	x1, x1, #0xc50
ffffffffea809794:	9400237b 	bl	ffffffffea812580 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 3);
ffffffffea809798:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80979c:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097a0:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097a4:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8097a8:	91276084 	add	x4, x4, #0x9d8
ffffffffea8097ac:	52801ae3 	mov	w3, #0xd7                  	// #215
ffffffffea8097b0:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8097b4:	91314021 	add	x1, x1, #0xc50
ffffffffea8097b8:	94002372 	bl	ffffffffea812580 <_panic>
			ASSERT((trusty_app->props.config_entry_cnt - i) > 1);
ffffffffea8097bc:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8097c0:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097c4:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097c8:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8097cc:	91256084 	add	x4, x4, #0x958
ffffffffea8097d0:	52801923 	mov	w3, #0xc9                  	// #201
ffffffffea8097d4:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8097d8:	91314021 	add	x1, x1, #0xc50
ffffffffea8097dc:	94002369 	bl	ffffffffea812580 <_panic>
			ASSERT(trusty_app->props.min_heap_size > 0);
ffffffffea8097e0:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8097e4:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097e8:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8097ec:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8097f0:	9126c084 	add	x4, x4, #0x9b0
ffffffffea8097f4:	52801a63 	mov	w3, #0xd3                  	// #211
ffffffffea8097f8:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8097fc:	91314021 	add	x1, x1, #0xc50
ffffffffea809800:	94002360 	bl	ffffffffea812580 <_panic>
			void *segment_start = trusty_app_image + prg_hdr->p_offset;
ffffffffea809804:	b94006a4 	ldr	w4, [x21, #4]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea809808:	8b214281 	add	x1, x20, w1, uxtw
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea80980c:	2a0003e2 	mov	w2, w0
			trusty_app->start_brk = last_mem;
ffffffffea809810:	f9000763 	str	x3, [x27, #8]
			trusty_app->end_brk = prg_hdr->p_vaddr + size;
ffffffffea809814:	f9000f61 	str	x1, [x27, #24]
			memset(segment_start + prg_hdr->p_memsz, 0,
ffffffffea809818:	8b020080 	add	x0, x4, x2
ffffffffea80981c:	8b000380 	add	x0, x28, x0
ffffffffea809820:	cb020282 	sub	x2, x20, x2
ffffffffea809824:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809828:	94002a24 	bl	ffffffffea8140b8 <memset>
ffffffffea80982c:	17fffe5b 	b	ffffffffea809198 <trusty_app_init+0x220>
		ASSERT(!(prg_hdr->p_vaddr & PAGE_MASK) &&
ffffffffea809830:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809834:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809838:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80983c:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809840:	912de084 	add	x4, x4, #0xb78
ffffffffea809844:	528027e3 	mov	w3, #0x13f                 	// #319
ffffffffea809848:	911f6042 	add	x2, x2, #0x7d8
ffffffffea80984c:	91314021 	add	x1, x1, #0xc50
ffffffffea809850:	9400234c 	bl	ffffffffea812580 <_panic>
	ASSERT(ROUNDUP(max_extent, 4) == elf_hdr->e_shoff);
ffffffffea809854:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809858:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80985c:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809860:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809864:	9128c084 	add	x4, x4, #0xa30
ffffffffea809868:	52803523 	mov	w3, #0x1a9                 	// #425
ffffffffea80986c:	911f6042 	add	x2, x2, #0x7d8
ffffffffea809870:	91314021 	add	x1, x1, #0xc50
ffffffffea809874:	94002343 	bl	ffffffffea812580 <_panic>
	ASSERT((trusty_app_image_addr + max_extent + 1) <= trusty_app_image_end);
ffffffffea809878:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80987c:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809880:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809884:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea809888:	91298084 	add	x4, x4, #0xa60
ffffffffea80988c:	528035c3 	mov	w3, #0x1ae                 	// #430
ffffffffea809890:	911f6042 	add	x2, x2, #0x7d8
ffffffffea809894:	91314021 	add	x1, x1, #0xc50
ffffffffea809898:	9400233a 	bl	ffffffffea812580 <_panic>
	ASSERT(next_trusty_app_align_start <= next_trusty_app_fsize_start);
ffffffffea80989c:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8098a0:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8098a4:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8098a8:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8098ac:	912aa084 	add	x4, x4, #0xaa8
ffffffffea8098b0:	52803643 	mov	w3, #0x1b2                 	// #434
ffffffffea8098b4:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8098b8:	91314021 	add	x1, x1, #0xc50
ffffffffea8098bc:	94002331 	bl	ffffffffea812580 <_panic>
		ASSERT((trusty_app_count + 1) < MAX_TRUSTY_APP_COUNT);
ffffffffea8098c0:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8098c4:	d0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8098c8:	d0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8098cc:	b0000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8098d0:	912ba084 	add	x4, x4, #0xae8
ffffffffea8098d4:	528048a3 	mov	w3, #0x245                 	// #581
ffffffffea8098d8:	911f6042 	add	x2, x2, #0x7d8
ffffffffea8098dc:	91314021 	add	x1, x1, #0xc50
ffffffffea8098e0:	94002328 	bl	ffffffffea812580 <_panic>
			dprintf(CRITICAL, "trusty_app_bootloader: ELF header not found\n");
ffffffffea8098e4:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8098e8:	b0000353 	adrp	x19, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8098ec:	91218000 	add	x0, x0, #0x860
ffffffffea8098f0:	9400229c 	bl	ffffffffea812360 <_dprintf>
ffffffffea8098f4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea8098f8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8098fc:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea809900:	17fffdc4 	b	ffffffffea809010 <trusty_app_init+0x98>
			dprintf(CRITICAL, "VMID convert fail\n");
ffffffffea809904:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809908:	91204000 	add	x0, x0, #0x810
ffffffffea80990c:	94002295 	bl	ffffffffea812360 <_dprintf>
			panic("failed to get trusty app image address \n");
ffffffffea809910:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809914:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809918:	9120a021 	add	x1, x1, #0x828
ffffffffea80991c:	94002319 	bl	ffffffffea812580 <_panic>
	heap = memalign(PAGE_SIZE, trusty_app->props.min_heap_size);
ffffffffea809920:	d2820000 	mov	x0, #0x1000                	// #4096
ffffffffea809924:	94002913 	bl	ffffffffea813d70 <memalign>
ffffffffea809928:	aa0003f4 	mov	x20, x0
	if (heap == 0) {
ffffffffea80992c:	b4000760 	cbz	x0, ffffffffea809a18 <trusty_app_init+0xaa0>
	memset(heap, 0, trusty_app->props.min_heap_size);
ffffffffea809930:	b9403b62 	ldr	w2, [x27, #56]
ffffffffea809934:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea809938:	940029e0 	bl	ffffffffea8140b8 <memset>
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea80993c:	f9402f77 	ldr	x23, [x27, #88]
	vaddr = trusty_app->end_brk;
ffffffffea809940:	f9400f60 	ldr	x0, [x27, #24]
ffffffffea809944:	f90057a0 	str	x0, [x29, #168]
ffffffffea809948:	aa1403e0 	mov	x0, x20
ffffffffea80994c:	94001f59 	bl	ffffffffea8116b0 <kvaddr_to_paddr>
	status = uthread_map_contig(trusty_app->ut, &vaddr,
ffffffffea809950:	b9403b63 	ldr	w3, [x27, #56]
ffffffffea809954:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea809958:	f94043a2 	ldr	x2, [x29, #128]
ffffffffea80995c:	52802464 	mov	w4, #0x123                 	// #291
ffffffffea809960:	f9404fa1 	ldr	x1, [x29, #152]
ffffffffea809964:	f9005ba0 	str	x0, [x29, #176]
ffffffffea809968:	aa1703e0 	mov	x0, x23
ffffffffea80996c:	94002bd1 	bl	ffffffffea8148b0 <uthread_map>
	if (status != NO_ERROR || vaddr != trusty_app->end_brk) {
ffffffffea809970:	35000280 	cbnz	w0, ffffffffea8099c0 <trusty_app_init+0xa48>
ffffffffea809974:	f9400f61 	ldr	x1, [x27, #24]
ffffffffea809978:	f94057a0 	ldr	x0, [x29, #168]
ffffffffea80997c:	eb00003f 	cmp	x1, x0
ffffffffea809980:	54000201 	b.ne	ffffffffea8099c0 <trusty_app_init+0xa48>  // b.any
	trusty_app->end_brk += trusty_app->props.min_heap_size;
ffffffffea809984:	b9403b60 	ldr	w0, [x27, #56]
ffffffffea809988:	8b010000 	add	x0, x0, x1
ffffffffea80998c:	f9000f60 	str	x0, [x27, #24]
ffffffffea809990:	17fffe0f 	b	ffffffffea8091cc <trusty_app_init+0x254>
			dprintf(CRITICAL, "cannot map the segment\n");
ffffffffea809994:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809998:	912f0000 	add	x0, x0, #0xbc0
ffffffffea80999c:	94002271 	bl	ffffffffea812360 <_dprintf>
			panic("failed to load address map\n");
ffffffffea8099a0:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8099a4:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8099a8:	91318021 	add	x1, x1, #0xc60
ffffffffea8099ac:	940022f5 	bl	ffffffffea812580 <_panic>
			dprintf(CRITICAL,
ffffffffea8099b0:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8099b4:	912f6000 	add	x0, x0, #0xbd8
ffffffffea8099b8:	9400226a 	bl	ffffffffea812360 <_dprintf>
ffffffffea8099bc:	17fffff9 	b	ffffffffea8099a0 <trusty_app_init+0xa28>
		dprintf(CRITICAL, "cannot map brk\n");
ffffffffea8099c0:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8099c4:	91304000 	add	x0, x0, #0xc10
ffffffffea8099c8:	94002266 	bl	ffffffffea812360 <_dprintf>
		free(heap);
ffffffffea8099cc:	aa1403e0 	mov	x0, x20
ffffffffea8099d0:	940028fc 	bl	ffffffffea813dc0 <free>
		dprintf(CRITICAL, "failed to load trusty_app: trusty_app heap creation error\n");
ffffffffea8099d4:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea8099d8:	91308000 	add	x0, x0, #0xc20
ffffffffea8099dc:	94002261 	bl	ffffffffea812360 <_dprintf>
ffffffffea8099e0:	17fffff0 	b	ffffffffea8099a0 <trusty_app_init+0xa28>
ffffffffea8099e4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8099e8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8099ec:	a9046bb9 	stp	x25, x26, [x29, #64]
}
ffffffffea8099f0:	940028ce 	bl	ffffffffea813d28 <__stack_chk_fail>
					panic("failed (%d) to invoke startup notifier\n", ret);
ffffffffea8099f4:	2a0003e2 	mov	w2, w0
ffffffffea8099f8:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8099fc:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809a00:	9132a021 	add	x1, x1, #0xca8
ffffffffea809a04:	940022df 	bl	ffffffffea812580 <_panic>
			panic("allocate app local storage failed\n");
ffffffffea809a08:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809a0c:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809a10:	91320021 	add	x1, x1, #0xc80
ffffffffea809a14:	940022db 	bl	ffffffffea812580 <_panic>
		dprintf(CRITICAL, "failed to load trusty_app: trusty_app heap creation error\n");
ffffffffea809a18:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809a1c:	91308000 	add	x0, x0, #0xc20
ffffffffea809a20:	94002250 	bl	ffffffffea812360 <_dprintf>
ffffffffea809a24:	17ffffdf 	b	ffffffffea8099a0 <trusty_app_init+0xa28>
			panic("allocate user thread failed\n");
ffffffffea809a28:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea809a2c:	d0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809a30:	912ce021 	add	x1, x1, #0xb38
ffffffffea809a34:	940022d3 	bl	ffffffffea812580 <_panic>
ffffffffea809a38:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea809a3c:	17fffd75 	b	ffffffffea809010 <trusty_app_init+0x98>

ffffffffea809a40 <sys_std_write>:
	return uthread_is_valid_range(uthread_get_current(), addr, size);
}

/* handle stdout/stderr */
static int32_t sys_std_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
ffffffffea809a40:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809a44:	910003fd 	mov	x29, sp
ffffffffea809a48:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea809a4c:	2a0203f5 	mov	w21, w2
ffffffffea809a50:	f90017f6 	str	x22, [sp, #40]
	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea809a54:	2a0103f4 	mov	w20, w1
{
ffffffffea809a58:	2a0003f6 	mov	w22, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea809a5c:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809a60:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809a64:	aa1503e2 	mov	x2, x21
ffffffffea809a68:	aa1403e1 	mov	x1, x20
ffffffffea809a6c:	94002d5b 	bl	ffffffffea814fd8 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)user_ptr, size)) {
ffffffffea809a70:	72001c1f 	tst	w0, #0xff
ffffffffea809a74:	540001e0 	b.eq	ffffffffea809ab0 <sys_std_write+0x70>  // b.none
ffffffffea809a78:	f9000bb3 	str	x19, [x29, #16]
		return ERR_INVALID_ARGS;
	}
	/* always send out error logs */
	dwrite((fd == 2) ? ALWAYS : INFO, (const void *)(uintptr_t)user_ptr, size);
ffffffffea809a7c:	71000adf 	cmp	w22, #0x2
ffffffffea809a80:	aa1503f3 	mov	x19, x21
ffffffffea809a84:	540000e0 	b.eq	ffffffffea809aa0 <sys_std_write+0x60>  // b.none

	return size;
ffffffffea809a88:	2a1303e0 	mov	w0, w19
ffffffffea809a8c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea809a90:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea809a94:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea809a98:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809a9c:	d65f03c0 	ret
	dwrite((fd == 2) ? ALWAYS : INFO, (const void *)(uintptr_t)user_ptr, size);
ffffffffea809aa0:	aa1503e1 	mov	x1, x21
ffffffffea809aa4:	aa1403e0 	mov	x0, x20
ffffffffea809aa8:	94002204 	bl	ffffffffea8122b8 <_dwrite>
ffffffffea809aac:	17fffff7 	b	ffffffffea809a88 <sys_std_write+0x48>
		return ERR_INVALID_ARGS;
ffffffffea809ab0:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea809ab4:	17fffff7 	b	ffffffffea809a90 <sys_std_write+0x50>

ffffffffea809ab8 <sys_write>:
	if (fd >= countof(sys_fds)) {
ffffffffea809ab8:	7100241f 	cmp	w0, #0x9
ffffffffea809abc:	540001c8 	b.hi	ffffffffea809af4 <sys_write+0x3c>  // b.pmore
ffffffffea809ac0:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809ac4:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809ac8:	91352063 	add	x3, x3, #0xd48
ffffffffea809acc:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_write(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->write) {
ffffffffea809ad0:	b4000123 	cbz	x3, ffffffffea809af4 <sys_write+0x3c>
ffffffffea809ad4:	f9400463 	ldr	x3, [x3, #8]
ffffffffea809ad8:	b40000e3 	cbz	x3, ffffffffea809af4 <sys_write+0x3c>
{
ffffffffea809adc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809ae0:	910003fd 	mov	x29, sp
		return ops->write(fd, user_ptr, size);
ffffffffea809ae4:	d63f0060 	blr	x3
ffffffffea809ae8:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809aec:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809af0:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809af4:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809af8:	d65f03c0 	ret
ffffffffea809afc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809b00 <sys_brk>:
ffffffffea809b00:	d538d081 	mrs	x1, tpidr_el1

long sys_brk(u_int brk)
{
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809b04:	f9415821 	ldr	x1, [x1, #688]

	/* update brk, if within range */
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea809b08:	2a0003e0 	mov	w0, w0
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809b0c:	f9404821 	ldr	x1, [x1, #144]
	if ((brk >= trusty_app->start_brk) && (brk <= trusty_app->end_brk)) {
ffffffffea809b10:	f9400422 	ldr	x2, [x1, #8]
ffffffffea809b14:	eb02001f 	cmp	x0, x2
ffffffffea809b18:	540000c3 	b.cc	ffffffffea809b30 <sys_brk+0x30>  // b.lo, b.ul, b.last
ffffffffea809b1c:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea809b20:	eb02001f 	cmp	x0, x2
ffffffffea809b24:	54000068 	b.hi	ffffffffea809b30 <sys_brk+0x30>  // b.pmore
		trusty_app->cur_brk = brk;
ffffffffea809b28:	f9000820 	str	x0, [x1, #16]
	}
	return (long) trusty_app->cur_brk;
}
ffffffffea809b2c:	d65f03c0 	ret
ffffffffea809b30:	f9400820 	ldr	x0, [x1, #16]
ffffffffea809b34:	d65f03c0 	ret

ffffffffea809b38 <sys_exit_group>:

long sys_exit_group(void)
{
ffffffffea809b38:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809b3c:	910003fd 	mov	x29, sp
ffffffffea809b40:	d538d081 	mrs	x1, tpidr_el1
	thread_t *current = get_current_thread();
	dprintf(CRITICAL, "exit called, thread %p, name %s\n",
ffffffffea809b44:	910ae022 	add	x2, x1, #0x2b8
ffffffffea809b48:	d0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea809b4c:	91338000 	add	x0, x0, #0xce0
ffffffffea809b50:	94002204 	bl	ffffffffea812360 <_dprintf>
		current, current->name);
	uthread_exit(0);
ffffffffea809b54:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea809b58:	94002b38 	bl	ffffffffea814838 <uthread_exit>
ffffffffea809b5c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809b60 <sys_read>:
	if (fd >= countof(sys_fds)) {
ffffffffea809b60:	7100241f 	cmp	w0, #0x9
ffffffffea809b64:	540001c8 	b.hi	ffffffffea809b9c <sys_read+0x3c>  // b.pmore
ffffffffea809b68:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809b6c:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809b70:	91352063 	add	x3, x3, #0xd48
ffffffffea809b74:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_read(uint32_t fd, user_addr_t user_ptr, uint32_t size)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->read) {
ffffffffea809b78:	b4000123 	cbz	x3, ffffffffea809b9c <sys_read+0x3c>
ffffffffea809b7c:	f9400063 	ldr	x3, [x3]
ffffffffea809b80:	b40000e3 	cbz	x3, ffffffffea809b9c <sys_read+0x3c>
{
ffffffffea809b84:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809b88:	910003fd 	mov	x29, sp
		return ops->read(fd, user_ptr, size);
ffffffffea809b8c:	d63f0060 	blr	x3
ffffffffea809b90:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809b94:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809b98:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809b9c:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809ba0:	d65f03c0 	ret
ffffffffea809ba4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809ba8 <sys_ioctl>:
	if (fd >= countof(sys_fds)) {
ffffffffea809ba8:	7100241f 	cmp	w0, #0x9
ffffffffea809bac:	540001c8 	b.hi	ffffffffea809be4 <sys_ioctl+0x3c>  // b.pmore
ffffffffea809bb0:	2a0003e4 	mov	w4, w0
	return sys_fds[fd];
ffffffffea809bb4:	90000083 	adrp	x3, ffffffffea819000 <_mem_phys_base>
ffffffffea809bb8:	91352063 	add	x3, x3, #0xd48
ffffffffea809bbc:	f8645863 	ldr	x3, [x3, w4, uxtw #3]

long sys_ioctl(uint32_t fd, uint32_t req, user_addr_t user_ptr)
{
	const struct sys_fd_ops *ops = get_sys_fd_handler(fd);

	if (ops && ops->ioctl) {
ffffffffea809bc0:	b4000123 	cbz	x3, ffffffffea809be4 <sys_ioctl+0x3c>
ffffffffea809bc4:	f9400863 	ldr	x3, [x3, #16]
ffffffffea809bc8:	b40000e3 	cbz	x3, ffffffffea809be4 <sys_ioctl+0x3c>
{
ffffffffea809bcc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809bd0:	910003fd 	mov	x29, sp
		return ops->ioctl(fd, req, user_ptr);
ffffffffea809bd4:	d63f0060 	blr	x3
ffffffffea809bd8:	93407c00 	sxtw	x0, w0
	}
	return ERR_NOT_SUPPORTED;
}
ffffffffea809bdc:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809be0:	d65f03c0 	ret
	return ERR_NOT_SUPPORTED;
ffffffffea809be4:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
}
ffffffffea809be8:	d65f03c0 	ret
ffffffffea809bec:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809bf0 <sys_nanosleep>:
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))

long sys_nanosleep(uint32_t clock_id, uint32_t flags,
		   uint32_t sleep_time_l, uint32_t sleep_time_h)
{
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea809bf0:	2a0203e2 	mov	w2, w2
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809bf4:	d2869b61 	mov	x1, #0x34db                	// #13531
	uint64_t sleep_time = sleep_time_l + ((uint64_t)sleep_time_h << 32);
ffffffffea809bf8:	8b038040 	add	x0, x2, x3, lsl #32
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809bfc:	f2baf6c1 	movk	x1, #0xd7b6, lsl #16
ffffffffea809c00:	9143d000 	add	x0, x0, #0xf4, lsl #12
ffffffffea809c04:	f2dbd041 	movk	x1, #0xde82, lsl #32
ffffffffea809c08:	9108fc00 	add	x0, x0, #0x23f
ffffffffea809c0c:	f2e86361 	movk	x1, #0x431b, lsl #48
{
ffffffffea809c10:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c14:	9bc17c00 	umulh	x0, x0, x1
{
ffffffffea809c18:	910003fd 	mov	x29, sp
	thread_sleep((lk_time_t)(DIV_ROUND_UP(sleep_time, 1000 * 1000)));
ffffffffea809c1c:	d352c400 	ubfx	x0, x0, #18, #32
ffffffffea809c20:	97fff20e 	bl	ffffffffea806458 <thread_sleep>

	return NO_ERROR;
}
ffffffffea809c24:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea809c28:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809c2c:	d65f03c0 	ret

ffffffffea809c30 <sys_gettime>:

long sys_gettime(uint32_t clock_id, uint32_t flags, user_addr_t time)
{
ffffffffea809c30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809c34:	910003fd 	mov	x29, sp
ffffffffea809c38:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809c3c:	b00002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea809c40:	2a0203f4 	mov	w20, w2
ffffffffea809c44:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea809c48:	f9400260 	ldr	x0, [x19]
ffffffffea809c4c:	f90017a0 	str	x0, [x29, #40]
ffffffffea809c50:	d2800000 	mov	x0, #0x0                   	// #0
	// return time in nanoseconds
	lk_bigtime_t t = current_time_hires() * 1000;
ffffffffea809c54:	97ffedb3 	bl	ffffffffea805320 <current_time_hires>
ffffffffea809c58:	aa0003e4 	mov	x4, x0
ffffffffea809c5c:	9100c3a1 	add	x1, x29, #0x30
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809c60:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea809c64:	d37be883 	lsl	x3, x4, #5
ffffffffea809c68:	2a1403e0 	mov	w0, w20
ffffffffea809c6c:	cb040063 	sub	x3, x3, x4
ffffffffea809c70:	8b030883 	add	x3, x4, x3, lsl #2
ffffffffea809c74:	d37df063 	lsl	x3, x3, #3
ffffffffea809c78:	f81f0c23 	str	x3, [x1, #-16]!
ffffffffea809c7c:	940029c5 	bl	ffffffffea814390 <arch_copy_to_user>

	return copy_to_user(time, &t, sizeof(uint64_t));
}
ffffffffea809c80:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea809c84:	f9400261 	ldr	x1, [x19]
ffffffffea809c88:	ca010041 	eor	x1, x2, x1
ffffffffea809c8c:	b50000a1 	cbnz	x1, ffffffffea809ca0 <sys_gettime+0x70>
ffffffffea809c90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809c94:	93407c00 	sxtw	x0, w0
ffffffffea809c98:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809c9c:	d65f03c0 	ret
ffffffffea809ca0:	94002822 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea809ca4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809ca8 <sys_mmap>:

long sys_mmap(user_addr_t uaddr, uint32_t size, uint32_t flags, uint32_t handle)
{
ffffffffea809ca8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809cac:	2a0303e5 	mov	w5, w3
ffffffffea809cb0:	910003fd 	mov	x29, sp
ffffffffea809cb4:	f9000bf3 	str	x19, [sp, #16]
ffffffffea809cb8:	b00002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea809cbc:	f9402a64 	ldr	x4, [x19, #80]
ffffffffea809cc0:	f9400083 	ldr	x3, [x4]
ffffffffea809cc4:	f90017a3 	str	x3, [x29, #40]
ffffffffea809cc8:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea809ccc:	d538d083 	mrs	x3, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809cd0:	f9415863 	ldr	x3, [x3, #688]
ffffffffea809cd4:	f9404864 	ldr	x4, [x3, #144]
	long ret;

	/*
	 * Allocate and map memory with Device attributes
	 */
	if (flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea809cd8:	370802a2 	tbnz	w2, #1, ffffffffea809d2c <sys_mmap+0x84>
	/*
	 * Only allows mapping on IO region specified by handle (id) and uaddr
	 * must be 0 for now.
	 * TBD: Add support in uthread_map to use uaddr as a hint.
	 */
	if (flags != MMAP_FLAG_IO_HANDLE || uaddr != 0) {
ffffffffea809cdc:	7100001f 	cmp	w0, #0x0
ffffffffea809ce0:	7a410840 	ccmp	w2, #0x1, #0x0, eq  // eq = none
ffffffffea809ce4:	540003a1 	b.ne	ffffffffea809d58 <sys_mmap+0xb0>  // b.any
		return ERR_INVALID_ARGS;
	}
	ret = trusty_app_setup_mmio(trusty_app, handle, &vaddr, size);
ffffffffea809ce8:	2a0103e3 	mov	w3, w1
ffffffffea809cec:	910083a2 	add	x2, x29, #0x20
ffffffffea809cf0:	2a0503e1 	mov	w1, w5
ffffffffea809cf4:	aa0403e0 	mov	x0, x4
ffffffffea809cf8:	97fffc6a 	bl	ffffffffea808ea0 <trusty_app_setup_mmio>
ffffffffea809cfc:	93407c00 	sxtw	x0, w0
	if (ret != NO_ERROR) {
		return ret;
	}
	return vaddr;
ffffffffea809d00:	f94013a1 	ldr	x1, [x29, #32]
ffffffffea809d04:	f100001f 	cmp	x0, #0x0
ffffffffea809d08:	9a800020 	csel	x0, x1, x0, eq  // eq = none
}
ffffffffea809d0c:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea809d10:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea809d14:	f9400261 	ldr	x1, [x19]
ffffffffea809d18:	ca010041 	eor	x1, x2, x1
ffffffffea809d1c:	b5000221 	cbnz	x1, ffffffffea809d60 <sys_mmap+0xb8>
ffffffffea809d20:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea809d24:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809d28:	d65f03c0 	ret
		ret = uthread_pmm_alloc_and_map(trusty_app->ut, &vaddr, size,
ffffffffea809d2c:	f9402c80 	ldr	x0, [x4, #88]
ffffffffea809d30:	2a0203e3 	mov	w3, w2
ffffffffea809d34:	52800024 	mov	w4, #0x1                   	// #1
ffffffffea809d38:	2a0103e2 	mov	w2, w1
ffffffffea809d3c:	910083a1 	add	x1, x29, #0x20
ffffffffea809d40:	94002bbc 	bl	ffffffffea814c30 <uthread_pmm_alloc_and_map>
ffffffffea809d44:	93407c00 	sxtw	x0, w0
		return vaddr;
ffffffffea809d48:	f94013a1 	ldr	x1, [x29, #32]
ffffffffea809d4c:	f100001f 	cmp	x0, #0x0
ffffffffea809d50:	9a800020 	csel	x0, x1, x0, eq  // eq = none
ffffffffea809d54:	17ffffee 	b	ffffffffea809d0c <sys_mmap+0x64>
		return ERR_INVALID_ARGS;
ffffffffea809d58:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809d5c:	17ffffec 	b	ffffffffea809d0c <sys_mmap+0x64>
}
ffffffffea809d60:	940027f2 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea809d64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809d68 <sys_munmap>:

long sys_munmap(user_addr_t uaddr, uint32_t size)
{
ffffffffea809d68:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea809d6c:	910003fd 	mov	x29, sp
ffffffffea809d70:	d538d082 	mrs	x2, tpidr_el1
	trusty_app_t *trusty_app = uthread_get_current()->private_data;
ffffffffea809d74:	f9415843 	ldr	x3, [x2, #688]

	/*
	 * uthread_unmap always unmaps whole region.
	 * TBD: Add support to unmap partial region when there's use case.
	 */
	return uthread_unmap(trusty_app->ut, uaddr, size);
ffffffffea809d78:	2a0103e2 	mov	w2, w1
ffffffffea809d7c:	2a0003e1 	mov	w1, w0
ffffffffea809d80:	f9404860 	ldr	x0, [x3, #144]
ffffffffea809d84:	f9402c00 	ldr	x0, [x0, #88]
ffffffffea809d88:	94002c2a 	bl	ffffffffea814e30 <uthread_unmap>
}
ffffffffea809d8c:	93407c00 	sxtw	x0, w0
ffffffffea809d90:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea809d94:	d65f03c0 	ret

ffffffffea809d98 <sys_prepare_dma>:

#if UTHREAD_WITH_MEMORY_MAPPING_SUPPORT

long sys_prepare_dma(user_addr_t uaddr, uint32_t size, uint32_t flags,
		user_addr_t pmem)
{
ffffffffea809d98:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea809d9c:	910003fd 	mov	x29, sp
ffffffffea809da0:	f9002bfb 	str	x27, [sp, #80]
ffffffffea809da4:	b00002db 	adrp	x27, ffffffffea862000 <__ctor_list>
ffffffffea809da8:	f9000ff4 	str	x20, [sp, #24]
ffffffffea809dac:	2a0103f4 	mov	w20, w1
ffffffffea809db0:	f9402b61 	ldr	x1, [x27, #80]
ffffffffea809db4:	b9006ba2 	str	w2, [x29, #104]
ffffffffea809db8:	f9001ff8 	str	x24, [sp, #56]
ffffffffea809dbc:	f9400022 	ldr	x2, [x1]
ffffffffea809dc0:	f90047a2 	str	x2, [x29, #136]
ffffffffea809dc4:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea809dc8:	d538d081 	mrs	x1, tpidr_el1
}

static inline uthread_t *uthread_get_current(void)
{
	return (uthread_t *)tls_get(TLS_ENTRY_UTHREAD);
ffffffffea809dcc:	f9415838 	ldr	x24, [x1, #688]
	long ret;

	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x, pmem 0x%x\n",
	        uaddr, size, flags, pmem);

	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809dd0:	340009f4 	cbz	w20, ffffffffea809f0c <sys_prepare_dma+0x174>
ffffffffea809dd4:	f9000bb3 	str	x19, [x29, #16]
ffffffffea809dd8:	2a0303f3 	mov	w19, w3
ffffffffea809ddc:	f9001bb7 	str	x23, [x29, #48]
ffffffffea809de0:	2a0003f7 	mov	w23, w0
ffffffffea809de4:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809de8:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809dec:	2a1403e2 	mov	w2, w20
ffffffffea809df0:	aa1703e1 	mov	x1, x23
ffffffffea809df4:	94002c79 	bl	ffffffffea814fd8 <uthread_is_valid_range>
	if (size == 0 || !valid_address((vaddr_t)uaddr, size)) {
ffffffffea809df8:	72001c1f 	tst	w0, #0xff
ffffffffea809dfc:	54000840 	b.eq	ffffffffea809f04 <sys_prepare_dma+0x16c>  // b.none
		pmem += sizeof(struct dma_pmem);

		mapped_size += kpmem.size;
		entries++;

	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809e00:	b9406ba0 	ldr	w0, [x29, #104]
ffffffffea809e04:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea809e08:	9101e3b6 	add	x22, x29, #0x78
ffffffffea809e0c:	a9046bb9 	stp	x25, x26, [x29, #64]
	uint32_t entries = 0;
ffffffffea809e10:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea809e14:	f9002fbc 	str	x28, [x29, #88]
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e18:	d2820019 	mov	x25, #0x1000                	// #4096
	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809e1c:	121e001a 	and	w26, w0, #0x4
	uint32_t mapped_size = 0;
ffffffffea809e20:	5280001c 	mov	w28, #0x0                   	// #0
ffffffffea809e24:	14000015 	b	ffffffffea809e78 <sys_prepare_dma+0xe0>
		kpmem.size = MIN(size - mapped_size,
ffffffffea809e28:	f9403fa4 	ldr	x4, [x29, #120]
ffffffffea809e2c:	4b1c0286 	sub	w6, w20, w28
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea809e30:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea809e34:	aa1603e1 	mov	x1, x22
ffffffffea809e38:	92402c84 	and	x4, x4, #0xfff
ffffffffea809e3c:	2a1303e0 	mov	w0, w19
ffffffffea809e40:	cb040323 	sub	x3, x25, x4
ffffffffea809e44:	eb06007f 	cmp	x3, x6
ffffffffea809e48:	9a869063 	csel	x3, x3, x6, ls  // ls = plast
ffffffffea809e4c:	b90083a3 	str	w3, [x29, #128]
ffffffffea809e50:	94002950 	bl	ffffffffea814390 <arch_copy_to_user>
		ret = copy_to_user(pmem, &kpmem, sizeof(struct dma_pmem));
ffffffffea809e54:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809e58:	b50001c0 	cbnz	x0, ffffffffea809e90 <sys_prepare_dma+0xf8>
		mapped_size += kpmem.size;
ffffffffea809e5c:	b94083a0 	ldr	w0, [x29, #128]
		pmem += sizeof(struct dma_pmem);
ffffffffea809e60:	11004273 	add	w19, w19, #0x10
		entries++;
ffffffffea809e64:	110006b5 	add	w21, w21, #0x1
		mapped_size += kpmem.size;
ffffffffea809e68:	0b00039c 	add	w28, w28, w0
	} while (mapped_size < size && (flags & DMA_FLAG_MULTI_PMEM));
ffffffffea809e6c:	6b1c029f 	cmp	w20, w28
ffffffffea809e70:	540002e9 	b.ls	ffffffffea809ecc <sys_prepare_dma+0x134>  // b.plast
ffffffffea809e74:	340002da 	cbz	w26, ffffffffea809ecc <sys_prepare_dma+0x134>
		ret = uthread_virt_to_phys(current,
ffffffffea809e78:	aa1603e2 	mov	x2, x22
ffffffffea809e7c:	8b3c42e1 	add	x1, x23, w28, uxtw
ffffffffea809e80:	aa1803e0 	mov	x0, x24
ffffffffea809e84:	94002c7f 	bl	ffffffffea815080 <uthread_virt_to_phys>
ffffffffea809e88:	93407c00 	sxtw	x0, w0
		if (ret != NO_ERROR) {
ffffffffea809e8c:	b4fffce0 	cbz	x0, ffffffffea809e28 <sys_prepare_dma+0x90>
ffffffffea809e90:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809e94:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea809e98:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea809e9c:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea809ea0:	f9402fbc 	ldr	x28, [x29, #88]
	}
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
		return ERR_BAD_LEN;
	}
	return entries;
}
ffffffffea809ea4:	f9402b7b 	ldr	x27, [x27, #80]
ffffffffea809ea8:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea809eac:	f9400361 	ldr	x1, [x27]
ffffffffea809eb0:	ca010041 	eor	x1, x2, x1
ffffffffea809eb4:	b5000301 	cbnz	x1, ffffffffea809f14 <sys_prepare_dma+0x17c>
ffffffffea809eb8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea809ebc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea809ec0:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea809ec4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea809ec8:	d65f03c0 	ret
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809ecc:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea809ed0:	2a1c03e1 	mov	w1, w28
ffffffffea809ed4:	36080120 	tbz	w0, #1, ffffffffea809ef8 <sys_prepare_dma+0x160>
		arch_clean_invalidate_cache_range(uaddr, mapped_size);
ffffffffea809ed8:	aa1703e0 	mov	x0, x23
ffffffffea809edc:	97ffe28b 	bl	ffffffffea802908 <arch_clean_invalidate_cache_range>
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809ee0:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea809ee4:	f27d001f 	tst	x0, #0x8
	return entries;
ffffffffea809ee8:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
	if (!(flags & DMA_FLAG_ALLOW_PARTIAL) && mapped_size != size) {
ffffffffea809eec:	7a5c0284 	ccmp	w20, w28, #0x4, eq  // eq = none
	return entries;
ffffffffea809ef0:	9a8002a0 	csel	x0, x21, x0, eq  // eq = none
ffffffffea809ef4:	17ffffe7 	b	ffffffffea809e90 <sys_prepare_dma+0xf8>
		arch_clean_cache_range(uaddr, mapped_size);
ffffffffea809ef8:	aa1703e0 	mov	x0, x23
ffffffffea809efc:	97ffe27b 	bl	ffffffffea8028e8 <arch_clean_cache_range>
ffffffffea809f00:	17fffff8 	b	ffffffffea809ee0 <sys_prepare_dma+0x148>
ffffffffea809f04:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea809f08:	f9401bb7 	ldr	x23, [x29, #48]
		return ERR_INVALID_ARGS;
ffffffffea809f0c:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea809f10:	17ffffe5 	b	ffffffffea809ea4 <sys_prepare_dma+0x10c>
ffffffffea809f14:	f9000bb3 	str	x19, [x29, #16]
ffffffffea809f18:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea809f1c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea809f20:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea809f24:	f9002fbc 	str	x28, [x29, #88]
}
ffffffffea809f28:	94002780 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea809f2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea809f30 <sys_finish_dma>:

long sys_finish_dma(user_addr_t uaddr, uint32_t size, uint32_t flags)
{
ffffffffea809f30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809f34:	910003fd 	mov	x29, sp
ffffffffea809f38:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACEF("uaddr 0x%x, size 0x%x, flags 0x%x\n", uaddr, size, flags);

	/* check buffer is in task's address space */
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f3c:	2a0003f3 	mov	w19, w0
{
ffffffffea809f40:	a9025bf5 	stp	x21, x22, [sp, #32]
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f44:	2a0103f4 	mov	w20, w1
{
ffffffffea809f48:	2a0203f6 	mov	w22, w2
ffffffffea809f4c:	d538d080 	mrs	x0, tpidr_el1
	return uthread_is_valid_range(uthread_get_current(), addr, size);
ffffffffea809f50:	f9415800 	ldr	x0, [x0, #688]
ffffffffea809f54:	aa1403e2 	mov	x2, x20
ffffffffea809f58:	aa1303e1 	mov	x1, x19
ffffffffea809f5c:	94002c1f 	bl	ffffffffea814fd8 <uthread_is_valid_range>
	if (!valid_address((vaddr_t)uaddr, size)) {
ffffffffea809f60:	72001c1f 	tst	w0, #0xff
ffffffffea809f64:	54000160 	b.eq	ffffffffea809f90 <sys_finish_dma+0x60>  // b.none
		return ERR_INVALID_ARGS;
	}
	if (flags & DMA_FLAG_FROM_DEVICE) {
		arch_clean_invalidate_cache_range(uaddr, size);
	}
	return NO_ERROR;
ffffffffea809f68:	d2800015 	mov	x21, #0x0                   	// #0
	if (flags & DMA_FLAG_FROM_DEVICE) {
ffffffffea809f6c:	36080096 	tbz	w22, #1, ffffffffea809f7c <sys_finish_dma+0x4c>
		arch_clean_invalidate_cache_range(uaddr, size);
ffffffffea809f70:	aa1403e1 	mov	x1, x20
ffffffffea809f74:	aa1303e0 	mov	x0, x19
ffffffffea809f78:	97ffe264 	bl	ffffffffea802908 <arch_clean_invalidate_cache_range>
}
ffffffffea809f7c:	aa1503e0 	mov	x0, x21
ffffffffea809f80:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809f84:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea809f88:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea809f8c:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea809f90:	928000f5 	mov	x21, #0xfffffffffffffff8    	// #-8
ffffffffea809f94:	17fffffa 	b	ffffffffea809f7c <sys_finish_dma+0x4c>

ffffffffea809f98 <_finish_wait_handle>:
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
	return ret;
}

static void _finish_wait_handle(handle_t *handle)
{
ffffffffea809f98:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea809f9c:	910003fd 	mov	x29, sp
ffffffffea809fa0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea809fa4:	aa0003f4 	mov	x20, x0
	spin_lock_saved_state_t state;

	/* clear out our event ptr */
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea809fa8:	91006013 	add	x19, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea809fac:	d53b4220 	mrs	x0, daif
ffffffffea809fb0:	37380160 	tbnz	w0, #7, ffffffffea809fdc <_finish_wait_handle+0x44>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea809fb4:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea809fb8:	aa1303e0 	mov	x0, x19
ffffffffea809fbc:	97ffe241 	bl	ffffffffea8028c0 <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809fc0:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809fc4:	aa1303e0 	mov	x0, x19
ffffffffea809fc8:	97ffe246 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea809fcc:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&handle->slock, state, SPIN_LOCK_FLAG_INTERRUPTS);
}
ffffffffea809fd0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809fd4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809fd8:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea809fdc:	aa1303e0 	mov	x0, x19
ffffffffea809fe0:	97ffe238 	bl	ffffffffea8028c0 <arch_spin_lock>
	handle->wait_event = NULL;
ffffffffea809fe4:	f9000a9f 	str	xzr, [x20, #16]
    arch_spin_unlock(lock);
ffffffffea809fe8:	aa1303e0 	mov	x0, x19
}
ffffffffea809fec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea809ff0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea809ff4:	17ffe23b 	b	ffffffffea8028e0 <arch_spin_unlock>

ffffffffea809ff8 <_prepare_wait_handle>:
{
ffffffffea809ff8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea809ffc:	910003fd 	mov	x29, sp
ffffffffea80a000:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a004:	aa0103f3 	mov	x19, x1
ffffffffea80a008:	f90013f5 	str	x21, [sp, #32]
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea80a00c:	91006034 	add	x20, x1, #0x18
{
ffffffffea80a010:	aa0003f5 	mov	x21, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80a014:	d53b4220 	mrs	x0, daif
ffffffffea80a018:	373801e0 	tbnz	w0, #7, ffffffffea80a054 <_prepare_wait_handle+0x5c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80a01c:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80a020:	aa1403e0 	mov	x0, x20
ffffffffea80a024:	97ffe227 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea80a028:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a02c:	b50003a0 	cbnz	x0, ffffffffea80a0a0 <_prepare_wait_handle+0xa8>
		handle->wait_event = ev;
ffffffffea80a030:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea80a034:	aa1403e0 	mov	x0, x20
ffffffffea80a038:	97ffe22a 	bl	ffffffffea8028e0 <arch_spin_unlock>
	int ret = 0;
ffffffffea80a03c:	52800000 	mov	w0, #0x0                   	// #0
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80a040:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80a044:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a048:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a04c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a050:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80a054:	aa1403e0 	mov	x0, x20
ffffffffea80a058:	97ffe21a 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (unlikely(handle->wait_event)) {
ffffffffea80a05c:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a060:	b5000120 	cbnz	x0, ffffffffea80a084 <_prepare_wait_handle+0x8c>
		handle->wait_event = ev;
ffffffffea80a064:	f9000a75 	str	x21, [x19, #16]
    arch_spin_unlock(lock);
ffffffffea80a068:	aa1403e0 	mov	x0, x20
ffffffffea80a06c:	97ffe21d 	bl	ffffffffea8028e0 <arch_spin_unlock>
}
ffffffffea80a070:	f94013f5 	ldr	x21, [sp, #32]
	int ret = 0;
ffffffffea80a074:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80a078:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a07c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a080:	d65f03c0 	ret
ffffffffea80a084:	aa1403e0 	mov	x0, x20
ffffffffea80a088:	97ffe216 	bl	ffffffffea8028e0 <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea80a08c:	128000a0 	mov	w0, #0xfffffffa            	// #-6
}
ffffffffea80a090:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a094:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a098:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80a09c:	d65f03c0 	ret
ffffffffea80a0a0:	aa1403e0 	mov	x0, x20
ffffffffea80a0a4:	97ffe20f 	bl	ffffffffea8028e0 <arch_spin_unlock>
		ret = ERR_ALREADY_STARTED;
ffffffffea80a0a8:	128000a0 	mov	w0, #0xfffffffa            	// #-6
ffffffffea80a0ac:	d50342ff 	msr	daifclr, #0x2
ffffffffea80a0b0:	17ffffe5 	b	ffffffffea80a044 <_prepare_wait_handle+0x4c>
ffffffffea80a0b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a0b8 <_hlist_do_poll_locked>:
 *  handle until the ready one is found and return it to caller.
 *  Undo prepare op if ready handle is found or en error occured.
 */
static int _hlist_do_poll_locked(handle_list_t *hlist, handle_t **handle_ptr,
				 uint32_t *event_ptr, bool prepare)
{
ffffffffea80a0b8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80a0bc:	910003fd 	mov	x29, sp
ffffffffea80a0c0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a0c4:	f90023f9 	str	x25, [sp, #64]
	return (list->next == list) ? true : false;
ffffffffea80a0c8:	f9400413 	ldr	x19, [x0, #8]
	int ret = 0;

	DEBUG_ASSERT(hlist->wait_event);

	if (list_is_empty(&hlist->handles))
ffffffffea80a0cc:	eb13001f 	cmp	x0, x19
ffffffffea80a0d0:	54000840 	b.eq	ffffffffea80a1d8 <_hlist_do_poll_locked+0x120>  // b.none
ffffffffea80a0d4:	a901d7b4 	stp	x20, x21, [x29, #24]
		return ERR_NOT_FOUND;  /* no handles in the list */

	handle_t *next;
	handle_t *last_prep = NULL;
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea80a0d8:	d1008273 	sub	x19, x19, #0x20
ffffffffea80a0dc:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80a0e0:	12001c75 	and	w21, w3, #0xff
ffffffffea80a0e4:	aa0203f7 	mov	x23, x2
ffffffffea80a0e8:	aa0103f6 	mov	x22, x1
ffffffffea80a0ec:	aa0003f4 	mov	x20, x0
ffffffffea80a0f0:	f9001fb8 	str	x24, [x29, #56]
	handle_t *last_prep = NULL;
ffffffffea80a0f4:	d2800018 	mov	x24, #0x0                   	// #0
		if (prepare) {
ffffffffea80a0f8:	35000275 	cbnz	w21, ffffffffea80a144 <_hlist_do_poll_locked+0x8c>
			if (ret)
				break;
			last_prep = next;
		}

		uint32_t event = next->ops->poll(next);
ffffffffea80a0fc:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a100:	aa1303e0 	mov	x0, x19
ffffffffea80a104:	f9400063 	ldr	x3, [x3]
ffffffffea80a108:	d63f0060 	blr	x3
		if (event) {
ffffffffea80a10c:	35000320 	cbnz	w0, ffffffffea80a170 <_hlist_do_poll_locked+0xb8>
	list_for_every_entry(&hlist->handles, next, handle_t, hlist_node) {
ffffffffea80a110:	f9401663 	ldr	x3, [x19, #40]
ffffffffea80a114:	d1008073 	sub	x19, x3, #0x20
ffffffffea80a118:	eb03029f 	cmp	x20, x3
ffffffffea80a11c:	54fffee1 	b.ne	ffffffffea80a0f8 <_hlist_do_poll_locked+0x40>  // b.any
			*event_ptr = event;
			*handle_ptr = next;
			ret = 1;
ffffffffea80a120:	52800019 	mov	w25, #0x0                   	// #0
ffffffffea80a124:	f9401fb8 	ldr	x24, [x29, #56]
	if (ret && prepare && last_prep) {
		/* need to undo prepare */
		_hlist_finish_wait_locked(hlist, last_prep);
	}
	return ret;
}
ffffffffea80a128:	2a1903e0 	mov	w0, w25
ffffffffea80a12c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a130:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80a134:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80a138:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a13c:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80a140:	d65f03c0 	ret
			ret = _prepare_wait_handle(hlist->wait_event, next);
ffffffffea80a144:	f9402680 	ldr	x0, [x20, #72]
ffffffffea80a148:	aa1303e1 	mov	x1, x19
ffffffffea80a14c:	97ffffab 	bl	ffffffffea809ff8 <_prepare_wait_handle>
ffffffffea80a150:	2a0003f9 	mov	w25, w0
			if (ret)
ffffffffea80a154:	35000160 	cbnz	w0, ffffffffea80a180 <_hlist_do_poll_locked+0xc8>
		uint32_t event = next->ops->poll(next);
ffffffffea80a158:	f9400663 	ldr	x3, [x19, #8]
ffffffffea80a15c:	aa1303f8 	mov	x24, x19
ffffffffea80a160:	aa1303e0 	mov	x0, x19
ffffffffea80a164:	f9400063 	ldr	x3, [x3]
ffffffffea80a168:	d63f0060 	blr	x3
		if (event) {
ffffffffea80a16c:	34fffd20 	cbz	w0, ffffffffea80a110 <_hlist_do_poll_locked+0x58>
			*event_ptr = event;
ffffffffea80a170:	b90002e0 	str	w0, [x23]
			ret = 1;
ffffffffea80a174:	52800039 	mov	w25, #0x1                   	// #1
			*handle_ptr = next;
ffffffffea80a178:	f90002d3 	str	x19, [x22]
	if (ret && prepare && last_prep) {
ffffffffea80a17c:	340001f5 	cbz	w21, ffffffffea80a1b8 <_hlist_do_poll_locked+0x100>
ffffffffea80a180:	b40001d8 	cbz	x24, ffffffffea80a1b8 <_hlist_do_poll_locked+0x100>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a184:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a188:	d1008013 	sub	x19, x0, #0x20
ffffffffea80a18c:	eb00029f 	cmp	x20, x0
ffffffffea80a190:	540000c1 	b.ne	ffffffffea80a1a8 <_hlist_do_poll_locked+0xf0>  // b.any
ffffffffea80a194:	14000009 	b	ffffffffea80a1b8 <_hlist_do_poll_locked+0x100>
ffffffffea80a198:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80a19c:	d1008013 	sub	x19, x0, #0x20
ffffffffea80a1a0:	eb00029f 	cmp	x20, x0
ffffffffea80a1a4:	540000a0 	b.eq	ffffffffea80a1b8 <_hlist_do_poll_locked+0x100>  // b.none
		_finish_wait_handle(handle);
ffffffffea80a1a8:	aa1303e0 	mov	x0, x19
ffffffffea80a1ac:	97ffff7b 	bl	ffffffffea809f98 <_finish_wait_handle>
		if (handle == last) {
ffffffffea80a1b0:	eb18027f 	cmp	x19, x24
ffffffffea80a1b4:	54ffff21 	b.ne	ffffffffea80a198 <_hlist_do_poll_locked+0xe0>  // b.any
ffffffffea80a1b8:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea80a1bc:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80a1c0:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80a1c4:	2a1903e0 	mov	w0, w25
ffffffffea80a1c8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a1cc:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80a1d0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80a1d4:	d65f03c0 	ret
		return ERR_NOT_FOUND;  /* no handles in the list */
ffffffffea80a1d8:	12800039 	mov	w25, #0xfffffffe            	// #-2
ffffffffea80a1dc:	17fffffa 	b	ffffffffea80a1c4 <_hlist_do_poll_locked+0x10c>

ffffffffea80a1e0 <handle_init>:
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a1e0:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80a1e4:	885f7c03 	ldxr	w3, [x0]
ffffffffea80a1e8:	88047c02 	stxr	w4, w2, [x0]
ffffffffea80a1ec:	35ffffc4 	cbnz	w4, ffffffffea80a1e4 <handle_init+0x4>
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a1f0:	885f7c02 	ldxr	w2, [x0]
ffffffffea80a1f4:	11000442 	add	w2, w2, #0x1
ffffffffea80a1f8:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80a1fc:	35ffffa3 	cbnz	w3, ffffffffea80a1f0 <handle_init+0x10>
	handle->wait_event = NULL;
ffffffffea80a200:	a900fc01 	stp	x1, xzr, [x0, #8]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea80a204:	529fdda1 	mov	w1, #0xfeed                	// #65261
ffffffffea80a208:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	item->prev = item->next = 0;
ffffffffea80a20c:	a901fc1f 	stp	xzr, xzr, [x0, #24]
	handle->cookie = NULL;
ffffffffea80a210:	a902fc1f 	stp	xzr, xzr, [x0, #40]
	handle->guest_id = DEFAULT_GUEST_ID;
ffffffffea80a214:	b9003801 	str	w1, [x0, #56]
}
ffffffffea80a218:	d65f03c0 	ret
ffffffffea80a21c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a220 <handle_incref>:
ffffffffea80a220:	885f7c01 	ldxr	w1, [x0]
ffffffffea80a224:	11000421 	add	w1, w1, #0x1
ffffffffea80a228:	88027c01 	stxr	w2, w1, [x0]
ffffffffea80a22c:	35ffffa2 	cbnz	w2, ffffffffea80a220 <handle_incref>
}
ffffffffea80a230:	d65f03c0 	ret
ffffffffea80a234:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a238 <handle_decref>:
{
ffffffffea80a238:	aa0003e1 	mov	x1, x0
ffffffffea80a23c:	885f7c22 	ldxr	w2, [x1]
ffffffffea80a240:	51000443 	sub	w3, w2, #0x1
ffffffffea80a244:	88047c23 	stxr	w4, w3, [x1]
ffffffffea80a248:	35ffffa4 	cbnz	w4, ffffffffea80a23c <handle_decref+0x4>

static inline __ALWAYS_INLINE
void refcount_dec(refcount_t *ref, refcount_destroy_func destroy)
{
	/* decerementing from 1? destroy */
	if (atomic_add(&ref->cnt, -1) == 1)
ffffffffea80a24c:	7100045f 	cmp	w2, #0x1
ffffffffea80a250:	54000081 	b.ne	ffffffffea80a260 <handle_decref+0x28>  // b.any
	handle->ops->destroy(handle);
ffffffffea80a254:	f9400421 	ldr	x1, [x1, #8]
ffffffffea80a258:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80a25c:	d61f0020 	br	x1
}
ffffffffea80a260:	d65f03c0 	ret
ffffffffea80a264:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a268 <_handle_list_del_locked>:
{
ffffffffea80a268:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a26c:	910003fd 	mov	x29, sp
ffffffffea80a270:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a274:	aa0003f4 	mov	x20, x0
	item->next->prev = item->prev;
ffffffffea80a278:	a9420022 	ldp	x2, x0, [x1, #32]
ffffffffea80a27c:	aa0103f3 	mov	x19, x1
	if (hlist->wait_event) {
ffffffffea80a280:	f9402681 	ldr	x1, [x20, #72]
ffffffffea80a284:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea80a288:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80a28c:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80a290:	a9027e7f 	stp	xzr, xzr, [x19, #32]
ffffffffea80a294:	b40000c1 	cbz	x1, ffffffffea80a2ac <_handle_list_del_locked+0x44>
		_finish_wait_handle(handle);
ffffffffea80a298:	aa1303e0 	mov	x0, x19
ffffffffea80a29c:	97ffff3f 	bl	ffffffffea809f98 <_finish_wait_handle>
		if (list_is_empty(&hlist->handles)) {
ffffffffea80a2a0:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a2a4:	eb00029f 	cmp	x20, x0
ffffffffea80a2a8:	540000a0 	b.eq	ffffffffea80a2bc <_handle_list_del_locked+0x54>  // b.none
	handle_decref(handle);
ffffffffea80a2ac:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a2b4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a2b8:	17ffffe0 	b	ffffffffea80a238 <handle_decref>
			event_signal(hlist->wait_event, true);
ffffffffea80a2bc:	f9402680 	ldr	x0, [x20, #72]
ffffffffea80a2c0:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80a2c4:	97ffed1b 	bl	ffffffffea805730 <event_signal>
	handle_decref(handle);
ffffffffea80a2c8:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2cc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a2d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a2d4:	17ffffd9 	b	ffffffffea80a238 <handle_decref>

ffffffffea80a2d8 <handle_close>:
{
ffffffffea80a2d8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a2dc:	910003fd 	mov	x29, sp
	if (handle->ops->shutdown) {
ffffffffea80a2e0:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80a2e4:	f9400821 	ldr	x1, [x1, #16]
{
ffffffffea80a2e8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a2ec:	aa0003f3 	mov	x19, x0
	if (handle->ops->shutdown) {
ffffffffea80a2f0:	b4000041 	cbz	x1, ffffffffea80a2f8 <handle_close+0x20>
		handle->ops->shutdown(handle);
ffffffffea80a2f4:	d63f0020 	blr	x1
	handle_decref(handle);
ffffffffea80a2f8:	aa1303e0 	mov	x0, x19
}
ffffffffea80a2fc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a300:	a8c27bfd 	ldp	x29, x30, [sp], #32
	handle_decref(handle);
ffffffffea80a304:	17ffffcd 	b	ffffffffea80a238 <handle_decref>

ffffffffea80a308 <handle_wait>:
{
ffffffffea80a308:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	if (!handle || !handle_event) {
ffffffffea80a30c:	f100001f 	cmp	x0, #0x0
ffffffffea80a310:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
{
ffffffffea80a314:	910003fd 	mov	x29, sp
ffffffffea80a318:	f90017f6 	str	x22, [sp, #40]
ffffffffea80a31c:	900002d6 	adrp	x22, ffffffffea862000 <__ctor_list>
ffffffffea80a320:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a324:	aa0003f3 	mov	x19, x0
ffffffffea80a328:	f9402ac0 	ldr	x0, [x22, #80]
ffffffffea80a32c:	a903e7f8 	stp	x24, x25, [sp, #56]
ffffffffea80a330:	aa0103f9 	mov	x25, x1
ffffffffea80a334:	f9400001 	ldr	x1, [x0]
ffffffffea80a338:	f90047a1 	str	x1, [x29, #136]
ffffffffea80a33c:	d2800001 	mov	x1, #0x0                   	// #0
	if (!handle || !handle_event) {
ffffffffea80a340:	540006a0 	b.eq	ffffffffea80a414 <handle_wait+0x10c>  // b.none
ffffffffea80a344:	f90013b5 	str	x21, [x29, #32]
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a348:	910163b5 	add	x21, x29, #0x58
ffffffffea80a34c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80a350:	2a0203f7 	mov	w23, w2
ffffffffea80a354:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80a358:	aa1503e0 	mov	x0, x21
ffffffffea80a35c:	97ffec9b 	bl	ffffffffea8055c8 <event_init>
	ret = _prepare_wait_handle(&ev, handle);
ffffffffea80a360:	aa1303e1 	mov	x1, x19
ffffffffea80a364:	aa1503e0 	mov	x0, x21
ffffffffea80a368:	97ffff24 	bl	ffffffffea809ff8 <_prepare_wait_handle>
ffffffffea80a36c:	2a0003f8 	mov	w24, w0
	if (ret) {
ffffffffea80a370:	34000200 	cbz	w0, ffffffffea80a3b0 <handle_wait+0xa8>
	event_destroy(&ev);
ffffffffea80a374:	aa1503e0 	mov	x0, x21
ffffffffea80a378:	97ffeca0 	bl	ffffffffea8055f8 <event_destroy>
	return ret;
ffffffffea80a37c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80a380:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80a384:	f9402ad6 	ldr	x22, [x22, #80]
ffffffffea80a388:	2a1803e0 	mov	w0, w24
ffffffffea80a38c:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea80a390:	f94002c1 	ldr	x1, [x22]
ffffffffea80a394:	ca010041 	eor	x1, x2, x1
ffffffffea80a398:	b5000421 	cbnz	x1, ffffffffea80a41c <handle_wait+0x114>
ffffffffea80a39c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a3a0:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80a3a4:	a943e7f8 	ldp	x24, x25, [sp, #56]
ffffffffea80a3a8:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80a3ac:	d65f03c0 	ret
ffffffffea80a3b0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80a3b4:	14000005 	b	ffffffffea80a3c8 <handle_wait+0xc0>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a3b8:	2a1703e1 	mov	w1, w23
ffffffffea80a3bc:	aa1503e0 	mov	x0, x21
ffffffffea80a3c0:	97ffecb8 	bl	ffffffffea8056a0 <event_wait_timeout>
		if (ret < 0) {
ffffffffea80a3c4:	37f80240 	tbnz	w0, #31, ffffffffea80a40c <handle_wait+0x104>
		event = handle->ops->poll(handle);
ffffffffea80a3c8:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80a3cc:	aa1303e0 	mov	x0, x19
ffffffffea80a3d0:	f9400021 	ldr	x1, [x1]
ffffffffea80a3d4:	d63f0020 	blr	x1
ffffffffea80a3d8:	2a0003f4 	mov	w20, w0
		if (event) {
ffffffffea80a3dc:	34fffee0 	cbz	w0, ffffffffea80a3b8 <handle_wait+0xb0>
	if (handle->ops->finalize_event) {
ffffffffea80a3e0:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80a3e4:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a3e8:	b4000082 	cbz	x2, ffffffffea80a3f8 <handle_wait+0xf0>
		handle->ops->finalize_event(handle, event);
ffffffffea80a3ec:	2a1403e1 	mov	w1, w20
ffffffffea80a3f0:	aa1303e0 	mov	x0, x19
ffffffffea80a3f4:	d63f0040 	blr	x2
	*handle_event = event;
ffffffffea80a3f8:	b9000334 	str	w20, [x25]
	_finish_wait_handle(handle);
ffffffffea80a3fc:	aa1303e0 	mov	x0, x19
ffffffffea80a400:	97fffee6 	bl	ffffffffea809f98 <_finish_wait_handle>
ffffffffea80a404:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80a408:	17ffffdb 	b	ffffffffea80a374 <handle_wait+0x6c>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a40c:	2a0003f8 	mov	w24, w0
ffffffffea80a410:	17fffffb 	b	ffffffffea80a3fc <handle_wait+0xf4>
		return ERR_INVALID_ARGS;
ffffffffea80a414:	128000f8 	mov	w24, #0xfffffff8            	// #-8
ffffffffea80a418:	17ffffdb 	b	ffffffffea80a384 <handle_wait+0x7c>
ffffffffea80a41c:	a901d7b4 	stp	x20, x21, [x29, #24]
ffffffffea80a420:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea80a424:	94002641 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80a428 <handle_notify>:
{
ffffffffea80a428:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a42c:	910003fd 	mov	x29, sp
ffffffffea80a430:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a434:	aa0003f3 	mov	x19, x0
	spin_lock_save(&handle->slock, &state, SPIN_LOCK_FLAG_INTERRUPTS);
ffffffffea80a438:	91006014 	add	x20, x0, #0x18
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80a43c:	d53b4220 	mrs	x0, daif
ffffffffea80a440:	373801c0 	tbnz	w0, #7, ffffffffea80a478 <handle_notify+0x50>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80a444:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80a448:	aa1403e0 	mov	x0, x20
ffffffffea80a44c:	97ffe11d 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a450:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a454:	b4000060 	cbz	x0, ffffffffea80a460 <handle_notify+0x38>
		event_signal(handle->wait_event, false);
ffffffffea80a458:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a45c:	97ffecb5 	bl	ffffffffea805730 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80a460:	aa1403e0 	mov	x0, x20
ffffffffea80a464:	97ffe11f 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80a468:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea80a46c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a470:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a474:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80a478:	aa1403e0 	mov	x0, x20
ffffffffea80a47c:	97ffe111 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (handle->wait_event) {
ffffffffea80a480:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea80a484:	b50000a0 	cbnz	x0, ffffffffea80a498 <handle_notify+0x70>
    arch_spin_unlock(lock);
ffffffffea80a488:	aa1403e0 	mov	x0, x20
}
ffffffffea80a48c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a490:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a494:	17ffe113 	b	ffffffffea8028e0 <arch_spin_unlock>
		event_signal(handle->wait_event, false);
ffffffffea80a498:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a49c:	97ffeca5 	bl	ffffffffea805730 <event_signal>
ffffffffea80a4a0:	17fffffa 	b	ffffffffea80a488 <handle_notify+0x60>
ffffffffea80a4a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a4a8 <handle_list_init>:
	*hlist = (handle_list_t)HANDLE_LIST_INITIAL_VALUE(*hlist);
ffffffffea80a4a8:	a9017c1f 	stp	xzr, xzr, [x0, #16]
ffffffffea80a4ac:	528e8f03 	mov	w3, #0x7478                	// #29816
ffffffffea80a4b0:	a9027c1f 	stp	xzr, xzr, [x0, #32]
ffffffffea80a4b4:	528d2e82 	mov	w2, #0x6974                	// #26996
ffffffffea80a4b8:	72adaea3 	movk	w3, #0x6d75, lsl #16
ffffffffea80a4bc:	9100c001 	add	x1, x0, #0x30
ffffffffea80a4c0:	72aeec22 	movk	w2, #0x7761, lsl #16
ffffffffea80a4c4:	a9000000 	stp	x0, x0, [x0]
ffffffffea80a4c8:	b9001003 	str	w3, [x0, #16]
ffffffffea80a4cc:	b9002802 	str	w2, [x0, #40]
ffffffffea80a4d0:	a9030401 	stp	x1, x1, [x0, #48]
ffffffffea80a4d4:	a9047c1f 	stp	xzr, xzr, [x0, #64]
}
ffffffffea80a4d8:	d65f03c0 	ret
ffffffffea80a4dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a4e0 <handle_list_add>:
{
ffffffffea80a4e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a4e4:	910003fd 	mov	x29, sp
ffffffffea80a4e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80a4ec:	aa0003f4 	mov	x20, x0
ffffffffea80a4f0:	aa0103f3 	mov	x19, x1
ffffffffea80a4f4:	f90013f5 	str	x21, [sp, #32]
    return __atomic_fetch_add(ptr, val, __ATOMIC_RELAXED);
ffffffffea80a4f8:	885f7e60 	ldxr	w0, [x19]
ffffffffea80a4fc:	11000400 	add	w0, w0, #0x1
ffffffffea80a500:	88017e60 	stxr	w1, w0, [x19]
ffffffffea80a504:	35ffffa1 	cbnz	w1, ffffffffea80a4f8 <handle_list_add+0x18>
	mutex_acquire(&hlist->lock);
ffffffffea80a508:	91004295 	add	x21, x20, #0x10
ffffffffea80a50c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a510:	aa1503e0 	mov	x0, x21
ffffffffea80a514:	97ffecdd 	bl	ffffffffea805888 <mutex_acquire_timeout>
	item->prev = list->prev;
ffffffffea80a518:	f9400280 	ldr	x0, [x20]
	list_add_tail(&hlist->handles, &handle->hlist_node);
ffffffffea80a51c:	91008261 	add	x1, x19, #0x20
	item->next = list;
ffffffffea80a520:	a9025260 	stp	x0, x20, [x19, #32]
	if (hlist->wait_event) {
ffffffffea80a524:	f9402680 	ldr	x0, [x20, #72]
	list->prev->next = item;
ffffffffea80a528:	f9400282 	ldr	x2, [x20]
ffffffffea80a52c:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80a530:	f9000281 	str	x1, [x20]
ffffffffea80a534:	b4000100 	cbz	x0, ffffffffea80a554 <handle_list_add+0x74>
		_prepare_wait_handle(hlist->wait_event, handle);
ffffffffea80a538:	aa1303e1 	mov	x1, x19
ffffffffea80a53c:	97fffeaf 	bl	ffffffffea809ff8 <_prepare_wait_handle>
		uint32_t event = handle->ops->poll(handle);
ffffffffea80a540:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80a544:	aa1303e0 	mov	x0, x19
ffffffffea80a548:	f9400021 	ldr	x1, [x1]
ffffffffea80a54c:	d63f0020 	blr	x1
		if (event) {
ffffffffea80a550:	350000c0 	cbnz	w0, ffffffffea80a568 <handle_list_add+0x88>
	mutex_release(&hlist->lock);
ffffffffea80a554:	aa1503e0 	mov	x0, x21
}
ffffffffea80a558:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a55c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a560:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a564:	17ffecf5 	b	ffffffffea805938 <mutex_release>
			handle_notify(handle);
ffffffffea80a568:	aa1303e0 	mov	x0, x19
ffffffffea80a56c:	97ffffaf 	bl	ffffffffea80a428 <handle_notify>
	mutex_release(&hlist->lock);
ffffffffea80a570:	aa1503e0 	mov	x0, x21
}
ffffffffea80a574:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80a578:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a57c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a580:	17ffecee 	b	ffffffffea805938 <mutex_release>
ffffffffea80a584:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a588 <handle_list_del>:
{
ffffffffea80a588:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a58c:	910003fd 	mov	x29, sp
ffffffffea80a590:	a90153f3 	stp	x19, x20, [sp, #16]
	mutex_acquire(&hlist->lock);
ffffffffea80a594:	91004013 	add	x19, x0, #0x10
{
ffffffffea80a598:	f90013f5 	str	x21, [sp, #32]
ffffffffea80a59c:	aa0003f4 	mov	x20, x0
ffffffffea80a5a0:	aa0103f5 	mov	x21, x1
ffffffffea80a5a4:	aa1303e0 	mov	x0, x19
ffffffffea80a5a8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a5ac:	97ffecb7 	bl	ffffffffea805888 <mutex_acquire_timeout>
	_handle_list_del_locked(hlist, handle);
ffffffffea80a5b0:	aa1503e1 	mov	x1, x21
ffffffffea80a5b4:	aa1403e0 	mov	x0, x20
ffffffffea80a5b8:	97ffff2c 	bl	ffffffffea80a268 <_handle_list_del_locked>
}
ffffffffea80a5bc:	f94013f5 	ldr	x21, [sp, #32]
	mutex_release(&hlist->lock);
ffffffffea80a5c0:	aa1303e0 	mov	x0, x19
}
ffffffffea80a5c4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a5c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&hlist->lock);
ffffffffea80a5cc:	17ffecdb 	b	ffffffffea805938 <mutex_release>

ffffffffea80a5d0 <handle_list_wait>:
/* fills in the handle that has a pending event. The reference taken by the list
 * is not dropped until the caller has had a chance to process the handle.
 */
int handle_list_wait(handle_list_t *hlist, handle_t **handle_ptr,
                     uint32_t *event_ptr, lk_time_t timeout)
{
ffffffffea80a5d0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea80a5d4:	910003fd 	mov	x29, sp
ffffffffea80a5d8:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80a5dc:	900002da 	adrp	x26, ffffffffea862000 <__ctor_list>
ffffffffea80a5e0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80a5e4:	aa0203f9 	mov	x25, x2
ffffffffea80a5e8:	f9402b44 	ldr	x4, [x26, #80]
ffffffffea80a5ec:	2a0303f5 	mov	w21, w3
ffffffffea80a5f0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80a5f4:	aa0103f8 	mov	x24, x1
ffffffffea80a5f8:	f9400083 	ldr	x3, [x4]
ffffffffea80a5fc:	f90047a3 	str	x3, [x29, #136]
ffffffffea80a600:	d2800003 	mov	x3, #0x0                   	// #0

	DEBUG_ASSERT(hlist);
	DEBUG_ASSERT(handle_ptr);
	DEBUG_ASSERT(event_ptr);

	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a604:	910163b7 	add	x23, x29, #0x58
{
ffffffffea80a608:	a90153f3 	stp	x19, x20, [sp, #16]
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a60c:	52800022 	mov	w2, #0x1                   	// #1
{
ffffffffea80a610:	aa0003f4 	mov	x20, x0
	event_init(&ev, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea80a614:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80a618:	aa1703e0 	mov	x0, x23
ffffffffea80a61c:	97ffebeb 	bl	ffffffffea8055c8 <event_init>

	*event_ptr = 0;
ffffffffea80a620:	b900033f 	str	wzr, [x25]
	*handle_ptr = 0;

	mutex_acquire(&hlist->lock);
ffffffffea80a624:	91004296 	add	x22, x20, #0x10
	*handle_ptr = 0;
ffffffffea80a628:	f900031f 	str	xzr, [x24]
ffffffffea80a62c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a630:	aa1603e0 	mov	x0, x22
ffffffffea80a634:	97ffec95 	bl	ffffffffea805888 <mutex_acquire_timeout>

	DEBUG_ASSERT(hlist->wait_event == NULL);

	hlist->wait_event = &ev;
ffffffffea80a638:	f9002697 	str	x23, [x20, #72]
	ret = _hlist_do_poll_locked(hlist, handle_ptr, event_ptr, true);
ffffffffea80a63c:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea80a640:	aa1903e2 	mov	x2, x25
ffffffffea80a644:	aa1803e1 	mov	x1, x24
ffffffffea80a648:	aa1403e0 	mov	x0, x20
ffffffffea80a64c:	97fffe9b 	bl	ffffffffea80a0b8 <_hlist_do_poll_locked>
ffffffffea80a650:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80a654:	7100001f 	cmp	w0, #0x0
ffffffffea80a658:	5400008b 	b.lt	ffffffffea80a668 <handle_list_wait+0x98>  // b.tstop
		goto err_do_poll;
	}
	if (ret == 0) {
ffffffffea80a65c:	54000360 	b.eq	ffffffffea80a6c8 <handle_list_wait+0xf8>  // b.none
		} while (!ret);

		_hlist_finish_wait_locked(hlist, NULL);
	}

	if (ret == 1) {
ffffffffea80a660:	7100067f 	cmp	w19, #0x1
ffffffffea80a664:	54000620 	b.eq	ffffffffea80a728 <handle_list_wait+0x158>  // b.none

		ret = NO_ERROR;
	}

err_do_poll:
	hlist->wait_event = NULL;
ffffffffea80a668:	f900269f 	str	xzr, [x20, #72]
	mutex_release(&hlist->lock);
ffffffffea80a66c:	aa1603e0 	mov	x0, x22
ffffffffea80a670:	97ffecb2 	bl	ffffffffea805938 <mutex_release>
	event_destroy(&ev);
ffffffffea80a674:	aa1703e0 	mov	x0, x23
ffffffffea80a678:	97ffebe0 	bl	ffffffffea8055f8 <event_destroy>
	return ret;
}
ffffffffea80a67c:	f9402b5a 	ldr	x26, [x26, #80]
ffffffffea80a680:	2a1303e0 	mov	w0, w19
ffffffffea80a684:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea80a688:	f9400341 	ldr	x1, [x26]
ffffffffea80a68c:	ca010041 	eor	x1, x2, x1
ffffffffea80a690:	b5000861 	cbnz	x1, ffffffffea80a79c <handle_list_wait+0x1cc>
ffffffffea80a694:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80a698:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80a69c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80a6a0:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80a6a4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80a6a8:	d65f03c0 	ret
			ret = _hlist_do_poll_locked(hlist, handle_ptr,
ffffffffea80a6ac:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80a6b0:	aa1903e2 	mov	x2, x25
ffffffffea80a6b4:	aa1803e1 	mov	x1, x24
ffffffffea80a6b8:	aa1403e0 	mov	x0, x20
ffffffffea80a6bc:	97fffe7f 	bl	ffffffffea80a0b8 <_hlist_do_poll_locked>
ffffffffea80a6c0:	2a0003f3 	mov	w19, w0
		} while (!ret);
ffffffffea80a6c4:	35000620 	cbnz	w0, ffffffffea80a788 <handle_list_wait+0x1b8>
			mutex_release(&hlist->lock);
ffffffffea80a6c8:	aa1603e0 	mov	x0, x22
ffffffffea80a6cc:	97ffec9b 	bl	ffffffffea805938 <mutex_release>
	ret = event_wait_timeout(ev, timeout);
ffffffffea80a6d0:	2a1503e1 	mov	w1, w21
ffffffffea80a6d4:	aa1703e0 	mov	x0, x23
ffffffffea80a6d8:	97ffebf2 	bl	ffffffffea8056a0 <event_wait_timeout>
ffffffffea80a6dc:	2a0003f3 	mov	w19, w0
ffffffffea80a6e0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80a6e4:	aa1603e0 	mov	x0, x22
ffffffffea80a6e8:	97ffec68 	bl	ffffffffea805888 <mutex_acquire_timeout>
			if (ret < 0) {
ffffffffea80a6ec:	36fffe13 	tbz	w19, #31, ffffffffea80a6ac <handle_list_wait+0xdc>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a6f0:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a6f4:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a6f8:	eb00029f 	cmp	x20, x0
ffffffffea80a6fc:	540000c1 	b.ne	ffffffffea80a714 <handle_list_wait+0x144>  // b.any
ffffffffea80a700:	17ffffda 	b	ffffffffea80a668 <handle_list_wait+0x98>
ffffffffea80a704:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a708:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a70c:	eb00029f 	cmp	x20, x0
ffffffffea80a710:	54fffa80 	b.eq	ffffffffea80a660 <handle_list_wait+0x90>  // b.none
		_finish_wait_handle(handle);
ffffffffea80a714:	aa1503e0 	mov	x0, x21
ffffffffea80a718:	97fffe20 	bl	ffffffffea809f98 <_finish_wait_handle>
		if (handle == last) {
ffffffffea80a71c:	b5ffff55 	cbnz	x21, ffffffffea80a704 <handle_list_wait+0x134>
	if (ret == 1) {
ffffffffea80a720:	7100067f 	cmp	w19, #0x1
ffffffffea80a724:	54fffa21 	b.ne	ffffffffea80a668 <handle_list_wait+0x98>  // b.any
		handle_t *handle = *handle_ptr;
ffffffffea80a728:	f9400315 	ldr	x21, [x24]
		if (handle->ops->finalize_event) {
ffffffffea80a72c:	f94006a0 	ldr	x0, [x21, #8]
ffffffffea80a730:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80a734:	b4000082 	cbz	x2, ffffffffea80a744 <handle_list_wait+0x174>
			handle->ops->finalize_event(handle, *event_ptr);
ffffffffea80a738:	b9400321 	ldr	w1, [x25]
ffffffffea80a73c:	aa1503e0 	mov	x0, x21
ffffffffea80a740:	d63f0040 	blr	x2
ffffffffea80a744:	885f7ea0 	ldxr	w0, [x21]
ffffffffea80a748:	11000400 	add	w0, w0, #0x1
ffffffffea80a74c:	88017ea0 	stxr	w1, w0, [x21]
ffffffffea80a750:	35ffffa1 	cbnz	w1, ffffffffea80a744 <handle_list_wait+0x174>
	item->next->prev = item->prev;
ffffffffea80a754:	a9400282 	ldp	x2, x0, [x20]
		list_add_head(&handle->hlist_node, &hlist->handles);
ffffffffea80a758:	910082a1 	add	x1, x21, #0x20
		ret = NO_ERROR;
ffffffffea80a75c:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80a760:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea80a764:	f9400282 	ldr	x2, [x20]
ffffffffea80a768:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80a76c:	f900069f 	str	xzr, [x20, #8]
	item->next = list->next;
ffffffffea80a770:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a774:	a9000281 	stp	x1, x0, [x20]
	list->next->prev = item;
ffffffffea80a778:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80a77c:	f9000014 	str	x20, [x0]
	list->next = item;
ffffffffea80a780:	f90016b4 	str	x20, [x21, #40]
ffffffffea80a784:	17ffffb9 	b	ffffffffea80a668 <handle_list_wait+0x98>
	list_for_every_entry(&hlist->handles, handle, handle_t, hlist_node) {
ffffffffea80a788:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80a78c:	d1008015 	sub	x21, x0, #0x20
ffffffffea80a790:	eb00029f 	cmp	x20, x0
ffffffffea80a794:	54fffc01 	b.ne	ffffffffea80a714 <handle_list_wait+0x144>  // b.any
ffffffffea80a798:	17ffffb2 	b	ffffffffea80a660 <handle_list_wait+0x90>
}
ffffffffea80a79c:	94002563 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80a7a0 <uctx_init>:
	trusty_als_set(app, _uctx_slot_id, uctx);
	return NO_ERROR;
}

static void uctx_init(uint level)
{
ffffffffea80a7a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80a7a4:	910003fd 	mov	x29, sp
ffffffffea80a7a8:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80a7ac:	aa1e03f3 	mov	x19, x30
	int res;

	/* allocate als slot */
	res = trusty_als_alloc_slot();
ffffffffea80a7b0:	97fff9a4 	bl	ffffffffea808e40 <trusty_als_alloc_slot>
ffffffffea80a7b4:	2a0003e2 	mov	w2, w0
	if (res < 0) {
ffffffffea80a7b8:	37f80140 	tbnz	w0, #31, ffffffffea80a7e0 <uctx_init+0x40>
		panic("failed (%d) to alloc als slot\n", res);
	}
	_uctx_slot_id = res;
ffffffffea80a7bc:	90000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>

	/* register notifier */
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a7c0:	f0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80a7c4:	9136c000 	add	x0, x0, #0xdb0
	_uctx_slot_id = res;
ffffffffea80a7c8:	b90f3822 	str	w2, [x1, #3896]
	res = trusty_register_app_notifier(&_uctx_notifier);
ffffffffea80a7cc:	97fff97f 	bl	ffffffffea808dc8 <trusty_register_app_notifier>
	if (res < 0) {
ffffffffea80a7d0:	37f80100 	tbnz	w0, #31, ffffffffea80a7f0 <uctx_init+0x50>
		panic("failed (%d) to register uctx notifier\n", res);
	}
}
ffffffffea80a7d4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80a7d8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80a7dc:	d65f03c0 	ret
		panic("failed (%d) to alloc als slot\n", res);
ffffffffea80a7e0:	b0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a7e4:	aa1303e0 	mov	x0, x19
ffffffffea80a7e8:	91380021 	add	x1, x1, #0xe00
ffffffffea80a7ec:	94001f65 	bl	ffffffffea812580 <_panic>
		panic("failed (%d) to register uctx notifier\n", res);
ffffffffea80a7f0:	b0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a7f4:	2a0003e2 	mov	w2, w0
ffffffffea80a7f8:	91388021 	add	x1, x1, #0xe20
ffffffffea80a7fc:	aa1303e0 	mov	x0, x19
ffffffffea80a800:	94001f60 	bl	ffffffffea812580 <_panic>
ffffffffea80a804:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a808 <_check_handle_id>:
 */
static int _check_handle_id(uctx_t *ctx, handle_id_t handle_id)
{
	DEBUG_ASSERT(ctx);

	if (unlikely(handle_id >= IPC_MAX_HANDLES)) {
ffffffffea80a808:	7101fc3f 	cmp	w1, #0x7f
ffffffffea80a80c:	540002e8 	b.hi	ffffffffea80a868 <_check_handle_id+0x60>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80a810:	2a0103e2 	mov	w2, w1
ffffffffea80a814:	aa0003e4 	mov	x4, x0
ffffffffea80a818:	d346fc43 	lsr	x3, x2, #6
ffffffffea80a81c:	f8637803 	ldr	x3, [x0, x3, lsl #3]
ffffffffea80a820:	9ac12461 	lsr	x1, x3, x1
		LTRACEF("%d is invalid handle id\n", handle_id);
		return ERR_BAD_HANDLE;
	}

	if (!bitmap_test(ctx->inuse, handle_id)) {
ffffffffea80a824:	36000261 	tbz	w1, #0, ffffffffea80a870 <_check_handle_id+0x68>
		LTRACEF("%d is unused handle id\n", handle_id);
		return ERR_NOT_FOUND;
	}

	/* there should be a handle there */
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a828:	91000842 	add	x2, x2, #0x2

	return NO_ERROR;
ffffffffea80a82c:	52800000 	mov	w0, #0x0                   	// #0
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a830:	f8627881 	ldr	x1, [x4, x2, lsl #3]
ffffffffea80a834:	b4000041 	cbz	x1, ffffffffea80a83c <_check_handle_id+0x34>
}
ffffffffea80a838:	d65f03c0 	ret
{
ffffffffea80a83c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a840:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a844:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a848:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
{
ffffffffea80a84c:	910003fd 	mov	x29, sp
ffffffffea80a850:	aa1e03e0 	mov	x0, x30
	ASSERT(ctx->handles[handle_id]);
ffffffffea80a854:	9134e084 	add	x4, x4, #0xd38
ffffffffea80a858:	52801283 	mov	w3, #0x94                  	// #148
ffffffffea80a85c:	91354042 	add	x2, x2, #0xd50
ffffffffea80a860:	91314021 	add	x1, x1, #0xc50
ffffffffea80a864:	94001f47 	bl	ffffffffea812580 <_panic>
		return ERR_BAD_HANDLE;
ffffffffea80a868:	12800520 	mov	w0, #0xffffffd6            	// #-42
ffffffffea80a86c:	d65f03c0 	ret
		return ERR_NOT_FOUND;
ffffffffea80a870:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80a874:	d65f03c0 	ret

ffffffffea80a878 <set_current_guest>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80a878:	d538d083 	mrs	x3, tpidr_el1
extern uint als_slot_cnt;

static inline void *trusty_als_get(struct trusty_app *app, int slot_id)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80a87c:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a880:	90000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a884:	f9415863 	ldr	x3, [x3, #688]
ffffffffea80a888:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80a88c:	b94f3821 	ldr	w1, [x1, #3896]
ffffffffea80a890:	f9404863 	ldr	x3, [x3, #144]
ffffffffea80a894:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80a898:	b9400042 	ldr	w2, [x2]
ffffffffea80a89c:	6b02003f 	cmp	w1, w2
ffffffffea80a8a0:	540001e2 	b.cs	ffffffffea80a8dc <set_current_guest+0x64>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a8a4:	f9403062 	ldr	x2, [x3, #96]
ffffffffea80a8a8:	f8615841 	ldr	x1, [x2, w1, uxtw #3]

static void set_current_guest(handle_t *handle)
{
	uctx_t *ctx = current_uctx();

	if (handle == NULL) {
ffffffffea80a8ac:	b4000080 	cbz	x0, ffffffffea80a8bc <set_current_guest+0x44>
		TRACEF("%s: handle pointer NULL\n", __func__);
		return;
	}

	ctx->cur_guest = handle->guest_id;
ffffffffea80a8b0:	b9403800 	ldr	w0, [x0, #56]
ffffffffea80a8b4:	b9046820 	str	w0, [x1, #1128]
ffffffffea80a8b8:	d65f03c0 	ret
		TRACEF("%s: handle pointer NULL\n", __func__);
ffffffffea80a8bc:	b0000063 	adrp	x3, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a8c0:	b0000061 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a8c4:	b0000060 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a8c8:	91348063 	add	x3, x3, #0xd20
ffffffffea80a8cc:	52802762 	mov	w2, #0x13b                 	// #315
ffffffffea80a8d0:	91342021 	add	x1, x1, #0xd08
ffffffffea80a8d4:	91370000 	add	x0, x0, #0xdc0
ffffffffea80a8d8:	140024e0 	b	ffffffffea813c58 <_printf>
{
ffffffffea80a8dc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a8e0:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a8e4:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a8e8:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80a8ec:	910003fd 	mov	x29, sp
ffffffffea80a8f0:	aa1e03e0 	mov	x0, x30
ffffffffea80a8f4:	9135c084 	add	x4, x4, #0xd70
ffffffffea80a8f8:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a8fc:	91362042 	add	x2, x2, #0xd88
ffffffffea80a900:	91314021 	add	x1, x1, #0xc50
ffffffffea80a904:	94001f1f 	bl	ffffffffea812580 <_panic>

ffffffffea80a908 <uctx_get_current_guest>:
ffffffffea80a908:	d538d083 	mrs	x3, tpidr_el1
ffffffffea80a90c:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a910:	90000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a914:	f9415863 	ldr	x3, [x3, #688]
ffffffffea80a918:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80a91c:	b94f3821 	ldr	w1, [x1, #3896]
ffffffffea80a920:	f9404863 	ldr	x3, [x3, #144]
ffffffffea80a924:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80a928:	b9400042 	ldr	w2, [x2]
ffffffffea80a92c:	6b02003f 	cmp	w1, w2
ffffffffea80a930:	540000a2 	b.cs	ffffffffea80a944 <uctx_get_current_guest+0x3c>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a934:	f9403060 	ldr	x0, [x3, #96]
	return ctx->cur_guest;
ffffffffea80a938:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
}
ffffffffea80a93c:	b9446800 	ldr	w0, [x0, #1128]
ffffffffea80a940:	d65f03c0 	ret
{
ffffffffea80a944:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a948:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a94c:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a950:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80a954:	910003fd 	mov	x29, sp
ffffffffea80a958:	aa1e03e0 	mov	x0, x30
ffffffffea80a95c:	9135c084 	add	x4, x4, #0xd70
ffffffffea80a960:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a964:	91362042 	add	x2, x2, #0xd88
ffffffffea80a968:	91314021 	add	x1, x1, #0xc50
ffffffffea80a96c:	94001f05 	bl	ffffffffea812580 <_panic>

ffffffffea80a970 <current_uctx>:
ffffffffea80a970:	d538d083 	mrs	x3, tpidr_el1
ffffffffea80a974:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80a978:	90000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80a97c:	f9415863 	ldr	x3, [x3, #688]
ffffffffea80a980:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80a984:	b94f3821 	ldr	w1, [x1, #3896]
ffffffffea80a988:	f9404863 	ldr	x3, [x3, #144]
ffffffffea80a98c:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80a990:	b9400042 	ldr	w2, [x2]
ffffffffea80a994:	6b02003f 	cmp	w1, w2
ffffffffea80a998:	54000082 	b.cs	ffffffffea80a9a8 <current_uctx+0x38>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80a99c:	f9403060 	ldr	x0, [x3, #96]
}
ffffffffea80a9a0:	f8615800 	ldr	x0, [x0, w1, uxtw #3]
ffffffffea80a9a4:	d65f03c0 	ret
{
ffffffffea80a9a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	ASSERT(slot < als_slot_cnt);
ffffffffea80a9ac:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a9b0:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80a9b4:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80a9b8:	910003fd 	mov	x29, sp
ffffffffea80a9bc:	aa1e03e0 	mov	x0, x30
ffffffffea80a9c0:	9135c084 	add	x4, x4, #0xd70
ffffffffea80a9c4:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80a9c8:	91362042 	add	x2, x2, #0xd88
ffffffffea80a9cc:	91314021 	add	x1, x1, #0xc50
ffffffffea80a9d0:	94001eec 	bl	ffffffffea812580 <_panic>
ffffffffea80a9d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80a9d8 <uctx_create>:
{
ffffffffea80a9d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80a9dc:	910003fd 	mov	x29, sp
ffffffffea80a9e0:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80a9e4:	aa0003f5 	mov	x21, x0
ffffffffea80a9e8:	aa0103f4 	mov	x20, x1
	new_ctx = calloc(1, sizeof(uctx_t));
ffffffffea80a9ec:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80a9f0:	d2808e01 	mov	x1, #0x470                 	// #1136
ffffffffea80a9f4:	940024e3 	bl	ffffffffea813d80 <calloc>
	if (!new_ctx) {
ffffffffea80a9f8:	b40001e0 	cbz	x0, ffffffffea80aa34 <uctx_create+0x5c>
ffffffffea80a9fc:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80aa00:	aa0003f3 	mov	x19, x0
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80aa04:	529fdda1 	mov	w1, #0xfeed                	// #65261
	handle_list_init(&new_ctx->handle_list);
ffffffffea80aa08:	91106000 	add	x0, x0, #0x418
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80aa0c:	72bbd5a1 	movk	w1, #0xdead, lsl #16
	new_ctx->priv = priv;
ffffffffea80aa10:	f9020a75 	str	x21, [x19, #1040]
	new_ctx->cur_guest = DEFAULT_GUEST_ID;
ffffffffea80aa14:	b9046a61 	str	w1, [x19, #1128]
	handle_list_init(&new_ctx->handle_list);
ffffffffea80aa18:	97fffea4 	bl	ffffffffea80a4a8 <handle_list_init>
	*ctx = new_ctx;
ffffffffea80aa1c:	f9000293 	str	x19, [x20]
	return NO_ERROR;
ffffffffea80aa20:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80aa24:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80aa28:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80aa2c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80aa30:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea80aa34:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80aa38:	17fffffc 	b	ffffffffea80aa28 <uctx_create+0x50>
ffffffffea80aa3c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80aa40 <_uctx_startup>:
{
ffffffffea80aa40:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80aa44:	910003fd 	mov	x29, sp
ffffffffea80aa48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80aa4c:	900002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80aa50:	aa0003f4 	mov	x20, x0
	int err = uctx_create(app, &uctx);
ffffffffea80aa54:	9100c3a1 	add	x1, x29, #0x30
{
ffffffffea80aa58:	f9402a62 	ldr	x2, [x19, #80]
ffffffffea80aa5c:	f9400043 	ldr	x3, [x2]
ffffffffea80aa60:	f9001fa3 	str	x3, [x29, #56]
ffffffffea80aa64:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea80aa68:	f90013f5 	str	x21, [sp, #32]
ffffffffea80aa6c:	aa1e03f5 	mov	x21, x30
	int err = uctx_create(app, &uctx);
ffffffffea80aa70:	97ffffda 	bl	ffffffffea80a9d8 <uctx_create>
	if (err) {
ffffffffea80aa74:	34000140 	cbz	w0, ffffffffea80aa9c <_uctx_startup+0x5c>
}
ffffffffea80aa78:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80aa7c:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea80aa80:	f9400261 	ldr	x1, [x19]
ffffffffea80aa84:	ca010041 	eor	x1, x2, x1
ffffffffea80aa88:	b5000341 	cbnz	x1, ffffffffea80aaf0 <_uctx_startup+0xb0>
ffffffffea80aa8c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80aa90:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80aa94:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80aa98:	d65f03c0 	ret
}

static inline void trusty_als_set(struct trusty_app *app, int slot_id, void *ptr)
{
	uint slot = slot_id - 1;
	ASSERT(slot < als_slot_cnt);
ffffffffea80aa9c:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	trusty_als_set(app, _uctx_slot_id, uctx);
ffffffffea80aaa0:	90000341 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80aaa4:	f9401ba3 	ldr	x3, [x29, #48]
ffffffffea80aaa8:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80aaac:	b94f3821 	ldr	w1, [x1, #3896]
ffffffffea80aab0:	51000421 	sub	w1, w1, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80aab4:	b9400042 	ldr	w2, [x2]
ffffffffea80aab8:	6b02003f 	cmp	w1, w2
ffffffffea80aabc:	54000082 	b.cs	ffffffffea80aacc <_uctx_startup+0x8c>  // b.hs, b.nlast
	app->als[slot] = ptr;
ffffffffea80aac0:	f9403282 	ldr	x2, [x20, #96]
ffffffffea80aac4:	f8215843 	str	x3, [x2, w1, uxtw #3]
ffffffffea80aac8:	17ffffec 	b	ffffffffea80aa78 <_uctx_startup+0x38>
	ASSERT(slot < als_slot_cnt);
ffffffffea80aacc:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80aad0:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80aad4:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80aad8:	9135c084 	add	x4, x4, #0xd70
ffffffffea80aadc:	52800d63 	mov	w3, #0x6b                  	// #107
ffffffffea80aae0:	91362042 	add	x2, x2, #0xd88
ffffffffea80aae4:	91314021 	add	x1, x1, #0xc50
ffffffffea80aae8:	aa1503e0 	mov	x0, x21
ffffffffea80aaec:	94001ea5 	bl	ffffffffea812580 <_panic>
}
ffffffffea80aaf0:	9400248e 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80aaf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80aaf8 <uctx_handle_install>:
{
ffffffffea80aaf8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80aafc:	910003fd 	mov	x29, sp
ffffffffea80ab00:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ab04:	52800013 	mov	w19, #0x0                   	// #0
{
	uint i;
	int bit;

	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
		if (bitmap[i] == ~0UL)
ffffffffea80ab08:	f9400004 	ldr	x4, [x0]
ffffffffea80ab0c:	b100049f 	cmn	x4, #0x1
ffffffffea80ab10:	54000380 	b.eq	ffffffffea80ab80 <uctx_handle_install+0x88>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80ab14:	aa2403e4 	mvn	x4, x4
ffffffffea80ab18:	aa0203f4 	mov	x20, x2
ffffffffea80ab1c:	dac00083 	rbit	x3, x4
ffffffffea80ab20:	f100009f 	cmp	x4, #0x0
ffffffffea80ab24:	dac01063 	clz	x3, x3
ffffffffea80ab28:	5a9f1063 	csinv	w3, w3, wzr, ne  // ne = any
			continue;
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80ab2c:	0b130063 	add	w3, w3, w19
ffffffffea80ab30:	aa0303f3 	mov	x19, x3
ffffffffea80ab34:	8b030c04 	add	x4, x0, x3, lsl #3
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80ab38:	f9400882 	ldr	x2, [x4, #16]
ffffffffea80ab3c:	b50002c2 	cbnz	x2, ffffffffea80ab94 <uctx_handle_install+0x9c>
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80ab40:	d345fc63 	lsr	x3, x3, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80ab44:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea80ab48:	1ad32042 	lsl	w2, w2, w19
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80ab4c:	8b030803 	add	x3, x0, x3, lsl #2
ffffffffea80ab50:	885f7c65 	ldxr	w5, [x3]
ffffffffea80ab54:	2a0200a5 	orr	w5, w5, w2
ffffffffea80ab58:	88067c65 	stxr	w6, w5, [x3]
ffffffffea80ab5c:	35ffffa6 	cbnz	w6, ffffffffea80ab50 <uctx_handle_install+0x58>
	ctx->handles[new_id] = handle;
ffffffffea80ab60:	f9000881 	str	x1, [x4, #16]
	handle_list_add(&ctx->handle_list, handle);
ffffffffea80ab64:	91106000 	add	x0, x0, #0x418
ffffffffea80ab68:	97fffe5e 	bl	ffffffffea80a4e0 <handle_list_add>
	*id = (handle_id_t) new_id;
ffffffffea80ab6c:	b9000293 	str	w19, [x20]
	return NO_ERROR;
ffffffffea80ab70:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80ab74:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ab78:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80ab7c:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea80ab80:	f9400404 	ldr	x4, [x0, #8]
ffffffffea80ab84:	b100049f 	cmn	x4, #0x1
ffffffffea80ab88:	54000180 	b.eq	ffffffffea80abb8 <uctx_handle_install+0xc0>  // b.none
ffffffffea80ab8c:	52800813 	mov	w19, #0x40                  	// #64
ffffffffea80ab90:	17ffffe1 	b	ffffffffea80ab14 <uctx_handle_install+0x1c>
	ASSERT(ctx->handles[new_id] == NULL);
ffffffffea80ab94:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80ab98:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80ab9c:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80aba0:	91378084 	add	x4, x4, #0xde0
ffffffffea80aba4:	52801e23 	mov	w3, #0xf1                  	// #241
ffffffffea80aba8:	91354042 	add	x2, x2, #0xd50
ffffffffea80abac:	91314021 	add	x1, x1, #0xc50
ffffffffea80abb0:	aa1e03e0 	mov	x0, x30
ffffffffea80abb4:	94001e73 	bl	ffffffffea812580 <_panic>
		return ERR_NO_RESOURCES;
ffffffffea80abb8:	12800500 	mov	w0, #0xffffffd7            	// #-41
ffffffffea80abbc:	17ffffee 	b	ffffffffea80ab74 <uctx_handle_install+0x7c>

ffffffffea80abc0 <uctx_handle_get>:
{
ffffffffea80abc0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80abc4:	910003fd 	mov	x29, sp
ffffffffea80abc8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80abcc:	2a0103f4 	mov	w20, w1
ffffffffea80abd0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80abd4:	aa0003f6 	mov	x22, x0
ffffffffea80abd8:	aa0203f5 	mov	x21, x2
	int ret = _check_handle_id (ctx, handle_id);
ffffffffea80abdc:	97ffff0b 	bl	ffffffffea80a808 <_check_handle_id>
ffffffffea80abe0:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80abe4:	350000e0 	cbnz	w0, ffffffffea80ac00 <uctx_handle_get+0x40>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80abe8:	8b344ed4 	add	x20, x22, w20, uxtw #3
		platform_arch_speculation_barrier();
ffffffffea80abec:	97ffdd8d 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80abf0:	f9400a94 	ldr	x20, [x20, #16]
		handle_incref(handle);
ffffffffea80abf4:	aa1403e0 	mov	x0, x20
ffffffffea80abf8:	97fffd8a 	bl	ffffffffea80a220 <handle_incref>
		*handle_ptr = handle;
ffffffffea80abfc:	f90002b4 	str	x20, [x21]
}
ffffffffea80ac00:	2a1303e0 	mov	w0, w19
ffffffffea80ac04:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ac08:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ac0c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ac10:	d65f03c0 	ret
ffffffffea80ac14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ac18 <uctx_handle_remove>:
{
ffffffffea80ac18:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ac1c:	910003fd 	mov	x29, sp
ffffffffea80ac20:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ac24:	aa0003f4 	mov	x20, x0
ffffffffea80ac28:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ac2c:	2a0103f5 	mov	w21, w1
ffffffffea80ac30:	aa0203f6 	mov	x22, x2
	int ret = _check_handle_id(ctx, handle_id);
ffffffffea80ac34:	97fffef5 	bl	ffffffffea80a808 <_check_handle_id>
ffffffffea80ac38:	2a0003f3 	mov	w19, w0
	if (ret == NO_ERROR) {
ffffffffea80ac3c:	340000c0 	cbz	w0, ffffffffea80ac54 <uctx_handle_remove+0x3c>
}
ffffffffea80ac40:	2a1303e0 	mov	w0, w19
ffffffffea80ac44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ac48:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ac4c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ac50:	d65f03c0 	ret
		platform_arch_speculation_barrier();
ffffffffea80ac54:	97ffdd73 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
ffffffffea80ac58:	8b354e82 	add	x2, x20, w21, uxtw #3
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80ac5c:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80ac60:	52800021 	mov	w1, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80ac64:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea80ac68:	1ad52021 	lsl	w1, w1, w21
ffffffffea80ac6c:	8b000280 	add	x0, x20, x0
		handle_t *handle = ctx->handles[handle_id];
ffffffffea80ac70:	f9400855 	ldr	x21, [x2, #16]
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80ac74:	2a2103e1 	mvn	w1, w1
ffffffffea80ac78:	885f7c03 	ldxr	w3, [x0]
ffffffffea80ac7c:	0a010063 	and	w3, w3, w1
ffffffffea80ac80:	88047c03 	stxr	w4, w3, [x0]
ffffffffea80ac84:	35ffffa4 	cbnz	w4, ffffffffea80ac78 <uctx_handle_remove+0x60>
		ctx->handles[handle_id] = NULL;
ffffffffea80ac88:	f900085f 	str	xzr, [x2, #16]
		handle_list_del(&ctx->handle_list, handle);
ffffffffea80ac8c:	aa1503e1 	mov	x1, x21
ffffffffea80ac90:	91106280 	add	x0, x20, #0x418
ffffffffea80ac94:	97fffe3d 	bl	ffffffffea80a588 <handle_list_del>
		*handle_ptr = handle;
ffffffffea80ac98:	f90002d5 	str	x21, [x22]
}
ffffffffea80ac9c:	2a1303e0 	mov	w0, w19
ffffffffea80aca0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80aca4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80aca8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80acac:	d65f03c0 	ret

ffffffffea80acb0 <sys_wait>:
/*
 *   wait on single handle specified by handle id
 */
long __SYSCALL sys_wait(uint32_t handle_id, user_addr_t user_event,
                        unsigned long timeout_msecs)
{
ffffffffea80acb0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80acb4:	910003fd 	mov	x29, sp
ffffffffea80acb8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80acbc:	900002d4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80acc0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80acc4:	2a0003f5 	mov	w21, w0
ffffffffea80acc8:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80accc:	2a0103f6 	mov	w22, w1
ffffffffea80acd0:	aa0203f3 	mov	x19, x2
ffffffffea80acd4:	f9400001 	ldr	x1, [x0]
ffffffffea80acd8:	f9002fa1 	str	x1, [x29, #88]
ffffffffea80acdc:	d2800001 	mov	x1, #0x0                   	// #0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea80ace0:	d538d082 	mrs	x2, tpidr_el1
	ASSERT(slot < als_slot_cnt);
ffffffffea80ace4:	900002c1 	adrp	x1, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ace8:	90000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80acec:	f9415842 	ldr	x2, [x2, #688]
ffffffffea80acf0:	f9406421 	ldr	x1, [x1, #200]
	uint slot = slot_id - 1;
ffffffffea80acf4:	b94f3800 	ldr	w0, [x0, #3896]
ffffffffea80acf8:	f9404842 	ldr	x2, [x2, #144]
ffffffffea80acfc:	51000400 	sub	w0, w0, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80ad00:	b9400021 	ldr	w1, [x1]
ffffffffea80ad04:	6b01001f 	cmp	w0, w1
ffffffffea80ad08:	540005a2 	b.cs	ffffffffea80adbc <sys_wait+0x10c>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ad0c:	f9403043 	ldr	x3, [x2, #96]
	int ret;

	LTRACEF("[%p][%d]: %ld msec\n", uthread_get_current(),
	                                handle_id, timeout_msecs);

	ret = uctx_handle_get(ctx, handle_id, &handle);
ffffffffea80ad10:	2a1503e1 	mov	w1, w21
ffffffffea80ad14:	910103a2 	add	x2, x29, #0x40
ffffffffea80ad18:	f8605860 	ldr	x0, [x3, w0, uxtw #3]
ffffffffea80ad1c:	97ffffa9 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80ad20:	34000160 	cbz	w0, ffffffffea80ad4c <sys_wait+0x9c>
		return ret;
ffffffffea80ad24:	93407c00 	sxtw	x0, w0
	handle_decref(handle);

	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                handle_id, ret);
	return ret;
}
ffffffffea80ad28:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80ad2c:	f9402fa2 	ldr	x2, [x29, #88]
ffffffffea80ad30:	f9400281 	ldr	x1, [x20]
ffffffffea80ad34:	ca010041 	eor	x1, x2, x1
ffffffffea80ad38:	b50005c1 	cbnz	x1, ffffffffea80adf0 <sys_wait+0x140>
ffffffffea80ad3c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ad40:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ad44:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80ad48:	d65f03c0 	ret
	ret = handle_wait(handle, &tmp_event.event,
ffffffffea80ad4c:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80ad50:	2a1303e2 	mov	w2, w19
ffffffffea80ad54:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80ad58:	910133a1 	add	x1, x29, #0x4c
ffffffffea80ad5c:	910123b7 	add	x23, x29, #0x48
ffffffffea80ad60:	97fffd6a 	bl	ffffffffea80a308 <handle_wait>
ffffffffea80ad64:	2a0003f3 	mov	w19, w0
	if (ret < 0) {
ffffffffea80ad68:	36f800c0 	tbz	w0, #31, ffffffffea80ad80 <sys_wait+0xd0>
	handle_decref(handle);
ffffffffea80ad6c:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80ad70:	97fffd32 	bl	ffffffffea80a238 <handle_decref>
	return ret;
ffffffffea80ad74:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80ad78:	93407e60 	sxtw	x0, w19
ffffffffea80ad7c:	17ffffeb 	b	ffffffffea80ad28 <sys_wait+0x78>
	handle->cookie = cookie;
}

static inline void *handle_get_cookie(handle_t *handle)
{
	return handle->cookie;
ffffffffea80ad80:	f94023a3 	ldr	x3, [x29, #64]
ffffffffea80ad84:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80ad88:	aa1703e1 	mov	x1, x23
ffffffffea80ad8c:	2a1603e0 	mov	w0, w22
	tmp_event.handle = handle_id;
ffffffffea80ad90:	b9004bb5 	str	w21, [x29, #72]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80ad94:	f9401863 	ldr	x3, [x3, #48]
ffffffffea80ad98:	b90053a3 	str	w3, [x29, #80]
ffffffffea80ad9c:	9400257d 	bl	ffffffffea814390 <arch_copy_to_user>
	if (status) {
ffffffffea80ada0:	34000220 	cbz	w0, ffffffffea80ade4 <sys_wait+0x134>
ffffffffea80ada4:	2a0003f3 	mov	w19, w0
	handle_decref(handle);
ffffffffea80ada8:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80adac:	97fffd23 	bl	ffffffffea80a238 <handle_decref>
	return ret;
ffffffffea80adb0:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80adb4:	93407e60 	sxtw	x0, w19
ffffffffea80adb8:	17ffffdc 	b	ffffffffea80ad28 <sys_wait+0x78>
	ASSERT(slot < als_slot_cnt);
ffffffffea80adbc:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80adc0:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80adc4:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80adc8:	9135c084 	add	x4, x4, #0xd70
ffffffffea80adcc:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80add0:	91362042 	add	x2, x2, #0xd88
ffffffffea80add4:	91314021 	add	x1, x1, #0xc50
ffffffffea80add8:	aa1e03e0 	mov	x0, x30
ffffffffea80addc:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80ade0:	94001de8 	bl	ffffffffea812580 <_panic>
		set_current_guest(handle);
ffffffffea80ade4:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80ade8:	97fffea4 	bl	ffffffffea80a878 <set_current_guest>
out:
ffffffffea80adec:	17ffffe0 	b	ffffffffea80ad6c <sys_wait+0xbc>
ffffffffea80adf0:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea80adf4:	940023cd 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80adf8 <sys_wait_any>:

/*
 *   Wait on any handle existing in user context.
 */
long __SYSCALL sys_wait_any(user_addr_t user_event, unsigned long timeout_msecs)
{
ffffffffea80adf8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80adfc:	910003fd 	mov	x29, sp
ffffffffea80ae00:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80ae04:	900002d4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80ae08:	2a0003f5 	mov	w21, w0
ffffffffea80ae0c:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80ae10:	f9400002 	ldr	x2, [x0]
ffffffffea80ae14:	f9002fa2 	str	x2, [x29, #88]
ffffffffea80ae18:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80ae1c:	d538d084 	mrs	x4, tpidr_el1
ffffffffea80ae20:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ae24:	f9415884 	ldr	x4, [x4, #688]
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80ae28:	90000340 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea80ae2c:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80ae30:	b94f3800 	ldr	w0, [x0, #3896]
	trusty_app_t *tapp = ut->private_data;
ffffffffea80ae34:	f9404883 	ldr	x3, [x4, #144]
ffffffffea80ae38:	51000400 	sub	w0, w0, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80ae3c:	b9400042 	ldr	w2, [x2]
ffffffffea80ae40:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80ae44:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80ae48:	6b02001f 	cmp	w0, w2
ffffffffea80ae4c:	540005c2 	b.cs	ffffffffea80af04 <sys_wait_any+0x10c>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80ae50:	f9403064 	ldr	x4, [x3, #96]
	                            timeout_msecs);
	/*
	 * Get a handle that has a pending event. The returned handle has
	 * extra ref taken.
	 */
	ret = handle_list_wait(&ctx->handle_list, &handle, &tmp_event.event,
ffffffffea80ae54:	910123b6 	add	x22, x29, #0x48
ffffffffea80ae58:	2a0103e3 	mov	w3, w1
ffffffffea80ae5c:	910012c2 	add	x2, x22, #0x4
ffffffffea80ae60:	910103a1 	add	x1, x29, #0x40
ffffffffea80ae64:	f8605893 	ldr	x19, [x4, w0, uxtw #3]
ffffffffea80ae68:	91106260 	add	x0, x19, #0x418
ffffffffea80ae6c:	97fffdd9 	bl	ffffffffea80a5d0 <handle_list_wait>
ffffffffea80ae70:	2a0003f7 	mov	w23, w0
			       timeout_msecs);
	if (ret < 0) {
ffffffffea80ae74:	37f802c0 	tbnz	w0, #31, ffffffffea80aecc <sys_wait_any+0xd4>
ffffffffea80ae78:	91004261 	add	x1, x19, #0x10
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80ae7c:	52800002 	mov	w2, #0x0                   	// #0
		goto out;
	}

	DEBUG_ASSERT(handle); /* there should be a handle */

	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80ae80:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80ae84:	14000005 	b	ffffffffea80ae98 <sys_wait_any+0xa0>
	for (int i = 0; i < IPC_MAX_HANDLES; i++) {
ffffffffea80ae88:	11000442 	add	w2, w2, #0x1
ffffffffea80ae8c:	91002021 	add	x1, x1, #0x8
ffffffffea80ae90:	7102005f 	cmp	w2, #0x80
ffffffffea80ae94:	540004a0 	b.eq	ffffffffea80af28 <sys_wait_any+0x130>  // b.none
		if (ctx->handles[i] == handle) {
ffffffffea80ae98:	f9400023 	ldr	x3, [x1]
ffffffffea80ae9c:	eb03001f 	cmp	x0, x3
ffffffffea80aea0:	54ffff41 	b.ne	ffffffffea80ae88 <sys_wait_any+0x90>  // b.any
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80aea4:	f9401801 	ldr	x1, [x0, #48]
	tmp_event.handle = _handle_to_id_locked(ctx, handle);
ffffffffea80aea8:	b9004ba2 	str	w2, [x29, #72]
	tmp_event.cookie = (user_addr_t)(uintptr_t)handle_get_cookie(handle);
ffffffffea80aeac:	b90053a1 	str	w1, [x29, #80]

	/* drop the reference that was taken by wait_any */
	handle_decref(handle);
ffffffffea80aeb0:	97fffce2 	bl	ffffffffea80a238 <handle_decref>
ffffffffea80aeb4:	d2800182 	mov	x2, #0xc                   	// #12
ffffffffea80aeb8:	aa1603e1 	mov	x1, x22
ffffffffea80aebc:	2a1503e0 	mov	w0, w21
ffffffffea80aec0:	94002534 	bl	ffffffffea814390 <arch_copy_to_user>

	/* there should be a handle id */
	DEBUG_ASSERT(tmp_event.handle < IPC_MAX_HANDLES);

	status = copy_to_user(user_event, &tmp_event, sizeof(tmp_event));
	if (status) {
ffffffffea80aec4:	340001a0 	cbz	w0, ffffffffea80aef8 <sys_wait_any+0x100>
ffffffffea80aec8:	2a0003f7 	mov	w23, w0
	}
out:
	LTRACEF("[%p][%d]: ret = %d\n", uthread_get_current(),
	                                tmp_event.handle, ret);
	return ret;
}
ffffffffea80aecc:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80aed0:	93407ee0 	sxtw	x0, w23
ffffffffea80aed4:	f9402fa2 	ldr	x2, [x29, #88]
ffffffffea80aed8:	f9400281 	ldr	x1, [x20]
ffffffffea80aedc:	ca010041 	eor	x1, x2, x1
ffffffffea80aee0:	b5000281 	cbnz	x1, ffffffffea80af30 <sys_wait_any+0x138>
ffffffffea80aee4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80aee8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80aeec:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80aef0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80aef4:	d65f03c0 	ret
		set_current_guest(handle);
ffffffffea80aef8:	f94023a0 	ldr	x0, [x29, #64]
ffffffffea80aefc:	97fffe5f 	bl	ffffffffea80a878 <set_current_guest>
out:
ffffffffea80af00:	17fffff3 	b	ffffffffea80aecc <sys_wait_any+0xd4>
	ASSERT(slot < als_slot_cnt);
ffffffffea80af04:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80af08:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80af0c:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80af10:	9135c084 	add	x4, x4, #0xd70
ffffffffea80af14:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80af18:	91362042 	add	x2, x2, #0xd88
ffffffffea80af1c:	91314021 	add	x1, x1, #0xc50
ffffffffea80af20:	aa1e03e0 	mov	x0, x30
ffffffffea80af24:	94001d97 	bl	ffffffffea812580 <_panic>
	return INVALID_HANDLE_ID;
ffffffffea80af28:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80af2c:	17ffffde 	b	ffffffffea80aea4 <sys_wait_any+0xac>
}
ffffffffea80af30:	9400237e 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80af34:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80af38 <sys_close>:

long __SYSCALL sys_close(uint32_t handle_id)
{
ffffffffea80af38:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80af3c:	910003fd 	mov	x29, sp
ffffffffea80af40:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80af44:	900002d3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80af48:	f9402a62 	ldr	x2, [x19, #80]
ffffffffea80af4c:	f9400041 	ldr	x1, [x2]
ffffffffea80af50:	f90017a1 	str	x1, [x29, #40]
ffffffffea80af54:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80af58:	d538d084 	mrs	x4, tpidr_el1
ffffffffea80af5c:	900002c2 	adrp	x2, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80af60:	90000343 	adrp	x3, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80af64:	f9415884 	ldr	x4, [x4, #688]
ffffffffea80af68:	f9406442 	ldr	x2, [x2, #200]
	uint slot = slot_id - 1;
ffffffffea80af6c:	b94f3863 	ldr	w3, [x3, #3896]
ffffffffea80af70:	f9404881 	ldr	x1, [x4, #144]
ffffffffea80af74:	51000463 	sub	w3, w3, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80af78:	b9400042 	ldr	w2, [x2]
ffffffffea80af7c:	6b02007f 	cmp	w3, w2
ffffffffea80af80:	54000282 	b.cs	ffffffffea80afd0 <sys_close+0x98>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80af84:	f9403024 	ldr	x4, [x1, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]\n", uthread_get_current(),
	                      handle_id);

	int ret = uctx_handle_remove(current_uctx(), handle_id, &handle);
ffffffffea80af88:	2a0003e1 	mov	w1, w0
ffffffffea80af8c:	910083a2 	add	x2, x29, #0x20
ffffffffea80af90:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80af94:	97ffff21 	bl	ffffffffea80ac18 <uctx_handle_remove>
	if (ret != NO_ERROR) {
ffffffffea80af98:	34000140 	cbz	w0, ffffffffea80afc0 <sys_close+0x88>
		return ret;
ffffffffea80af9c:	93407c00 	sxtw	x0, w0
	}
	handle_close(handle);
	return NO_ERROR;
}
ffffffffea80afa0:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80afa4:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80afa8:	f9400261 	ldr	x1, [x19]
ffffffffea80afac:	ca010041 	eor	x1, x2, x1
ffffffffea80afb0:	b5000221 	cbnz	x1, ffffffffea80aff4 <sys_close+0xbc>
ffffffffea80afb4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80afb8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80afbc:	d65f03c0 	ret
	handle_close(handle);
ffffffffea80afc0:	f94013a0 	ldr	x0, [x29, #32]
ffffffffea80afc4:	97fffcc5 	bl	ffffffffea80a2d8 <handle_close>
	return NO_ERROR;
ffffffffea80afc8:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80afcc:	17fffff5 	b	ffffffffea80afa0 <sys_close+0x68>
	ASSERT(slot < als_slot_cnt);
ffffffffea80afd0:	b0000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80afd4:	b0000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80afd8:	90000061 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80afdc:	9135c084 	add	x4, x4, #0xd70
ffffffffea80afe0:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80afe4:	91362042 	add	x2, x2, #0xd88
ffffffffea80afe8:	91314021 	add	x1, x1, #0xc50
ffffffffea80afec:	aa1e03e0 	mov	x0, x30
ffffffffea80aff0:	94001d64 	bl	ffffffffea812580 <_panic>
}
ffffffffea80aff4:	9400234d 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80aff8 <sys_set_cookie>:

long __SYSCALL sys_set_cookie(uint32_t handle_id, user_addr_t cookie)
{
ffffffffea80aff8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80affc:	910003fd 	mov	x29, sp
ffffffffea80b000:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b004:	f00002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80b008:	2a0103f4 	mov	w20, w1
ffffffffea80b00c:	f9402a61 	ldr	x1, [x19, #80]
ffffffffea80b010:	f9400022 	ldr	x2, [x1]
ffffffffea80b014:	f90017a2 	str	x2, [x29, #40]
ffffffffea80b018:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80b01c:	d538d082 	mrs	x2, tpidr_el1
ffffffffea80b020:	f00002a1 	adrp	x1, ffffffffea862000 <__ctor_list>
	return trusty_als_get(tapp, _uctx_slot_id);
ffffffffea80b024:	f0000323 	adrp	x3, ffffffffea872000 <idle_threads+0xeb0>
	trusty_app_t *tapp = ut->private_data;
ffffffffea80b028:	f9415842 	ldr	x2, [x2, #688]
ffffffffea80b02c:	f9406421 	ldr	x1, [x1, #200]
	uint slot = slot_id - 1;
ffffffffea80b030:	b94f3863 	ldr	w3, [x3, #3896]
ffffffffea80b034:	f9404842 	ldr	x2, [x2, #144]
ffffffffea80b038:	51000463 	sub	w3, w3, #0x1
	ASSERT(slot < als_slot_cnt);
ffffffffea80b03c:	b9400021 	ldr	w1, [x1]
ffffffffea80b040:	6b01007f 	cmp	w3, w1
ffffffffea80b044:	540002c2 	b.cs	ffffffffea80b09c <sys_set_cookie+0xa4>  // b.hs, b.nlast
	return app->als[slot];
ffffffffea80b048:	f9403044 	ldr	x4, [x2, #96]
	handle_t *handle;

	LTRACEF("[%p][%d]: cookie = 0x%08x\n", uthread_get_current(),
	                              handle_id, (uint) cookie);

	int ret = uctx_handle_get(current_uctx(), handle_id, &handle);
ffffffffea80b04c:	2a0003e1 	mov	w1, w0
ffffffffea80b050:	910083a2 	add	x2, x29, #0x20
ffffffffea80b054:	f8635880 	ldr	x0, [x4, w3, uxtw #3]
ffffffffea80b058:	97fffeda 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80b05c:	34000140 	cbz	w0, ffffffffea80b084 <sys_set_cookie+0x8c>
		return ret;
ffffffffea80b060:	93407c00 	sxtw	x0, w0
	}
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);

	handle_decref(handle);
	return NO_ERROR;
}
ffffffffea80b064:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80b068:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80b06c:	f9400261 	ldr	x1, [x19]
ffffffffea80b070:	ca010041 	eor	x1, x2, x1
ffffffffea80b074:	b5000261 	cbnz	x1, ffffffffea80b0c0 <sys_set_cookie+0xc8>
ffffffffea80b078:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b07c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b080:	d65f03c0 	ret
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80b084:	f94013a1 	ldr	x1, [x29, #32]
	handle_decref(handle);
ffffffffea80b088:	aa0103e0 	mov	x0, x1
	handle_set_cookie(handle, (void *)(uintptr_t)cookie);
ffffffffea80b08c:	f9001834 	str	x20, [x1, #48]
	handle_decref(handle);
ffffffffea80b090:	97fffc6a 	bl	ffffffffea80a238 <handle_decref>
	return NO_ERROR;
ffffffffea80b094:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80b098:	17fffff3 	b	ffffffffea80b064 <sys_set_cookie+0x6c>
	ASSERT(slot < als_slot_cnt);
ffffffffea80b09c:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b0a0:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b0a4:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b0a8:	9135c084 	add	x4, x4, #0xd70
ffffffffea80b0ac:	52800c83 	mov	w3, #0x64                  	// #100
ffffffffea80b0b0:	91362042 	add	x2, x2, #0xd88
ffffffffea80b0b4:	91314021 	add	x1, x1, #0xc50
ffffffffea80b0b8:	aa1e03e0 	mov	x0, x30
ffffffffea80b0bc:	94001d31 	bl	ffffffffea812580 <_panic>
}
ffffffffea80b0c0:	9400231a 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80b0c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b0c8 <port_poll>:
	}
	return NULL;
}

static uint32_t port_poll(handle_t *phandle)
{
ffffffffea80b0c8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b0cc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b0d0:	910003fd 	mov	x29, sp
ffffffffea80b0d4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b0d8:	aa0003f3 	mov	x19, x0
ffffffffea80b0dc:	d0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80b0e0:	9137c280 	add	x0, x20, #0xdf0
ffffffffea80b0e4:	97ffe9e9 	bl	ffffffffea805888 <mutex_acquire_timeout>

	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
	uint32_t events = 0;

	mutex_acquire(&ipc_lock);
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b0e8:	b85e8260 	ldur	w0, [x19, #-24]
ffffffffea80b0ec:	7100041f 	cmp	w0, #0x1
ffffffffea80b0f0:	54000161 	b.ne	ffffffffea80b11c <port_poll+0x54>  // b.any
		events |= IPC_HANDLE_POLL_ERROR;
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80b0f4:	f9402660 	ldr	x0, [x19, #72]
ffffffffea80b0f8:	91010273 	add	x19, x19, #0x40
ffffffffea80b0fc:	eb13001f 	cmp	x0, x19
		events |= IPC_HANDLE_POLL_READY;
	} else {
		/* All if-else chains must end with an else clause */
	}
	LTRACEF("%s in state %d events %x\n", port->path, port->state, events);
	mutex_release(&ipc_lock);
ffffffffea80b100:	9137c280 	add	x0, x20, #0xdf0
	} else if (!list_is_empty(&port->pending_list)) {
ffffffffea80b104:	1a9f07f3 	cset	w19, ne  // ne = any
	mutex_release(&ipc_lock);
ffffffffea80b108:	97ffea0c 	bl	ffffffffea805938 <mutex_release>

	return events;
}
ffffffffea80b10c:	2a1303e0 	mov	w0, w19
ffffffffea80b110:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b114:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80b118:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80b11c:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80b120:	9137c280 	add	x0, x20, #0xdf0
ffffffffea80b124:	97ffea05 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80b128:	2a1303e0 	mov	w0, w19
ffffffffea80b12c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b130:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80b134:	d65f03c0 	ret

ffffffffea80b138 <chan_poll>:

/*
 *  Poll channel state
 */
static uint32_t chan_poll(handle_t *chandle)
{
ffffffffea80b138:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b13c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b140:	910003fd 	mov	x29, sp
ffffffffea80b144:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b148:	aa0003f4 	mov	x20, x0
ffffffffea80b14c:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b150:	d0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80b154:	9137c2a0 	add	x0, x21, #0xdf0
ffffffffea80b158:	97ffe9cc 	bl	ffffffffea805888 <mutex_acquire_timeout>

	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);

	uint32_t events = 0;

	if (chan->state == IPC_CHAN_STATE_INVALID) {
ffffffffea80b15c:	b85e0293 	ldur	w19, [x20, #-32]
ffffffffea80b160:	340002f3 	cbz	w19, ffffffffea80b1bc <chan_poll+0x84>
	if (chan->state == IPC_CHAN_STATE_DISCONNECTING) {
		events |= IPC_HANDLE_POLL_HUP;
	}

	/* server accepted our connection */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_CONNECTED) {
ffffffffea80b164:	b85e8281 	ldur	w1, [x20, #-24]
	uint32_t events = 0;
ffffffffea80b168:	7100127f 	cmp	w19, #0x4
		events |= IPC_HANDLE_POLL_READY;
	}

	/* have a pending message? */
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80b16c:	f9403280 	ldr	x0, [x20, #96]
	uint32_t events = 0;
ffffffffea80b170:	1a9f0273 	csel	w19, w19, wzr, eq  // eq = none
		events |= IPC_HANDLE_POLL_READY;
ffffffffea80b174:	32000262 	orr	w2, w19, #0x1
ffffffffea80b178:	f27e003f 	tst	x1, #0x4
ffffffffea80b17c:	1a931053 	csel	w19, w2, w19, ne  // ne = any
	if (chan->msg_queue && !ipc_msg_queue_is_empty(chan->msg_queue)) {
ffffffffea80b180:	b40000a0 	cbz	x0, ffffffffea80b194 <chan_poll+0x5c>
ffffffffea80b184:	94000735 	bl	ffffffffea80ce58 <ipc_msg_queue_is_empty>
ffffffffea80b188:	72001c1f 	tst	w0, #0xff
ffffffffea80b18c:	b85e8281 	ldur	w1, [x20, #-24]
ffffffffea80b190:	54000260 	b.eq	ffffffffea80b1dc <chan_poll+0xa4>  // b.none
		events |= IPC_HANDLE_POLL_MSG;
	}

	/* check if we were send blocked */
	if (chan->aux_state & IPC_CHAN_AUX_STATE_SEND_UNBLOCKED) {
		events |= IPC_HANDLE_POLL_SEND_UNBLOCKED;
ffffffffea80b194:	f27f003f 	tst	x1, #0x2
ffffffffea80b198:	321c0260 	orr	w0, w19, #0x10
ffffffffea80b19c:	1a931013 	csel	w19, w0, w19, ne  // ne = any
	}

done:
	mutex_release(&ipc_lock);
ffffffffea80b1a0:	9137c2a0 	add	x0, x21, #0xdf0
ffffffffea80b1a4:	97ffe9e5 	bl	ffffffffea805938 <mutex_release>
	return events;
}
ffffffffea80b1a8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b1ac:	2a1303e0 	mov	w0, w19
ffffffffea80b1b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b1b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b1b8:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_ERROR;
ffffffffea80b1bc:	52800053 	mov	w19, #0x2                   	// #2
	mutex_release(&ipc_lock);
ffffffffea80b1c0:	9137c2a0 	add	x0, x21, #0xdf0
ffffffffea80b1c4:	97ffe9dd 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80b1c8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b1cc:	2a1303e0 	mov	w0, w19
ffffffffea80b1d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b1d4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b1d8:	d65f03c0 	ret
		events |= IPC_HANDLE_POLL_MSG;
ffffffffea80b1dc:	321d0273 	orr	w19, w19, #0x8
ffffffffea80b1e0:	17ffffed 	b	ffffffffea80b194 <chan_poll+0x5c>
ffffffffea80b1e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b1e8 <chan_alloc>:
{
ffffffffea80b1e8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b1ec:	910003fd 	mov	x29, sp
ffffffffea80b1f0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b1f4:	2a0003f4 	mov	w20, w0
ffffffffea80b1f8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b1fc:	aa0203f3 	mov	x19, x2
ffffffffea80b200:	aa0103f5 	mov	x21, x1
	chan = calloc(1, sizeof(ipc_chan_t));
ffffffffea80b204:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80b208:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80b20c:	940022dd 	bl	ffffffffea813d80 <calloc>
	if (!chan) {
ffffffffea80b210:	b4000100 	cbz	x0, ffffffffea80b230 <chan_alloc+0x48>
	list->prev->next = item;
ffffffffea80b214:	a9004c13 	stp	x19, x19, [x0]
}

static inline __ALWAYS_INLINE
void obj_ref_init(obj_ref_t *ref)
{
	*ref = (obj_ref_t)OBJ_REF_INITIAL_VALUE(*ref);
ffffffffea80b218:	a9017c1f 	stp	xzr, xzr, [x0, #16]
	chan->uuid  = uuid;
ffffffffea80b21c:	f9001415 	str	x21, [x0, #40]
	chan->flags = flags;
ffffffffea80b220:	2906501f 	stp	wzr, w20, [x0, #48]
ffffffffea80b224:	a9047c1f 	stp	xzr, xzr, [x0, #64]
ffffffffea80b228:	a9097c1f 	stp	xzr, xzr, [x0, #144]
	item->next = list;
ffffffffea80b22c:	a9000260 	stp	x0, x0, [x19]
}
ffffffffea80b230:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b234:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b238:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b23c:	d65f03c0 	ret

ffffffffea80b240 <port_find_locked>:
{
ffffffffea80b240:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b244:	910003fd 	mov	x29, sp
ffffffffea80b248:	a90153f3 	stp	x19, x20, [sp, #16]
	list_for_every_entry(&ipc_port_list, port, ipc_port_t, node) {
ffffffffea80b24c:	d0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80b250:	91392294 	add	x20, x20, #0xe48
ffffffffea80b254:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80b258:	eb01029f 	cmp	x20, x1
ffffffffea80b25c:	54000300 	b.eq	ffffffffea80b2bc <port_find_locked+0x7c>  // b.none
ffffffffea80b260:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b264:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80b268:	aa0003f5 	mov	x21, x0
ffffffffea80b26c:	14000005 	b	ffffffffea80b280 <port_find_locked+0x40>
ffffffffea80b270:	f9405e61 	ldr	x1, [x19, #184]
ffffffffea80b274:	d102c033 	sub	x19, x1, #0xb0
ffffffffea80b278:	eb01029f 	cmp	x20, x1
ffffffffea80b27c:	54000140 	b.eq	ffffffffea80b2a4 <port_find_locked+0x64>  // b.none
		if (!strcmp(path, port->path)) {
ffffffffea80b280:	aa1303e1 	mov	x1, x19
ffffffffea80b284:	aa1503e0 	mov	x0, x21
ffffffffea80b288:	940023ac 	bl	ffffffffea814138 <strcmp>
ffffffffea80b28c:	35ffff20 	cbnz	w0, ffffffffea80b270 <port_find_locked+0x30>
ffffffffea80b290:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80b294:	aa1303e0 	mov	x0, x19
ffffffffea80b298:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b29c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b2a0:	d65f03c0 	ret
	return NULL;
ffffffffea80b2a4:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80b2a8:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80b2ac:	aa1303e0 	mov	x0, x19
ffffffffea80b2b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b2b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b2b8:	d65f03c0 	ret
	return NULL;
ffffffffea80b2bc:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80b2c0:	17fffff5 	b	ffffffffea80b294 <port_find_locked+0x54>
ffffffffea80b2c4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b2c8 <chan_finalize_event>:
static void chan_finalize_event(handle_t *chandle, uint32_t event)
{
	DEBUG_ASSERT(chandle);
	DEBUG_ASSERT(ipc_is_channel(chandle));

	if (event & (IPC_HANDLE_POLL_SEND_UNBLOCKED | IPC_HANDLE_POLL_READY)) {
ffffffffea80b2c8:	52800222 	mov	w2, #0x11                  	// #17
ffffffffea80b2cc:	6a02003f 	tst	w1, w2
ffffffffea80b2d0:	54000041 	b.ne	ffffffffea80b2d8 <chan_finalize_event+0x10>  // b.any
ffffffffea80b2d4:	d65f03c0 	ret
{
ffffffffea80b2d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b2dc:	910003fd 	mov	x29, sp
ffffffffea80b2e0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b2e4:	2a0103f3 	mov	w19, w1
ffffffffea80b2e8:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b2ec:	aa0003f4 	mov	x20, x0
ffffffffea80b2f0:	d0000075 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea80b2f4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b2f8:	9137c2a0 	add	x0, x21, #0xdf0
ffffffffea80b2fc:	97ffe963 	bl	ffffffffea805888 <mutex_acquire_timeout>
		mutex_acquire(&ipc_lock);
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		if (event & IPC_HANDLE_POLL_SEND_UNBLOCKED) {
ffffffffea80b300:	36200093 	tbz	w19, #4, ffffffffea80b310 <chan_finalize_event+0x48>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80b304:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80b308:	121e7800 	and	w0, w0, #0xfffffffd
ffffffffea80b30c:	b81e8280 	stur	w0, [x20, #-24]
		}
		if (event & IPC_HANDLE_POLL_READY) {
ffffffffea80b310:	36000093 	tbz	w19, #0, ffffffffea80b320 <chan_finalize_event+0x58>
			chan->aux_state &= ~IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80b314:	b85e8280 	ldur	w0, [x20, #-24]
ffffffffea80b318:	121d7800 	and	w0, w0, #0xfffffffb
ffffffffea80b31c:	b81e8280 	stur	w0, [x20, #-24]
		}
		mutex_release(&ipc_lock);
ffffffffea80b320:	9137c2a0 	add	x0, x21, #0xdf0
	}
}
ffffffffea80b324:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b328:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b32c:	a8c37bfd 	ldp	x29, x30, [sp], #48
		mutex_release(&ipc_lock);
ffffffffea80b330:	17ffe982 	b	ffffffffea805938 <mutex_release>
ffffffffea80b334:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b338 <port_handle_destroy>:
{
ffffffffea80b338:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80b33c:	910003fd 	mov	x29, sp
	ASSERT(phandle);
ffffffffea80b340:	b4000120 	cbz	x0, ffffffffea80b364 <port_handle_destroy+0x2c>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b344:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80b348:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80b34c:	9138a021 	add	x1, x1, #0xe28
ffffffffea80b350:	eb01005f 	cmp	x2, x1
ffffffffea80b354:	540001a1 	b.ne	ffffffffea80b388 <port_handle_destroy+0x50>  // b.any
}
ffffffffea80b358:	a8c17bfd 	ldp	x29, x30, [sp], #16
	free(port);
ffffffffea80b35c:	d1018000 	sub	x0, x0, #0x60
ffffffffea80b360:	14002298 	b	ffffffffea813dc0 <free>
	ASSERT(phandle);
ffffffffea80b364:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b368:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b36c:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b370:	913c0084 	add	x4, x4, #0xf00
ffffffffea80b374:	52801b83 	mov	w3, #0xdc                  	// #220
ffffffffea80b378:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b37c:	91314021 	add	x1, x1, #0xc50
ffffffffea80b380:	aa1e03e0 	mov	x0, x30
ffffffffea80b384:	94001c7f 	bl	ffffffffea812580 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b388:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b38c:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b390:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b394:	913ca084 	add	x4, x4, #0xf28
ffffffffea80b398:	52801ba3 	mov	w3, #0xdd                  	// #221
ffffffffea80b39c:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b3a0:	91314021 	add	x1, x1, #0xc50
ffffffffea80b3a4:	aa1e03e0 	mov	x0, x30
ffffffffea80b3a8:	94001c76 	bl	ffffffffea812580 <_panic>
ffffffffea80b3ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b3b0 <chan_handle_destroy>:
{
ffffffffea80b3b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b3b4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b3b8:	910003fd 	mov	x29, sp
ffffffffea80b3bc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b3c0:	aa0003f3 	mov	x19, x0
ffffffffea80b3c4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80b3c8:	d0000074 	adrp	x20, ffffffffea819000 <_mem_phys_base>
ffffffffea80b3cc:	aa1e03f6 	mov	x22, x30
ffffffffea80b3d0:	9137c280 	add	x0, x20, #0xdf0
ffffffffea80b3d4:	97ffe92d 	bl	ffffffffea805888 <mutex_acquire_timeout>
	ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80b3d8:	d1014275 	sub	x21, x19, #0x50
	item->next->prev = item->prev;
ffffffffea80b3dc:	a97f0261 	ldp	x1, x0, [x19, #-16]
ffffffffea80b3e0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b3e4:	f85f0261 	ldur	x1, [x19, #-16]
ffffffffea80b3e8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b3ec:	a93f7e7f 	stp	xzr, xzr, [x19, #-16]
	assert(list_in_list(&ref->ref_node));
	assert(destroy);

	list_delete(&ref->ref_node);
	dead = list_is_empty(&obj->ref_list);
	if (dead)
ffffffffea80b3f0:	f85b8260 	ldur	x0, [x19, #-72]
ffffffffea80b3f4:	eb0002bf 	cmp	x21, x0
ffffffffea80b3f8:	540000c0 	b.eq	ffffffffea80b410 <chan_handle_destroy+0x60>  // b.none
	mutex_release(&ipc_lock);
ffffffffea80b3fc:	9137c280 	add	x0, x20, #0xdf0
}
ffffffffea80b400:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b404:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80b408:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80b40c:	17ffe94b 	b	ffffffffea805938 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b410:	f85d0260 	ldur	x0, [x19, #-48]
ffffffffea80b414:	b5000380 	cbnz	x0, ffffffffea80b484 <chan_handle_destroy+0xd4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b418:	f94052a0 	ldr	x0, [x21, #160]
ffffffffea80b41c:	b4000140 	cbz	x0, ffffffffea80b444 <chan_handle_destroy+0x94>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b420:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b424:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b428:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b42c:	913aa084 	add	x4, x4, #0xea8
ffffffffea80b430:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b434:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b438:	91314021 	add	x1, x1, #0xc50
ffffffffea80b43c:	aa1603e0 	mov	x0, x22
ffffffffea80b440:	94001c50 	bl	ffffffffea812580 <_panic>
ffffffffea80b444:	f94056a0 	ldr	x0, [x21, #168]
ffffffffea80b448:	b5fffec0 	cbnz	x0, ffffffffea80b420 <chan_handle_destroy+0x70>
	if (chan->path) {
ffffffffea80b44c:	f9405ea0 	ldr	x0, [x21, #184]
ffffffffea80b450:	b4000040 	cbz	x0, ffffffffea80b458 <chan_handle_destroy+0xa8>
		free((void *)chan->path);
ffffffffea80b454:	9400225b 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80b458:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80b45c:	b4000060 	cbz	x0, ffffffffea80b468 <chan_handle_destroy+0xb8>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b460:	94000674 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b464:	f9005abf 	str	xzr, [x21, #176]
	free(chan);
ffffffffea80b468:	aa1503e0 	mov	x0, x21
ffffffffea80b46c:	94002255 	bl	ffffffffea813dc0 <free>
	mutex_release(&ipc_lock);
ffffffffea80b470:	9137c280 	add	x0, x20, #0xdf0
}
ffffffffea80b474:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b478:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80b47c:	a8c37bfd 	ldp	x29, x30, [sp], #48
	mutex_release(&ipc_lock);
ffffffffea80b480:	17ffe92e 	b	ffffffffea805938 <mutex_release>
	ASSERT(chan->peer == NULL);
ffffffffea80b484:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b488:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b48c:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b490:	913a4084 	add	x4, x4, #0xe90
ffffffffea80b494:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b498:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b49c:	91314021 	add	x1, x1, #0xc50
ffffffffea80b4a0:	aa1603e0 	mov	x0, x22
ffffffffea80b4a4:	94001c37 	bl	ffffffffea812580 <_panic>

ffffffffea80b4a8 <_chan_shutdown_locked>:
	switch (chan->state) {
ffffffffea80b4a8:	b9403001 	ldr	w1, [x0, #48]
ffffffffea80b4ac:	71000c3f 	cmp	w1, #0x3
ffffffffea80b4b0:	54000188 	b.hi	ffffffffea80b4e0 <_chan_shutdown_locked+0x38>  // b.pmore
ffffffffea80b4b4:	7100083f 	cmp	w1, #0x2
ffffffffea80b4b8:	540000c2 	b.cs	ffffffffea80b4d0 <_chan_shutdown_locked+0x28>  // b.hs, b.nlast
ffffffffea80b4bc:	7100043f 	cmp	w1, #0x1
ffffffffea80b4c0:	54000581 	b.ne	ffffffffea80b570 <_chan_shutdown_locked+0xc8>  // b.any
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b4c4:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b4c8:	b9003001 	str	w1, [x0, #48]
ffffffffea80b4cc:	d65f03c0 	ret
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b4d0:	52800081 	mov	w1, #0x4                   	// #4
ffffffffea80b4d4:	b9003001 	str	w1, [x0, #48]
		handle_notify(&chan->handle);
ffffffffea80b4d8:	91014000 	add	x0, x0, #0x50
ffffffffea80b4dc:	17fffbd3 	b	ffffffffea80a428 <handle_notify>
	switch (chan->state) {
ffffffffea80b4e0:	7100143f 	cmp	w1, #0x5
ffffffffea80b4e4:	54000481 	b.ne	ffffffffea80b574 <_chan_shutdown_locked+0xcc>  // b.any
{
ffffffffea80b4e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b4ec:	910003fd 	mov	x29, sp
ffffffffea80b4f0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b4f4:	aa0003f3 	mov	x19, x0
ffffffffea80b4f8:	a94a0001 	ldp	x1, x0, [x0, #160]
ffffffffea80b4fc:	b4000261 	cbz	x1, ffffffffea80b548 <_chan_shutdown_locked+0xa0>
	item->next->prev = item->prev;
ffffffffea80b500:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b504:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b508:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b50c:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b510:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b514:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b518:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b51c:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b520:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b524:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b528:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b52c:	eb00027f 	cmp	x19, x0
ffffffffea80b530:	54000240 	b.eq	ffffffffea80b578 <_chan_shutdown_locked+0xd0>  // b.none
		chan->state = IPC_CHAN_STATE_DISCONNECTING;
ffffffffea80b534:	52800080 	mov	w0, #0x4                   	// #4
ffffffffea80b538:	b9003260 	str	w0, [x19, #48]
}
ffffffffea80b53c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b540:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80b544:	d65f03c0 	ret
	if (item->prev == 0 && item->next == 0)
ffffffffea80b548:	b5fffdc0 	cbnz	x0, ffffffffea80b500 <_chan_shutdown_locked+0x58>
		ASSERT(list_in_list(&chan->node));
ffffffffea80b54c:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b550:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b554:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b558:	9139c084 	add	x4, x4, #0xe70
ffffffffea80b55c:	52803b43 	mov	w3, #0x1da                 	// #474
ffffffffea80b560:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b564:	91314021 	add	x1, x1, #0xc50
ffffffffea80b568:	aa1e03e0 	mov	x0, x30
ffffffffea80b56c:	94001c05 	bl	ffffffffea812580 <_panic>
ffffffffea80b570:	d65f03c0 	ret
ffffffffea80b574:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b578:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b57c:	b5000300 	cbnz	x0, ffffffffea80b5dc <_chan_shutdown_locked+0x134>
ffffffffea80b580:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b584:	b4000140 	cbz	x0, ffffffffea80b5ac <_chan_shutdown_locked+0x104>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b588:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b58c:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b590:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b594:	913aa084 	add	x4, x4, #0xea8
ffffffffea80b598:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b59c:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b5a0:	91314021 	add	x1, x1, #0xc50
ffffffffea80b5a4:	aa1e03e0 	mov	x0, x30
ffffffffea80b5a8:	94001bf6 	bl	ffffffffea812580 <_panic>
ffffffffea80b5ac:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b5b0:	b5fffec0 	cbnz	x0, ffffffffea80b588 <_chan_shutdown_locked+0xe0>
	if (chan->path) {
ffffffffea80b5b4:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b5b8:	b4000040 	cbz	x0, ffffffffea80b5c0 <_chan_shutdown_locked+0x118>
		free((void *)chan->path);
ffffffffea80b5bc:	94002201 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80b5c0:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b5c4:	b4000060 	cbz	x0, ffffffffea80b5d0 <_chan_shutdown_locked+0x128>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b5c8:	9400061a 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b5cc:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b5d0:	aa1303e0 	mov	x0, x19
ffffffffea80b5d4:	940021fb 	bl	ffffffffea813dc0 <free>
ffffffffea80b5d8:	17ffffd7 	b	ffffffffea80b534 <_chan_shutdown_locked+0x8c>
	ASSERT(chan->peer == NULL);
ffffffffea80b5dc:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b5e0:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b5e4:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b5e8:	913a4084 	add	x4, x4, #0xe90
ffffffffea80b5ec:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b5f0:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b5f4:	91314021 	add	x1, x1, #0xc50
ffffffffea80b5f8:	aa1e03e0 	mov	x0, x30
ffffffffea80b5fc:	94001be1 	bl	ffffffffea812580 <_panic>

ffffffffea80b600 <chan_shutdown_locked>:
{
ffffffffea80b600:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80b604:	910003fd 	mov	x29, sp
ffffffffea80b608:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80b60c:	aa0003f3 	mov	x19, x0
ffffffffea80b610:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b614:	aa1e03f5 	mov	x21, x30
	_chan_shutdown_locked(chan);
ffffffffea80b618:	97ffffa4 	bl	ffffffffea80b4a8 <_chan_shutdown_locked>
	if (chan->peer) {
ffffffffea80b61c:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b620:	b40001c0 	cbz	x0, ffffffffea80b658 <chan_shutdown_locked+0x58>
ffffffffea80b624:	f9000fb4 	str	x20, [x29, #24]
		_chan_shutdown_locked(chan->peer);
ffffffffea80b628:	97ffffa0 	bl	ffffffffea80b4a8 <_chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b62c:	a9410261 	ldp	x1, x0, [x19, #16]
		chan_del_ref(chan->peer, &chan->peer_ref);
ffffffffea80b630:	f9401274 	ldr	x20, [x19, #32]
ffffffffea80b634:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b638:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea80b63c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b640:	a9017e7f 	stp	xzr, xzr, [x19, #16]
ffffffffea80b644:	f9400680 	ldr	x0, [x20, #8]
ffffffffea80b648:	eb00029f 	cmp	x20, x0
ffffffffea80b64c:	540000e0 	b.eq	ffffffffea80b668 <chan_shutdown_locked+0x68>  // b.none
		chan->peer = NULL;
ffffffffea80b650:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80b654:	f900127f 	str	xzr, [x19, #32]
}
ffffffffea80b658:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80b65c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80b660:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80b664:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80b668:	f9401280 	ldr	x0, [x20, #32]
ffffffffea80b66c:	b5000300 	cbnz	x0, ffffffffea80b6cc <chan_shutdown_locked+0xcc>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b670:	f9405280 	ldr	x0, [x20, #160]
ffffffffea80b674:	b4000140 	cbz	x0, ffffffffea80b69c <chan_shutdown_locked+0x9c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b678:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b67c:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b680:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b684:	913aa084 	add	x4, x4, #0xea8
ffffffffea80b688:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b68c:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b690:	91314021 	add	x1, x1, #0xc50
ffffffffea80b694:	aa1503e0 	mov	x0, x21
ffffffffea80b698:	94001bba 	bl	ffffffffea812580 <_panic>
ffffffffea80b69c:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b6a0:	b5fffec0 	cbnz	x0, ffffffffea80b678 <chan_shutdown_locked+0x78>
	if (chan->path) {
ffffffffea80b6a4:	f9405e80 	ldr	x0, [x20, #184]
ffffffffea80b6a8:	b4000040 	cbz	x0, ffffffffea80b6b0 <chan_shutdown_locked+0xb0>
		free((void *)chan->path);
ffffffffea80b6ac:	940021c5 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80b6b0:	f9405a80 	ldr	x0, [x20, #176]
ffffffffea80b6b4:	b4000060 	cbz	x0, ffffffffea80b6c0 <chan_shutdown_locked+0xc0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b6b8:	940005de 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b6bc:	f9005a9f 	str	xzr, [x20, #176]
	free(chan);
ffffffffea80b6c0:	aa1403e0 	mov	x0, x20
ffffffffea80b6c4:	940021bf 	bl	ffffffffea813dc0 <free>
ffffffffea80b6c8:	17ffffe2 	b	ffffffffea80b650 <chan_shutdown_locked+0x50>
	ASSERT(chan->peer == NULL);
ffffffffea80b6cc:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b6d0:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b6d4:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b6d8:	913a4084 	add	x4, x4, #0xe90
ffffffffea80b6dc:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b6e0:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b6e4:	91314021 	add	x1, x1, #0xc50
ffffffffea80b6e8:	aa1503e0 	mov	x0, x21
ffffffffea80b6ec:	94001ba5 	bl	ffffffffea812580 <_panic>

ffffffffea80b6f0 <chan_shutdown>:
{
ffffffffea80b6f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80b6f4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b6f8:	910003fd 	mov	x29, sp
ffffffffea80b6fc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b700:	d0000073 	adrp	x19, ffffffffea819000 <_mem_phys_base>
ffffffffea80b704:	9137c273 	add	x19, x19, #0xdf0
ffffffffea80b708:	aa0003f4 	mov	x20, x0
ffffffffea80b70c:	aa1303e0 	mov	x0, x19
ffffffffea80b710:	97ffe85e 	bl	ffffffffea805888 <mutex_acquire_timeout>
	chan_shutdown_locked(chan);
ffffffffea80b714:	d1014280 	sub	x0, x20, #0x50
ffffffffea80b718:	97ffffba 	bl	ffffffffea80b600 <chan_shutdown_locked>
	mutex_release(&ipc_lock);
ffffffffea80b71c:	aa1303e0 	mov	x0, x19
}
ffffffffea80b720:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80b724:	a8c27bfd 	ldp	x29, x30, [sp], #32
	mutex_release(&ipc_lock);
ffffffffea80b728:	17ffe884 	b	ffffffffea805938 <mutex_release>
ffffffffea80b72c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80b730 <port_shutdown>:
{
ffffffffea80b730:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80b734:	910003fd 	mov	x29, sp
ffffffffea80b738:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80b73c:	aa1e03f8 	mov	x24, x30
	ASSERT(phandle);
ffffffffea80b740:	b4000b80 	cbz	x0, ffffffffea80b8b0 <port_shutdown+0x180>
ffffffffea80b744:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b748:	aa0003f6 	mov	x22, x0
	ASSERT(ipc_is_port(phandle));
ffffffffea80b74c:	d0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80b750:	9138a000 	add	x0, x0, #0xe28
ffffffffea80b754:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea80b758:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b75c:	f90013b5 	str	x21, [x29, #32]
ffffffffea80b760:	eb00003f 	cmp	x1, x0
ffffffffea80b764:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b768:	54000bc1 	b.ne	ffffffffea80b8e0 <port_shutdown+0x1b0>  // b.any
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80b76c:	d10182d5 	sub	x21, x22, #0x60
ffffffffea80b770:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80b774:	d0000077 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea80b778:	9137c2e0 	add	x0, x23, #0xdf0
ffffffffea80b77c:	97ffe843 	bl	ffffffffea805888 <mutex_acquire_timeout>
ffffffffea80b780:	f9405aa0 	ldr	x0, [x21, #176]
	port->state = IPC_PORT_STATE_CLOSING;
ffffffffea80b784:	52800041 	mov	w1, #0x2                   	// #2
ffffffffea80b788:	b81e82c1 	stur	w1, [x22, #-24]
ffffffffea80b78c:	f9405ea1 	ldr	x1, [x21, #184]
ffffffffea80b790:	b4000740 	cbz	x0, ffffffffea80b878 <port_shutdown+0x148>
	item->next->prev = item->prev;
ffffffffea80b794:	f9000020 	str	x0, [x1]
		handle_decref(phandle);
ffffffffea80b798:	aa1603e0 	mov	x0, x22
	item->prev->next = item->next;
ffffffffea80b79c:	f9405aa2 	ldr	x2, [x21, #176]
ffffffffea80b7a0:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b7a4:	a90b7ebf 	stp	xzr, xzr, [x21, #176]
ffffffffea80b7a8:	97fffaa4 	bl	ffffffffea80a238 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b7ac:	f94056b3 	ldr	x19, [x21, #168]
ffffffffea80b7b0:	d1028273 	sub	x19, x19, #0xa0
ffffffffea80b7b4:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b7b8:	eb1302bf 	cmp	x21, x19
ffffffffea80b7bc:	d1028014 	sub	x20, x0, #0xa0
ffffffffea80b7c0:	54000141 	b.ne	ffffffffea80b7e8 <port_shutdown+0xb8>  // b.any
ffffffffea80b7c4:	14000026 	b	ffffffffea80b85c <port_shutdown+0x12c>
		handle_decref(phandle);
ffffffffea80b7c8:	aa1603e0 	mov	x0, x22
ffffffffea80b7cc:	97fffa9b 	bl	ffffffffea80a238 <handle_decref>
	list_for_every_entry_safe(&port->pending_list, server, temp, ipc_chan_t, node) {
ffffffffea80b7d0:	f9405680 	ldr	x0, [x20, #168]
ffffffffea80b7d4:	aa1403f3 	mov	x19, x20
ffffffffea80b7d8:	eb15029f 	cmp	x20, x21
ffffffffea80b7dc:	d1028000 	sub	x0, x0, #0xa0
ffffffffea80b7e0:	540003e0 	b.eq	ffffffffea80b85c <port_shutdown+0x12c>  // b.none
ffffffffea80b7e4:	aa0003f4 	mov	x20, x0
		chan_shutdown_locked(server);
ffffffffea80b7e8:	aa1303e0 	mov	x0, x19
ffffffffea80b7ec:	97ffff85 	bl	ffffffffea80b600 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80b7f0:	a94a0261 	ldp	x1, x0, [x19, #160]
ffffffffea80b7f4:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b7f8:	f9405262 	ldr	x2, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b7fc:	f9404a61 	ldr	x1, [x19, #144]
	item->prev->next = item->next;
ffffffffea80b800:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80b804:	a90a7e7f 	stp	xzr, xzr, [x19, #160]
	item->next->prev = item->prev;
ffffffffea80b808:	f9404e60 	ldr	x0, [x19, #152]
ffffffffea80b80c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b810:	f9404a61 	ldr	x1, [x19, #144]
ffffffffea80b814:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b818:	a9097e7f 	stp	xzr, xzr, [x19, #144]
ffffffffea80b81c:	f9400660 	ldr	x0, [x19, #8]
ffffffffea80b820:	eb00027f 	cmp	x19, x0
ffffffffea80b824:	54fffd21 	b.ne	ffffffffea80b7c8 <port_shutdown+0x98>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80b828:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80b82c:	b50006c0 	cbnz	x0, ffffffffea80b904 <port_shutdown+0x1d4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80b830:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80b834:	b4000260 	cbz	x0, ffffffffea80b880 <port_shutdown+0x150>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80b838:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b83c:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b840:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b844:	913aa084 	add	x4, x4, #0xea8
ffffffffea80b848:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80b84c:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b850:	91314021 	add	x1, x1, #0xc50
ffffffffea80b854:	aa1803e0 	mov	x0, x24
ffffffffea80b858:	94001b4a 	bl	ffffffffea812580 <_panic>
	mutex_release(&ipc_lock);
ffffffffea80b85c:	9137c2e0 	add	x0, x23, #0xdf0
}
ffffffffea80b860:	f9401ff8 	ldr	x24, [sp, #56]
	mutex_release(&ipc_lock);
ffffffffea80b864:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80b868:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80b86c:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80b870:	a8c47bfd 	ldp	x29, x30, [sp], #64
	mutex_release(&ipc_lock);
ffffffffea80b874:	17ffe831 	b	ffffffffea805938 <mutex_release>
ffffffffea80b878:	b5fff8e1 	cbnz	x1, ffffffffea80b794 <port_shutdown+0x64>
ffffffffea80b87c:	17ffffcc 	b	ffffffffea80b7ac <port_shutdown+0x7c>
ffffffffea80b880:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80b884:	b5fffda0 	cbnz	x0, ffffffffea80b838 <port_shutdown+0x108>
	if (chan->path) {
ffffffffea80b888:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80b88c:	b4000040 	cbz	x0, ffffffffea80b894 <port_shutdown+0x164>
		free((void *)chan->path);
ffffffffea80b890:	9400214c 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80b894:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80b898:	b4000060 	cbz	x0, ffffffffea80b8a4 <port_shutdown+0x174>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80b89c:	94000565 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80b8a0:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80b8a4:	aa1303e0 	mov	x0, x19
ffffffffea80b8a8:	94002146 	bl	ffffffffea813dc0 <free>
ffffffffea80b8ac:	17ffffc7 	b	ffffffffea80b7c8 <port_shutdown+0x98>
	ASSERT(phandle);
ffffffffea80b8b0:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b8b4:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b8b8:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b8bc:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80b8c0:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80b8c4:	913c0084 	add	x4, x4, #0xf00
ffffffffea80b8c8:	528015a3 	mov	w3, #0xad                  	// #173
ffffffffea80b8cc:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b8d0:	91314021 	add	x1, x1, #0xc50
ffffffffea80b8d4:	aa1e03e0 	mov	x0, x30
ffffffffea80b8d8:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80b8dc:	94001b29 	bl	ffffffffea812580 <_panic>
	ASSERT(ipc_is_port(phandle));
ffffffffea80b8e0:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b8e4:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b8e8:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b8ec:	913ca084 	add	x4, x4, #0xf28
ffffffffea80b8f0:	528015c3 	mov	w3, #0xae                  	// #174
ffffffffea80b8f4:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b8f8:	91314021 	add	x1, x1, #0xc50
ffffffffea80b8fc:	aa1e03e0 	mov	x0, x30
ffffffffea80b900:	94001b20 	bl	ffffffffea812580 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80b904:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b908:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80b90c:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80b910:	913a4084 	add	x4, x4, #0xe90
ffffffffea80b914:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80b918:	913c2042 	add	x2, x2, #0xf08
ffffffffea80b91c:	91314021 	add	x1, x1, #0xc50
ffffffffea80b920:	aa1803e0 	mov	x0, x24
ffffffffea80b924:	94001b17 	bl	ffffffffea812580 <_panic>

ffffffffea80b928 <port_attach_client>:

	return ERR_ACCESS_DENIED;
}

static int port_attach_client(ipc_port_t *port, ipc_chan_t *client)
{
ffffffffea80b928:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80b92c:	910003fd 	mov	x29, sp
ffffffffea80b930:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80b934:	f00002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80b938:	aa0003f4 	mov	x20, x0
	int ret;
	ipc_chan_t *server;
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);

	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b93c:	b9404800 	ldr	w0, [x0, #72]
{
ffffffffea80b940:	f9402a62 	ldr	x2, [x19, #80]
ffffffffea80b944:	f90013f5 	str	x21, [sp, #32]
ffffffffea80b948:	aa0103f5 	mov	x21, x1
ffffffffea80b94c:	f9400041 	ldr	x1, [x2]
ffffffffea80b950:	f90037a1 	str	x1, [x29, #104]
ffffffffea80b954:	d2800001 	mov	x1, #0x0                   	// #0
	obj_ref_t   tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80b958:	a905ffbf 	stp	xzr, xzr, [x29, #88]
{
ffffffffea80b95c:	f9001bf7 	str	x23, [sp, #48]
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80b960:	7100041f 	cmp	w0, #0x1
ffffffffea80b964:	54000ca1 	b.ne	ffffffffea80baf8 <port_attach_client+0x1d0>  // b.any
			 port->path, port->state);
		return ERR_NOT_READY;
	}

	/* check if we are allowed to connect */
	ret = check_access(port, client->uuid);
ffffffffea80b968:	f94016a0 	ldr	x0, [x21, #40]
	if (!uuid) {
ffffffffea80b96c:	b4000580 	cbz	x0, ffffffffea80ba1c <port_attach_client+0xf4>
ffffffffea80b970:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80b974:	aa1e03f8 	mov	x24, x30
	if (is_ns_client(uuid)) {
ffffffffea80b978:	940014a0 	bl	ffffffffea810bf8 <is_ns_client>
ffffffffea80b97c:	72001c1f 	tst	w0, #0xff
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80b980:	b9404e80 	ldr	w0, [x20, #76]
	if (is_ns_client(uuid)) {
ffffffffea80b984:	54000481 	b.ne	ffffffffea80ba14 <port_attach_client+0xec>  // b.any
		if (port->flags & IPC_PORT_ALLOW_TA_CONNECT) {
ffffffffea80b988:	36000480 	tbz	w0, #0, ffffffffea80ba18 <port_attach_client+0xf0>
	if (ret != NO_ERROR) {
		LTRACEF("access denied: %d\n", ret);
		return ret;
	}

	server = chan_alloc(IPC_CHAN_FLAG_SERVER, port->uuid, &tmp_server_ref);
ffffffffea80b98c:	f9402281 	ldr	x1, [x20, #64]
ffffffffea80b990:	910163a2 	add	x2, x29, #0x58
ffffffffea80b994:	f90017b6 	str	x22, [x29, #40]
ffffffffea80b998:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80b99c:	97fffe13 	bl	ffffffffea80b1e8 <chan_alloc>
ffffffffea80b9a0:	aa0003f6 	mov	x22, x0
	if (!server) {
ffffffffea80b9a4:	b40001c0 	cbz	x0, ffffffffea80b9dc <port_attach_client+0xb4>
		LTRACEF("failed to alloc server: %d\n", ret);
		return ERR_NO_MEMORY;
	}

	/* allocate msg queues */
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80b9a8:	b9405280 	ldr	w0, [x20, #80]
ffffffffea80b9ac:	9102c2a2 	add	x2, x21, #0xb0
ffffffffea80b9b0:	f9402e81 	ldr	x1, [x20, #88]
ffffffffea80b9b4:	940004db 	bl	ffffffffea80cd20 <ipc_msg_queue_create>
				   port->recv_buf_size,
				   &client->msg_queue);
	if (ret != NO_ERROR) {
ffffffffea80b9b8:	34000360 	cbz	w0, ffffffffea80ba24 <port_attach_client+0xfc>
	item->next->prev = item->prev;
ffffffffea80b9bc:	a94583a1 	ldp	x1, x0, [x29, #88]
ffffffffea80b9c0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80b9c4:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80b9c8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80b9cc:	a905ffbf 	stp	xzr, xzr, [x29, #88]
	return (list->next == list) ? true : false;
ffffffffea80b9d0:	f94006d4 	ldr	x20, [x22, #8]
ffffffffea80b9d4:	eb16029f 	cmp	x20, x22
ffffffffea80b9d8:	54000b60 	b.eq	ffffffffea80bb44 <port_attach_client+0x21c>  // b.none
ffffffffea80b9dc:	f94017b6 	ldr	x22, [x29, #40]
		return ERR_NO_MEMORY;
ffffffffea80b9e0:	12800097 	mov	w23, #0xfffffffb            	// #-5
ffffffffea80b9e4:	f9401fb8 	ldr	x24, [x29, #56]
	ipc_msg_queue_destroy(client->msg_queue);
	client->msg_queue = NULL;
err_client_mq:
	chan_del_ref(server, &tmp_server_ref);
	return ERR_NO_MEMORY;
}
ffffffffea80b9e8:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80b9ec:	2a1703e0 	mov	w0, w23
ffffffffea80b9f0:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80b9f4:	f9400261 	ldr	x1, [x19]
ffffffffea80b9f8:	ca010041 	eor	x1, x2, x1
ffffffffea80b9fc:	b5000fe1 	cbnz	x1, ffffffffea80bbf8 <port_attach_client+0x2d0>
ffffffffea80ba00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ba04:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80ba08:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80ba0c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80ba10:	d65f03c0 	ret
		if (port->flags & IPC_PORT_ALLOW_NS_CONNECT) {
ffffffffea80ba14:	370ffbc0 	tbnz	w0, #1, ffffffffea80b98c <port_attach_client+0x64>
ffffffffea80ba18:	f9401fb8 	ldr	x24, [x29, #56]
		return ERR_ACCESS_DENIED;
ffffffffea80ba1c:	12800557 	mov	w23, #0xffffffd5            	// #-43
ffffffffea80ba20:	17fffff2 	b	ffffffffea80b9e8 <port_attach_client+0xc0>
	ret = ipc_msg_queue_create(port->num_recv_bufs,
ffffffffea80ba24:	b9405280 	ldr	w0, [x20, #80]
ffffffffea80ba28:	9102c2c2 	add	x2, x22, #0xb0
ffffffffea80ba2c:	f9402e81 	ldr	x1, [x20, #88]
ffffffffea80ba30:	940004bc 	bl	ffffffffea80cd20 <ipc_msg_queue_create>
ffffffffea80ba34:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80ba38:	35000640 	cbnz	w0, ffffffffea80bb00 <port_attach_client+0x1d8>
	item->prev = list->prev;
ffffffffea80ba3c:	f94002c1 	ldr	x1, [x22]
	server->state = IPC_CHAN_STATE_ACCEPTING;
ffffffffea80ba40:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80ba44:	f90023b9 	str	x25, [x29, #64]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80ba48:	910042a5 	add	x5, x21, #0x10
ffffffffea80ba4c:	b90032c0 	str	w0, [x22, #48]
	client->state = IPC_CHAN_STATE_CONNECTING;
ffffffffea80ba50:	52800040 	mov	w0, #0x2                   	// #2
	item->next = list;
ffffffffea80ba54:	a9015aa1 	stp	x1, x22, [x21, #16]
ffffffffea80ba58:	910042c4 	add	x4, x22, #0x10
ffffffffea80ba5c:	b90032a0 	str	w0, [x21, #48]
	list->prev = item;
ffffffffea80ba60:	aa1603e1 	mov	x1, x22
	list->prev->next = item;
ffffffffea80ba64:	f94002c0 	ldr	x0, [x22]
ffffffffea80ba68:	910242c3 	add	x3, x22, #0x90
	item->prev = list->prev;
ffffffffea80ba6c:	aa1403e2 	mov	x2, x20
	handle_incref(&port->handle);
ffffffffea80ba70:	91018299 	add	x25, x20, #0x60
	list->prev->next = item;
ffffffffea80ba74:	f9000405 	str	x5, [x0, #8]
ffffffffea80ba78:	aa1903e0 	mov	x0, x25
	list->prev = item;
ffffffffea80ba7c:	f90002c5 	str	x5, [x22]
	client->peer = server;
ffffffffea80ba80:	f90012b6 	str	x22, [x21, #32]
	item->prev = list->prev;
ffffffffea80ba84:	f94002a5 	ldr	x5, [x21]
	item->next = list;
ffffffffea80ba88:	a90156c5 	stp	x5, x21, [x22, #16]
	list->prev->next = item;
ffffffffea80ba8c:	f94002a5 	ldr	x5, [x21]
ffffffffea80ba90:	f90004a4 	str	x4, [x5, #8]
	list->prev = item;
ffffffffea80ba94:	f90002a4 	str	x4, [x21]
	server->peer = client;
ffffffffea80ba98:	f90012d5 	str	x21, [x22, #32]
	item->prev = list->prev;
ffffffffea80ba9c:	f94002c4 	ldr	x4, [x22]
	item->next = list;
ffffffffea80baa0:	a9095ac4 	stp	x4, x22, [x22, #144]
	list->prev->next = item;
ffffffffea80baa4:	f9000483 	str	x3, [x4, #8]
	list->prev = item;
ffffffffea80baa8:	f80a0423 	str	x3, [x1], #160
	item->prev = list->prev;
ffffffffea80baac:	f84a0c43 	ldr	x3, [x2, #160]!
	item->next = list;
ffffffffea80bab0:	a90a0ac3 	stp	x3, x2, [x22, #160]
	list->prev->next = item;
ffffffffea80bab4:	f9405282 	ldr	x2, [x20, #160]
ffffffffea80bab8:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80babc:	f9005281 	str	x1, [x20, #160]
	handle_incref(&port->handle);
ffffffffea80bac0:	97fff9d8 	bl	ffffffffea80a220 <handle_incref>
	handle_notify(&port->handle);
ffffffffea80bac4:	aa1903e0 	mov	x0, x25
ffffffffea80bac8:	97fffa58 	bl	ffffffffea80a428 <handle_notify>
	item->next->prev = item->prev;
ffffffffea80bacc:	a94583a1 	ldp	x1, x0, [x29, #88]
ffffffffea80bad0:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bad4:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80bad8:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80badc:	a905ffbf 	stp	xzr, xzr, [x29, #88]
	if (dead)
ffffffffea80bae0:	f94006c0 	ldr	x0, [x22, #8]
ffffffffea80bae4:	eb16001f 	cmp	x0, x22
ffffffffea80bae8:	54000140 	b.eq	ffffffffea80bb10 <port_attach_client+0x1e8>  // b.none
ffffffffea80baec:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80baf0:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80baf4:	17ffffbd 	b	ffffffffea80b9e8 <port_attach_client+0xc0>
		return ERR_NOT_READY;
ffffffffea80baf8:	12800057 	mov	w23, #0xfffffffd            	// #-3
ffffffffea80bafc:	17ffffbb 	b	ffffffffea80b9e8 <port_attach_client+0xc0>
	ipc_msg_queue_destroy(client->msg_queue);
ffffffffea80bb00:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80bb04:	940004cb 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
	client->msg_queue = NULL;
ffffffffea80bb08:	f9005abf 	str	xzr, [x21, #176]
ffffffffea80bb0c:	17ffffac 	b	ffffffffea80b9bc <port_attach_client+0x94>
	ASSERT(chan->peer == NULL);
ffffffffea80bb10:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80bb14:	b5000440 	cbnz	x0, ffffffffea80bb9c <port_attach_client+0x274>
	if (item->prev == 0 && item->next == 0)
ffffffffea80bb18:	f94052c0 	ldr	x0, [x22, #160]
ffffffffea80bb1c:	b4000520 	cbz	x0, ffffffffea80bbc0 <port_attach_client+0x298>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80bb20:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bb24:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bb28:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80bb2c:	913aa084 	add	x4, x4, #0xea8
ffffffffea80bb30:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80bb34:	913c2042 	add	x2, x2, #0xf08
ffffffffea80bb38:	91314021 	add	x1, x1, #0xc50
ffffffffea80bb3c:	aa1803e0 	mov	x0, x24
ffffffffea80bb40:	94001a90 	bl	ffffffffea812580 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80bb44:	f94012c0 	ldr	x0, [x22, #32]
ffffffffea80bb48:	b5000280 	cbnz	x0, ffffffffea80bb98 <port_attach_client+0x270>
ffffffffea80bb4c:	f94052c0 	ldr	x0, [x22, #160]
ffffffffea80bb50:	b4000060 	cbz	x0, ffffffffea80bb5c <port_attach_client+0x234>
ffffffffea80bb54:	f90023b9 	str	x25, [x29, #64]
ffffffffea80bb58:	17fffff2 	b	ffffffffea80bb20 <port_attach_client+0x1f8>
ffffffffea80bb5c:	f94056c0 	ldr	x0, [x22, #168]
ffffffffea80bb60:	b5ffffa0 	cbnz	x0, ffffffffea80bb54 <port_attach_client+0x22c>
	if (chan->path) {
ffffffffea80bb64:	f9405ec0 	ldr	x0, [x22, #184]
ffffffffea80bb68:	b4000040 	cbz	x0, ffffffffea80bb70 <port_attach_client+0x248>
		free((void *)chan->path);
ffffffffea80bb6c:	94002095 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80bb70:	f9405ac0 	ldr	x0, [x22, #176]
ffffffffea80bb74:	b4000060 	cbz	x0, ffffffffea80bb80 <port_attach_client+0x258>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bb78:	940004ae 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bb7c:	f9005adf 	str	xzr, [x22, #176]
	free(chan);
ffffffffea80bb80:	aa1403e0 	mov	x0, x20
	return ERR_NO_MEMORY;
ffffffffea80bb84:	12800097 	mov	w23, #0xfffffffb            	// #-5
	free(chan);
ffffffffea80bb88:	9400208e 	bl	ffffffffea813dc0 <free>
ffffffffea80bb8c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80bb90:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80bb94:	17ffff95 	b	ffffffffea80b9e8 <port_attach_client+0xc0>
ffffffffea80bb98:	f90023b9 	str	x25, [x29, #64]
	ASSERT(chan->peer == NULL);
ffffffffea80bb9c:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bba0:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bba4:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80bba8:	913a4084 	add	x4, x4, #0xe90
ffffffffea80bbac:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80bbb0:	913c2042 	add	x2, x2, #0xf08
ffffffffea80bbb4:	91314021 	add	x1, x1, #0xc50
ffffffffea80bbb8:	aa1803e0 	mov	x0, x24
ffffffffea80bbbc:	94001a71 	bl	ffffffffea812580 <_panic>
ffffffffea80bbc0:	f94056c0 	ldr	x0, [x22, #168]
ffffffffea80bbc4:	b5fffae0 	cbnz	x0, ffffffffea80bb20 <port_attach_client+0x1f8>
	if (chan->path) {
ffffffffea80bbc8:	f9405ec0 	ldr	x0, [x22, #184]
ffffffffea80bbcc:	b4000040 	cbz	x0, ffffffffea80bbd4 <port_attach_client+0x2ac>
		free((void *)chan->path);
ffffffffea80bbd0:	9400207c 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80bbd4:	f9405ac0 	ldr	x0, [x22, #176]
ffffffffea80bbd8:	b4000060 	cbz	x0, ffffffffea80bbe4 <port_attach_client+0x2bc>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bbdc:	94000495 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bbe0:	f9005adf 	str	xzr, [x22, #176]
	free(chan);
ffffffffea80bbe4:	aa1603e0 	mov	x0, x22
ffffffffea80bbe8:	94002076 	bl	ffffffffea813dc0 <free>
ffffffffea80bbec:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80bbf0:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80bbf4:	17ffff7d 	b	ffffffffea80b9e8 <port_attach_client+0xc0>
ffffffffea80bbf8:	f90017b6 	str	x22, [x29, #40]
ffffffffea80bbfc:	a903e7b8 	stp	x24, x25, [x29, #56]
}
ffffffffea80bc00:	9400204a 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80bc04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80bc08 <ipc_is_channel>:
	return likely(handle->ops == &ipc_chan_handle_ops);
ffffffffea80bc08:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80bc0c:	d0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80bc10:	91374000 	add	x0, x0, #0xdd0
ffffffffea80bc14:	eb00003f 	cmp	x1, x0
}
ffffffffea80bc18:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80bc1c:	d65f03c0 	ret

ffffffffea80bc20 <ipc_port_create>:
{
ffffffffea80bc20:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea80bc24:	910003fd 	mov	x29, sp
ffffffffea80bc28:	f9000ff4 	str	x20, [sp, #24]
	if (!sid) {
ffffffffea80bc2c:	b40007e0 	cbz	x0, ffffffffea80bd28 <ipc_port_create+0x108>
	if (!num_recv_bufs || num_recv_bufs > IPC_CHAN_MAX_BUFS ||
ffffffffea80bc30:	51000446 	sub	w6, w2, #0x1
ffffffffea80bc34:	71007cdf 	cmp	w6, #0x1f
ffffffffea80bc38:	54000788 	b.hi	ffffffffea80bd28 <ipc_port_create+0x108>  // b.pmore
	    !recv_buf_size || recv_buf_size > IPC_CHAN_MAX_BUF_SIZE) {
ffffffffea80bc3c:	d1000466 	sub	x6, x3, #0x1
ffffffffea80bc40:	f13ffcdf 	cmp	x6, #0xfff
ffffffffea80bc44:	54000728 	b.hi	ffffffffea80bd28 <ipc_port_create+0x108>  // b.pmore
ffffffffea80bc48:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80bc4c:	aa0103f4 	mov	x20, x1
ffffffffea80bc50:	a9025bb5 	stp	x21, x22, [x29, #32]
	new_port = calloc(1, sizeof(ipc_port_t));
ffffffffea80bc54:	d2801801 	mov	x1, #0xc0                  	// #192
ffffffffea80bc58:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80bc5c:	2a0203f6 	mov	w22, w2
ffffffffea80bc60:	f90023b9 	str	x25, [x29, #64]
ffffffffea80bc64:	aa0503f7 	mov	x23, x5
ffffffffea80bc68:	2a0403f8 	mov	w24, w4
ffffffffea80bc6c:	aa0003f5 	mov	x21, x0
ffffffffea80bc70:	aa0303f9 	mov	x25, x3
ffffffffea80bc74:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80bc78:	94002042 	bl	ffffffffea813d80 <calloc>
ffffffffea80bc7c:	aa0003f3 	mov	x19, x0
	if (!new_port) {
ffffffffea80bc80:	b4000580 	cbz	x0, ffffffffea80bd30 <ipc_port_create+0x110>
	ret = strlcpy(new_port->path, path, sizeof(new_port->path));
ffffffffea80bc84:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80bc88:	aa1403e1 	mov	x1, x20
ffffffffea80bc8c:	9400214d 	bl	ffffffffea8141c0 <strlcpy>
	if (ret == 0) {
ffffffffea80bc90:	340001c0 	cbz	w0, ffffffffea80bcc8 <ipc_port_create+0xa8>
		ret = ERR_TOO_BIG;
ffffffffea80bc94:	12800314 	mov	w20, #0xffffffe7            	// #-25
	if ((uint) ret >= sizeof(new_port->path)) {
ffffffffea80bc98:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80bc9c:	540001a9 	b.ls	ffffffffea80bcd0 <ipc_port_create+0xb0>  // b.plast
	free(new_port);
ffffffffea80bca0:	aa1303e0 	mov	x0, x19
ffffffffea80bca4:	94002047 	bl	ffffffffea813dc0 <free>
	return ret;
ffffffffea80bca8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bcac:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80bcb0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bcb4:	f94023b9 	ldr	x25, [x29, #64]
}
ffffffffea80bcb8:	2a1403e0 	mov	w0, w20
ffffffffea80bcbc:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80bcc0:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80bcc4:	d65f03c0 	ret
		ret = ERR_INVALID_ARGS;
ffffffffea80bcc8:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80bccc:	17fffff5 	b	ffffffffea80bca0 <ipc_port_create+0x80>
ffffffffea80bcd0:	f90027ba 	str	x26, [x29, #72]
	list_initialize(&new_port->pending_list);
ffffffffea80bcd4:	91028260 	add	x0, x19, #0xa0
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bcd8:	9101827a 	add	x26, x19, #0x60
	new_port->uuid = sid;
ffffffffea80bcdc:	f9002275 	str	x21, [x19, #64]
	new_port->flags = flags;
ffffffffea80bce0:	2909627f 	stp	wzr, w24, [x19, #72]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bce4:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	new_port->num_recv_bufs = num_recv_bufs;
ffffffffea80bce8:	b9005276 	str	w22, [x19, #80]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bcec:	9138a021 	add	x1, x1, #0xe28
	new_port->recv_buf_size = recv_buf_size;
ffffffffea80bcf0:	f9002e79 	str	x25, [x19, #88]
	return NO_ERROR;
ffffffffea80bcf4:	52800014 	mov	w20, #0x0                   	// #0
	list->prev = list->next = list;
ffffffffea80bcf8:	a90a0260 	stp	x0, x0, [x19, #160]
	handle_init(&new_port->handle, &ipc_port_handle_ops);
ffffffffea80bcfc:	aa1a03e0 	mov	x0, x26
ffffffffea80bd00:	97fff938 	bl	ffffffffea80a1e0 <handle_init>
	return NO_ERROR;
ffffffffea80bd04:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bd08:	a9425bb5 	ldp	x21, x22, [x29, #32]
	*phandle_ptr = &new_port->handle;
ffffffffea80bd0c:	f90002fa 	str	x26, [x23]
}
ffffffffea80bd10:	2a1403e0 	mov	w0, w20
ffffffffea80bd14:	f9400ff4 	ldr	x20, [sp, #24]
	return NO_ERROR;
ffffffffea80bd18:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bd1c:	a9446bb9 	ldp	x25, x26, [x29, #64]
}
ffffffffea80bd20:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea80bd24:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80bd28:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80bd2c:	17ffffe3 	b	ffffffffea80bcb8 <ipc_port_create+0x98>
		return ERR_NO_MEMORY;
ffffffffea80bd30:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea80bd34:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80bd38:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80bd3c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80bd40:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80bd44:	17ffffdd 	b	ffffffffea80bcb8 <ipc_port_create+0x98>

ffffffffea80bd48 <ipc_port_publish>:
{
ffffffffea80bd48:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea80bd4c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80bd50:	910003fd 	mov	x29, sp
ffffffffea80bd54:	f9001ff8 	str	x24, [sp, #56]
ffffffffea80bd58:	f00002b8 	adrp	x24, ffffffffea862000 <__ctor_list>
ffffffffea80bd5c:	a90153f3 	stp	x19, x20, [sp, #16]
	ipc_port_t *port = containerof(phandle, ipc_port_t, handle);
ffffffffea80bd60:	d1018014 	sub	x20, x0, #0x60
{
ffffffffea80bd64:	f9402b02 	ldr	x2, [x24, #80]
ffffffffea80bd68:	aa0003f3 	mov	x19, x0
ffffffffea80bd6c:	f90013f5 	str	x21, [sp, #32]
ffffffffea80bd70:	f9400043 	ldr	x3, [x2]
ffffffffea80bd74:	f90047a3 	str	x3, [x29, #136]
ffffffffea80bd78:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea80bd7c:	f9002bfb 	str	x27, [sp, #80]
ffffffffea80bd80:	f90033be 	str	x30, [x29, #96]
ffffffffea80bd84:	d000007b 	adrp	x27, ffffffffea819000 <_mem_phys_base>
ffffffffea80bd88:	9137c360 	add	x0, x27, #0xdf0
ffffffffea80bd8c:	97ffe6bf 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (port_find_locked(port->path)) {
ffffffffea80bd90:	aa1403e0 	mov	x0, x20
ffffffffea80bd94:	97fffd2b 	bl	ffffffffea80b240 <port_find_locked>
ffffffffea80bd98:	b50014e0 	cbnz	x0, ffffffffea80c034 <ipc_port_publish+0x2ec>
	item->prev = list->prev;
ffffffffea80bd9c:	d0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80bda0:	f90017b6 	str	x22, [x29, #40]
ffffffffea80bda4:	f9002fbc 	str	x28, [x29, #88]
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80bda8:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80bdac:	f9472422 	ldr	x2, [x1, #3656]
		list_add_tail(&ipc_port_list, &port->node);
ffffffffea80bdb0:	91014263 	add	x3, x19, #0x50
		port->state = IPC_PORT_STATE_LISTENING;
ffffffffea80bdb4:	b81e8260 	stur	w0, [x19, #-24]
ffffffffea80bdb8:	91392020 	add	x0, x1, #0xe48
	item->next = list;
ffffffffea80bdbc:	a90b0282 	stp	x2, x0, [x20, #176]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80bdc0:	aa1303e0 	mov	x0, x19
	list->prev->next = item;
ffffffffea80bdc4:	f9000443 	str	x3, [x2, #8]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bdc8:	d0000076 	adrp	x22, ffffffffea819000 <_mem_phys_base>
	list->prev = item;
ffffffffea80bdcc:	f9072423 	str	x3, [x1, #3656]
		handle_incref(&port->handle); /* and inc usage count */
ffffffffea80bdd0:	97fff914 	bl	ffffffffea80a220 <handle_incref>
		obj_ref_t tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80bdd4:	a907ffbf 	stp	xzr, xzr, [x29, #120]
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bdd8:	913962c1 	add	x1, x22, #0xe58
ffffffffea80bddc:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80bde0:	d102801c 	sub	x28, x0, #0xa0
ffffffffea80bde4:	eb00003f 	cmp	x1, x0
ffffffffea80bde8:	f9405793 	ldr	x19, [x28, #168]
ffffffffea80bdec:	d1028273 	sub	x19, x19, #0xa0
ffffffffea80bdf0:	54001080 	b.eq	ffffffffea80c000 <ipc_port_publish+0x2b8>  // b.none
ffffffffea80bdf4:	f9001bb7 	str	x23, [x29, #48]
	int ret = NO_ERROR;
ffffffffea80bdf8:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea80bdfc:	a9046bb9 	stp	x25, x26, [x29, #64]
	list->prev->next = item;
ffffffffea80be00:	9101e3b7 	add	x23, x29, #0x78
				TRACEF("guest %u access to port denied, ret = %d\n",
ffffffffea80be04:	9000007a 	adrp	x26, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80be08:	90000079 	adrp	x25, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80be0c:	9139235a 	add	x26, x26, #0xe48
ffffffffea80be10:	913b2320 	add	x0, x25, #0xec8
ffffffffea80be14:	f90037a0 	str	x0, [x29, #104]
ffffffffea80be18:	14000016 	b	ffffffffea80be70 <ipc_port_publish+0x128>
ffffffffea80be1c:	2a0003e4 	mov	w4, w0
ffffffffea80be20:	b9408b83 	ldr	w3, [x28, #136]
ffffffffea80be24:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80be28:	52802382 	mov	w2, #0x11c                 	// #284
ffffffffea80be2c:	aa1a03e1 	mov	x1, x26
ffffffffea80be30:	94001f8a 	bl	ffffffffea813c58 <_printf>
	item->next->prev = item->prev;
ffffffffea80be34:	a94783a1 	ldp	x1, x0, [x29, #120]
ffffffffea80be38:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80be3c:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea80be40:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80be44:	a907ffbf 	stp	xzr, xzr, [x29, #120]
ffffffffea80be48:	f9400780 	ldr	x0, [x28, #8]
ffffffffea80be4c:	eb00039f 	cmp	x28, x0
ffffffffea80be50:	54000700 	b.eq	ffffffffea80bf30 <ipc_port_publish+0x1e8>  // b.none
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80be54:	f9405661 	ldr	x1, [x19, #168]
ffffffffea80be58:	91028262 	add	x2, x19, #0xa0
ffffffffea80be5c:	913962c0 	add	x0, x22, #0xe58
ffffffffea80be60:	aa1303fc 	mov	x28, x19
ffffffffea80be64:	eb02001f 	cmp	x0, x2
ffffffffea80be68:	d1028033 	sub	x19, x1, #0xa0
ffffffffea80be6c:	540008e0 	b.eq	ffffffffea80bf88 <ipc_port_publish+0x240>  // b.none
			if (strcmp(client->path, port->path)) {
ffffffffea80be70:	f9405f99 	ldr	x25, [x28, #184]
ffffffffea80be74:	aa1403e1 	mov	x1, x20
ffffffffea80be78:	aa1903e0 	mov	x0, x25
ffffffffea80be7c:	940020af 	bl	ffffffffea814138 <strcmp>
ffffffffea80be80:	35fffea0 	cbnz	w0, ffffffffea80be54 <ipc_port_publish+0x10c>
			free((void *)client->path);
ffffffffea80be84:	aa1903e0 	mov	x0, x25
ffffffffea80be88:	94001fce 	bl	ffffffffea813dc0 <free>
	item->prev = list->prev;
ffffffffea80be8c:	f9400380 	ldr	x0, [x28]
	item->next = list;
ffffffffea80be90:	a907f3a0 	stp	x0, x28, [x29, #120]
			client->path = NULL;
ffffffffea80be94:	f9005f9f 	str	xzr, [x28, #184]
	list->prev->next = item;
ffffffffea80be98:	f9400380 	ldr	x0, [x28]
	item->next->prev = item->prev;
ffffffffea80be9c:	f9405381 	ldr	x1, [x28, #160]
	list->prev->next = item;
ffffffffea80bea0:	f9000417 	str	x23, [x0, #8]
	list->prev = item;
ffffffffea80bea4:	f9000397 	str	x23, [x28]
	item->next->prev = item->prev;
ffffffffea80bea8:	f9405780 	ldr	x0, [x28, #168]
ffffffffea80beac:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80beb0:	f9405382 	ldr	x2, [x28, #160]
	item->next->prev = item->prev;
ffffffffea80beb4:	f9404b81 	ldr	x1, [x28, #144]
	item->prev->next = item->next;
ffffffffea80beb8:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea80bebc:	a90a7f9f 	stp	xzr, xzr, [x28, #160]
	item->next->prev = item->prev;
ffffffffea80bec0:	f9404f80 	ldr	x0, [x28, #152]
ffffffffea80bec4:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bec8:	f9404b81 	ldr	x1, [x28, #144]
ffffffffea80becc:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bed0:	a9097f9f 	stp	xzr, xzr, [x28, #144]
ffffffffea80bed4:	f9400780 	ldr	x0, [x28, #8]
ffffffffea80bed8:	eb1c001f 	cmp	x0, x28
ffffffffea80bedc:	54000780 	b.eq	ffffffffea80bfcc <ipc_port_publish+0x284>  // b.none
			ret = trusty_hyp_check_guest_access(client->handle.guest_id, port->uuid);
ffffffffea80bee0:	b9408b80 	ldr	w0, [x28, #136]
ffffffffea80bee4:	f9402281 	ldr	x1, [x20, #64]
ffffffffea80bee8:	97ffda48 	bl	ffffffffea802808 <trusty_hyp_check_guest_access>
ffffffffea80beec:	2a0003f5 	mov	w21, w0
			if (ret) {
ffffffffea80bef0:	35fff960 	cbnz	w0, ffffffffea80be1c <ipc_port_publish+0xd4>
				int err = port_attach_client(port, client);
ffffffffea80bef4:	aa1c03e1 	mov	x1, x28
ffffffffea80bef8:	aa1403e0 	mov	x0, x20
ffffffffea80befc:	97fffe8b 	bl	ffffffffea80b928 <port_attach_client>
				if (err) {
ffffffffea80bf00:	34fff9a0 	cbz	w0, ffffffffea80be34 <ipc_port_publish+0xec>
					chan_shutdown_locked(client);
ffffffffea80bf04:	aa1c03e0 	mov	x0, x28
ffffffffea80bf08:	97fffdbe 	bl	ffffffffea80b600 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80bf0c:	a94783a1 	ldp	x1, x0, [x29, #120]
ffffffffea80bf10:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80bf14:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea80bf18:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80bf1c:	a907ffbf 	stp	xzr, xzr, [x29, #120]
ffffffffea80bf20:	f9400780 	ldr	x0, [x28, #8]
ffffffffea80bf24:	eb00039f 	cmp	x28, x0
ffffffffea80bf28:	54fff961 	b.ne	ffffffffea80be54 <ipc_port_publish+0x10c>  // b.any
ffffffffea80bf2c:	d503201f 	nop
	ASSERT(chan->peer == NULL);
ffffffffea80bf30:	f9401380 	ldr	x0, [x28, #32]
ffffffffea80bf34:	b5000840 	cbnz	x0, ffffffffea80c03c <ipc_port_publish+0x2f4>
	if (item->prev == 0 && item->next == 0)
ffffffffea80bf38:	f9405380 	ldr	x0, [x28, #160]
ffffffffea80bf3c:	b5000500 	cbnz	x0, ffffffffea80bfdc <ipc_port_publish+0x294>
ffffffffea80bf40:	f9405780 	ldr	x0, [x28, #168]
ffffffffea80bf44:	b50004c0 	cbnz	x0, ffffffffea80bfdc <ipc_port_publish+0x294>
	if (chan->path) {
ffffffffea80bf48:	f9405f80 	ldr	x0, [x28, #184]
ffffffffea80bf4c:	b4000040 	cbz	x0, ffffffffea80bf54 <ipc_port_publish+0x20c>
		free((void *)chan->path);
ffffffffea80bf50:	94001f9c 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80bf54:	f9405b80 	ldr	x0, [x28, #176]
ffffffffea80bf58:	b4000060 	cbz	x0, ffffffffea80bf64 <ipc_port_publish+0x21c>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80bf5c:	940003b5 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80bf60:	f9005b9f 	str	xzr, [x28, #176]
	free(chan);
ffffffffea80bf64:	aa1c03e0 	mov	x0, x28
ffffffffea80bf68:	94001f96 	bl	ffffffffea813dc0 <free>
		list_for_every_entry_safe(&waiting_for_port_chan_list, client, temp, ipc_chan_t, node) {
ffffffffea80bf6c:	f9405661 	ldr	x1, [x19, #168]
ffffffffea80bf70:	91028262 	add	x2, x19, #0xa0
ffffffffea80bf74:	913962c0 	add	x0, x22, #0xe58
ffffffffea80bf78:	aa1303fc 	mov	x28, x19
ffffffffea80bf7c:	eb02001f 	cmp	x0, x2
ffffffffea80bf80:	d1028033 	sub	x19, x1, #0xa0
ffffffffea80bf84:	54fff761 	b.ne	ffffffffea80be70 <ipc_port_publish+0x128>  // b.any
ffffffffea80bf88:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80bf8c:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80bf90:	f9402fbc 	ldr	x28, [x29, #88]
	mutex_release(&ipc_lock);
ffffffffea80bf94:	9137c360 	add	x0, x27, #0xdf0
ffffffffea80bf98:	97ffe668 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80bf9c:	f9402b18 	ldr	x24, [x24, #80]
ffffffffea80bfa0:	2a1503e0 	mov	w0, w21
ffffffffea80bfa4:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea80bfa8:	f9400301 	ldr	x1, [x24]
ffffffffea80bfac:	ca010041 	eor	x1, x2, x1
ffffffffea80bfb0:	b5000581 	cbnz	x1, ffffffffea80c060 <ipc_port_publish+0x318>
ffffffffea80bfb4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80bfb8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80bfbc:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea80bfc0:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea80bfc4:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea80bfc8:	d65f03c0 	ret
	ASSERT(chan->peer == NULL);
ffffffffea80bfcc:	f9401380 	ldr	x0, [x28, #32]
ffffffffea80bfd0:	b5000360 	cbnz	x0, ffffffffea80c03c <ipc_port_publish+0x2f4>
ffffffffea80bfd4:	f9405380 	ldr	x0, [x28, #160]
ffffffffea80bfd8:	b40001c0 	cbz	x0, ffffffffea80c010 <ipc_port_publish+0x2c8>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80bfdc:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80bfe0:	90000064 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bfe4:	90000062 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80bfe8:	f0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80bfec:	913aa084 	add	x4, x4, #0xea8
ffffffffea80bff0:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80bff4:	913c2042 	add	x2, x2, #0xf08
ffffffffea80bff8:	91314021 	add	x1, x1, #0xc50
ffffffffea80bffc:	94001961 	bl	ffffffffea812580 <_panic>
	int ret = NO_ERROR;
ffffffffea80c000:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea80c004:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c008:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80c00c:	17ffffe2 	b	ffffffffea80bf94 <ipc_port_publish+0x24c>
ffffffffea80c010:	f9405780 	ldr	x0, [x28, #168]
ffffffffea80c014:	b5fffe40 	cbnz	x0, ffffffffea80bfdc <ipc_port_publish+0x294>
	if (chan->msg_queue) {
ffffffffea80c018:	f9405b80 	ldr	x0, [x28, #176]
ffffffffea80c01c:	b4000060 	cbz	x0, ffffffffea80c028 <ipc_port_publish+0x2e0>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c020:	94000384 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c024:	f9005b9f 	str	xzr, [x28, #176]
	free(chan);
ffffffffea80c028:	aa1c03e0 	mov	x0, x28
ffffffffea80c02c:	94001f65 	bl	ffffffffea813dc0 <free>
ffffffffea80c030:	17ffffac 	b	ffffffffea80bee0 <ipc_port_publish+0x198>
		ret = ERR_ALREADY_EXISTS;
ffffffffea80c034:	128001b5 	mov	w21, #0xfffffff2            	// #-14
ffffffffea80c038:	17ffffd7 	b	ffffffffea80bf94 <ipc_port_publish+0x24c>
	ASSERT(chan->peer == NULL);
ffffffffea80c03c:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80c040:	f0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c044:	f0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c048:	d0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80c04c:	913a4084 	add	x4, x4, #0xe90
ffffffffea80c050:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c054:	913c2042 	add	x2, x2, #0xf08
ffffffffea80c058:	91314021 	add	x1, x1, #0xc50
ffffffffea80c05c:	94001949 	bl	ffffffffea812580 <_panic>
ffffffffea80c060:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80c064:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80c068:	f9002fbc 	str	x28, [x29, #88]
}
ffffffffea80c06c:	94001f2f 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80c070 <sys_port_create>:
{
ffffffffea80c070:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
ffffffffea80c074:	910003fd 	mov	x29, sp
ffffffffea80c078:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c07c:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80c080:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80c084:	2a0003f5 	mov	w21, w0
ffffffffea80c088:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80c08c:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80c090:	2a0103f7 	mov	w23, w1
ffffffffea80c094:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80c098:	aa0203f8 	mov	x24, x2
ffffffffea80c09c:	2a0303f9 	mov	w25, w3
ffffffffea80c0a0:	f9400001 	ldr	x1, [x0]
ffffffffea80c0a4:	f90057a1 	str	x1, [x29, #168]
ffffffffea80c0a8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80c0ac:	d538d080 	mrs	x0, tpidr_el1
	trusty_app_t *tapp = ut->private_data;
ffffffffea80c0b0:	f9415800 	ldr	x0, [x0, #688]
	return arch_strlcpy_from_user(kdest, usrc, len);
ffffffffea80c0b4:	9101a3b3 	add	x19, x29, #0x68
ffffffffea80c0b8:	f9404816 	ldr	x22, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80c0bc:	97fffa2d 	bl	ffffffffea80a970 <current_uctx>
	handle_t *port_handle = NULL;
ffffffffea80c0c0:	f90033bf 	str	xzr, [x29, #96]
	uctx_t *ctx = current_uctx();
ffffffffea80c0c4:	aa0003fa 	mov	x26, x0
ffffffffea80c0c8:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80c0cc:	aa1303e0 	mov	x0, x19
ffffffffea80c0d0:	2a1503e1 	mov	w1, w21
ffffffffea80c0d4:	940020bf 	bl	ffffffffea8143d0 <arch_strlcpy_from_user>
	if (ret < 0) {
ffffffffea80c0d8:	37f804a0 	tbnz	w0, #31, ffffffffea80c16c <sys_port_create+0xfc>
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80c0dc:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80c0e0:	54000588 	b.hi	ffffffffea80c190 <sys_port_create+0x120>  // b.pmore
	ret = ipc_port_create(&tapp->props.uuid, tmp_path,
ffffffffea80c0e4:	910183b5 	add	x21, x29, #0x60
ffffffffea80c0e8:	aa1303e1 	mov	x1, x19
ffffffffea80c0ec:	2a1903e4 	mov	w4, w25
ffffffffea80c0f0:	aa1503e5 	mov	x5, x21
ffffffffea80c0f4:	aa1803e3 	mov	x3, x24
ffffffffea80c0f8:	2a1703e2 	mov	w2, w23
ffffffffea80c0fc:	910082c0 	add	x0, x22, #0x20
ffffffffea80c100:	97fffec8 	bl	ffffffffea80bc20 <ipc_port_create>
ffffffffea80c104:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c108:	340001a0 	cbz	w0, ffffffffea80c13c <sys_port_create+0xcc>
	return (long) ret;
ffffffffea80c10c:	93407e60 	sxtw	x0, w19
}
ffffffffea80c110:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80c114:	f94057a2 	ldr	x2, [x29, #168]
ffffffffea80c118:	f9400281 	ldr	x1, [x20]
ffffffffea80c11c:	ca010041 	eor	x1, x2, x1
ffffffffea80c120:	b50003c1 	cbnz	x1, ffffffffea80c198 <sys_port_create+0x128>
ffffffffea80c124:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c128:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c12c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80c130:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80c134:	a8cb7bfd 	ldp	x29, x30, [sp], #176
ffffffffea80c138:	d65f03c0 	ret
	ret = uctx_handle_install(ctx, port_handle, &handle_id);
ffffffffea80c13c:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c140:	910173a2 	add	x2, x29, #0x5c
ffffffffea80c144:	aa1a03e0 	mov	x0, x26
ffffffffea80c148:	97fffa6c 	bl	ffffffffea80aaf8 <uctx_handle_install>
ffffffffea80c14c:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c150:	350001a0 	cbnz	w0, ffffffffea80c184 <sys_port_create+0x114>
	ret = ipc_port_publish(port_handle);
ffffffffea80c154:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80c158:	97fffefc 	bl	ffffffffea80bd48 <ipc_port_publish>
ffffffffea80c15c:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c160:	350000a0 	cbnz	w0, ffffffffea80c174 <sys_port_create+0x104>
	return (long) handle_id;
ffffffffea80c164:	b9405fa0 	ldr	w0, [x29, #92]
ffffffffea80c168:	17ffffea 	b	ffffffffea80c110 <sys_port_create+0xa0>
		return (long) ret;
ffffffffea80c16c:	93407c00 	sxtw	x0, w0
ffffffffea80c170:	17ffffe8 	b	ffffffffea80c110 <sys_port_create+0xa0>
	(void) uctx_handle_remove(ctx, handle_id, &port_handle);
ffffffffea80c174:	b9405fa1 	ldr	w1, [x29, #92]
ffffffffea80c178:	aa1503e2 	mov	x2, x21
ffffffffea80c17c:	aa1a03e0 	mov	x0, x26
ffffffffea80c180:	97fffaa6 	bl	ffffffffea80ac18 <uctx_handle_remove>
	handle_decref(port_handle);
ffffffffea80c184:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80c188:	97fff82c 	bl	ffffffffea80a238 <handle_decref>
ffffffffea80c18c:	17ffffe0 	b	ffffffffea80c10c <sys_port_create+0x9c>
		return ERR_INVALID_ARGS;
ffffffffea80c190:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80c194:	17ffffdf 	b	ffffffffea80c110 <sys_port_create+0xa0>
}
ffffffffea80c198:	94001ee4 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80c19c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c1a0 <ipc_port_connect_async>:
 * Client requests a connection to a port. It can be called in context
 * of user task as well as vdev RX thread.
 */
int ipc_port_connect_async(uint32_t guest, const uuid_t *cid, const char *path, size_t max_path,
			   uint flags, handle_t **chandle_ptr)
{
ffffffffea80c1a0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80c1a4:	910003fd 	mov	x29, sp
ffffffffea80c1a8:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80c1ac:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80c1b0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80c1b4:	2a0003f7 	mov	w23, w0
ffffffffea80c1b8:	f9402a86 	ldr	x6, [x20, #80]
	ipc_port_t *port;
	ipc_chan_t *client;
	obj_ref_t   tmp_client_ref = OBJ_REF_INITIAL_VALUE(tmp_client_ref);
ffffffffea80c1bc:	a906ffbf 	stp	xzr, xzr, [x29, #104]
{
ffffffffea80c1c0:	f94000c0 	ldr	x0, [x6]
ffffffffea80c1c4:	f9003fa0 	str	x0, [x29, #120]
ffffffffea80c1c8:	d2800000 	mov	x0, #0x0                   	// #0
	int ret;

	if (!cid) {
ffffffffea80c1cc:	b40013a1 	cbz	x1, ffffffffea80c440 <ipc_port_connect_async+0x2a0>
ffffffffea80c1d0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80c1d4:	aa0103f5 	mov	x21, x1
ffffffffea80c1d8:	f90017b6 	str	x22, [x29, #40]
ffffffffea80c1dc:	aa0303f3 	mov	x19, x3
ffffffffea80c1e0:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea80c1e4:	aa0203f6 	mov	x22, x2
ffffffffea80c1e8:	f90027ba 	str	x26, [x29, #72]
ffffffffea80c1ec:	2a0403f8 	mov	w24, w4
ffffffffea80c1f0:	aa0503f9 	mov	x25, x5
ffffffffea80c1f4:	aa1e03fa 	mov	x26, x30
		/* client uuid is required */
		LTRACEF("client uuid is required\n");
		return ERR_INVALID_ARGS;
	}

	size_t len = strnlen(path, max_path);
ffffffffea80c1f8:	aa0303e1 	mov	x1, x3
ffffffffea80c1fc:	aa0203e0 	mov	x0, x2
ffffffffea80c200:	9400203a 	bl	ffffffffea8142e8 <strnlen>
	if (len == 0 || len >= max_path) {
ffffffffea80c204:	f100001f 	cmp	x0, #0x0
ffffffffea80c208:	fa401260 	ccmp	x19, x0, #0x0, ne  // ne = any
ffffffffea80c20c:	54000f09 	b.ls	ffffffffea80c3ec <ipc_port_connect_async+0x24c>  // b.plast
		return ERR_INVALID_ARGS;
	}
	/* After this point path is zero terminated */

	/* allocate channel pair */
	client = chan_alloc(0, cid, &tmp_client_ref);
ffffffffea80c210:	9101a3a2 	add	x2, x29, #0x68
ffffffffea80c214:	aa1503e1 	mov	x1, x21
ffffffffea80c218:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80c21c:	97fffbf3 	bl	ffffffffea80b1e8 <chan_alloc>
ffffffffea80c220:	aa0003f3 	mov	x19, x0
	if (!client) {
ffffffffea80c224:	b4000f00 	cbz	x0, ffffffffea80c404 <ipc_port_connect_async+0x264>
ffffffffea80c228:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c22c:	a90573bb 	stp	x27, x28, [x29, #80]
ffffffffea80c230:	b000007b 	adrp	x27, ffffffffea819000 <_mem_phys_base>
ffffffffea80c234:	9137c360 	add	x0, x27, #0xdf0
ffffffffea80c238:	97ffe594 	bl	ffffffffea805888 <mutex_acquire_timeout>

	LTRACEF("Connecting to '%s'\n", path);

	mutex_acquire(&ipc_lock);

	port = port_find_locked(path);
ffffffffea80c23c:	aa1603e0 	mov	x0, x22
ffffffffea80c240:	97fffc00 	bl	ffffffffea80b240 <port_find_locked>
ffffffffea80c244:	aa0003fc 	mov	x28, x0
	if (port) {
ffffffffea80c248:	b40003e0 	cbz	x0, ffffffffea80c2c4 <ipc_port_connect_async+0x124>
		/* found  */
		ret = trusty_hyp_check_guest_access(guest, port->uuid);
ffffffffea80c24c:	f9402381 	ldr	x1, [x28, #64]
ffffffffea80c250:	2a1703e0 	mov	w0, w23
ffffffffea80c254:	97ffd96d 	bl	ffffffffea802808 <trusty_hyp_check_guest_access>
ffffffffea80c258:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80c25c:	34000600 	cbz	w0, ffffffffea80c31c <ipc_port_connect_async+0x17c>
	item->next->prev = item->prev;
ffffffffea80c260:	a94683a1 	ldp	x1, x0, [x29, #104]
ffffffffea80c264:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c268:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea80c26c:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c270:	a906ffbf 	stp	xzr, xzr, [x29, #104]
	return (list->next == list) ? true : false;
ffffffffea80c274:	f9400676 	ldr	x22, [x19, #8]
ffffffffea80c278:	eb1302df 	cmp	x22, x19
ffffffffea80c27c:	54000860 	b.eq	ffffffffea80c388 <ipc_port_connect_async+0x1e8>  // b.none

err_alloc_path:
err_attach_client:
err_find_ports:
	chan_del_ref(client, &tmp_client_ref);
	mutex_release(&ipc_lock);
ffffffffea80c280:	9137c360 	add	x0, x27, #0xdf0
ffffffffea80c284:	97ffe5ad 	bl	ffffffffea805938 <mutex_release>
	return ret;
ffffffffea80c288:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c28c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c290:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c294:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea80c298:	f9402fbc 	ldr	x28, [x29, #88]
}
ffffffffea80c29c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80c2a0:	2a1503e0 	mov	w0, w21
ffffffffea80c2a4:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea80c2a8:	f9400281 	ldr	x1, [x20]
ffffffffea80c2ac:	ca010041 	eor	x1, x2, x1
ffffffffea80c2b0:	b5000cc1 	cbnz	x1, ffffffffea80c448 <ipc_port_connect_async+0x2a8>
ffffffffea80c2b4:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80c2b8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80c2bc:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c2c0:	d65f03c0 	ret
			ret = ERR_NOT_FOUND;
ffffffffea80c2c4:	12800035 	mov	w21, #0xfffffffe            	// #-2
		if (!(flags & IPC_CONNECT_WAIT_FOR_PORT)) {
ffffffffea80c2c8:	3607fcd8 	tbz	w24, #0, ffffffffea80c260 <ipc_port_connect_async+0xc0>
		client->path = strdup(path);
ffffffffea80c2cc:	aa1603e0 	mov	x0, x22
ffffffffea80c2d0:	94001fa8 	bl	ffffffffea814170 <strdup>
ffffffffea80c2d4:	f9005e60 	str	x0, [x19, #184]
			ret = ERR_NO_MEMORY;
ffffffffea80c2d8:	12800095 	mov	w21, #0xfffffffb            	// #-5
		if (!client->path) {
ffffffffea80c2dc:	b4fffc20 	cbz	x0, ffffffffea80c260 <ipc_port_connect_async+0xc0>
	item->prev = list->prev;
ffffffffea80c2e0:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
		list_add_tail(&waiting_for_port_chan_list, &client->node);
ffffffffea80c2e4:	91028260 	add	x0, x19, #0xa0
ffffffffea80c2e8:	91396023 	add	x3, x1, #0xe58
		client->state = IPC_CHAN_STATE_WAITING_FOR_PORT;
ffffffffea80c2ec:	528000a4 	mov	w4, #0x5                   	// #5
ffffffffea80c2f0:	f9472c22 	ldr	x2, [x1, #3672]
	list->prev = item;
ffffffffea80c2f4:	f9072c20 	str	x0, [x1, #3672]
ffffffffea80c2f8:	b9003264 	str	w4, [x19, #48]
	item->prev = list->prev;
ffffffffea80c2fc:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea80c300:	a90a0e62 	stp	x2, x3, [x19, #160]
	list->prev->next = item;
ffffffffea80c304:	f9000440 	str	x0, [x2, #8]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80c308:	91024260 	add	x0, x19, #0x90
	item->next = list;
ffffffffea80c30c:	a9094e61 	stp	x1, x19, [x19, #144]
	list->prev->next = item;
ffffffffea80c310:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c314:	f9000260 	str	x0, [x19]
ffffffffea80c318:	14000007 	b	ffffffffea80c334 <ipc_port_connect_async+0x194>
		port->handle.guest_id = guest;
ffffffffea80c31c:	b9009b97 	str	w23, [x28, #152]
		ret = port_attach_client(port, client);
ffffffffea80c320:	aa1303e1 	mov	x1, x19
ffffffffea80c324:	aa1c03e0 	mov	x0, x28
ffffffffea80c328:	97fffd80 	bl	ffffffffea80b928 <port_attach_client>
ffffffffea80c32c:	2a0003f5 	mov	w21, w0
		if (ret) {
ffffffffea80c330:	35fff980 	cbnz	w0, ffffffffea80c260 <ipc_port_connect_async+0xc0>
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c334:	91014276 	add	x22, x19, #0x50
ffffffffea80c338:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80c33c:	aa1603e0 	mov	x0, x22
ffffffffea80c340:	91374021 	add	x1, x1, #0xdd0
ffffffffea80c344:	97fff7a7 	bl	ffffffffea80a1e0 <handle_init>
	ret = NO_ERROR;
ffffffffea80c348:	52800015 	mov	w21, #0x0                   	// #0
	item->prev = list->prev;
ffffffffea80c34c:	f9400261 	ldr	x1, [x19]
ffffffffea80c350:	91010260 	add	x0, x19, #0x40
	item->next = list;
ffffffffea80c354:	a9044e61 	stp	x1, x19, [x19, #64]
	list->prev->next = item;
ffffffffea80c358:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80c35c:	f9000260 	str	x0, [x19]
	*chandle_ptr = chan_handle_init(client);
ffffffffea80c360:	f9000336 	str	x22, [x25]
	item->next->prev = item->prev;
ffffffffea80c364:	a94683a1 	ldp	x1, x0, [x29, #104]
	client->handle.guest_id = guest;
ffffffffea80c368:	b9008a77 	str	w23, [x19, #136]
ffffffffea80c36c:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c370:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea80c374:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c378:	a906ffbf 	stp	xzr, xzr, [x29, #104]
	return (list->next == list) ? true : false;
ffffffffea80c37c:	f9400676 	ldr	x22, [x19, #8]
	if (dead)
ffffffffea80c380:	eb1302df 	cmp	x22, x19
ffffffffea80c384:	54fff7e1 	b.ne	ffffffffea80c280 <ipc_port_connect_async+0xe0>  // b.any
	ASSERT(chan->peer == NULL);
ffffffffea80c388:	f9401260 	ldr	x0, [x19, #32]
ffffffffea80c38c:	b5000480 	cbnz	x0, ffffffffea80c41c <ipc_port_connect_async+0x27c>
	if (item->prev == 0 && item->next == 0)
ffffffffea80c390:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c394:	b4000140 	cbz	x0, ffffffffea80c3bc <ipc_port_connect_async+0x21c>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80c398:	f0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c39c:	f0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c3a0:	d0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80c3a4:	913aa084 	add	x4, x4, #0xea8
ffffffffea80c3a8:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80c3ac:	913c2042 	add	x2, x2, #0xf08
ffffffffea80c3b0:	91314021 	add	x1, x1, #0xc50
ffffffffea80c3b4:	aa1a03e0 	mov	x0, x26
ffffffffea80c3b8:	94001872 	bl	ffffffffea812580 <_panic>
ffffffffea80c3bc:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c3c0:	b5fffec0 	cbnz	x0, ffffffffea80c398 <ipc_port_connect_async+0x1f8>
	if (chan->path) {
ffffffffea80c3c4:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c3c8:	b4000040 	cbz	x0, ffffffffea80c3d0 <ipc_port_connect_async+0x230>
		free((void *)chan->path);
ffffffffea80c3cc:	94001e7d 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80c3d0:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c3d4:	b4000060 	cbz	x0, ffffffffea80c3e0 <ipc_port_connect_async+0x240>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c3d8:	94000296 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c3dc:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c3e0:	aa1603e0 	mov	x0, x22
ffffffffea80c3e4:	94001e77 	bl	ffffffffea813dc0 <free>
ffffffffea80c3e8:	17ffffa6 	b	ffffffffea80c280 <ipc_port_connect_async+0xe0>
		return ERR_INVALID_ARGS;
ffffffffea80c3ec:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80c3f0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c3f4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c3f8:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c3fc:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80c400:	17ffffa7 	b	ffffffffea80c29c <ipc_port_connect_async+0xfc>
		return ERR_NO_MEMORY;
ffffffffea80c404:	12800095 	mov	w21, #0xfffffffb            	// #-5
ffffffffea80c408:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80c40c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80c410:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c414:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80c418:	17ffffa1 	b	ffffffffea80c29c <ipc_port_connect_async+0xfc>
	ASSERT(chan->peer == NULL);
ffffffffea80c41c:	f0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c420:	f0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c424:	d0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80c428:	913a4084 	add	x4, x4, #0xe90
ffffffffea80c42c:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c430:	913c2042 	add	x2, x2, #0xf08
ffffffffea80c434:	91314021 	add	x1, x1, #0xc50
ffffffffea80c438:	aa1a03e0 	mov	x0, x26
ffffffffea80c43c:	94001851 	bl	ffffffffea812580 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea80c440:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80c444:	17ffff96 	b	ffffffffea80c29c <ipc_port_connect_async+0xfc>
ffffffffea80c448:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80c44c:	f90017b6 	str	x22, [x29, #40]
ffffffffea80c450:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea80c454:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80c458:	f9002fbc 	str	x28, [x29, #88]
}
ffffffffea80c45c:	94001e33 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80c460 <sys_connect>:
#ifndef DEFAULT_IPC_CONNECT_WARN_TIMEOUT
#define DEFAULT_IPC_CONNECT_WARN_TIMEOUT   INFINITE_TIME
#endif

long __SYSCALL sys_connect(user_addr_t path, uint flags)
{
ffffffffea80c460:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
ffffffffea80c464:	910003fd 	mov	x29, sp
ffffffffea80c468:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c46c:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80c470:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80c474:	2a0003f6 	mov	w22, w0
ffffffffea80c478:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80c47c:	2a0103f3 	mov	w19, w1
ffffffffea80c480:	f9400001 	ldr	x1, [x0]
ffffffffea80c484:	f9004fa1 	str	x1, [x29, #152]
ffffffffea80c488:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80c48c:	d538d080 	mrs	x0, tpidr_el1
	uthread_t *ut = uthread_get_current();
	trusty_app_t *tapp = ut->private_data;
ffffffffea80c490:	f9415800 	ldr	x0, [x0, #688]
ffffffffea80c494:	f9404817 	ldr	x23, [x0, #144]
	uctx_t *ctx = current_uctx();
ffffffffea80c498:	97fff936 	bl	ffffffffea80a970 <current_uctx>
	char tmp_path[IPC_PORT_PATH_MAX];
	int ret;
	handle_id_t handle_id;
	uint32_t cur_guest;

	if (flags & ~IPC_CONNECT_MASK) {
ffffffffea80c49c:	721e767f 	tst	w19, #0xfffffffc
ffffffffea80c4a0:	54000841 	b.ne	ffffffffea80c5a8 <sys_connect+0x148>  // b.any
ffffffffea80c4a4:	f90013b5 	str	x21, [x29, #32]
ffffffffea80c4a8:	910163b5 	add	x21, x29, #0x58
ffffffffea80c4ac:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80c4b0:	d2800802 	mov	x2, #0x40                  	// #64
ffffffffea80c4b4:	aa0003f8 	mov	x24, x0
ffffffffea80c4b8:	2a1603e1 	mov	w1, w22
ffffffffea80c4bc:	aa1503e0 	mov	x0, x21
ffffffffea80c4c0:	94001fc4 	bl	ffffffffea8143d0 <arch_strlcpy_from_user>
		/* unsupported flags specified */
		return ERR_INVALID_ARGS;
	}

	ret = (int) strncpy_from_user(tmp_path, path, sizeof(tmp_path));
	if (ret < 0) {
ffffffffea80c4c4:	37f804a0 	tbnz	w0, #31, ffffffffea80c558 <sys_connect+0xf8>
		return (long) ret;
	}
	if ((uint)ret >= sizeof(tmp_path)) {
ffffffffea80c4c8:	7100fc1f 	cmp	w0, #0x3f
ffffffffea80c4cc:	540006a8 	b.hi	ffffffffea80c5a0 <sys_connect+0x140>  // b.pmore
		return (long) ERR_INVALID_ARGS;
	}
	cur_guest = uctx_get_current_guest();
ffffffffea80c4d0:	97fff90e 	bl	ffffffffea80a908 <uctx_get_current_guest>

	ret = ipc_port_connect_async(cur_guest, &tapp->props.uuid,
ffffffffea80c4d4:	910143a5 	add	x5, x29, #0x50
ffffffffea80c4d8:	2a1303e4 	mov	w4, w19
ffffffffea80c4dc:	d2800803 	mov	x3, #0x40                  	// #64
ffffffffea80c4e0:	aa1503e2 	mov	x2, x21
ffffffffea80c4e4:	910082e1 	add	x1, x23, #0x20
ffffffffea80c4e8:	97ffff2e 	bl	ffffffffea80c1a0 <ipc_port_connect_async>
				     tmp_path, sizeof(tmp_path),
				     flags, &chandle);
	if (ret != NO_ERROR) {
ffffffffea80c4ec:	35000360 	cbnz	w0, ffffffffea80c558 <sys_connect+0xf8>
	}
	if (!(flags & IPC_CONNECT_ASYNC)) {
		uint32_t event;
		lk_time_t timeout_msecs = DEFAULT_IPC_CONNECT_WARN_TIMEOUT;

		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80c4f0:	910133b6 	add	x22, x29, #0x4c
ffffffffea80c4f4:	f9402ba0 	ldr	x0, [x29, #80]
	if (!(flags & IPC_CONNECT_ASYNC)) {
ffffffffea80c4f8:	370801d3 	tbnz	w19, #1, ffffffffea80c530 <sys_connect+0xd0>
		ret = handle_wait(chandle, &event, timeout_msecs);
ffffffffea80c4fc:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c500:	aa1603e1 	mov	x1, x22
ffffffffea80c504:	97fff781 	bl	ffffffffea80a308 <handle_wait>
ffffffffea80c508:	2a0003f3 	mov	w19, w0
		if (ret == ERR_TIMED_OUT) {
ffffffffea80c50c:	3100341f 	cmn	w0, #0xd
ffffffffea80c510:	54000500 	b.eq	ffffffffea80c5b0 <sys_connect+0x150>  // b.none
			TRACEF("Timedout connecting to %s\n", tmp_path);
			ret = handle_wait(chandle, &event, INFINITE_TIME);
		}

		if (ret < 0) {
ffffffffea80c514:	37f803b3 	tbnz	w19, #31, ffffffffea80c588 <sys_connect+0x128>
			/* timeout or other error */
			handle_close(chandle);
			return ret;
		}

		if ((event & IPC_HANDLE_POLL_HUP) &&
ffffffffea80c518:	b9404fa3 	ldr	w3, [x29, #76]
ffffffffea80c51c:	121e0460 	and	w0, w3, #0xc
ffffffffea80c520:	7100101f 	cmp	w0, #0x4
ffffffffea80c524:	54000780 	b.eq	ffffffffea80c614 <sys_connect+0x1b4>  // b.none
			/* hangup and no pending messages */
			handle_close(chandle);
			return ERR_CHANNEL_CLOSED;
		}

		if (!(event & IPC_HANDLE_POLL_READY)) {
ffffffffea80c528:	360005e3 	tbz	w3, #0, ffffffffea80c5e4 <sys_connect+0x184>
ffffffffea80c52c:	f9402ba0 	ldr	x0, [x29, #80]
			handle_close(chandle);
			return ERR_NOT_READY;
		}
	}

	ret = uctx_handle_install(ctx, chandle, &handle_id);
ffffffffea80c530:	aa0003e1 	mov	x1, x0
ffffffffea80c534:	aa1603e2 	mov	x2, x22
ffffffffea80c538:	aa1803e0 	mov	x0, x24
ffffffffea80c53c:	97fff96f 	bl	ffffffffea80aaf8 <uctx_handle_install>
ffffffffea80c540:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c544:	35000220 	cbnz	w0, ffffffffea80c588 <sys_connect+0x128>
		/* Failed to install handle into user context */
		handle_close(chandle);
		return (long) ret;
	}

	return (long) handle_id;
ffffffffea80c548:	b9404fa0 	ldr	w0, [x29, #76]
ffffffffea80c54c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c550:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80c554:	14000004 	b	ffffffffea80c564 <sys_connect+0x104>
		return (long) ret;
ffffffffea80c558:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c55c:	93407c00 	sxtw	x0, w0
ffffffffea80c560:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80c564:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80c568:	f9404fa2 	ldr	x2, [x29, #152]
ffffffffea80c56c:	f9400281 	ldr	x1, [x20]
ffffffffea80c570:	ca010041 	eor	x1, x2, x1
ffffffffea80c574:	b50005c1 	cbnz	x1, ffffffffea80c62c <sys_connect+0x1cc>
ffffffffea80c578:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c57c:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80c580:	a8ca7bfd 	ldp	x29, x30, [sp], #160
ffffffffea80c584:	d65f03c0 	ret
		handle_close(chandle);
ffffffffea80c588:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80c58c:	97fff753 	bl	ffffffffea80a2d8 <handle_close>
		return (long) ret;
ffffffffea80c590:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c594:	93407e60 	sxtw	x0, w19
ffffffffea80c598:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80c59c:	17fffff2 	b	ffffffffea80c564 <sys_connect+0x104>
ffffffffea80c5a0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c5a4:	f9401fb8 	ldr	x24, [x29, #56]
		return ERR_INVALID_ARGS;
ffffffffea80c5a8:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80c5ac:	17ffffee 	b	ffffffffea80c564 <sys_connect+0x104>
			TRACEF("Timedout connecting to %s\n", tmp_path);
ffffffffea80c5b0:	aa1503e3 	mov	x3, x21
ffffffffea80c5b4:	528066e2 	mov	w2, #0x337                 	// #823
ffffffffea80c5b8:	f0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c5bc:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c5c0:	91398021 	add	x1, x1, #0xe60
ffffffffea80c5c4:	913d0000 	add	x0, x0, #0xf40
ffffffffea80c5c8:	94001da4 	bl	ffffffffea813c58 <_printf>
			ret = handle_wait(chandle, &event, INFINITE_TIME);
ffffffffea80c5cc:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80c5d0:	12800002 	mov	w2, #0xffffffff            	// #-1
ffffffffea80c5d4:	aa1603e1 	mov	x1, x22
ffffffffea80c5d8:	97fff74c 	bl	ffffffffea80a308 <handle_wait>
ffffffffea80c5dc:	2a0003f3 	mov	w19, w0
ffffffffea80c5e0:	17ffffcd 	b	ffffffffea80c514 <sys_connect+0xb4>
			TRACEF("Unexpected channel state: event = 0x%x\n", event);
ffffffffea80c5e4:	52806942 	mov	w2, #0x34a                 	// #842
ffffffffea80c5e8:	f0000041 	adrp	x1, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c5ec:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c5f0:	91398021 	add	x1, x1, #0xe60
ffffffffea80c5f4:	913da000 	add	x0, x0, #0xf68
ffffffffea80c5f8:	94001d98 	bl	ffffffffea813c58 <_printf>
			handle_close(chandle);
ffffffffea80c5fc:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80c600:	97fff736 	bl	ffffffffea80a2d8 <handle_close>
			return ERR_NOT_READY;
ffffffffea80c604:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c608:	92800040 	mov	x0, #0xfffffffffffffffd    	// #-3
ffffffffea80c60c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80c610:	17ffffd5 	b	ffffffffea80c564 <sys_connect+0x104>
			handle_close(chandle);
ffffffffea80c614:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80c618:	97fff730 	bl	ffffffffea80a2d8 <handle_close>
			return ERR_CHANNEL_CLOSED;
ffffffffea80c61c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c620:	928001c0 	mov	x0, #0xfffffffffffffff1    	// #-15
ffffffffea80c624:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80c628:	17ffffcf 	b	ffffffffea80c564 <sys_connect+0x104>
ffffffffea80c62c:	f90013b5 	str	x21, [x29, #32]
ffffffffea80c630:	f9001fb8 	str	x24, [x29, #56]
}
ffffffffea80c634:	94001dbd 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80c638 <ipc_port_accept>:
/*
 *  Called by user task to accept incomming connection
 */
int ipc_port_accept(handle_t *phandle, handle_t **chandle_ptr,
                    const uuid_t **uuid_ptr)
{
ffffffffea80c638:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80c63c:	910003fd 	mov	x29, sp
ffffffffea80c640:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c644:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80c648:	aa0003f3 	mov	x19, x0
ffffffffea80c64c:	f9402a83 	ldr	x3, [x20, #80]
	ipc_port_t *port;
	ipc_chan_t *server = NULL;
	ipc_chan_t *client = NULL;
	obj_ref_t tmp_server_ref = OBJ_REF_INITIAL_VALUE(tmp_server_ref);
ffffffffea80c650:	a906ffbf 	stp	xzr, xzr, [x29, #104]
{
ffffffffea80c654:	f9400060 	ldr	x0, [x3]
ffffffffea80c658:	f9003fa0 	str	x0, [x29, #120]
ffffffffea80c65c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80c660:	f90027fa 	str	x26, [sp, #72]
	int ret = NO_ERROR;

	DEBUG_ASSERT(chandle_ptr);
	DEBUG_ASSERT(uuid_ptr);

	if (!phandle || !ipc_is_port(phandle)) {
ffffffffea80c664:	b40014b3 	cbz	x19, ffffffffea80c8f8 <ipc_port_accept+0x2c0>
ffffffffea80c668:	f90023b9 	str	x25, [x29, #64]
ffffffffea80c66c:	aa0103f9 	mov	x25, x1
ffffffffea80c670:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80c674:	b0000060 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea80c678:	9138a000 	add	x0, x0, #0xe28
ffffffffea80c67c:	eb00003f 	cmp	x1, x0
ffffffffea80c680:	54000a41 	b.ne	ffffffffea80c7c8 <ipc_port_accept+0x190>  // b.any
ffffffffea80c684:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea80c688:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80c68c:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80c690:	aa1e03f7 	mov	x23, x30
ffffffffea80c694:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80c698:	b0000076 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea80c69c:	aa0203f8 	mov	x24, x2
ffffffffea80c6a0:	9137c2c0 	add	x0, x22, #0xdf0
ffffffffea80c6a4:	97ffe479 	bl	ffffffffea805888 <mutex_acquire_timeout>

	if (port->state != IPC_PORT_STATE_LISTENING) {
		/* Not in listening state: caller should close port.
		 * is it really possible to get here?
		 */
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c6a8:	128001da 	mov	w26, #0xfffffff1            	// #-15
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c6ac:	b85e8260 	ldur	w0, [x19, #-24]
	port = containerof(phandle, ipc_port_t, handle);
ffffffffea80c6b0:	d101827b 	sub	x27, x19, #0x60
	if (port->state != IPC_PORT_STATE_LISTENING) {
ffffffffea80c6b4:	7100041f 	cmp	w0, #0x1
ffffffffea80c6b8:	54000200 	b.eq	ffffffffea80c6f8 <ipc_port_accept+0xc0>  // b.none

err_bad_chan_state:
	chan_del_ref(server, &tmp_server_ref);
err_no_connections:
err_bad_port_state:
	mutex_release(&ipc_lock);
ffffffffea80c6bc:	9137c2c0 	add	x0, x22, #0xdf0
ffffffffea80c6c0:	97ffe49e 	bl	ffffffffea805938 <mutex_release>
	return ret;
ffffffffea80c6c4:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea80c6c8:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea80c6cc:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80c6d0:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80c6d4:	2a1a03e0 	mov	w0, w26
ffffffffea80c6d8:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea80c6dc:	f9400281 	ldr	x1, [x20]
ffffffffea80c6e0:	ca010041 	eor	x1, x2, x1
ffffffffea80c6e4:	b5001221 	cbnz	x1, ffffffffea80c928 <ipc_port_accept+0x2f0>
ffffffffea80c6e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c6ec:	f94027fa 	ldr	x26, [sp, #72]
ffffffffea80c6f0:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80c6f4:	d65f03c0 	ret
ffffffffea80c6f8:	f90013b5 	str	x21, [x29, #32]
	server = list_remove_head_type(&port->pending_list, ipc_chan_t, node);
ffffffffea80c6fc:	91010273 	add	x19, x19, #0x40
	if (list->next != list) {
ffffffffea80c700:	f9405775 	ldr	x21, [x27, #168]
ffffffffea80c704:	eb1302bf 	cmp	x21, x19
ffffffffea80c708:	540005a0 	b.eq	ffffffffea80c7bc <ipc_port_accept+0x184>  // b.none
	item->next->prev = item->prev;
ffffffffea80c70c:	a94002a1 	ldp	x1, x0, [x21]
	item->prev = item->next = 0;
ffffffffea80c710:	aa1503f3 	mov	x19, x21
	if (!server) {
ffffffffea80c714:	f10282bf 	cmp	x21, #0xa0
	item->next->prev = item->prev;
ffffffffea80c718:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c71c:	f94002a1 	ldr	x1, [x21]
ffffffffea80c720:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c724:	f90006bf 	str	xzr, [x21, #8]
ffffffffea80c728:	f816067f 	str	xzr, [x19], #-160
ffffffffea80c72c:	54000480 	b.eq	ffffffffea80c7bc <ipc_port_accept+0x184>  // b.none
	item->prev = list->prev;
ffffffffea80c730:	f85602a0 	ldur	x0, [x21, #-160]
	item->next = list;
ffffffffea80c734:	a906cfa0 	stp	x0, x19, [x29, #104]
	list->prev->next = item;
ffffffffea80c738:	9101a3a0 	add	x0, x29, #0x68
	item->next->prev = item->prev;
ffffffffea80c73c:	f85f02a1 	ldur	x1, [x21, #-16]
	list->prev->next = item;
ffffffffea80c740:	f85602a2 	ldur	x2, [x21, #-160]
ffffffffea80c744:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea80c748:	f81602a0 	stur	x0, [x21, #-160]
	item->next->prev = item->prev;
ffffffffea80c74c:	f85f82a0 	ldur	x0, [x21, #-8]
ffffffffea80c750:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c754:	f85f02a1 	ldur	x1, [x21, #-16]
ffffffffea80c758:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c75c:	a93f7ebf 	stp	xzr, xzr, [x21, #-16]
ffffffffea80c760:	f85682a0 	ldur	x0, [x21, #-152]
ffffffffea80c764:	eb13001f 	cmp	x0, x19
ffffffffea80c768:	54000720 	b.eq	ffffffffea80c84c <ipc_port_accept+0x214>  // b.none
	handle_decref(&port->handle);
ffffffffea80c76c:	91018360 	add	x0, x27, #0x60
ffffffffea80c770:	97fff6b2 	bl	ffffffffea80a238 <handle_decref>
	client = server->peer;
ffffffffea80c774:	f85802bb 	ldur	x27, [x21, #-128]
	if (!client ||
ffffffffea80c778:	b400009b 	cbz	x27, ffffffffea80c788 <ipc_port_accept+0x150>
ffffffffea80c77c:	b85902a0 	ldur	w0, [x21, #-112]
ffffffffea80c780:	7100041f 	cmp	w0, #0x1
ffffffffea80c784:	54000280 	b.eq	ffffffffea80c7d4 <ipc_port_accept+0x19c>  // b.none
		chan_shutdown_locked(server);
ffffffffea80c788:	aa1303e0 	mov	x0, x19
		ret = ERR_CHANNEL_CLOSED;
ffffffffea80c78c:	128001da 	mov	w26, #0xfffffff1            	// #-15
		chan_shutdown_locked(server);
ffffffffea80c790:	97fffb9c 	bl	ffffffffea80b600 <chan_shutdown_locked>
	item->next->prev = item->prev;
ffffffffea80c794:	a94683a1 	ldp	x1, x0, [x29, #104]
ffffffffea80c798:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea80c79c:	f94037a1 	ldr	x1, [x29, #104]
ffffffffea80c7a0:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea80c7a4:	a906ffbf 	stp	xzr, xzr, [x29, #104]
ffffffffea80c7a8:	f85682a0 	ldur	x0, [x21, #-152]
ffffffffea80c7ac:	eb00027f 	cmp	x19, x0
ffffffffea80c7b0:	540006a0 	b.eq	ffffffffea80c884 <ipc_port_accept+0x24c>  // b.none
ffffffffea80c7b4:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c7b8:	17ffffc1 	b	ffffffffea80c6bc <ipc_port_accept+0x84>
		ret = ERR_NO_MSG;
ffffffffea80c7bc:	1280007a 	mov	w26, #0xfffffffc            	// #-4
ffffffffea80c7c0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c7c4:	17ffffbe 	b	ffffffffea80c6bc <ipc_port_accept+0x84>
		return ERR_INVALID_ARGS;
ffffffffea80c7c8:	128000fa 	mov	w26, #0xfffffff8            	// #-8
ffffffffea80c7cc:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80c7d0:	17ffffc0 	b	ffffffffea80c6d0 <ipc_port_accept+0x98>
	    server->state != IPC_CHAN_STATE_ACCEPTING ||
ffffffffea80c7d4:	b9403360 	ldr	w0, [x27, #48]
ffffffffea80c7d8:	7100081f 	cmp	w0, #0x2
ffffffffea80c7dc:	54fffd61 	b.ne	ffffffffea80c788 <ipc_port_accept+0x150>  // b.any
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c7e0:	b9403b60 	ldr	w0, [x27, #56]
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c7e4:	52800061 	mov	w1, #0x3                   	// #3
ffffffffea80c7e8:	f9002fbc 	str	x28, [x29, #88]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c7ec:	9101427c 	add	x28, x19, #0x50
	server->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c7f0:	b81902a1 	stur	w1, [x21, #-112]
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c7f4:	321e0000 	orr	w0, w0, #0x4
	client->state = IPC_CHAN_STATE_CONNECTED;
ffffffffea80c7f8:	b9003361 	str	w1, [x27, #48]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c7fc:	b0000061 	adrp	x1, ffffffffea819000 <_mem_phys_base>
	client->aux_state |= IPC_CHAN_AUX_STATE_CONNECTED;
ffffffffea80c800:	b9003b60 	str	w0, [x27, #56]
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c804:	91374021 	add	x1, x1, #0xdd0
ffffffffea80c808:	aa1c03e0 	mov	x0, x28
	ret = NO_ERROR;
ffffffffea80c80c:	5280001a 	mov	w26, #0x0                   	// #0
	handle_init(&chan->handle, &ipc_chan_handle_ops);
ffffffffea80c810:	97fff674 	bl	ffffffffea80a1e0 <handle_init>
	item->prev = list->prev;
ffffffffea80c814:	f85602a1 	ldur	x1, [x21, #-160]
	list_add_tail(&obj->ref_list, &ref->ref_node);
ffffffffea80c818:	91010260 	add	x0, x19, #0x40
	*uuid_ptr = client->uuid;
ffffffffea80c81c:	f9401762 	ldr	x2, [x27, #40]
	item->next = list;
ffffffffea80c820:	a93a4ea1 	stp	x1, x19, [x21, #-96]
	list->prev->next = item;
ffffffffea80c824:	f9000420 	str	x0, [x1, #8]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c828:	b9408b61 	ldr	w1, [x27, #136]
	list->prev = item;
ffffffffea80c82c:	f81602a0 	stur	x0, [x21, #-160]
	handle_notify(&client->handle);
ffffffffea80c830:	91014360 	add	x0, x27, #0x50
	*chandle_ptr = chan_handle_init(server);
ffffffffea80c834:	f900033c 	str	x28, [x25]
	*uuid_ptr = client->uuid;
ffffffffea80c838:	f9000302 	str	x2, [x24]
	server->handle.guest_id = client->handle.guest_id;
ffffffffea80c83c:	b81e82a1 	stur	w1, [x21, #-24]
	handle_notify(&client->handle);
ffffffffea80c840:	97fff6fa 	bl	ffffffffea80a428 <handle_notify>
ffffffffea80c844:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80c848:	17ffffd3 	b	ffffffffea80c794 <ipc_port_accept+0x15c>
	ASSERT(chan->peer == NULL);
ffffffffea80c84c:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80c850:	b5000580 	cbnz	x0, ffffffffea80c900 <ipc_port_accept+0x2c8>
	if (item->prev == 0 && item->next == 0)
ffffffffea80c854:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c858:	b4000380 	cbz	x0, ffffffffea80c8c8 <ipc_port_accept+0x290>
	ASSERT(!list_in_list(&chan->node));
ffffffffea80c85c:	f0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c860:	f0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c864:	d0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80c868:	913aa084 	add	x4, x4, #0xea8
ffffffffea80c86c:	528032c3 	mov	w3, #0x196                 	// #406
ffffffffea80c870:	913c2042 	add	x2, x2, #0xf08
ffffffffea80c874:	91314021 	add	x1, x1, #0xc50
ffffffffea80c878:	aa1703e0 	mov	x0, x23
ffffffffea80c87c:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80c880:	94001740 	bl	ffffffffea812580 <_panic>
	ASSERT(chan->peer == NULL);
ffffffffea80c884:	f85802a0 	ldur	x0, [x21, #-128]
ffffffffea80c888:	b50003c0 	cbnz	x0, ffffffffea80c900 <ipc_port_accept+0x2c8>
ffffffffea80c88c:	f9405260 	ldr	x0, [x19, #160]
ffffffffea80c890:	b5fffe60 	cbnz	x0, ffffffffea80c85c <ipc_port_accept+0x224>
ffffffffea80c894:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c898:	b5fffe20 	cbnz	x0, ffffffffea80c85c <ipc_port_accept+0x224>
	if (chan->path) {
ffffffffea80c89c:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c8a0:	b4000040 	cbz	x0, ffffffffea80c8a8 <ipc_port_accept+0x270>
		free((void *)chan->path);
ffffffffea80c8a4:	94001d47 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80c8a8:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c8ac:	b4000060 	cbz	x0, ffffffffea80c8b8 <ipc_port_accept+0x280>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c8b0:	94000160 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c8b4:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c8b8:	aa1303e0 	mov	x0, x19
ffffffffea80c8bc:	94001d41 	bl	ffffffffea813dc0 <free>
ffffffffea80c8c0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80c8c4:	17ffff7e 	b	ffffffffea80c6bc <ipc_port_accept+0x84>
ffffffffea80c8c8:	f9405660 	ldr	x0, [x19, #168]
ffffffffea80c8cc:	b5fffc80 	cbnz	x0, ffffffffea80c85c <ipc_port_accept+0x224>
	if (chan->path) {
ffffffffea80c8d0:	f9405e60 	ldr	x0, [x19, #184]
ffffffffea80c8d4:	b4000040 	cbz	x0, ffffffffea80c8dc <ipc_port_accept+0x2a4>
		free((void *)chan->path);
ffffffffea80c8d8:	94001d3a 	bl	ffffffffea813dc0 <free>
	if (chan->msg_queue) {
ffffffffea80c8dc:	f9405a60 	ldr	x0, [x19, #176]
ffffffffea80c8e0:	b4000060 	cbz	x0, ffffffffea80c8ec <ipc_port_accept+0x2b4>
		ipc_msg_queue_destroy(chan->msg_queue);
ffffffffea80c8e4:	94000153 	bl	ffffffffea80ce30 <ipc_msg_queue_destroy>
		chan->msg_queue = NULL;
ffffffffea80c8e8:	f9005a7f 	str	xzr, [x19, #176]
	free(chan);
ffffffffea80c8ec:	aa1303e0 	mov	x0, x19
ffffffffea80c8f0:	94001d34 	bl	ffffffffea813dc0 <free>
ffffffffea80c8f4:	17ffff9e 	b	ffffffffea80c76c <ipc_port_accept+0x134>
		return ERR_INVALID_ARGS;
ffffffffea80c8f8:	128000fa 	mov	w26, #0xfffffff8            	// #-8
ffffffffea80c8fc:	17ffff75 	b	ffffffffea80c6d0 <ipc_port_accept+0x98>
	ASSERT(chan->peer == NULL);
ffffffffea80c900:	f0000044 	adrp	x4, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c904:	f0000042 	adrp	x2, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80c908:	d0000041 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea80c90c:	913a4084 	add	x4, x4, #0xe90
ffffffffea80c910:	52803263 	mov	w3, #0x193                 	// #403
ffffffffea80c914:	913c2042 	add	x2, x2, #0xf08
ffffffffea80c918:	91314021 	add	x1, x1, #0xc50
ffffffffea80c91c:	aa1703e0 	mov	x0, x23
ffffffffea80c920:	f9002fbc 	str	x28, [x29, #88]
ffffffffea80c924:	94001717 	bl	ffffffffea812580 <_panic>
ffffffffea80c928:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80c92c:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80c930:	f90023b9 	str	x25, [x29, #64]
ffffffffea80c934:	a90573bb 	stp	x27, x28, [x29, #80]
}
ffffffffea80c938:	94001cfc 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80c93c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80c940 <sys_accept>:

long __SYSCALL sys_accept(uint32_t handle_id, user_addr_t user_uuid)
{
ffffffffea80c940:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80c944:	910003fd 	mov	x29, sp
ffffffffea80c948:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80c94c:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80c950:	2a0003f3 	mov	w19, w0
ffffffffea80c954:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80c958:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80c95c:	2a0103f6 	mov	w22, w1
ffffffffea80c960:	f9400001 	ldr	x1, [x0]
ffffffffea80c964:	f90037a1 	str	x1, [x29, #104]
ffffffffea80c968:	d2800001 	mov	x1, #0x0                   	// #0
	uctx_t *ctx = current_uctx();
ffffffffea80c96c:	97fff801 	bl	ffffffffea80a970 <current_uctx>
	handle_t *phandle = NULL;
	handle_t *chandle = NULL;
ffffffffea80c970:	a9057fbf 	stp	xzr, xzr, [x29, #80]
	uctx_t *ctx = current_uctx();
ffffffffea80c974:	aa0003f5 	mov	x21, x0
	int ret;
	handle_id_t new_id;
	const uuid_t *peer_uuid_ptr;

	ret = uctx_handle_get(ctx, handle_id, &phandle);
ffffffffea80c978:	910143a2 	add	x2, x29, #0x50
ffffffffea80c97c:	2a1303e1 	mov	w1, w19
ffffffffea80c980:	97fff890 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (ret != NO_ERROR) {
ffffffffea80c984:	34000160 	cbz	w0, ffffffffea80c9b0 <sys_accept+0x70>
		return (long) ret;
ffffffffea80c988:	93407c00 	sxtw	x0, w0
err_install:
	handle_close(chandle);
err_accept:
	handle_decref(phandle);
	return (long) ret;
}
ffffffffea80c98c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80c990:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80c994:	f9400281 	ldr	x1, [x20]
ffffffffea80c998:	ca010041 	eor	x1, x2, x1
ffffffffea80c99c:	b5000521 	cbnz	x1, ffffffffea80ca40 <sys_accept+0x100>
ffffffffea80c9a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80c9a4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80c9a8:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80c9ac:	d65f03c0 	ret
	ret = ipc_port_accept(phandle, &chandle, &peer_uuid_ptr);
ffffffffea80c9b0:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80c9b4:	910183a2 	add	x2, x29, #0x60
ffffffffea80c9b8:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80c9bc:	910163b7 	add	x23, x29, #0x58
ffffffffea80c9c0:	aa1703e1 	mov	x1, x23
ffffffffea80c9c4:	97ffff1d 	bl	ffffffffea80c638 <ipc_port_accept>
ffffffffea80c9c8:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c9cc:	35000260 	cbnz	w0, ffffffffea80ca18 <sys_accept+0xd8>
	ret = uctx_handle_install(ctx, chandle, &new_id);
ffffffffea80c9d0:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80c9d4:	910133a2 	add	x2, x29, #0x4c
ffffffffea80c9d8:	aa1503e0 	mov	x0, x21
ffffffffea80c9dc:	97fff847 	bl	ffffffffea80aaf8 <uctx_handle_install>
ffffffffea80c9e0:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c9e4:	35000160 	cbnz	w0, ffffffffea80ca10 <sys_accept+0xd0>
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80c9e8:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80c9ec:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80c9f0:	2a1603e0 	mov	w0, w22
ffffffffea80c9f4:	94001e67 	bl	ffffffffea814390 <arch_copy_to_user>
ffffffffea80c9f8:	2a0003f3 	mov	w19, w0
	if (ret != NO_ERROR) {
ffffffffea80c9fc:	34000180 	cbz	w0, ffffffffea80ca2c <sys_accept+0xec>
	uctx_handle_remove(ctx, new_id, &chandle);
ffffffffea80ca00:	b9404fa1 	ldr	w1, [x29, #76]
ffffffffea80ca04:	aa1703e2 	mov	x2, x23
ffffffffea80ca08:	aa1503e0 	mov	x0, x21
ffffffffea80ca0c:	97fff883 	bl	ffffffffea80ac18 <uctx_handle_remove>
	handle_close(chandle);
ffffffffea80ca10:	f9402fa0 	ldr	x0, [x29, #88]
ffffffffea80ca14:	97fff631 	bl	ffffffffea80a2d8 <handle_close>
	handle_decref(phandle);
ffffffffea80ca18:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80ca1c:	97fff607 	bl	ffffffffea80a238 <handle_decref>
	return (long) ret;
ffffffffea80ca20:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80ca24:	93407e60 	sxtw	x0, w19
ffffffffea80ca28:	17ffffd9 	b	ffffffffea80c98c <sys_accept+0x4c>
	handle_decref(phandle);
ffffffffea80ca2c:	f9402ba0 	ldr	x0, [x29, #80]
ffffffffea80ca30:	97fff602 	bl	ffffffffea80a238 <handle_decref>
	return (long) new_id;
ffffffffea80ca34:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80ca38:	b9404fa0 	ldr	w0, [x29, #76]
ffffffffea80ca3c:	17ffffd4 	b	ffffffffea80c98c <sys_accept+0x4c>
ffffffffea80ca40:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea80ca44:	94001cb9 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80ca48 <msg_get_filled_locked>:
	if (list->next != list) {
ffffffffea80ca48:	f9400c01 	ldr	x1, [x0, #24]
 */
static void msg_get_filled_locked(ipc_msg_queue_t *mq)
{
	msg_item_t *item;

	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80ca4c:	91004002 	add	x2, x0, #0x10
ffffffffea80ca50:	f100003f 	cmp	x1, #0x0
ffffffffea80ca54:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80ca58:	540001e0 	b.eq	ffffffffea80ca94 <msg_get_filled_locked+0x4c>  // b.none
	item->next->prev = item->prev;
ffffffffea80ca5c:	a9401026 	ldp	x6, x4, [x1]
	item->prev = list->prev;
ffffffffea80ca60:	aa0003e3 	mov	x3, x0
	DEBUG_ASSERT(item);

	list_delete(&item->node);
	list_add_tail(&mq->read_list, &item->node);
	item->state = MSG_ITEM_STATE_READ;
ffffffffea80ca64:	52800045 	mov	w5, #0x2                   	// #2
	item->next->prev = item->prev;
ffffffffea80ca68:	f9000086 	str	x6, [x4]
	item->prev->next = item->next;
ffffffffea80ca6c:	f9400026 	ldr	x6, [x1]
ffffffffea80ca70:	f90004c4 	str	x4, [x6, #8]
	item->prev = item->next = 0;
ffffffffea80ca74:	f900003f 	str	xzr, [x1]
	item->prev = list->prev;
ffffffffea80ca78:	f8420c64 	ldr	x4, [x3, #32]!
	item->next = list;
ffffffffea80ca7c:	a9000c24 	stp	x4, x3, [x1]
	list->prev->next = item;
ffffffffea80ca80:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80ca84:	f9000441 	str	x1, [x2, #8]
	list->prev = item;
ffffffffea80ca88:	f9001001 	str	x1, [x0, #32]
ffffffffea80ca8c:	381d1025 	sturb	w5, [x1, #-47]
}
ffffffffea80ca90:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea80ca94:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80ca98:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea80ca9c:	d4207d00 	brk	#0x3e8

ffffffffea80caa0 <check_channel_connected_locked>:
	if (unlikely(!chandle)) {
ffffffffea80caa0:	b4000300 	cbz	x0, ffffffffea80cb00 <check_channel_connected_locked+0x60>
{
ffffffffea80caa4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80caa8:	910003fd 	mov	x29, sp
ffffffffea80caac:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80cab0:	aa0003f3 	mov	x19, x0
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80cab4:	97fffc55 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80cab8:	72001c1f 	tst	w0, #0xff
ffffffffea80cabc:	54000100 	b.eq	ffffffffea80cadc <check_channel_connected_locked+0x3c>  // b.none
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80cac0:	b85e0261 	ldur	w1, [x19, #-32]
		return NO_ERROR;
ffffffffea80cac4:	52800000 	mov	w0, #0x0                   	// #0
	if (likely(chan->state == IPC_CHAN_STATE_CONNECTED)) {
ffffffffea80cac8:	71000c3f 	cmp	w1, #0x3
ffffffffea80cacc:	54000101 	b.ne	ffffffffea80caec <check_channel_connected_locked+0x4c>  // b.any
}
ffffffffea80cad0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cad4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80cad8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80cadc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80cae0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80cae4:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80cae8:	d65f03c0 	ret
		return ERR_NOT_READY;
ffffffffea80caec:	7100103f 	cmp	w1, #0x4
ffffffffea80caf0:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80caf4:	12800041 	mov	w1, #0xfffffffd            	// #-3
ffffffffea80caf8:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea80cafc:	17fffff5 	b	ffffffffea80cad0 <check_channel_connected_locked+0x30>
		return ERR_INVALID_ARGS;
ffffffffea80cb00:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80cb04:	d65f03c0 	ret

ffffffffea80cb08 <msg_write_locked>:
{
ffffffffea80cb08:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cb0c:	910003fd 	mov	x29, sp
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80cb10:	f9401002 	ldr	x2, [x0, #32]
{
ffffffffea80cb14:	a90153f3 	stp	x19, x20, [sp, #16]
	ipc_msg_queue_t *mq = chan->peer->msg_queue;
ffffffffea80cb18:	f9405854 	ldr	x20, [x2, #176]
	if (list->next != list) {
ffffffffea80cb1c:	f9400693 	ldr	x19, [x20, #8]
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80cb20:	f100027f 	cmp	x19, #0x0
ffffffffea80cb24:	fa531284 	ccmp	x20, x19, #0x4, ne  // ne = any
ffffffffea80cb28:	54000740 	b.eq	ffffffffea80cc10 <msg_write_locked+0x108>  // b.none
ffffffffea80cb2c:	f90013b5 	str	x21, [x29, #32]
	if (item == NULL) {
ffffffffea80cb30:	f100c27f 	cmp	x19, #0x30
	item = list_peek_head_type(&mq->free_list, msg_item_t, node);
ffffffffea80cb34:	d100c275 	sub	x21, x19, #0x30
	if (item == NULL) {
ffffffffea80cb38:	540006a0 	b.eq	ffffffffea80cc0c <msg_write_locked+0x104>  // b.none
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80cb3c:	b9400023 	ldr	w3, [x1]
ffffffffea80cb40:	aa0103e2 	mov	x2, x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80cb44:	f9402284 	ldr	x4, [x20, #64]
	item->len = 0;
ffffffffea80cb48:	f81f827f 	stur	xzr, [x19, #-8]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80cb4c:	7100047f 	cmp	w3, #0x1
	return mq->buf + item->id * mq->item_sz;
ffffffffea80cb50:	385d0260 	ldurb	w0, [x19, #-48]
	uint8_t *buf = msg_queue_get_buf(mq, item);
ffffffffea80cb54:	f9401e81 	ldr	x1, [x20, #56]
	item->num_handles = 0;
ffffffffea80cb58:	b81d427f 	stur	wzr, [x19, #-44]
	return mq->buf + item->id * mq->item_sz;
ffffffffea80cb5c:	9b011000 	madd	x0, x0, x1, x4
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80cb60:	54000380 	b.eq	ffffffffea80cbd0 <msg_write_locked+0xc8>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80cb64:	35000603 	cbnz	w3, ffffffffea80cc24 <msg_write_locked+0x11c>
		if (msg->user.num_handles) {
ffffffffea80cb68:	b9401043 	ldr	w3, [x2, #16]
ffffffffea80cb6c:	350004a3 	cbnz	w3, ffffffffea80cc00 <msg_write_locked+0xf8>
		ret = user_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80cb70:	29410843 	ldp	w3, w2, [x2, #8]
ffffffffea80cb74:	94000385 	bl	ffffffffea80d988 <user_iovec_to_membuf>
ffffffffea80cb78:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80cb7c:	b7f80380 	tbnz	x0, #63, ffffffffea80cbec <msg_write_locked+0xe4>
	item->next->prev = item->prev;
ffffffffea80cb80:	a9430ea5 	ldp	x5, x3, [x21, #48]
	item->len = (size_t) ret;
ffffffffea80cb84:	f81f8260 	stur	x0, [x19, #-8]
	item->prev = list->prev;
ffffffffea80cb88:	aa1403e1 	mov	x1, x20
	list_delete(&item->node);
ffffffffea80cb8c:	9100c2a0 	add	x0, x21, #0x30
	item->state = MSG_ITEM_STATE_FILLED;
ffffffffea80cb90:	52800024 	mov	w4, #0x1                   	// #1
	item->next->prev = item->prev;
ffffffffea80cb94:	f9000065 	str	x5, [x3]
	item->prev->next = item->next;
ffffffffea80cb98:	f9401aa5 	ldr	x5, [x21, #48]
ffffffffea80cb9c:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea80cba0:	f9001abf 	str	xzr, [x21, #48]
	item->prev = list->prev;
ffffffffea80cba4:	f8410c23 	ldr	x3, [x1, #16]!
	item->next = list;
ffffffffea80cba8:	a90306a3 	stp	x3, x1, [x21, #48]
	list->prev->next = item;
ffffffffea80cbac:	f9400a81 	ldr	x1, [x20, #16]
ffffffffea80cbb0:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea80cbb4:	f9000a80 	str	x0, [x20, #16]
ffffffffea80cbb8:	381d1264 	sturb	w4, [x19, #-47]
	return item->len;
ffffffffea80cbbc:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80cbc0:	2a0203e0 	mov	w0, w2
ffffffffea80cbc4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cbc8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cbcc:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80cbd0:	b9401843 	ldr	w3, [x2, #24]
ffffffffea80cbd4:	35000163 	cbnz	w3, ffffffffea80cc00 <msg_write_locked+0xf8>
		ret = kern_iovec_to_membuf(buf, mq->item_sz,
ffffffffea80cbd8:	b9400843 	ldr	w3, [x2, #8]
ffffffffea80cbdc:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80cbe0:	940002ce 	bl	ffffffffea80d718 <kern_iovec_to_membuf>
ffffffffea80cbe4:	2a0003e2 	mov	w2, w0
	if (ret < 0) {
ffffffffea80cbe8:	b6fffcc0 	tbz	x0, #63, ffffffffea80cb80 <msg_write_locked+0x78>
ffffffffea80cbec:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea80cbf0:	2a0203e0 	mov	w0, w2
ffffffffea80cbf4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cbf8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cbfc:	d65f03c0 	ret
			return ERR_NOT_SUPPORTED;
ffffffffea80cc00:	128002e2 	mov	w2, #0xffffffe8            	// #-24
ffffffffea80cc04:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80cc08:	17ffffee 	b	ffffffffea80cbc0 <msg_write_locked+0xb8>
ffffffffea80cc0c:	f94013b5 	ldr	x21, [x29, #32]
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80cc10:	b9403801 	ldr	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80cc14:	12800102 	mov	w2, #0xfffffff7            	// #-9
		chan->aux_state |= IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80cc18:	32000021 	orr	w1, w1, #0x1
ffffffffea80cc1c:	b9003801 	str	w1, [x0, #56]
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80cc20:	17ffffe8 	b	ffffffffea80cbc0 <msg_write_locked+0xb8>
		return ERR_INVALID_ARGS;
ffffffffea80cc24:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80cc28:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80cc2c:	17ffffe5 	b	ffffffffea80cbc0 <msg_write_locked+0xb8>

ffffffffea80cc30 <msg_read_locked>:
	if (id < mq->num_items) {
ffffffffea80cc30:	b9403004 	ldr	w4, [x0, #48]
ffffffffea80cc34:	6b04003f 	cmp	w1, w4
ffffffffea80cc38:	54000702 	b.cs	ffffffffea80cd18 <msg_read_locked+0xe8>  // b.hs, b.nlast
{
ffffffffea80cc3c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80cc40:	910003fd 	mov	x29, sp
ffffffffea80cc44:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80cc48:	2a0103f3 	mov	w19, w1
ffffffffea80cc4c:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80cc50:	aa0003f4 	mov	x20, x0
ffffffffea80cc54:	2a0203f6 	mov	w22, w2
ffffffffea80cc58:	aa0303f5 	mov	x21, x3
		platform_arch_speculation_barrier();
ffffffffea80cc5c:	97ffd571 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
		return &mq->items[id];
ffffffffea80cc60:	2a1303e1 	mov	w1, w19
ffffffffea80cc64:	8b011a80 	add	x0, x20, x1, lsl #6
ffffffffea80cc68:	d37ae421 	lsl	x1, x1, #6
ffffffffea80cc6c:	91012021 	add	x1, x1, #0x48
	if (item->state != MSG_ITEM_STATE_READ) {
ffffffffea80cc70:	39412402 	ldrb	w2, [x0, #73]
ffffffffea80cc74:	7100085f 	cmp	w2, #0x2
ffffffffea80cc78:	54000421 	b.ne	ffffffffea80ccfc <msg_read_locked+0xcc>  // b.any
	if (item->num_handles) {
ffffffffea80cc7c:	b9404c02 	ldr	w2, [x0, #76]
ffffffffea80cc80:	35000482 	cbnz	w2, ffffffffea80cd10 <msg_read_locked+0xe0>
	if (offset > item->len) {
ffffffffea80cc84:	f9403803 	ldr	x3, [x0, #112]
ffffffffea80cc88:	2a1603e0 	mov	w0, w22
ffffffffea80cc8c:	eb03001f 	cmp	x0, x3
ffffffffea80cc90:	54000368 	b.hi	ffffffffea80ccfc <msg_read_locked+0xcc>  // b.pmore
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80cc94:	a9438a85 	ldp	x5, x2, [x20, #56]
	size_t bytes_left = item->len - offset;
ffffffffea80cc98:	cb000063 	sub	x3, x3, x0
	return mq->buf + item->id * mq->item_sz;
ffffffffea80cc9c:	38616a81 	ldrb	w1, [x20, x1]
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80cca0:	b94002a4 	ldr	w4, [x21]
ffffffffea80cca4:	7100049f 	cmp	w4, #0x1
	const uint8_t *buf = msg_queue_get_buf(mq, item) + offset;
ffffffffea80cca8:	9b050020 	madd	x0, x1, x5, x0
ffffffffea80ccac:	8b000042 	add	x2, x2, x0
	if (msg->type == IPC_MSG_BUFFER_KERNEL) {
ffffffffea80ccb0:	54000140 	b.eq	ffffffffea80ccd8 <msg_read_locked+0xa8>  // b.none
	} else if (msg->type == IPC_MSG_BUFFER_USER) {
ffffffffea80ccb4:	35000244 	cbnz	w4, ffffffffea80ccfc <msg_read_locked+0xcc>
		if (msg->user.num_handles) {
ffffffffea80ccb8:	b94012a0 	ldr	w0, [x21, #16]
ffffffffea80ccbc:	350002a0 	cbnz	w0, ffffffffea80cd10 <msg_read_locked+0xe0>
		return membuf_to_user_iovec(msg->user.iov, msg->user.num_iov,
ffffffffea80ccc0:	294102a1 	ldp	w1, w0, [x21, #8]
ffffffffea80ccc4:	940002db 	bl	ffffffffea80d830 <membuf_to_user_iovec>
}
ffffffffea80ccc8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cccc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ccd0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ccd4:	d65f03c0 	ret
		if (msg->kern.num_handles) {
ffffffffea80ccd8:	b9401aa0 	ldr	w0, [x21, #24]
ffffffffea80ccdc:	350001a0 	cbnz	w0, ffffffffea80cd10 <msg_read_locked+0xe0>
		return membuf_to_kern_iovec((const iovec_kern_t *)msg->kern.iov,
ffffffffea80cce0:	b9400aa1 	ldr	w1, [x21, #8]
ffffffffea80cce4:	f9400aa0 	ldr	x0, [x21, #16]
ffffffffea80cce8:	94000246 	bl	ffffffffea80d600 <membuf_to_kern_iovec>
}
ffffffffea80ccec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ccf0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80ccf4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ccf8:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80ccfc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80cd00:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cd04:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80cd08:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80cd0c:	d65f03c0 	ret
		return ERR_NOT_SUPPORTED;
ffffffffea80cd10:	128002e0 	mov	w0, #0xffffffe8            	// #-24
ffffffffea80cd14:	17ffffed 	b	ffffffffea80ccc8 <msg_read_locked+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80cd18:	128000e0 	mov	w0, #0xfffffff8            	// #-8
}
ffffffffea80cd1c:	d65f03c0 	ret

ffffffffea80cd20 <ipc_msg_queue_create>:
{
ffffffffea80cd20:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80cd24:	910003fd 	mov	x29, sp
ffffffffea80cd28:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea80cd2c:	2a0003f7 	mov	w23, w0
ffffffffea80cd30:	aa0103f6 	mov	x22, x1
ffffffffea80cd34:	f9000ff4 	str	x20, [sp, #24]
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80cd38:	d37a7ee1 	ubfiz	x1, x23, #6, #32
ffffffffea80cd3c:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea80cd40:	91012021 	add	x1, x1, #0x48
{
ffffffffea80cd44:	aa0203f4 	mov	x20, x2
	tmp_mq = calloc(1, (sizeof(ipc_msg_queue_t) +
ffffffffea80cd48:	94001c0e 	bl	ffffffffea813d80 <calloc>
	if (!tmp_mq) {
ffffffffea80cd4c:	b4000560 	cbz	x0, ffffffffea80cdf8 <ipc_msg_queue_create+0xd8>
ffffffffea80cd50:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80cd54:	aa0003f3 	mov	x19, x0
	tmp_mq->buf = malloc(num_items * item_sz);
ffffffffea80cd58:	9b167ee0 	mul	x0, x23, x22
ffffffffea80cd5c:	94001c03 	bl	ffffffffea813d68 <malloc>
ffffffffea80cd60:	f9002260 	str	x0, [x19, #64]
	if (!tmp_mq->buf) {
ffffffffea80cd64:	b4000540 	cbz	x0, ffffffffea80ce0c <ipc_msg_queue_create+0xec>
ffffffffea80cd68:	f90013b5 	str	x21, [x29, #32]
	list_initialize(&tmp_mq->filled_list);
ffffffffea80cd6c:	91004261 	add	x1, x19, #0x10
	list_initialize(&tmp_mq->read_list);
ffffffffea80cd70:	91008260 	add	x0, x19, #0x20
	list->prev = list->next = list;
ffffffffea80cd74:	a9004e73 	stp	x19, x19, [x19]
ffffffffea80cd78:	a9010661 	stp	x1, x1, [x19, #16]
ffffffffea80cd7c:	aa1703f5 	mov	x21, x23
ffffffffea80cd80:	a9020260 	stp	x0, x0, [x19, #32]
	tmp_mq->num_items = num_items;
ffffffffea80cd84:	b9003277 	str	w23, [x19, #48]
	tmp_mq->item_sz = item_sz;
ffffffffea80cd88:	f9001e76 	str	x22, [x19, #56]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80cd8c:	34000277 	cbz	w23, ffffffffea80cdd8 <ipc_msg_queue_create+0xb8>
ffffffffea80cd90:	9101e260 	add	x0, x19, #0x78
ffffffffea80cd94:	aa1303e2 	mov	x2, x19
ffffffffea80cd98:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea80cd9c:	14000002 	b	ffffffffea80cda4 <ipc_msg_queue_create+0x84>
ffffffffea80cda0:	2a0403e3 	mov	w3, w4
		tmp_mq->items[i].id = i;
ffffffffea80cda4:	381d0003 	sturb	w3, [x0, #-48]
	for (uint i = 0; i < num_items; i++) {
ffffffffea80cda8:	11000464 	add	w4, w3, #0x1
	item->next = list;
ffffffffea80cdac:	a9004c02 	stp	x2, x19, [x0]
ffffffffea80cdb0:	6b0402bf 	cmp	w21, w4
	list->prev->next = item;
ffffffffea80cdb4:	f9000440 	str	x0, [x2, #8]
ffffffffea80cdb8:	aa0003e2 	mov	x2, x0
ffffffffea80cdbc:	91010000 	add	x0, x0, #0x40
ffffffffea80cdc0:	54ffff01 	b.ne	ffffffffea80cda0 <ipc_msg_queue_create+0x80>  // b.any
ffffffffea80cdc4:	d37a7c60 	ubfiz	x0, x3, #6, #32
ffffffffea80cdc8:	9101e000 	add	x0, x0, #0x78
ffffffffea80cdcc:	8b000260 	add	x0, x19, x0
ffffffffea80cdd0:	f9000260 	str	x0, [x19]
ffffffffea80cdd4:	d503201f 	nop
	return 0;
ffffffffea80cdd8:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80cddc:	52800000 	mov	w0, #0x0                   	// #0
	*mq = tmp_mq;
ffffffffea80cde0:	f9000293 	str	x19, [x20]
	return 0;
ffffffffea80cde4:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea80cde8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80cdec:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea80cdf0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80cdf4:	d65f03c0 	ret
		dprintf(CRITICAL, "cannot allocate memory for message queue\n");
ffffffffea80cdf8:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80cdfc:	913e6000 	add	x0, x0, #0xf98
ffffffffea80ce00:	94001558 	bl	ffffffffea812360 <_dprintf>
		return ERR_NO_MEMORY;
ffffffffea80ce04:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80ce08:	17fffff8 	b	ffffffffea80cde8 <ipc_msg_queue_create+0xc8>
		dprintf(CRITICAL,
ffffffffea80ce0c:	f0000040 	adrp	x0, ffffffffea817000 <__PRETTY_FUNCTION__.1639>
ffffffffea80ce10:	913f2000 	add	x0, x0, #0xfc8
ffffffffea80ce14:	94001553 	bl	ffffffffea812360 <_dprintf>
	free(tmp_mq);
ffffffffea80ce18:	aa1303e0 	mov	x0, x19
ffffffffea80ce1c:	94001be9 	bl	ffffffffea813dc0 <free>
	return ret;
ffffffffea80ce20:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea80ce24:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80ce28:	17fffff0 	b	ffffffffea80cde8 <ipc_msg_queue_create+0xc8>
ffffffffea80ce2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ce30 <ipc_msg_queue_destroy>:
{
ffffffffea80ce30:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80ce34:	910003fd 	mov	x29, sp
ffffffffea80ce38:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80ce3c:	aa0003f3 	mov	x19, x0
	free(mq->buf);
ffffffffea80ce40:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80ce44:	94001bdf 	bl	ffffffffea813dc0 <free>
	free(mq);
ffffffffea80ce48:	aa1303e0 	mov	x0, x19
}
ffffffffea80ce4c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80ce50:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(mq);
ffffffffea80ce54:	14001bdb 	b	ffffffffea813dc0 <free>

ffffffffea80ce58 <ipc_msg_queue_is_empty>:
	return list_is_empty(&mq->filled_list);
ffffffffea80ce58:	91004001 	add	x1, x0, #0x10
	return (list->next == list) ? true : false;
ffffffffea80ce5c:	f9400c00 	ldr	x0, [x0, #24]
ffffffffea80ce60:	eb01001f 	cmp	x0, x1
}
ffffffffea80ce64:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea80ce68:	d65f03c0 	ret
ffffffffea80ce6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ce70 <sys_send_msg>:
	return NO_ERROR;
}


long __SYSCALL sys_send_msg(uint32_t handle_id, user_addr_t user_msg)
{
ffffffffea80ce70:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80ce74:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80ce78:	910003fd 	mov	x29, sp
ffffffffea80ce7c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ce80:	d00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80ce84:	2a0003f3 	mov	w19, w0
ffffffffea80ce88:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80ce8c:	f9400003 	ldr	x3, [x0]
ffffffffea80ce90:	f9003fa3 	str	x3, [x29, #120]
ffffffffea80ce94:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea80ce98:	f90013f5 	str	x21, [sp, #32]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* copy message descriptor from user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80ce9c:	910203b5 	add	x21, x29, #0x80
ffffffffea80cea0:	b81d0ebf 	str	wzr, [x21, #-48]!
ffffffffea80cea4:	910022a0 	add	x0, x21, #0x8
ffffffffea80cea8:	94001d42 	bl	ffffffffea8143b0 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80ceac:	35000560 	cbnz	w0, ffffffffea80cf58 <sys_send_msg+0xe8>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80ceb0:	97fff6b0 	bl	ffffffffea80a970 <current_uctx>
ffffffffea80ceb4:	910123a2 	add	x2, x29, #0x48
ffffffffea80ceb8:	2a1303e1 	mov	w1, w19
ffffffffea80cebc:	97fff741 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80cec0:	350004c0 	cbnz	w0, ffffffffea80cf58 <sys_send_msg+0xe8>
ffffffffea80cec4:	f90017b6 	str	x22, [x29, #40]
ffffffffea80cec8:	d00002b6 	adrp	x22, ffffffffea862000 <__ctor_list>
ffffffffea80cecc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ced0:	f940a2c0 	ldr	x0, [x22, #320]
ffffffffea80ced4:	97ffe26d 	bl	ffffffffea805888 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if it is  avalid channel to call send_msg */
	ret = check_channel_connected_locked(chandle);
ffffffffea80ced8:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80cedc:	97fffef1 	bl	ffffffffea80caa0 <check_channel_connected_locked>
ffffffffea80cee0:	2a0003f3 	mov	w19, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80cee4:	35000120 	cbnz	w0, ffffffffea80cf08 <sys_send_msg+0x98>
ffffffffea80cee8:	f9001bb7 	str	x23, [x29, #48]
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* do write message to target channel  */
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80ceec:	aa1503e1 	mov	x1, x21
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80cef0:	f94027b7 	ldr	x23, [x29, #72]
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80cef4:	d10142e0 	sub	x0, x23, #0x50
ffffffffea80cef8:	97ffff04 	bl	ffffffffea80cb08 <msg_write_locked>
ffffffffea80cefc:	2a0003f3 	mov	w19, w0
		if (ret >= 0) {
ffffffffea80cf00:	36f80220 	tbz	w0, #31, ffffffffea80cf44 <sys_send_msg+0xd4>
ffffffffea80cf04:	f9401bb7 	ldr	x23, [x29, #48]
			/* and notify target */
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80cf08:	f940a2c0 	ldr	x0, [x22, #320]
ffffffffea80cf0c:	97ffe28b 	bl	ffffffffea805938 <mutex_release>
	handle_decref(chandle);
ffffffffea80cf10:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80cf14:	97fff4c9 	bl	ffffffffea80a238 <handle_decref>
	return (long) ret;
ffffffffea80cf18:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80cf1c:	93407e60 	sxtw	x0, w19
}
ffffffffea80cf20:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80cf24:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea80cf28:	f9400281 	ldr	x1, [x20]
ffffffffea80cf2c:	ca010041 	eor	x1, x2, x1
ffffffffea80cf30:	b5000181 	cbnz	x1, ffffffffea80cf60 <sys_send_msg+0xf0>
ffffffffea80cf34:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80cf38:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80cf3c:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80cf40:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80cf44:	f85d02e0 	ldur	x0, [x23, #-48]
ffffffffea80cf48:	91014000 	add	x0, x0, #0x50
ffffffffea80cf4c:	97fff537 	bl	ffffffffea80a428 <handle_notify>
ffffffffea80cf50:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80cf54:	17ffffed 	b	ffffffffea80cf08 <sys_send_msg+0x98>
		return (long) ret;
ffffffffea80cf58:	93407c00 	sxtw	x0, w0
ffffffffea80cf5c:	17fffff1 	b	ffffffffea80cf20 <sys_send_msg+0xb0>
ffffffffea80cf60:	a902dfb6 	stp	x22, x23, [x29, #40]
}
ffffffffea80cf64:	94001b71 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80cf68 <ipc_send_msg>:

int ipc_send_msg(handle_t *chandle, ipc_msg_kern_t *msg)
{
ffffffffea80cf68:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80cf6c:	910003fd 	mov	x29, sp
ffffffffea80cf70:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80cf74:	d00002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80cf78:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80cf7c:	aa0003f6 	mov	x22, x0
ffffffffea80cf80:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea80cf84:	f9400002 	ldr	x2, [x0]
ffffffffea80cf88:	f90037a2 	str	x2, [x29, #104]
ffffffffea80cf8c:	d2800002 	mov	x2, #0x0                   	// #0
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80cf90:	b4000501 	cbz	x1, ffffffffea80d030 <ipc_send_msg+0xc8>
ffffffffea80cf94:	f9000fb4 	str	x20, [x29, #24]
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80cf98:	9101c3b4 	add	x20, x29, #0x70
ffffffffea80cf9c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80cfa0:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80cfa4:	d00002b7 	adrp	x23, ffffffffea862000 <__ctor_list>
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80cfa8:	d2800402 	mov	x2, #0x20                  	// #32
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80cfac:	b81d0e80 	str	w0, [x20, #-48]!
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80cfb0:	91002280 	add	x0, x20, #0x8
ffffffffea80cfb4:	94001b85 	bl	ffffffffea813dc8 <memcpy>
ffffffffea80cfb8:	f940a2e0 	ldr	x0, [x23, #320]
ffffffffea80cfbc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80cfc0:	97ffe232 	bl	ffffffffea805888 <mutex_acquire_timeout>

	mutex_acquire(&ipc_lock);
	ret = check_channel_connected_locked(chandle);
ffffffffea80cfc4:	aa1603e0 	mov	x0, x22
ffffffffea80cfc8:	97fffeb6 	bl	ffffffffea80caa0 <check_channel_connected_locked>
ffffffffea80cfcc:	2a0003f5 	mov	w21, w0
	if (likely(ret == NO_ERROR)) {
ffffffffea80cfd0:	350000c0 	cbnz	w0, ffffffffea80cfe8 <ipc_send_msg+0x80>
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_write_locked(chan, &tmp_msg);
ffffffffea80cfd4:	aa1403e1 	mov	x1, x20
ffffffffea80cfd8:	d10142c0 	sub	x0, x22, #0x50
ffffffffea80cfdc:	97fffecb 	bl	ffffffffea80cb08 <msg_write_locked>
ffffffffea80cfe0:	2a0003f5 	mov	w21, w0
		if (ret >= 0) {
ffffffffea80cfe4:	36f801e0 	tbz	w0, #31, ffffffffea80d020 <ipc_send_msg+0xb8>
			handle_notify(&chan->peer->handle);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80cfe8:	f940a2e0 	ldr	x0, [x23, #320]
ffffffffea80cfec:	97ffe253 	bl	ffffffffea805938 <mutex_release>
	return ret;
ffffffffea80cff0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80cff4:	f9401bb7 	ldr	x23, [x29, #48]
}
ffffffffea80cff8:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80cffc:	2a1503e0 	mov	w0, w21
ffffffffea80d000:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80d004:	f9400261 	ldr	x1, [x19]
ffffffffea80d008:	ca010041 	eor	x1, x2, x1
ffffffffea80d00c:	b5000161 	cbnz	x1, ffffffffea80d038 <ipc_send_msg+0xd0>
ffffffffea80d010:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80d014:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d018:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80d01c:	d65f03c0 	ret
			handle_notify(&chan->peer->handle);
ffffffffea80d020:	f85d02c0 	ldur	x0, [x22, #-48]
ffffffffea80d024:	91014000 	add	x0, x0, #0x50
ffffffffea80d028:	97fff500 	bl	ffffffffea80a428 <handle_notify>
ffffffffea80d02c:	17ffffef 	b	ffffffffea80cfe8 <ipc_send_msg+0x80>
		return ERR_INVALID_ARGS;
ffffffffea80d030:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80d034:	17fffff1 	b	ffffffffea80cff8 <ipc_send_msg+0x90>
ffffffffea80d038:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80d03c:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea80d040:	94001b3a 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80d044:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d048 <sys_get_msg>:

long __SYSCALL sys_get_msg(uint32_t handle_id, user_addr_t user_msg_info)
{
ffffffffea80d048:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80d04c:	910003fd 	mov	x29, sp
ffffffffea80d050:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d054:	b00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80d058:	2a0003f3 	mov	w19, w0
ffffffffea80d05c:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d060:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80d064:	2a0103f6 	mov	w22, w1
ffffffffea80d068:	f9400001 	ldr	x1, [x0]
ffffffffea80d06c:	f9002fa1 	str	x1, [x29, #88]
ffffffffea80d070:	d2800001 	mov	x1, #0x0                   	// #0
	handle_t *chandle;
	ipc_msg_info_t msg_info;
	int ret;

	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80d074:	97fff63f 	bl	ffffffffea80a970 <current_uctx>
ffffffffea80d078:	2a1303e1 	mov	w1, w19
ffffffffea80d07c:	910123a2 	add	x2, x29, #0x48
ffffffffea80d080:	97fff6d0 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (ret != NO_ERROR) {
		return (long) ret;
ffffffffea80d084:	93407c13 	sxtw	x19, w0
	if (ret != NO_ERROR) {
ffffffffea80d088:	34000160 	cbz	w0, ffffffffea80d0b4 <sys_get_msg+0x6c>
		}
	}
	mutex_release(&ipc_lock);
	handle_decref(chandle);
	return (long) ret;
}
ffffffffea80d08c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80d090:	aa1303e0 	mov	x0, x19
ffffffffea80d094:	f9402fa2 	ldr	x2, [x29, #88]
ffffffffea80d098:	f9400281 	ldr	x1, [x20]
ffffffffea80d09c:	ca010041 	eor	x1, x2, x1
ffffffffea80d0a0:	b50006a1 	cbnz	x1, ffffffffea80d174 <sys_get_msg+0x12c>
ffffffffea80d0a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d0a8:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80d0ac:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80d0b0:	d65f03c0 	ret
ffffffffea80d0b4:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80d0b8:	b00002b7 	adrp	x23, ffffffffea862000 <__ctor_list>
ffffffffea80d0bc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d0c0:	f940a2e0 	ldr	x0, [x23, #320]
ffffffffea80d0c4:	97ffe1f1 	bl	ffffffffea805888 <mutex_acquire_timeout>
	ret = check_channel_locked(chandle);
ffffffffea80d0c8:	f94027a0 	ldr	x0, [x29, #72]
	if (unlikely(!chandle)) {
ffffffffea80d0cc:	b40004a0 	cbz	x0, ffffffffea80d160 <sys_get_msg+0x118>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d0d0:	97ffface 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80d0d4:	72001c1f 	tst	w0, #0xff
ffffffffea80d0d8:	54000440 	b.eq	ffffffffea80d160 <sys_get_msg+0x118>  // b.none
ffffffffea80d0dc:	f90013b5 	str	x21, [x29, #32]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80d0e0:	92800073 	mov	x19, #0xfffffffffffffffc    	// #-4
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
ffffffffea80d0e4:	f94027b5 	ldr	x21, [x29, #72]
ffffffffea80d0e8:	d10142b5 	sub	x21, x21, #0x50
		ret = msg_peek_next_filled_locked(chan->msg_queue, &msg_info);
ffffffffea80d0ec:	f9405aa0 	ldr	x0, [x21, #176]
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80d0f0:	91004001 	add	x1, x0, #0x10
	if (list->next != list) {
ffffffffea80d0f4:	f9400c03 	ldr	x3, [x0, #24]
ffffffffea80d0f8:	f100007f 	cmp	x3, #0x0
ffffffffea80d0fc:	fa431024 	ccmp	x1, x3, #0x4, ne  // ne = any
ffffffffea80d100:	54000101 	b.ne	ffffffffea80d120 <sys_get_msg+0xd8>  // b.any
ffffffffea80d104:	f94013b5 	ldr	x21, [x29, #32]
	mutex_release(&ipc_lock);
ffffffffea80d108:	f940a2e0 	ldr	x0, [x23, #320]
ffffffffea80d10c:	97ffe20b 	bl	ffffffffea805938 <mutex_release>
	handle_decref(chandle);
ffffffffea80d110:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80d114:	97fff449 	bl	ffffffffea80a238 <handle_decref>
ffffffffea80d118:	f9401bb7 	ldr	x23, [x29, #48]
	return (long) ret;
ffffffffea80d11c:	17ffffdc 	b	ffffffffea80d08c <sys_get_msg+0x44>
	if (!item) {
ffffffffea80d120:	f100c07f 	cmp	x3, #0x30
ffffffffea80d124:	54ffff00 	b.eq	ffffffffea80d104 <sys_get_msg+0xbc>  // b.none
	info->len = item->len;
ffffffffea80d128:	f85f8060 	ldur	x0, [x3, #-8]
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80d12c:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d130:	b90053a0 	str	w0, [x29, #80]
ffffffffea80d134:	910143a1 	add	x1, x29, #0x50
ffffffffea80d138:	2a1603e0 	mov	w0, w22
	info->id  = item->id;
ffffffffea80d13c:	385d0063 	ldurb	w3, [x3, #-48]
ffffffffea80d140:	b90057a3 	str	w3, [x29, #84]
ffffffffea80d144:	94001c93 	bl	ffffffffea814390 <arch_copy_to_user>
			if (likely(ret == NO_ERROR)) {
ffffffffea80d148:	35000100 	cbnz	w0, ffffffffea80d168 <sys_get_msg+0x120>
				msg_get_filled_locked(chan->msg_queue);
ffffffffea80d14c:	f9405aa0 	ldr	x0, [x21, #176]
ffffffffea80d150:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea80d154:	97fffe3d 	bl	ffffffffea80ca48 <msg_get_filled_locked>
ffffffffea80d158:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d15c:	17ffffeb 	b	ffffffffea80d108 <sys_get_msg+0xc0>
	if (!item) {
ffffffffea80d160:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80d164:	17ffffe9 	b	ffffffffea80d108 <sys_get_msg+0xc0>
ffffffffea80d168:	93407c13 	sxtw	x19, w0
ffffffffea80d16c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80d170:	17ffffe6 	b	ffffffffea80d108 <sys_get_msg+0xc0>
ffffffffea80d174:	f90013b5 	str	x21, [x29, #32]
ffffffffea80d178:	f9001bb7 	str	x23, [x29, #48]
}
ffffffffea80d17c:	94001aeb 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80d180 <ipc_get_msg>:

int ipc_get_msg(handle_t *chandle, ipc_msg_info_t *msg_info)
{
ffffffffea80d180:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d184:	910003fd 	mov	x29, sp
ffffffffea80d188:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d18c:	b00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80d190:	aa0003f3 	mov	x19, x0
ffffffffea80d194:	f90013f5 	str	x21, [sp, #32]
ffffffffea80d198:	f940a280 	ldr	x0, [x20, #320]
ffffffffea80d19c:	aa0103f5 	mov	x21, x1
ffffffffea80d1a0:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d1a4:	97ffe1b9 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80d1a8:	b4000453 	cbz	x19, ffffffffea80d230 <ipc_get_msg+0xb0>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d1ac:	aa1303e0 	mov	x0, x19
ffffffffea80d1b0:	97fffa96 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80d1b4:	72001c1f 	tst	w0, #0xff
ffffffffea80d1b8:	540003c0 	b.eq	ffffffffea80d230 <ipc_get_msg+0xb0>  // b.none
	/* check if channel handle */
	ret = check_channel_locked(chandle);
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* peek next filled message */
		ret  = msg_peek_next_filled_locked(chan->msg_queue, msg_info);
ffffffffea80d1bc:	f9403260 	ldr	x0, [x19, #96]
		return ERR_NO_MSG;
ffffffffea80d1c0:	12800073 	mov	w19, #0xfffffffc            	// #-4
	item = list_peek_head_type(&mq->filled_list, msg_item_t, node);
ffffffffea80d1c4:	91004002 	add	x2, x0, #0x10
ffffffffea80d1c8:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80d1cc:	f100003f 	cmp	x1, #0x0
ffffffffea80d1d0:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea80d1d4:	54000101 	b.ne	ffffffffea80d1f4 <ipc_get_msg+0x74>  // b.any
		if (likely(ret == NO_ERROR)) {
			/* and make it readable */
			msg_get_filled_locked(chan->msg_queue);
		}
	}
	mutex_release(&ipc_lock);
ffffffffea80d1d8:	f940a280 	ldr	x0, [x20, #320]
ffffffffea80d1dc:	97ffe1d7 	bl	ffffffffea805938 <mutex_release>
	return ret;
}
ffffffffea80d1e0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d1e4:	2a1303e0 	mov	w0, w19
ffffffffea80d1e8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d1ec:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d1f0:	d65f03c0 	ret
	if (!item) {
ffffffffea80d1f4:	f100c03f 	cmp	x1, #0x30
ffffffffea80d1f8:	54ffff00 	b.eq	ffffffffea80d1d8 <ipc_get_msg+0x58>  // b.none
	info->len = item->len;
ffffffffea80d1fc:	f85f8022 	ldur	x2, [x1, #-8]
	return NO_ERROR;
ffffffffea80d200:	52800013 	mov	w19, #0x0                   	// #0
	info->len = item->len;
ffffffffea80d204:	b90002a2 	str	w2, [x21]
	info->id  = item->id;
ffffffffea80d208:	385d0021 	ldurb	w1, [x1, #-48]
ffffffffea80d20c:	b90006a1 	str	w1, [x21, #4]
			msg_get_filled_locked(chan->msg_queue);
ffffffffea80d210:	97fffe0e 	bl	ffffffffea80ca48 <msg_get_filled_locked>
	mutex_release(&ipc_lock);
ffffffffea80d214:	f940a280 	ldr	x0, [x20, #320]
ffffffffea80d218:	97ffe1c8 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80d21c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d220:	2a1303e0 	mov	w0, w19
ffffffffea80d224:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d228:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d22c:	d65f03c0 	ret
	mutex_release(&ipc_lock);
ffffffffea80d230:	f940a280 	ldr	x0, [x20, #320]
		return ERR_INVALID_ARGS;
ffffffffea80d234:	128000f3 	mov	w19, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80d238:	97ffe1c0 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80d23c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d240:	2a1303e0 	mov	w0, w19
ffffffffea80d244:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d248:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d24c:	d65f03c0 	ret

ffffffffea80d250 <ipc_put_msg>:

	return (long) ret;
}

int ipc_put_msg(handle_t *chandle, uint32_t msg_id)
{
ffffffffea80d250:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80d254:	910003fd 	mov	x29, sp
ffffffffea80d258:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80d25c:	b00002b5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea80d260:	aa0003f6 	mov	x22, x0
ffffffffea80d264:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80d268:	f940a2a0 	ldr	x0, [x21, #320]
ffffffffea80d26c:	2a0103f3 	mov	w19, w1
ffffffffea80d270:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d274:	97ffe185 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80d278:	b4000776 	cbz	x22, ffffffffea80d364 <ipc_put_msg+0x114>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d27c:	aa1603e0 	mov	x0, x22
ffffffffea80d280:	97fffa62 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80d284:	72001c1f 	tst	w0, #0xff
ffffffffea80d288:	540006e0 	b.eq	ffffffffea80d364 <ipc_put_msg+0x114>  // b.none
ffffffffea80d28c:	f9000fb4 	str	x20, [x29, #24]
	ipc_msg_queue_t *mq = chan->msg_queue;
ffffffffea80d290:	f94032d4 	ldr	x20, [x22, #96]
	if (id < mq->num_items) {
ffffffffea80d294:	b9403280 	ldr	w0, [x20, #48]
ffffffffea80d298:	6b00027f 	cmp	w19, w0
ffffffffea80d29c:	54000622 	b.cs	ffffffffea80d360 <ipc_put_msg+0x110>  // b.hs, b.nlast
		platform_arch_speculation_barrier();
ffffffffea80d2a0:	97ffd3e0 	bl	ffffffffea802220 <platform_arch_speculation_barrier>
ffffffffea80d2a4:	91000660 	add	x0, x19, #0x1
ffffffffea80d2a8:	8b131a93 	add	x19, x20, x19, lsl #6
ffffffffea80d2ac:	d37ae400 	lsl	x0, x0, #6
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80d2b0:	39412662 	ldrb	w2, [x19, #73]
		return &mq->items[id];
ffffffffea80d2b4:	91002001 	add	x1, x0, #0x8
ffffffffea80d2b8:	8b010281 	add	x1, x20, x1
	if (!item || item->state != MSG_ITEM_STATE_READ) {
ffffffffea80d2bc:	7100085f 	cmp	w2, #0x2
ffffffffea80d2c0:	54000501 	b.ne	ffffffffea80d360 <ipc_put_msg+0x110>  // b.any
	item->next->prev = item->prev;
ffffffffea80d2c4:	a9430c24 	ldp	x4, x3, [x1, #48]
	list_delete(&item->node);
ffffffffea80d2c8:	9100e000 	add	x0, x0, #0x38
	ipc_chan_t *peer = chan->peer;
ffffffffea80d2cc:	f85d02c2 	ldur	x2, [x22, #-48]
	list_delete(&item->node);
ffffffffea80d2d0:	8b000280 	add	x0, x20, x0
	return NO_ERROR;
ffffffffea80d2d4:	52800016 	mov	w22, #0x0                   	// #0
ffffffffea80d2d8:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea80d2dc:	f9401824 	ldr	x4, [x1, #48]
ffffffffea80d2e0:	f9000483 	str	x3, [x4, #8]
	item->prev = item->next = 0;
ffffffffea80d2e4:	f9001c3f 	str	xzr, [x1, #56]
	item->next = list->next;
ffffffffea80d2e8:	f9400683 	ldr	x3, [x20, #8]
ffffffffea80d2ec:	a9030c34 	stp	x20, x3, [x1, #48]
	list->next->prev = item;
ffffffffea80d2f0:	f9400681 	ldr	x1, [x20, #8]
ffffffffea80d2f4:	f9000020 	str	x0, [x1]
	list->next = item;
ffffffffea80d2f8:	f9000680 	str	x0, [x20, #8]
	item->state = MSG_ITEM_STATE_FREE;
ffffffffea80d2fc:	3901267f 	strb	wzr, [x19, #73]
	if (peer && (peer->aux_state & IPC_CHAN_AUX_STATE_SEND_BLOCKED)) {
ffffffffea80d300:	b4000062 	cbz	x2, ffffffffea80d30c <ipc_put_msg+0xbc>
ffffffffea80d304:	b9403840 	ldr	w0, [x2, #56]
ffffffffea80d308:	37000120 	tbnz	w0, #0, ffffffffea80d32c <ipc_put_msg+0xdc>
	if (likely(ret == NO_ERROR)) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* retire message */
		ret = msg_put_read_locked(chan, msg_id);
	}
	mutex_release(&ipc_lock);
ffffffffea80d30c:	f940a2a0 	ldr	x0, [x21, #320]
ffffffffea80d310:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80d314:	97ffe189 	bl	ffffffffea805938 <mutex_release>
	return ret;
}
ffffffffea80d318:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80d31c:	2a1603e0 	mov	w0, w22
ffffffffea80d320:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d324:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d328:	d65f03c0 	ret
		peer->aux_state &= ~IPC_CHAN_AUX_STATE_SEND_BLOCKED;
ffffffffea80d32c:	121f7801 	and	w1, w0, #0xfffffffe
		handle_notify(&peer->handle);
ffffffffea80d330:	91014040 	add	x0, x2, #0x50
		peer->aux_state |=  IPC_CHAN_AUX_STATE_SEND_UNBLOCKED;
ffffffffea80d334:	321f0021 	orr	w1, w1, #0x2
ffffffffea80d338:	b9003841 	str	w1, [x2, #56]
		handle_notify(&peer->handle);
ffffffffea80d33c:	97fff43b 	bl	ffffffffea80a428 <handle_notify>
ffffffffea80d340:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80d344:	f940a2a0 	ldr	x0, [x21, #320]
ffffffffea80d348:	97ffe17c 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80d34c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80d350:	2a1603e0 	mov	w0, w22
ffffffffea80d354:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d358:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d35c:	d65f03c0 	ret
ffffffffea80d360:	f9400fb4 	ldr	x20, [x29, #24]
	mutex_release(&ipc_lock);
ffffffffea80d364:	f940a2a0 	ldr	x0, [x21, #320]
		return ERR_INVALID_ARGS;
ffffffffea80d368:	128000f6 	mov	w22, #0xfffffff8            	// #-8
	mutex_release(&ipc_lock);
ffffffffea80d36c:	97ffe173 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea80d370:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80d374:	2a1603e0 	mov	w0, w22
ffffffffea80d378:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d37c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80d380:	d65f03c0 	ret
ffffffffea80d384:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d388 <sys_put_msg>:
{
ffffffffea80d388:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80d38c:	910003fd 	mov	x29, sp
ffffffffea80d390:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d394:	b00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80d398:	2a0003f3 	mov	w19, w0
ffffffffea80d39c:	f90013f5 	str	x21, [sp, #32]
ffffffffea80d3a0:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80d3a4:	2a0103f5 	mov	w21, w1
ffffffffea80d3a8:	f9400001 	ldr	x1, [x0]
ffffffffea80d3ac:	f9001fa1 	str	x1, [x29, #56]
ffffffffea80d3b0:	d2800001 	mov	x1, #0x0                   	// #0
	int ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80d3b4:	97fff56f 	bl	ffffffffea80a970 <current_uctx>
ffffffffea80d3b8:	9100c3a2 	add	x2, x29, #0x30
ffffffffea80d3bc:	2a1303e1 	mov	w1, w19
ffffffffea80d3c0:	97fff600 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d3c4:	35000220 	cbnz	w0, ffffffffea80d408 <sys_put_msg+0x80>
	ret = ipc_put_msg(chandle, msg_id);
ffffffffea80d3c8:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80d3cc:	2a1503e1 	mov	w1, w21
ffffffffea80d3d0:	97ffffa0 	bl	ffffffffea80d250 <ipc_put_msg>
ffffffffea80d3d4:	2a0003f3 	mov	w19, w0
	handle_decref(chandle);
ffffffffea80d3d8:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80d3dc:	97fff397 	bl	ffffffffea80a238 <handle_decref>
	return (long) ret;
ffffffffea80d3e0:	93407e60 	sxtw	x0, w19
}
ffffffffea80d3e4:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80d3e8:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea80d3ec:	f9400281 	ldr	x1, [x20]
ffffffffea80d3f0:	ca010041 	eor	x1, x2, x1
ffffffffea80d3f4:	b50000e1 	cbnz	x1, ffffffffea80d410 <sys_put_msg+0x88>
ffffffffea80d3f8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d3fc:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d400:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d404:	d65f03c0 	ret
		return (long) ret;
ffffffffea80d408:	93407c00 	sxtw	x0, w0
ffffffffea80d40c:	17fffff6 	b	ffffffffea80d3e4 <sys_put_msg+0x5c>
}
ffffffffea80d410:	94001a46 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80d414:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d418 <sys_read_msg>:


long __SYSCALL sys_read_msg(uint32_t handle_id, uint32_t msg_id, uint32_t offset,
                            user_addr_t user_msg)
{
ffffffffea80d418:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
ffffffffea80d41c:	910003fd 	mov	x29, sp
ffffffffea80d420:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d424:	b00002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea80d428:	a9025bf5 	stp	x21, x22, [sp, #32]
	handle_t  *chandle;
	msg_desc_t tmp_msg;
	int ret;

	/* get msg descriptor form user space */
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80d42c:	910203b3 	add	x19, x29, #0x80
{
ffffffffea80d430:	2a0003f5 	mov	w21, w0
ffffffffea80d434:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80d438:	2a0103f6 	mov	w22, w1
ffffffffea80d43c:	f9400001 	ldr	x1, [x0]
ffffffffea80d440:	f9003fa1 	str	x1, [x29, #120]
ffffffffea80d444:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80d448:	f9001bf7 	str	x23, [sp, #48]
	tmp_msg.type = IPC_MSG_BUFFER_USER;
ffffffffea80d44c:	b81d0e7f 	str	wzr, [x19, #-48]!
{
ffffffffea80d450:	2a0203f7 	mov	w23, w2
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80d454:	2a0303e1 	mov	w1, w3
ffffffffea80d458:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea80d45c:	91002260 	add	x0, x19, #0x8
ffffffffea80d460:	94001bd4 	bl	ffffffffea8143b0 <arch_copy_from_user>
	ret = copy_from_user(&tmp_msg.user, user_msg, sizeof(ipc_msg_user_t));
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d464:	350004a0 	cbnz	w0, ffffffffea80d4f8 <sys_read_msg+0xe0>
		return (long) ret;
	}
	/* grab handle */
	ret = uctx_handle_get(current_uctx(), handle_id, &chandle);
ffffffffea80d468:	97fff542 	bl	ffffffffea80a970 <current_uctx>
ffffffffea80d46c:	910123a2 	add	x2, x29, #0x48
ffffffffea80d470:	2a1503e1 	mov	w1, w21
ffffffffea80d474:	97fff5d3 	bl	ffffffffea80abc0 <uctx_handle_get>
	if (unlikely(ret != NO_ERROR)) {
ffffffffea80d478:	35000400 	cbnz	w0, ffffffffea80d4f8 <sys_read_msg+0xe0>
ffffffffea80d47c:	b00002b5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea80d480:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d484:	f940a2a0 	ldr	x0, [x21, #320]
ffffffffea80d488:	97ffe100 	bl	ffffffffea805888 <mutex_acquire_timeout>
		return (long) ret;
	}
	mutex_acquire(&ipc_lock);
	/* check if channel handle is a valid one */
	ret = check_channel_locked (chandle);
ffffffffea80d48c:	f94027a0 	ldr	x0, [x29, #72]
	if (unlikely(!chandle)) {
ffffffffea80d490:	b4000380 	cbz	x0, ffffffffea80d500 <sys_read_msg+0xe8>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d494:	97fff9dd 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80d498:	72001c1f 	tst	w0, #0xff
ffffffffea80d49c:	54000320 	b.eq	ffffffffea80d500 <sys_read_msg+0xe8>  // b.none
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		/* read message content */
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80d4a0:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80d4a4:	aa1303e3 	mov	x3, x19
ffffffffea80d4a8:	2a1703e2 	mov	w2, w23
ffffffffea80d4ac:	2a1603e1 	mov	w1, w22
ffffffffea80d4b0:	f9403000 	ldr	x0, [x0, #96]
ffffffffea80d4b4:	97fffddf 	bl	ffffffffea80cc30 <msg_read_locked>
ffffffffea80d4b8:	93407c13 	sxtw	x19, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80d4bc:	f940a2a0 	ldr	x0, [x21, #320]
ffffffffea80d4c0:	97ffe11e 	bl	ffffffffea805938 <mutex_release>
	handle_decref(chandle);
ffffffffea80d4c4:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea80d4c8:	97fff35c 	bl	ffffffffea80a238 <handle_decref>

	return (long) ret;
}
ffffffffea80d4cc:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80d4d0:	aa1303e0 	mov	x0, x19
ffffffffea80d4d4:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea80d4d8:	f9400281 	ldr	x1, [x20]
ffffffffea80d4dc:	ca010041 	eor	x1, x2, x1
ffffffffea80d4e0:	b5000141 	cbnz	x1, ffffffffea80d508 <sys_read_msg+0xf0>
ffffffffea80d4e4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d4e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80d4ec:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d4f0:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80d4f4:	d65f03c0 	ret
		return (long) ret;
ffffffffea80d4f8:	93407c13 	sxtw	x19, w0
ffffffffea80d4fc:	17fffff4 	b	ffffffffea80d4cc <sys_read_msg+0xb4>
{
ffffffffea80d500:	928000f3 	mov	x19, #0xfffffffffffffff8    	// #-8
ffffffffea80d504:	17ffffee 	b	ffffffffea80d4bc <sys_read_msg+0xa4>
}
ffffffffea80d508:	94001a08 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80d50c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d510 <ipc_read_msg>:

int ipc_read_msg(handle_t *chandle, uint32_t msg_id, uint32_t offset,
                 ipc_msg_kern_t *msg)
{
ffffffffea80d510:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80d514:	910003fd 	mov	x29, sp
ffffffffea80d518:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80d51c:	b00002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80d520:	f90013f5 	str	x21, [sp, #32]
ffffffffea80d524:	aa0003f5 	mov	x21, x0
ffffffffea80d528:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea80d52c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d530:	2a0103f7 	mov	w23, w1
ffffffffea80d534:	f9400001 	ldr	x1, [x0]
ffffffffea80d538:	f90037a1 	str	x1, [x29, #104]
ffffffffea80d53c:	d2800001 	mov	x1, #0x0                   	// #0
	int ret;
	msg_desc_t tmp_msg;

	if (!msg) {
ffffffffea80d540:	b4000563 	cbz	x3, ffffffffea80d5ec <ipc_read_msg+0xdc>
		return ERR_INVALID_ARGS;
	}
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80d544:	9101c3b4 	add	x20, x29, #0x70
ffffffffea80d548:	f90017b6 	str	x22, [x29, #40]
ffffffffea80d54c:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d550:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80d554:	b00002b6 	adrp	x22, ffffffffea862000 <__ctor_list>
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80d558:	aa0303e1 	mov	x1, x3
	tmp_msg.type = IPC_MSG_BUFFER_KERNEL;
ffffffffea80d55c:	b81d0e80 	str	w0, [x20, #-48]!
ffffffffea80d560:	2a0203f8 	mov	w24, w2
	memcpy(&tmp_msg.kern, msg, sizeof(ipc_msg_kern_t));
ffffffffea80d564:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea80d568:	91002280 	add	x0, x20, #0x8
ffffffffea80d56c:	94001a17 	bl	ffffffffea813dc8 <memcpy>
ffffffffea80d570:	f940a2c0 	ldr	x0, [x22, #320]
ffffffffea80d574:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80d578:	97ffe0c4 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (unlikely(!chandle)) {
ffffffffea80d57c:	b4000355 	cbz	x21, ffffffffea80d5e4 <ipc_read_msg+0xd4>
	if (unlikely(!ipc_is_channel(chandle))) {
ffffffffea80d580:	aa1503e0 	mov	x0, x21
ffffffffea80d584:	97fff9a1 	bl	ffffffffea80bc08 <ipc_is_channel>
ffffffffea80d588:	72001c1f 	tst	w0, #0xff
ffffffffea80d58c:	540002c0 	b.eq	ffffffffea80d5e4 <ipc_read_msg+0xd4>  // b.none

	mutex_acquire(&ipc_lock);
	ret = check_channel_locked (chandle);
	if (ret == NO_ERROR) {
		ipc_chan_t *chan = containerof(chandle, ipc_chan_t, handle);
		ret = msg_read_locked(chan->msg_queue, msg_id,
ffffffffea80d590:	f94032a0 	ldr	x0, [x21, #96]
ffffffffea80d594:	aa1403e3 	mov	x3, x20
ffffffffea80d598:	2a1803e2 	mov	w2, w24
ffffffffea80d59c:	2a1703e1 	mov	w1, w23
ffffffffea80d5a0:	97fffda4 	bl	ffffffffea80cc30 <msg_read_locked>
ffffffffea80d5a4:	2a0003f4 	mov	w20, w0
		                      offset, &tmp_msg);
	}
	mutex_release(&ipc_lock);
ffffffffea80d5a8:	f940a2c0 	ldr	x0, [x22, #320]
ffffffffea80d5ac:	97ffe0e3 	bl	ffffffffea805938 <mutex_release>
	return ret;
ffffffffea80d5b0:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80d5b4:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d5b8:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80d5bc:	2a1403e0 	mov	w0, w20
ffffffffea80d5c0:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80d5c4:	f9400261 	ldr	x1, [x19]
ffffffffea80d5c8:	ca010041 	eor	x1, x2, x1
ffffffffea80d5cc:	b5000141 	cbnz	x1, ffffffffea80d5f4 <ipc_read_msg+0xe4>
ffffffffea80d5d0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80d5d4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80d5d8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d5dc:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80d5e0:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80d5e4:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80d5e8:	17fffff0 	b	ffffffffea80d5a8 <ipc_read_msg+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80d5ec:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea80d5f0:	17fffff2 	b	ffffffffea80d5b8 <ipc_read_msg+0xa8>
ffffffffea80d5f4:	f90017b6 	str	x22, [x29, #40]
ffffffffea80d5f8:	f9001fb8 	str	x24, [x29, #56]
}
ffffffffea80d5fc:	940019cb 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80d600 <membuf_to_kern_iovec>:
ssize_t membuf_to_kern_iovec(const iovec_kern_t *iov, uint iov_cnt,
                             const uint8_t *buf, size_t len)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d600:	7100003f 	cmp	w1, #0x0
ffffffffea80d604:	fa401864 	ccmp	x3, #0x0, #0x4, ne  // ne = any
ffffffffea80d608:	54000820 	b.eq	ffffffffea80d70c <membuf_to_kern_iovec+0x10c>  // b.none
{
ffffffffea80d60c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}

	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80d610:	f100001f 	cmp	x0, #0x0
ffffffffea80d614:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d618:	910003fd 	mov	x29, sp
ffffffffea80d61c:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d620:	aa0003f4 	mov	x20, x0
ffffffffea80d624:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d628:	aa0203f7 	mov	x23, x2
	if (unlikely(iov == NULL || buf == NULL)) {
ffffffffea80d62c:	54000400 	b.eq	ffffffffea80d6ac <membuf_to_kern_iovec+0xac>  // b.none
ffffffffea80d630:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d634:	51000436 	sub	w22, w1, #0x1
ffffffffea80d638:	910006d6 	add	x22, x22, #0x1
ffffffffea80d63c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d640:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d644:	aa0303f5 	mov	x21, x3
ffffffffea80d648:	8b161016 	add	x22, x0, x22, lsl #4
	size_t copied = 0;
ffffffffea80d64c:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80d650:	1400000d 	b	ffffffffea80d684 <membuf_to_kern_iovec+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80d654:	b4000133 	cbz	x19, ffffffffea80d678 <membuf_to_kern_iovec+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80d658:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy(iov->base, buf, to_copy);

		copied += to_copy;
ffffffffea80d65c:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80d660:	8b1302f7 	add	x23, x23, x19
		memcpy(iov->base, buf, to_copy);
ffffffffea80d664:	aa0303e0 	mov	x0, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80d668:	b40001c3 	cbz	x3, ffffffffea80d6a0 <membuf_to_kern_iovec+0xa0>
		memcpy(iov->base, buf, to_copy);
ffffffffea80d66c:	940019d7 	bl	ffffffffea813dc8 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d670:	eb1302b5 	subs	x21, x21, x19
ffffffffea80d674:	54000260 	b.eq	ffffffffea80d6c0 <membuf_to_kern_iovec+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80d678:	91004294 	add	x20, x20, #0x10
ffffffffea80d67c:	eb16029f 	cmp	x20, x22
ffffffffea80d680:	54000200 	b.eq	ffffffffea80d6c0 <membuf_to_kern_iovec+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80d684:	f9400693 	ldr	x19, [x20, #8]
		memcpy(iov->base, buf, to_copy);
ffffffffea80d688:	aa1703e1 	mov	x1, x23
ffffffffea80d68c:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80d690:	eb15027f 	cmp	x19, x21
ffffffffea80d694:	54fffe03 	b.cc	ffffffffea80d654 <membuf_to_kern_iovec+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80d698:	f9400280 	ldr	x0, [x20]
ffffffffea80d69c:	b5000220 	cbnz	x0, ffffffffea80d6e0 <membuf_to_kern_iovec+0xe0>
ffffffffea80d6a0:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d6a4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d6a8:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d6ac:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return  (ssize_t) copied;
}
ffffffffea80d6b0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d6b4:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d6b8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d6bc:	d65f03c0 	ret
ffffffffea80d6c0:	aa1803e0 	mov	x0, x24
	return  (ssize_t) copied;
ffffffffea80d6c4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d6c8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d6cc:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d6d0:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d6d4:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d6d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d6dc:	d65f03c0 	ret
		memcpy(iov->base, buf, to_copy);
ffffffffea80d6e0:	aa1503e2 	mov	x2, x21
ffffffffea80d6e4:	aa1703e1 	mov	x1, x23
ffffffffea80d6e8:	940019b8 	bl	ffffffffea813dc8 <memcpy>
ffffffffea80d6ec:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d6f0:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d6f4:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d6f8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d6fc:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d700:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d704:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d708:	d65f03c0 	ret
		return 0;
ffffffffea80d70c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d710:	d65f03c0 	ret
ffffffffea80d714:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d718 <kern_iovec_to_membuf>:
ssize_t kern_iovec_to_membuf(uint8_t *buf, size_t len,
                             const iovec_kern_t *iov, uint iov_cnt)
{
	size_t copied = 0;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d718:	7100007f 	cmp	w3, #0x0
ffffffffea80d71c:	fa401824 	ccmp	x1, #0x0, #0x4, ne  // ne = any
ffffffffea80d720:	54000820 	b.eq	ffffffffea80d824 <kern_iovec_to_membuf+0x10c>  // b.none
{
ffffffffea80d724:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
		return 0;
	}
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d728:	f100001f 	cmp	x0, #0x0
ffffffffea80d72c:	fa401844 	ccmp	x2, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d730:	910003fd 	mov	x29, sp
ffffffffea80d734:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d738:	aa0203f4 	mov	x20, x2
ffffffffea80d73c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80d740:	aa0003f7 	mov	x23, x0
	if (unlikely(buf == NULL || iov == NULL)) {
ffffffffea80d744:	54000400 	b.eq	ffffffffea80d7c4 <kern_iovec_to_membuf+0xac>  // b.none
ffffffffea80d748:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d74c:	51000476 	sub	w22, w3, #0x1
ffffffffea80d750:	910006d6 	add	x22, x22, #0x1
ffffffffea80d754:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d758:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80d75c:	aa0103f5 	mov	x21, x1
ffffffffea80d760:	8b161056 	add	x22, x2, x22, lsl #4
	size_t copied = 0;
ffffffffea80d764:	d2800018 	mov	x24, #0x0                   	// #0
ffffffffea80d768:	1400000d 	b	ffffffffea80d79c <kern_iovec_to_membuf+0x84>

		size_t to_copy = len;
		if (to_copy > iov->len) {
			to_copy = iov->len;
		}
		if (unlikely(to_copy == 0)) {
ffffffffea80d76c:	b4000133 	cbz	x19, ffffffffea80d790 <kern_iovec_to_membuf+0x78>
			continue;
		}
		if (unlikely(iov->base == NULL)) {
ffffffffea80d770:	f9400283 	ldr	x3, [x20]
			return (ssize_t) ERR_INVALID_ARGS;
		}
		memcpy (buf, iov->base, to_copy);

		copied += to_copy;
ffffffffea80d774:	8b130318 	add	x24, x24, x19
		buf    += to_copy;
ffffffffea80d778:	8b1302f7 	add	x23, x23, x19
		memcpy (buf, iov->base, to_copy);
ffffffffea80d77c:	aa0303e1 	mov	x1, x3
		if (unlikely(iov->base == NULL)) {
ffffffffea80d780:	b40001c3 	cbz	x3, ffffffffea80d7b8 <kern_iovec_to_membuf+0xa0>
		memcpy (buf, iov->base, to_copy);
ffffffffea80d784:	94001991 	bl	ffffffffea813dc8 <memcpy>
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d788:	eb1302b5 	subs	x21, x21, x19
ffffffffea80d78c:	54000260 	b.eq	ffffffffea80d7d8 <kern_iovec_to_membuf+0xc0>  // b.none
	for (uint i = 0; i < iov_cnt; i++, iov++) {
ffffffffea80d790:	91004294 	add	x20, x20, #0x10
ffffffffea80d794:	eb16029f 	cmp	x20, x22
ffffffffea80d798:	54000200 	b.eq	ffffffffea80d7d8 <kern_iovec_to_membuf+0xc0>  // b.none
		if (to_copy > iov->len) {
ffffffffea80d79c:	f9400693 	ldr	x19, [x20, #8]
		memcpy (buf, iov->base, to_copy);
ffffffffea80d7a0:	aa1703e0 	mov	x0, x23
ffffffffea80d7a4:	aa1303e2 	mov	x2, x19
		if (to_copy > iov->len) {
ffffffffea80d7a8:	eb15027f 	cmp	x19, x21
ffffffffea80d7ac:	54fffe03 	b.cc	ffffffffea80d76c <kern_iovec_to_membuf+0x54>  // b.lo, b.ul, b.last
		if (unlikely(iov->base == NULL)) {
ffffffffea80d7b0:	f9400281 	ldr	x1, [x20]
ffffffffea80d7b4:	b5000221 	cbnz	x1, ffffffffea80d7f8 <kern_iovec_to_membuf+0xe0>
ffffffffea80d7b8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d7bc:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d7c0:	f9401fb8 	ldr	x24, [x29, #56]
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d7c4:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
			break;
		}
	}

	return (ssize_t) copied;
}
ffffffffea80d7c8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d7cc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d7d0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d7d4:	d65f03c0 	ret
ffffffffea80d7d8:	aa1803e0 	mov	x0, x24
	return (ssize_t) copied;
ffffffffea80d7dc:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d7e0:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d7e4:	f9401fb8 	ldr	x24, [x29, #56]
}
ffffffffea80d7e8:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d7ec:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d7f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d7f4:	d65f03c0 	ret
		memcpy (buf, iov->base, to_copy);
ffffffffea80d7f8:	aa1503e2 	mov	x2, x21
ffffffffea80d7fc:	aa1703e0 	mov	x0, x23
ffffffffea80d800:	94001972 	bl	ffffffffea813dc8 <memcpy>
ffffffffea80d804:	f9400bb3 	ldr	x19, [x29, #16]
		copied += to_copy;
ffffffffea80d808:	8b1802a0 	add	x0, x21, x24
}
ffffffffea80d80c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d810:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d814:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80d818:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80d81c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80d820:	d65f03c0 	ret
		return 0;
ffffffffea80d824:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea80d828:	d65f03c0 	ret
ffffffffea80d82c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d830 <membuf_to_user_iovec>:

ssize_t membuf_to_user_iovec(user_addr_t iov_uaddr, uint iov_cnt,
                             const uint8_t *buf, size_t len)
{
ffffffffea80d830:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d834:	7100003f 	cmp	w1, #0x0
{
ffffffffea80d838:	910003fd 	mov	x29, sp
ffffffffea80d83c:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80d840:	b00002b9 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea80d844:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d848:	aa0303f4 	mov	x20, x3
ffffffffea80d84c:	f9402b23 	ldr	x3, [x25, #80]
ffffffffea80d850:	2a0003fa 	mov	w26, w0
	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d854:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d858:	f9400060 	ldr	x0, [x3]
ffffffffea80d85c:	f90037a0 	str	x0, [x29, #104]
ffffffffea80d860:	d2800000 	mov	x0, #0x0                   	// #0
	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d864:	54000700 	b.eq	ffffffffea80d944 <membuf_to_user_iovec+0x114>  // b.none
ffffffffea80d868:	f90017b6 	str	x22, [x29, #40]
ffffffffea80d86c:	aa0203f6 	mov	x22, x2
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d870:	b40007a2 	cbz	x2, ffffffffea80d964 <membuf_to_user_iovec+0x134>
ffffffffea80d874:	51000421 	sub	w1, w1, #0x1
ffffffffea80d878:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d87c:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80d880:	91000438 	add	x24, x1, #0x1
ffffffffea80d884:	910183bb 	add	x27, x29, #0x60
ffffffffea80d888:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d88c:	f90013b5 	str	x21, [x29, #32]
	size_t copied = 0;
ffffffffea80d890:	d2800017 	mov	x23, #0x0                   	// #0
	if (unlikely(buf == NULL)) {
ffffffffea80d894:	d2800015 	mov	x21, #0x0                   	// #0
ffffffffea80d898:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d89c:	0b150f41 	add	w1, w26, w21, lsl #3
ffffffffea80d8a0:	aa1b03e0 	mov	x0, x27
ffffffffea80d8a4:	94001ac3 	bl	ffffffffea8143b0 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d8a8:	35000320 	cbnz	w0, ffffffffea80d90c <membuf_to_user_iovec+0xdc>
			return (ssize_t) ret;
		}

		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80d8ac:	294c4fa0 	ldp	w0, w19, [x29, #96]
ffffffffea80d8b0:	eb13029f 	cmp	x20, x19
ffffffffea80d8b4:	54000249 	b.ls	ffffffffea80d8fc <membuf_to_user_iovec+0xcc>  // b.plast
	return arch_copy_to_user(udest, ksrc, len);
ffffffffea80d8b8:	aa1303e2 	mov	x2, x19
ffffffffea80d8bc:	aa1603e1 	mov	x1, x22
ffffffffea80d8c0:	94001ab4 	bl	ffffffffea814390 <arch_copy_to_user>
			to_copy = uiov.len;
		}
		/* copy data to user space */
		ret = copy_to_user(uiov.base, buf, to_copy);
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d8c4:	35000240 	cbnz	w0, ffffffffea80d90c <membuf_to_user_iovec+0xdc>
			return (ssize_t) ret;
		}
		copied += to_copy;
ffffffffea80d8c8:	8b1302f7 	add	x23, x23, x19
		buf    += to_copy;
ffffffffea80d8cc:	8b1302d6 	add	x22, x22, x19
		len    -= to_copy;

		if (len == 0) {
ffffffffea80d8d0:	eb130294 	subs	x20, x20, x19
ffffffffea80d8d4:	54000080 	b.eq	ffffffffea80d8e4 <membuf_to_user_iovec+0xb4>  // b.none
ffffffffea80d8d8:	910006b5 	add	x21, x21, #0x1
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80d8dc:	eb1802bf 	cmp	x21, x24
ffffffffea80d8e0:	54fffdc1 	b.ne	ffffffffea80d898 <membuf_to_user_iovec+0x68>  // b.any
ffffffffea80d8e4:	aa1703e0 	mov	x0, x23
			break;;
		}
	}

	return  (ssize_t) copied;
ffffffffea80d8e8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d8ec:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d8f0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d8f4:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80d8f8:	1400000a 	b	ffffffffea80d920 <membuf_to_user_iovec+0xf0>
ffffffffea80d8fc:	aa1403e2 	mov	x2, x20
ffffffffea80d900:	aa1603e1 	mov	x1, x22
ffffffffea80d904:	94001aa3 	bl	ffffffffea814390 <arch_copy_to_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80d908:	34000220 	cbz	w0, ffffffffea80d94c <membuf_to_user_iovec+0x11c>
			return (ssize_t) ret;
ffffffffea80d90c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d910:	93407c00 	sxtw	x0, w0
ffffffffea80d914:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d918:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d91c:	f9402bbb 	ldr	x27, [x29, #80]
}
ffffffffea80d920:	f9402b39 	ldr	x25, [x25, #80]
ffffffffea80d924:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80d928:	f9400321 	ldr	x1, [x25]
ffffffffea80d92c:	ca010041 	eor	x1, x2, x1
ffffffffea80d930:	b5000201 	cbnz	x1, ffffffffea80d970 <membuf_to_user_iovec+0x140>
ffffffffea80d934:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80d938:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80d93c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80d940:	d65f03c0 	ret
		return 0;
ffffffffea80d944:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80d948:	17fffff6 	b	ffffffffea80d920 <membuf_to_user_iovec+0xf0>
		copied += to_copy;
ffffffffea80d94c:	8b170280 	add	x0, x20, x23
ffffffffea80d950:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80d954:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80d958:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80d95c:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80d960:	17fffff0 	b	ffffffffea80d920 <membuf_to_user_iovec+0xf0>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80d964:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80d968:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80d96c:	17ffffed 	b	ffffffffea80d920 <membuf_to_user_iovec+0xf0>
ffffffffea80d970:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d974:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80d978:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d97c:	f9002bbb 	str	x27, [x29, #80]
}
ffffffffea80d980:	940018ea 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80d984:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80d988 <user_iovec_to_membuf>:

ssize_t user_iovec_to_membuf(uint8_t *buf, size_t len,
                             user_addr_t iov_uaddr, uint iov_cnt)
{
ffffffffea80d988:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	status_t ret;
	size_t copied = 0;
	iovec_user_t uiov;

	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d98c:	7100007f 	cmp	w3, #0x0
{
ffffffffea80d990:	910003fd 	mov	x29, sp
ffffffffea80d994:	f90023f9 	str	x25, [sp, #64]
ffffffffea80d998:	b00002b9 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea80d99c:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80d9a0:	aa0103f4 	mov	x20, x1
ffffffffea80d9a4:	f9402b21 	ldr	x1, [x25, #80]
	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d9a8:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
{
ffffffffea80d9ac:	f90017f6 	str	x22, [sp, #40]
ffffffffea80d9b0:	aa0003f6 	mov	x22, x0
ffffffffea80d9b4:	f9400020 	ldr	x0, [x1]
ffffffffea80d9b8:	f90037a0 	str	x0, [x29, #104]
ffffffffea80d9bc:	d2800000 	mov	x0, #0x0                   	// #0
	if (unlikely(iov_cnt == 0 || len == 0)) {
ffffffffea80d9c0:	54000700 	b.eq	ffffffffea80daa0 <user_iovec_to_membuf+0x118>  // b.none
		return 0;
	}
	if (unlikely(buf == NULL)) {
ffffffffea80d9c4:	b40007f6 	cbz	x22, ffffffffea80dac0 <user_iovec_to_membuf+0x138>
ffffffffea80d9c8:	51000463 	sub	w3, w3, #0x1
ffffffffea80d9cc:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80d9d0:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80d9d4:	91000478 	add	x24, x3, #0x1
ffffffffea80d9d8:	2a0203fa 	mov	w26, w2
ffffffffea80d9dc:	910183bb 	add	x27, x29, #0x60
	size_t copied = 0;
ffffffffea80d9e0:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea80d9e4:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80d9e8:	f90013b5 	str	x21, [x29, #32]
	if (unlikely(buf == NULL)) {
ffffffffea80d9ec:	d2800015 	mov	x21, #0x0                   	// #0
	return arch_copy_from_user(kdest, usrc, len);
ffffffffea80d9f0:	d2800102 	mov	x2, #0x8                   	// #8
ffffffffea80d9f4:	0b150f41 	add	w1, w26, w21, lsl #3
ffffffffea80d9f8:	aa1b03e0 	mov	x0, x27
ffffffffea80d9fc:	94001a6d 	bl	ffffffffea8143b0 <arch_copy_from_user>

		/* copy user iovec from user space into local buffer */
		ret = copy_from_user(&uiov,
		                     iov_uaddr + i * sizeof(iovec_user_t),
		                     sizeof(iovec_user_t));
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80da00:	35000320 	cbnz	w0, ffffffffea80da64 <user_iovec_to_membuf+0xdc>
			return (ssize_t) ret;
		}
		size_t to_copy = len;
		if (to_copy > uiov.len) {
ffffffffea80da04:	294c4fa1 	ldp	w1, w19, [x29, #96]
ffffffffea80da08:	eb13029f 	cmp	x20, x19
ffffffffea80da0c:	54000249 	b.ls	ffffffffea80da54 <user_iovec_to_membuf+0xcc>  // b.plast
ffffffffea80da10:	aa1303e2 	mov	x2, x19
ffffffffea80da14:	aa1603e0 	mov	x0, x22
ffffffffea80da18:	94001a66 	bl	ffffffffea8143b0 <arch_copy_from_user>
			to_copy = uiov.len;
		}
		/* copy data to user space */
		ret = copy_from_user(buf, uiov.base, to_copy);
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80da1c:	35000240 	cbnz	w0, ffffffffea80da64 <user_iovec_to_membuf+0xdc>
			return (ssize_t) ret;
		}

		copied += to_copy;
ffffffffea80da20:	8b1302f7 	add	x23, x23, x19
		buf    += to_copy;
ffffffffea80da24:	8b1302d6 	add	x22, x22, x19
		len    -= to_copy;
		if (len == 0) {
ffffffffea80da28:	eb130294 	subs	x20, x20, x19
ffffffffea80da2c:	54000080 	b.eq	ffffffffea80da3c <user_iovec_to_membuf+0xb4>  // b.none
ffffffffea80da30:	910006b5 	add	x21, x21, #0x1
	for (uint i = 0; i < iov_cnt; i++) {
ffffffffea80da34:	eb1802bf 	cmp	x21, x24
ffffffffea80da38:	54fffdc1 	b.ne	ffffffffea80d9f0 <user_iovec_to_membuf+0x68>  // b.any
ffffffffea80da3c:	aa1703e0 	mov	x0, x23
			break;;
		}
	}

	return (ssize_t) copied;
ffffffffea80da40:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80da44:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80da48:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80da4c:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea80da50:	1400000a 	b	ffffffffea80da78 <user_iovec_to_membuf+0xf0>
ffffffffea80da54:	aa1403e2 	mov	x2, x20
ffffffffea80da58:	aa1603e0 	mov	x0, x22
ffffffffea80da5c:	94001a55 	bl	ffffffffea8143b0 <arch_copy_from_user>
		if (unlikely(ret != NO_ERROR)) {
ffffffffea80da60:	34000240 	cbz	w0, ffffffffea80daa8 <user_iovec_to_membuf+0x120>
			return (ssize_t) ret;
ffffffffea80da64:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80da68:	93407c00 	sxtw	x0, w0
ffffffffea80da6c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80da70:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80da74:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea80da78:	f9402b39 	ldr	x25, [x25, #80]
ffffffffea80da7c:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80da80:	f9400321 	ldr	x1, [x25]
ffffffffea80da84:	ca010041 	eor	x1, x2, x1
ffffffffea80da88:	b5000201 	cbnz	x1, ffffffffea80dac8 <user_iovec_to_membuf+0x140>
ffffffffea80da8c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80da90:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea80da94:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80da98:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80da9c:	d65f03c0 	ret
		return 0;
ffffffffea80daa0:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80daa4:	17fffff5 	b	ffffffffea80da78 <user_iovec_to_membuf+0xf0>
		copied += to_copy;
ffffffffea80daa8:	8b170280 	add	x0, x20, x23
ffffffffea80daac:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80dab0:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea80dab4:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80dab8:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea80dabc:	17ffffef 	b	ffffffffea80da78 <user_iovec_to_membuf+0xf0>
		return (ssize_t) ERR_INVALID_ARGS;
ffffffffea80dac0:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80dac4:	17ffffed 	b	ffffffffea80da78 <user_iovec_to_membuf+0xf0>
ffffffffea80dac8:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80dacc:	f90013b5 	str	x21, [x29, #32]
ffffffffea80dad0:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80dad4:	a904efba 	stp	x26, x27, [x29, #72]
}
ffffffffea80dad8:	94001894 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80dadc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dae0 <vqueue_init>:

int vqueue_init(struct vqueue *vq, uint32_t id,
		paddr_t paddr, uint num, ulong align,
		void *priv, vqueue_cb_t notify_cb, vqueue_cb_t kick_cb,
		uint32_t guest)
{
ffffffffea80dae0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
}

static inline unsigned vring_size(unsigned int num, unsigned long align)
{
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
		 + align - 1) & ~(align - 1))
ffffffffea80dae4:	51000489 	sub	w9, w4, #0x1
ffffffffea80dae8:	4b0403e8 	neg	w8, w4
ffffffffea80daec:	910003fd 	mov	x29, sp
ffffffffea80daf0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80daf4:	2a0303f4 	mov	w20, w3
	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (3 + num)
ffffffffea80daf8:	11000c63 	add	w3, w3, #0x3
ffffffffea80dafc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80db00:	8b344c63 	add	x3, x3, w20, uxtw #3
ffffffffea80db04:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80db08:	b00002b5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea80db0c:	aa0003f7 	mov	x23, x0
		 + align - 1) & ~(align - 1))
ffffffffea80db10:	0b030520 	add	w0, w9, w3, lsl #1
ffffffffea80db14:	aa0203f8 	mov	x24, x2
ffffffffea80db18:	0a080000 	and	w0, w0, w8
ffffffffea80db1c:	f9402aa3 	ldr	x3, [x21, #80]
		+ sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num;
ffffffffea80db20:	0b140c00 	add	w0, w0, w20, lsl #3

	DEBUG_ASSERT(vq);

	vq->vring_sz = vring_size(num, align);
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80db24:	b94083a2 	ldr	w2, [x29, #128]
{
ffffffffea80db28:	a9046bf9 	stp	x25, x26, [sp, #64]
	vq->vring_sz = vring_size(num, align);
ffffffffea80db2c:	11001800 	add	w0, w0, #0x6
{
ffffffffea80db30:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea80db34:	2a0103fa 	mov	w26, w1
	vq->vring_sz = vring_size(num, align);
ffffffffea80db38:	f9001ae0 	str	x0, [x23, #48]
	roundedup_vring_sz = ROUNDUP(vq->vring_sz, PAGE_SIZE);
ffffffffea80db3c:	913ffc00 	add	x0, x0, #0xfff
ffffffffea80db40:	9274cc13 	and	x19, x0, #0xfffffffffffff000
{
ffffffffea80db44:	f9400060 	ldr	x0, [x3]
ffffffffea80db48:	f9003fa0 	str	x0, [x29, #120]
ffffffffea80db4c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80db50:	aa0403f6 	mov	x22, x4
ffffffffea80db54:	aa0603fb 	mov	x27, x6
ffffffffea80db58:	aa0703f9 	mov	x25, x7
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80db5c:	aa1303e1 	mov	x1, x19
ffffffffea80db60:	aa1803e0 	mov	x0, x24
	void   *vptr = NULL;
ffffffffea80db64:	a906ffa5 	stp	x5, xzr, [x29, #104]
	ret = trusty_hyp_check_guest_pa_valid(paddr, roundedup_vring_sz, guest);
ffffffffea80db68:	97ffd326 	bl	ffffffffea802800 <trusty_hyp_check_guest_pa_valid>
	if (ret != NO_ERROR) {
ffffffffea80db6c:	350003c0 	cbnz	w0, ffffffffea80dbe4 <vqueue_init+0x104>
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
			__func__, ret);
		return ret;
	}

	ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80db70:	b00002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80db74:	2a1403e8 	mov	w8, w20
ffffffffea80db78:	f0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80db7c:	f90033a8 	str	x8, [x29, #96]
ffffffffea80db80:	f9408400 	ldr	x0, [x0, #264]
ffffffffea80db84:	52800607 	mov	w7, #0x30                  	// #48
ffffffffea80db88:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80db8c:	aa1803e5 	mov	x5, x24
ffffffffea80db90:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80db94:	9101c3a3 	add	x3, x29, #0x70
ffffffffea80db98:	aa1303e2 	mov	x2, x19
ffffffffea80db9c:	91038021 	add	x1, x1, #0xe0
ffffffffea80dba0:	94001016 	bl	ffffffffea811bf8 <vmm_alloc_physical>
ffffffffea80dba4:	2a0003fc 	mov	w28, w0
	                         roundedup_vring_sz,
	                         &vptr,  PAGE_SIZE_SHIFT,
	                         paddr, 0,
	                         ARCH_MMU_FLAG_NS | ARCH_MMU_FLAG_PERM_NO_EXECUTE |
	                         ARCH_MMU_FLAG_CACHED);
	if (ret != NO_ERROR) {
ffffffffea80dba8:	f94033a8 	ldr	x8, [x29, #96]
ffffffffea80dbac:	34000320 	cbz	w0, ffffffffea80dc10 <vqueue_init+0x130>
	vq->vring_addr = (vaddr_t)vptr;

	event_init(&vq->avail_event, false, 0);

	return NO_ERROR;
}
ffffffffea80dbb0:	f9402ab5 	ldr	x21, [x21, #80]
ffffffffea80dbb4:	2a1c03e0 	mov	w0, w28
ffffffffea80dbb8:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea80dbbc:	f94002a1 	ldr	x1, [x21]
ffffffffea80dbc0:	ca010041 	eor	x1, x2, x1
ffffffffea80dbc4:	b50004e1 	cbnz	x1, ffffffffea80dc60 <vqueue_init+0x180>
ffffffffea80dbc8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dbcc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80dbd0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80dbd4:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80dbd8:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80dbdc:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea80dbe0:	d65f03c0 	ret
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80dbe4:	f0000045 	adrp	x5, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80dbe8:	2a0003fc 	mov	w28, w0
ffffffffea80dbec:	2a0003e4 	mov	w4, w0
ffffffffea80dbf0:	f0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80dbf4:	f0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80dbf8:	9100a063 	add	x3, x3, #0x28
ffffffffea80dbfc:	528007c2 	mov	w2, #0x3e                  	// #62
ffffffffea80dc00:	91002021 	add	x1, x1, #0x8
ffffffffea80dc04:	9102a0a0 	add	x0, x5, #0xa8
ffffffffea80dc08:	94001814 	bl	ffffffffea813c58 <_printf>
		return ret;
ffffffffea80dc0c:	17ffffe9 	b	ffffffffea80dbb0 <vqueue_init+0xd0>
	vring_init(&vq->vring, num, vptr, align);
ffffffffea80dc10:	f9403ba1 	ldr	x1, [x29, #112]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80dc14:	91000900 	add	x0, x8, #0x2
		+ align-1) & ~(align - 1));
ffffffffea80dc18:	910006c4 	add	x4, x22, #0x1
ffffffffea80dc1c:	cb1603f6 	neg	x22, x22
	vq->id = id;
ffffffffea80dc20:	b90002fa 	str	w26, [x23]
	event_init(&vq->avail_event, false, 0);
ffffffffea80dc24:	52800002 	mov	w2, #0x0                   	// #0
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80dc28:	8b081028 	add	x8, x1, x8, lsl #4
	vr->num = num;
ffffffffea80dc2c:	b9000af4 	str	w20, [x23, #8]
	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + sizeof(__u16)
ffffffffea80dc30:	8b000500 	add	x0, x8, x0, lsl #1
	vr->avail = p + num*sizeof(struct vring_desc);
ffffffffea80dc34:	a90122e1 	stp	x1, x8, [x23, #16]
		+ align-1) & ~(align - 1));
ffffffffea80dc38:	8b040000 	add	x0, x0, x4
	vq->kick_cb = kick_cb;
ffffffffea80dc3c:	a907e6fb 	stp	x27, x25, [x23, #120]
ffffffffea80dc40:	8a160016 	and	x22, x0, x22
	vq->priv = priv;
ffffffffea80dc44:	f94037a0 	ldr	x0, [x29, #104]
	vq->vring_addr = (vaddr_t)vptr;
ffffffffea80dc48:	a90206f6 	stp	x22, x1, [x23, #32]
	event_init(&vq->avail_event, false, 0);
ffffffffea80dc4c:	52800001 	mov	w1, #0x0                   	// #0
	vq->priv = priv;
ffffffffea80dc50:	f90046e0 	str	x0, [x23, #136]
	event_init(&vq->avail_event, false, 0);
ffffffffea80dc54:	910122e0 	add	x0, x23, #0x48
ffffffffea80dc58:	97ffde5c 	bl	ffffffffea8055c8 <event_init>
	return NO_ERROR;
ffffffffea80dc5c:	17ffffd5 	b	ffffffffea80dbb0 <vqueue_init+0xd0>
}
ffffffffea80dc60:	94001832 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80dc64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80dc68 <vqueue_destroy>:

void vqueue_destroy(struct vqueue *vq)
{
ffffffffea80dc68:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80dc6c:	910003fd 	mov	x29, sp
ffffffffea80dc70:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80dc74:	aa0003f3 	mov	x19, x0
	vaddr_t vring_addr;
	spin_lock_saved_state_t state;

	DEBUG_ASSERT(vq);

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80dc78:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80dc7c:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80dc80:	d53b4220 	mrs	x0, daif
ffffffffea80dc84:	37380220 	tbnz	w0, #7, ffffffffea80dcc8 <vqueue_destroy+0x60>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80dc88:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80dc8c:	aa1403e0 	mov	x0, x20
ffffffffea80dc90:	97ffd30c 	bl	ffffffffea8028c0 <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80dc94:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80dc98:	aa1403e0 	mov	x0, x20
	vq->vring_addr = (vaddr_t)NULL;
	vq->vring_sz = 0;
ffffffffea80dc9c:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80dca0:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80dca4:	97ffd30f 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80dca8:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);

	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dcac:	b00002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80dcb0:	aa1503e1 	mov	x1, x21
}
ffffffffea80dcb4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dcb8:	f94013f5 	ldr	x21, [sp, #32]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dcbc:	f9408400 	ldr	x0, [x0, #264]
}
ffffffffea80dcc0:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dcc4:	1400102f 	b	ffffffffea811d80 <vmm_free_region>
    arch_spin_lock(lock);
ffffffffea80dcc8:	aa1403e0 	mov	x0, x20
ffffffffea80dccc:	97ffd2fd 	bl	ffffffffea8028c0 <arch_spin_lock>
	vring_addr = vq->vring_addr;
ffffffffea80dcd0:	f9401675 	ldr	x21, [x19, #40]
    arch_spin_unlock(lock);
ffffffffea80dcd4:	aa1403e0 	mov	x0, x20
	vq->vring_sz = 0;
ffffffffea80dcd8:	a902fe7f 	stp	xzr, xzr, [x19, #40]
	vq->last_avail_idx = 0;
ffffffffea80dcdc:	7900827f 	strh	wzr, [x19, #64]
ffffffffea80dce0:	97ffd300 	bl	ffffffffea8028e0 <arch_spin_unlock>
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dce4:	b00002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80dce8:	aa1503e1 	mov	x1, x21
}
ffffffffea80dcec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dcf0:	f94013f5 	ldr	x21, [sp, #32]
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dcf4:	f9408400 	ldr	x0, [x0, #264]
}
ffffffffea80dcf8:	a8c37bfd 	ldp	x29, x30, [sp], #48
	vmm_free_region(vmm_get_kernel_aspace(), vring_addr);
ffffffffea80dcfc:	14001021 	b	ffffffffea811d80 <vmm_free_region>

ffffffffea80dd00 <vqueue_signal_avail>:

void vqueue_signal_avail(struct vqueue *vq)
{
ffffffffea80dd00:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80dd04:	910003fd 	mov	x29, sp
ffffffffea80dd08:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80dd0c:	aa0003f3 	mov	x19, x0
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80dd10:	9100e014 	add	x20, x0, #0x38
{
ffffffffea80dd14:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80dd18:	d53b4220 	mrs	x0, daif
ffffffffea80dd1c:	91012275 	add	x21, x19, #0x48
ffffffffea80dd20:	37380280 	tbnz	w0, #7, ffffffffea80dd70 <vqueue_signal_avail+0x70>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80dd24:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80dd28:	aa1403e0 	mov	x0, x20
ffffffffea80dd2c:	97ffd2e5 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80dd30:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80dd34:	b4000440 	cbz	x0, ffffffffea80ddbc <vqueue_signal_avail+0xbc>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80dd38:	f9401263 	ldr	x3, [x19, #32]
	}
	event_signal(&vq->avail_event, false);
ffffffffea80dd3c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80dd40:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80dd44:	79400062 	ldrh	w2, [x3]
ffffffffea80dd48:	32000042 	orr	w2, w2, #0x1
ffffffffea80dd4c:	79000062 	strh	w2, [x3]
	event_signal(&vq->avail_event, false);
ffffffffea80dd50:	97ffde78 	bl	ffffffffea805730 <event_signal>
    arch_spin_unlock(lock);
ffffffffea80dd54:	aa1403e0 	mov	x0, x20
ffffffffea80dd58:	97ffd2e2 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80dd5c:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
}
ffffffffea80dd60:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dd64:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80dd68:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80dd6c:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea80dd70:	aa1403e0 	mov	x0, x20
ffffffffea80dd74:	97ffd2d3 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (vq->vring_addr) {
ffffffffea80dd78:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80dd7c:	b5000120 	cbnz	x0, ffffffffea80dda0 <vqueue_signal_avail+0xa0>
	event_signal(&vq->avail_event, false);
ffffffffea80dd80:	aa1503e0 	mov	x0, x21
ffffffffea80dd84:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80dd88:	97ffde6a 	bl	ffffffffea805730 <event_signal>
}
ffffffffea80dd8c:	f94013f5 	ldr	x21, [sp, #32]
    arch_spin_unlock(lock);
ffffffffea80dd90:	aa1403e0 	mov	x0, x20
ffffffffea80dd94:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80dd98:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80dd9c:	17ffd2d1 	b	ffffffffea8028e0 <arch_spin_unlock>
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80dda0:	f9401263 	ldr	x3, [x19, #32]
	event_signal(&vq->avail_event, false);
ffffffffea80dda4:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80dda8:	aa1503e0 	mov	x0, x21
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80ddac:	79400062 	ldrh	w2, [x3]
ffffffffea80ddb0:	32000042 	orr	w2, w2, #0x1
ffffffffea80ddb4:	79000062 	strh	w2, [x3]
ffffffffea80ddb8:	17fffff4 	b	ffffffffea80dd88 <vqueue_signal_avail+0x88>
	event_signal(&vq->avail_event, false);
ffffffffea80ddbc:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80ddc0:	aa1503e0 	mov	x0, x21
ffffffffea80ddc4:	97ffde5b 	bl	ffffffffea805730 <event_signal>
ffffffffea80ddc8:	aa1403e0 	mov	x0, x20
ffffffffea80ddcc:	97ffd2c5 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea80ddd0:	17ffffe3 	b	ffffffffea80dd5c <vqueue_signal_avail+0x5c>
ffffffffea80ddd4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ddd8 <vqueue_get_avail_buf>:

	return NO_ERROR;
}

int vqueue_get_avail_buf(struct vqueue *vq, struct vqueue_buf *iovbuf)
{
ffffffffea80ddd8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80dddc:	910003fd 	mov	x29, sp
ffffffffea80dde0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80dde4:	aa0103f4 	mov	x20, x1
ffffffffea80dde8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ddec:	aa0003f5 	mov	x21, x0
ffffffffea80ddf0:	f9001bf7 	str	x23, [sp, #48]
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80ddf4:	9100e016 	add	x22, x0, #0x38
ffffffffea80ddf8:	aa1e03f7 	mov	x23, x30
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80ddfc:	d53b4220 	mrs	x0, daif
ffffffffea80de00:	37380100 	tbnz	w0, #7, ffffffffea80de20 <vqueue_get_avail_buf+0x48>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80de04:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80de08:	aa1603e0 	mov	x0, x22
ffffffffea80de0c:	97ffd2ad 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80de10:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80de14:	b4000de0 	cbz	x0, ffffffffea80dfd0 <vqueue_get_avail_buf+0x1f8>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80de18:	52800033 	mov	w19, #0x1                   	// #1
ffffffffea80de1c:	14000006 	b	ffffffffea80de34 <vqueue_get_avail_buf+0x5c>
ffffffffea80de20:	aa1603e0 	mov	x0, x22
ffffffffea80de24:	97ffd2a7 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea80de28:	f94016a0 	ldr	x0, [x21, #40]
ffffffffea80de2c:	b4000e00 	cbz	x0, ffffffffea80dfec <vqueue_get_avail_buf+0x214>
    spin_lock_saved_state_t state = 0;
ffffffffea80de30:	52800013 	mov	w19, #0x0                   	// #0
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80de34:	f9400ea1 	ldr	x1, [x21, #24]
ffffffffea80de38:	794082a3 	ldrh	w3, [x21, #64]
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80de3c:	794012a0 	ldrh	w0, [x21, #8]
	uint16_t avail_cnt = vq->vring.avail->idx - vq->last_avail_idx;
ffffffffea80de40:	79400424 	ldrh	w4, [x1, #2]
ffffffffea80de44:	4b030081 	sub	w1, w4, w3
	if (unlikely(avail_cnt > (uint16_t) vq->vring.num)) {
ffffffffea80de48:	6b21201f 	cmp	w0, w1, uxth
ffffffffea80de4c:	54000aa3 	b.cc	ffffffffea80dfa0 <vqueue_get_avail_buf+0x1c8>  // b.lo, b.ul, b.last
	if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80de50:	6b03009f 	cmp	w4, w3
ffffffffea80de54:	54000780 	b.eq	ffffffffea80df44 <vqueue_get_avail_buf+0x16c>  // b.none
	smp_rmb();
ffffffffea80de58:	d50339bf 	dmb	ishld
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80de5c:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80de60:	b9400aa4 	ldr	w4, [x21, #8]
ffffffffea80de64:	f9400ea3 	ldr	x3, [x21, #24]
	vq->last_avail_idx++;
ffffffffea80de68:	11000422 	add	w2, w1, #0x1
	next_idx = vq->vring.avail->ring[vq->last_avail_idx % vq->vring.num];
ffffffffea80de6c:	1ac40820 	udiv	w0, w1, w4
ffffffffea80de70:	1b048400 	msub	w0, w0, w4, w1
ffffffffea80de74:	8b000460 	add	x0, x3, x0, lsl #1
ffffffffea80de78:	79400803 	ldrh	w3, [x0, #4]
	vq->last_avail_idx++;
ffffffffea80de7c:	790082a2 	strh	w2, [x21, #64]
	if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80de80:	6b03009f 	cmp	w4, w3
ffffffffea80de84:	540009a9 	b.ls	ffffffffea80dfb8 <vqueue_get_avail_buf+0x1e0>  // b.plast
		desc = &vq->vring.desc[next_idx];
ffffffffea80de88:	f9400aa9 	ldr	x9, [x21, #16]
			iovlist = &iovbuf->out_iovs;
ffffffffea80de8c:	9100a28c 	add	x12, x20, #0x28
	iovbuf->head = next_idx;
ffffffffea80de90:	79000283 	strh	w3, [x20]
			iovlist = &iovbuf->out_iovs;
ffffffffea80de94:	91002294 	add	x20, x20, #0x8
	iovbuf->in_iovs.used = 0;
ffffffffea80de98:	b900069f 	str	wzr, [x20, #4]
	iovbuf->in_iovs.len  = 0;
ffffffffea80de9c:	f900069f 	str	xzr, [x20, #8]
	iovbuf->out_iovs.used = 0;
ffffffffea80dea0:	b900269f 	str	wzr, [x20, #36]
	iovbuf->out_iovs.len  = 0;
ffffffffea80dea4:	f900169f 	str	xzr, [x20, #40]
		desc = &vq->vring.desc[next_idx];
ffffffffea80dea8:	d37c3c63 	ubfiz	x3, x3, #4, #16
ffffffffea80deac:	8b030125 	add	x5, x9, x3
		if (desc->flags & VRING_DESC_F_WRITE) {
ffffffffea80deb0:	794018a7 	ldrh	w7, [x5, #12]
			iovlist = &iovbuf->out_iovs;
ffffffffea80deb4:	f27f00ff 	tst	x7, #0x2
ffffffffea80deb8:	9a8c0280 	csel	x0, x20, x12, eq  // eq = none
		if (iovlist->used < iovlist->cnt) {
ffffffffea80debc:	29400801 	ldp	w1, w2, [x0]
ffffffffea80dec0:	6b01005f 	cmp	w2, w1
ffffffffea80dec4:	54000382 	b.cs	ffffffffea80df34 <vqueue_get_avail_buf+0x15c>  // b.hs, b.nlast
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80dec8:	a941180a 	ldp	x10, x6, [x0, #16]
ffffffffea80decc:	2a0203e8 	mov	w8, w2
ffffffffea80ded0:	b94008a1 	ldr	w1, [x5, #8]
			iovlist->used++;
ffffffffea80ded4:	11000442 	add	w2, w2, #0x1
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80ded8:	f863692b 	ldr	x11, [x9, x3]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80dedc:	8b0810c6 	add	x6, x6, x8, lsl #4
		next_idx = desc->next;
ffffffffea80dee0:	79401ca3 	ldrh	w3, [x5, #14]
			iovlist->iovs[iovlist->used].len = desc->len;
ffffffffea80dee4:	f90004c1 	str	x1, [x6, #8]
			iovlist->phys[iovlist->used] = (paddr_t) desc->addr;
ffffffffea80dee8:	f828794b 	str	x11, [x10, x8, lsl #3]
			iovlist->used++;
ffffffffea80deec:	b9000402 	str	w2, [x0, #4]
			iovlist->len += desc->len;
ffffffffea80def0:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80def4:	8b010042 	add	x2, x2, x1
ffffffffea80def8:	f9000402 	str	x2, [x0, #8]
	} while (desc->flags & VRING_DESC_F_NEXT);
ffffffffea80defc:	36000207 	tbz	w7, #0, ffffffffea80df3c <vqueue_get_avail_buf+0x164>
		if (unlikely(next_idx >= vq->vring.num)) {
ffffffffea80df00:	6b03009f 	cmp	w4, w3
ffffffffea80df04:	54fffd28 	b.hi	ffffffffea80dea8 <vqueue_get_avail_buf+0xd0>  // b.pmore
			return ERR_NOT_VALID;
ffffffffea80df08:	128000d4 	mov	w20, #0xfffffff9            	// #-7
    arch_spin_unlock(lock);
ffffffffea80df0c:	aa1603e0 	mov	x0, x22
ffffffffea80df10:	97ffd274 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80df14:	34000053 	cbz	w19, ffffffffea80df1c <vqueue_get_avail_buf+0x144>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80df18:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_get_avail_buf_locked(vq, iovbuf);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80df1c:	2a1403e0 	mov	w0, w20
ffffffffea80df20:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80df24:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80df28:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80df2c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80df30:	d65f03c0 	ret
			return ERR_TOO_BIG;
ffffffffea80df34:	12800314 	mov	w20, #0xffffffe7            	// #-25
ffffffffea80df38:	17fffff5 	b	ffffffffea80df0c <vqueue_get_avail_buf+0x134>
	return NO_ERROR;
ffffffffea80df3c:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea80df40:	17fffff3 	b	ffffffffea80df0c <vqueue_get_avail_buf+0x134>
ffffffffea80df44:	f9001fb8 	str	x24, [x29, #56]
		event_unsignal(&vq->avail_event);
ffffffffea80df48:	910122b8 	add	x24, x21, #0x48
ffffffffea80df4c:	aa1803e0 	mov	x0, x24
ffffffffea80df50:	97ffde38 	bl	ffffffffea805830 <event_unsignal>
		vq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;
ffffffffea80df54:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea80df58:	79400020 	ldrh	w0, [x1]
ffffffffea80df5c:	121f7800 	and	w0, w0, #0xfffffffe
ffffffffea80df60:	79000020 	strh	w0, [x1]
		smp_mb();
ffffffffea80df64:	d5033bbf 	dmb	ish
		if (vq->last_avail_idx == vq->vring.avail->idx) {
ffffffffea80df68:	f9400ea0 	ldr	x0, [x21, #24]
ffffffffea80df6c:	794082a1 	ldrh	w1, [x21, #64]
ffffffffea80df70:	79400400 	ldrh	w0, [x0, #2]
ffffffffea80df74:	6b00003f 	cmp	w1, w0
ffffffffea80df78:	54000340 	b.eq	ffffffffea80dfe0 <vqueue_get_avail_buf+0x208>  // b.none
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80df7c:	f94012a3 	ldr	x3, [x21, #32]
		event_signal(&vq->avail_event, false);
ffffffffea80df80:	aa1803e0 	mov	x0, x24
ffffffffea80df84:	52800001 	mov	w1, #0x0                   	// #0
		vq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;
ffffffffea80df88:	79400062 	ldrh	w2, [x3]
ffffffffea80df8c:	32000042 	orr	w2, w2, #0x1
ffffffffea80df90:	79000062 	strh	w2, [x3]
		event_signal(&vq->avail_event, false);
ffffffffea80df94:	97ffdde7 	bl	ffffffffea805730 <event_signal>
ffffffffea80df98:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80df9c:	17ffffaf 	b	ffffffffea80de58 <vqueue_get_avail_buf+0x80>
		panic("vq %p: new avail idx out of range (old %u new %u)\n",
ffffffffea80dfa0:	f0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80dfa4:	aa1503e2 	mov	x2, x21
ffffffffea80dfa8:	91012021 	add	x1, x1, #0x48
ffffffffea80dfac:	aa1703e0 	mov	x0, x23
ffffffffea80dfb0:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80dfb4:	94001173 	bl	ffffffffea812580 <_panic>
		panic("vq %p: head out of range %u (max %u)\n",
ffffffffea80dfb8:	f0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80dfbc:	aa1503e2 	mov	x2, x21
ffffffffea80dfc0:	91020021 	add	x1, x1, #0x80
ffffffffea80dfc4:	aa1703e0 	mov	x0, x23
ffffffffea80dfc8:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80dfcc:	9400116d 	bl	ffffffffea812580 <_panic>
ffffffffea80dfd0:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80dfd4:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80dfd8:	97ffd242 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea80dfdc:	17ffffcf 	b	ffffffffea80df18 <vqueue_get_avail_buf+0x140>
			return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80dfe0:	12800114 	mov	w20, #0xfffffff7            	// #-9
ffffffffea80dfe4:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80dfe8:	17ffffc9 	b	ffffffffea80df0c <vqueue_get_avail_buf+0x134>
ffffffffea80dfec:	aa1603e0 	mov	x0, x22
		return ERR_CHANNEL_CLOSED;
ffffffffea80dff0:	128001d4 	mov	w20, #0xfffffff1            	// #-15
ffffffffea80dff4:	97ffd23b 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea80dff8:	17ffffc9 	b	ffffffffea80df1c <vqueue_get_avail_buf+0x144>
ffffffffea80dffc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e000 <vqueue_map_iovs>:

int vqueue_map_iovs(struct vqueue_iovs *vqiovs, u_int flags, uint32_t guest)
{
ffffffffea80e000:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea80e004:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80e008:	b9400403 	ldr	w3, [x0, #4]
{
ffffffffea80e00c:	f9002ffc 	str	x28, [sp, #88]
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80e010:	34000883 	cbz	w3, ffffffffea80e120 <vqueue_map_iovs+0x120>
ffffffffea80e014:	a9025bb5 	stp	x21, x22, [x29, #32]
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
				__func__, ret);
			return ret;
		}
        vqiovs->iovs[i].base = NULL;
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80e018:	900002b5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea80e01c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80e020:	2a0203f6 	mov	w22, w2
ffffffffea80e024:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80e028:	aa0003f4 	mov	x20, x0
ffffffffea80e02c:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea80e030:	d0000058 	adrp	x24, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e034:	2a0103f7 	mov	w23, w1
ffffffffea80e038:	91038318 	add	x24, x24, #0xe0
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80e03c:	5280001a 	mov	w26, #0x0                   	// #0
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80e040:	f94086b5 	ldr	x21, [x21, #264]
ffffffffea80e044:	f9002bbb 	str	x27, [x29, #80]
ffffffffea80e048:	14000011 	b	ffffffffea80e08c <vqueue_map_iovs+0x8c>
        vqiovs->iovs[i].base = NULL;
ffffffffea80e04c:	a9410682 	ldp	x2, x1, [x20, #16]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80e050:	2a1703e7 	mov	w7, w23
ffffffffea80e054:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80e058:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea80e05c:	8b1b0023 	add	x3, x1, x27
ffffffffea80e060:	f8797845 	ldr	x5, [x2, x25, lsl #3]
ffffffffea80e064:	aa1303e2 	mov	x2, x19
        vqiovs->iovs[i].base = NULL;
ffffffffea80e068:	f83b683f 	str	xzr, [x1, x27]
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80e06c:	aa1803e1 	mov	x1, x24
ffffffffea80e070:	94000ee2 	bl	ffffffffea811bf8 <vmm_alloc_physical>
ffffffffea80e074:	2a0003fc 	mov	w28, w0
		                         roundedup_iovs_sz,
		                         &vqiovs->iovs[i].base, PAGE_SIZE_SHIFT,
		                         vqiovs->phys[i], 0, flags);
		if (ret) {
ffffffffea80e078:	350005e0 	cbnz	w0, ffffffffea80e134 <vqueue_map_iovs+0x134>
	for (i = 0; i < vqiovs->used; i++) {
ffffffffea80e07c:	b9400680 	ldr	w0, [x20, #4]
ffffffffea80e080:	1100075a 	add	w26, w26, #0x1
ffffffffea80e084:	6b1a001f 	cmp	w0, w26
ffffffffea80e088:	54000429 	b.ls	ffffffffea80e10c <vqueue_map_iovs+0x10c>  // b.plast
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80e08c:	a9410e80 	ldp	x0, x3, [x20, #16]
ffffffffea80e090:	2a1a03f9 	mov	w25, w26
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80e094:	2a1603e2 	mov	w2, w22
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80e098:	d37cef3b 	lsl	x27, x25, #4
ffffffffea80e09c:	8b1b0063 	add	x3, x3, x27
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80e0a0:	f8797800 	ldr	x0, [x0, x25, lsl #3]
		roundedup_iovs_sz = ROUNDUP(vqiovs->iovs[i].len, PAGE_SIZE);
ffffffffea80e0a4:	f9400473 	ldr	x19, [x3, #8]
ffffffffea80e0a8:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80e0ac:	9274ce73 	and	x19, x19, #0xfffffffffffff000
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80e0b0:	aa1303e1 	mov	x1, x19
ffffffffea80e0b4:	97ffd1d3 	bl	ffffffffea802800 <trusty_hyp_check_guest_pa_valid>
ffffffffea80e0b8:	aa0003e4 	mov	x4, x0
		ret = vmm_alloc_physical(vmm_get_kernel_aspace(), "vqueue",
ffffffffea80e0bc:	aa1503e0 	mov	x0, x21
		ret = trusty_hyp_check_guest_pa_valid(vqiovs->phys[i],
ffffffffea80e0c0:	2a0403fc 	mov	w28, w4
		if (ret != NO_ERROR) {
ffffffffea80e0c4:	34fffc44 	cbz	w4, ffffffffea80e04c <vqueue_map_iovs+0x4c>
			TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80e0c8:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e0cc:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e0d0:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e0d4:	9100e063 	add	x3, x3, #0x38
ffffffffea80e0d8:	52801e42 	mov	w2, #0xf2                  	// #242
ffffffffea80e0dc:	91006021 	add	x1, x1, #0x18
ffffffffea80e0e0:	9102a000 	add	x0, x0, #0xa8
ffffffffea80e0e4:	940016dd 	bl	ffffffffea813c58 <_printf>
		vmm_free_region(vmm_get_kernel_aspace(),
		                (vaddr_t)vqiovs->iovs[i].base);
		vqiovs->iovs[i].base = NULL;
	}
	return ret;
}
ffffffffea80e0e8:	2a1c03e0 	mov	w0, w28
ffffffffea80e0ec:	f9402bbb 	ldr	x27, [x29, #80]
ffffffffea80e0f0:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e0f4:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80e0f8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80e0fc:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80e100:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80e104:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e108:	d65f03c0 	ret
ffffffffea80e10c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e110:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80e114:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea80e118:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea80e11c:	f9402bbb 	ldr	x27, [x29, #80]
	return NO_ERROR;
ffffffffea80e120:	5280001c 	mov	w28, #0x0                   	// #0
}
ffffffffea80e124:	2a1c03e0 	mov	w0, w28
ffffffffea80e128:	f9402ffc 	ldr	x28, [sp, #88]
ffffffffea80e12c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea80e130:	d65f03c0 	ret
	while (i--) {
ffffffffea80e134:	51000753 	sub	w19, w26, #0x1
ffffffffea80e138:	34fffd9a 	cbz	w26, ffffffffea80e0e8 <vqueue_map_iovs+0xe8>
ffffffffea80e13c:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80e140:	d37c7e73 	ubfiz	x19, x19, #4, #32
ffffffffea80e144:	d503201f 	nop
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80e148:	f8736801 	ldr	x1, [x0, x19]
ffffffffea80e14c:	aa1503e0 	mov	x0, x21
ffffffffea80e150:	94000f0c 	bl	ffffffffea811d80 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80e154:	f9400e80 	ldr	x0, [x20, #24]
ffffffffea80e158:	f833681f 	str	xzr, [x0, x19]
ffffffffea80e15c:	d1004273 	sub	x19, x19, #0x10
	while (i--) {
ffffffffea80e160:	b100427f 	cmn	x19, #0x10
ffffffffea80e164:	54ffff21 	b.ne	ffffffffea80e148 <vqueue_map_iovs+0x148>  // b.any
ffffffffea80e168:	17ffffe0 	b	ffffffffea80e0e8 <vqueue_map_iovs+0xe8>
ffffffffea80e16c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e170 <vqueue_unmap_iovs>:
	DEBUG_ASSERT(vqiovs);
	DEBUG_ASSERT(vqiovs->phys);
	DEBUG_ASSERT(vqiovs->iovs);
	DEBUG_ASSERT(vqiovs->used <= vqiovs->cnt);

	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80e170:	b9400401 	ldr	w1, [x0, #4]
ffffffffea80e174:	34000321 	cbz	w1, ffffffffea80e1d8 <vqueue_unmap_iovs+0x68>
{
ffffffffea80e178:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e17c:	910003fd 	mov	x29, sp
ffffffffea80e180:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80e184:	900002b6 	adrp	x22, ffffffffea862000 <__ctor_list>
ffffffffea80e188:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80e18c:	aa0003f5 	mov	x21, x0
		/* base is expected to be set */
		DEBUG_ASSERT(vqiovs->iovs[i].base);
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80e190:	f94086d6 	ldr	x22, [x22, #264]
{
ffffffffea80e194:	a90153f3 	stp	x19, x20, [sp, #16]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80e198:	52800013 	mov	w19, #0x0                   	// #0
ffffffffea80e19c:	d503201f 	nop
		                (vaddr_t)vqiovs->iovs[i].base);
ffffffffea80e1a0:	d37c7e74 	ubfiz	x20, x19, #4, #32
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80e1a4:	aa1603e0 	mov	x0, x22
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80e1a8:	11000673 	add	w19, w19, #0x1
		vmm_free_region(vmm_get_kernel_aspace(),
ffffffffea80e1ac:	f8746821 	ldr	x1, [x1, x20]
ffffffffea80e1b0:	94000ef4 	bl	ffffffffea811d80 <vmm_free_region>
		vqiovs->iovs[i].base = NULL;
ffffffffea80e1b4:	f9400ea1 	ldr	x1, [x21, #24]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80e1b8:	b94006a0 	ldr	w0, [x21, #4]
		vqiovs->iovs[i].base = NULL;
ffffffffea80e1bc:	f834683f 	str	xzr, [x1, x20]
	for (uint i = 0; i < vqiovs->used; i++) {
ffffffffea80e1c0:	6b13001f 	cmp	w0, w19
ffffffffea80e1c4:	54fffee8 	b.hi	ffffffffea80e1a0 <vqueue_unmap_iovs+0x30>  // b.pmore
	}
}
ffffffffea80e1c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e1cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80e1d0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e1d4:	d65f03c0 	ret
ffffffffea80e1d8:	d65f03c0 	ret
ffffffffea80e1dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e1e0 <vqueue_add_buf>:
	vq->vring.used->idx++;
	return NO_ERROR;
}

int vqueue_add_buf(struct vqueue *vq, struct vqueue_buf *buf, uint32_t len)
{
ffffffffea80e1e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e1e4:	910003fd 	mov	x29, sp
ffffffffea80e1e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e1ec:	aa0003f3 	mov	x19, x0
ffffffffea80e1f0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80e1f4:	aa0103f4 	mov	x20, x1
ffffffffea80e1f8:	2a0203f6 	mov	w22, w2
	spin_lock_saved_state_t state;

	spin_lock_save(&vq->slock, &state, VQ_LOCK_FLAGS);
ffffffffea80e1fc:	9100e015 	add	x21, x0, #0x38
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea80e200:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea80e204:	37380180 	tbnz	w0, #7, ffffffffea80e234 <vqueue_add_buf+0x54>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea80e208:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea80e20c:	aa1503e0 	mov	x0, x21
ffffffffea80e210:	97ffd1ac 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80e214:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80e218:	b4000580 	cbz	x0, ffffffffea80e2c8 <vqueue_add_buf+0xe8>
	if (buf->head >= vq->vring.num) {
ffffffffea80e21c:	79400285 	ldrh	w5, [x20]
ffffffffea80e220:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e224:	6b05003f 	cmp	w1, w5
ffffffffea80e228:	54000589 	b.ls	ffffffffea80e2d8 <vqueue_add_buf+0xf8>  // b.plast
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea80e22c:	52800034 	mov	w20, #0x1                   	// #1
ffffffffea80e230:	1400000a 	b	ffffffffea80e258 <vqueue_add_buf+0x78>
ffffffffea80e234:	aa1503e0 	mov	x0, x21
ffffffffea80e238:	97ffd1a2 	bl	ffffffffea8028c0 <arch_spin_lock>
	if (!vq->vring_addr) {
ffffffffea80e23c:	f9401660 	ldr	x0, [x19, #40]
ffffffffea80e240:	b4000340 	cbz	x0, ffffffffea80e2a8 <vqueue_add_buf+0xc8>
	if (buf->head >= vq->vring.num) {
ffffffffea80e244:	79400285 	ldrh	w5, [x20]
ffffffffea80e248:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80e24c:	6b05003f 	cmp	w1, w5
ffffffffea80e250:	54000349 	b.ls	ffffffffea80e2b8 <vqueue_add_buf+0xd8>  // b.plast
    spin_lock_saved_state_t state = 0;
ffffffffea80e254:	52800014 	mov	w20, #0x0                   	// #0
	used = &vq->vring.used->ring[vq->vring.used->idx % vq->vring.num];
ffffffffea80e258:	f9401263 	ldr	x3, [x19, #32]
ffffffffea80e25c:	79400464 	ldrh	w4, [x3, #2]
ffffffffea80e260:	1ac10880 	udiv	w0, w4, w1
ffffffffea80e264:	1b019000 	msub	w0, w0, w1, w4
ffffffffea80e268:	8b000c60 	add	x0, x3, x0, lsl #3
	used->len = len;
ffffffffea80e26c:	2900d805 	stp	w5, w22, [x0, #4]
	smp_wmb();
ffffffffea80e270:	d5033abf 	dmb	ishst
	vq->vring.used->idx++;
ffffffffea80e274:	f9401262 	ldr	x2, [x19, #32]
    arch_spin_unlock(lock);
ffffffffea80e278:	aa1503e0 	mov	x0, x21
ffffffffea80e27c:	79400441 	ldrh	w1, [x2, #2]
ffffffffea80e280:	11000421 	add	w1, w1, #0x1
ffffffffea80e284:	79000441 	strh	w1, [x2, #2]
ffffffffea80e288:	97ffd196 	bl	ffffffffea8028e0 <arch_spin_unlock>
	return NO_ERROR;
ffffffffea80e28c:	52800000 	mov	w0, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea80e290:	34000054 	cbz	w20, ffffffffea80e298 <vqueue_add_buf+0xb8>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea80e294:	d50342ff 	msr	daifclr, #0x2
	int ret = _vqueue_add_buf_locked(vq, buf, len);
	spin_unlock_restore(&vq->slock, state, VQ_LOCK_FLAGS);
	return ret;
}
ffffffffea80e298:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e29c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80e2a0:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e2a4:	d65f03c0 	ret
ffffffffea80e2a8:	aa1503e0 	mov	x0, x21
ffffffffea80e2ac:	97ffd18d 	bl	ffffffffea8028e0 <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80e2b0:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80e2b4:	17fffff9 	b	ffffffffea80e298 <vqueue_add_buf+0xb8>
ffffffffea80e2b8:	aa1503e0 	mov	x0, x21
ffffffffea80e2bc:	97ffd189 	bl	ffffffffea8028e0 <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80e2c0:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80e2c4:	17fffff5 	b	ffffffffea80e298 <vqueue_add_buf+0xb8>
ffffffffea80e2c8:	aa1503e0 	mov	x0, x21
ffffffffea80e2cc:	97ffd185 	bl	ffffffffea8028e0 <arch_spin_unlock>
		return ERR_CHANNEL_CLOSED;
ffffffffea80e2d0:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80e2d4:	17fffff0 	b	ffffffffea80e294 <vqueue_add_buf+0xb4>
ffffffffea80e2d8:	aa1503e0 	mov	x0, x21
ffffffffea80e2dc:	97ffd181 	bl	ffffffffea8028e0 <arch_spin_unlock>
		return ERR_NOT_VALID;
ffffffffea80e2e0:	128000c0 	mov	w0, #0xfffffff9            	// #-7
ffffffffea80e2e4:	17ffffec 	b	ffffffffea80e294 <vqueue_add_buf+0xb4>

ffffffffea80e2e8 <trusty_sm_init>:
	.stdcall_handler = trusty_sm_stdcall,
	.nopcall_handler = trusty_sm_nopcall
};

static void trusty_sm_init(uint level)
{
ffffffffea80e2e8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	int err;

	dprintf(INFO, "Initializing Trusted OS SMC handler\n");

	err = sm_register_entity(SMC_ENTITY_TRUSTED_OS, &trusty_sm_entity);
ffffffffea80e2ec:	f0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80e2f0:	52800640 	mov	w0, #0x32                  	// #50
ffffffffea80e2f4:	9139a021 	add	x1, x1, #0xe68
{
ffffffffea80e2f8:	910003fd 	mov	x29, sp
	err = sm_register_entity(SMC_ENTITY_TRUSTED_OS, &trusty_sm_entity);
ffffffffea80e2fc:	97ffea0b 	bl	ffffffffea808b28 <sm_register_entity>
	if (err) {
ffffffffea80e300:	35000060 	cbnz	w0, ffffffffea80e30c <trusty_sm_init+0x24>
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
	}
}
ffffffffea80e304:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80e308:	d65f03c0 	ret
ffffffffea80e30c:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: Cannot register SMC entity! (%d)\n", err);
ffffffffea80e310:	d0000044 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e314:	2a0003e3 	mov	w3, w0
ffffffffea80e318:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e31c:	52802442 	mov	w2, #0x122                 	// #290
ffffffffea80e320:	91068021 	add	x1, x1, #0x1a0
ffffffffea80e324:	91078080 	add	x0, x4, #0x1e0
ffffffffea80e328:	1400164c 	b	ffffffffea813c58 <_printf>
ffffffffea80e32c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e330 <get_ns_mem_buf>:
{
ffffffffea80e330:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80e334:	910003fd 	mov	x29, sp
ffffffffea80e338:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80e33c:	aa0303f3 	mov	x19, x3
	status_t rc = smc32_decode_mem_buf_info(args, ppa, psz, pflags);
ffffffffea80e340:	97ffea60 	bl	ffffffffea808cc0 <smc32_decode_mem_buf_info>
	if (rc != NO_ERROR) {
ffffffffea80e344:	35000100 	cbnz	w0, ffffffffea80e364 <get_ns_mem_buf+0x34>
	uint mem_type = *pflags & ARCH_MMU_FLAG_CACHE_MASK;
ffffffffea80e348:	b9400260 	ldr	w0, [x19]
ffffffffea80e34c:	12000401 	and	w1, w0, #0x3
	if (mem_type != ARCH_MMU_FLAG_CACHED &&
ffffffffea80e350:	7100043f 	cmp	w1, #0x1
ffffffffea80e354:	540000e8 	b.hi	ffffffffea80e370 <get_ns_mem_buf+0x40>  // b.pmore
		return ERR_INVALID_ARGS;
ffffffffea80e358:	721e041f 	tst	w0, #0xc
ffffffffea80e35c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e360:	1a8003e0 	csel	w0, wzr, w0, eq  // eq = none
}
ffffffffea80e364:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80e368:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80e36c:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e370:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e374:	17fffffc 	b	ffffffffea80e364 <get_ns_mem_buf+0x34>

ffffffffea80e378 <trusty_sm_nopcall>:
{
ffffffffea80e378:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80e37c:	aa0003e1 	mov	x1, x0
ffffffffea80e380:	910003fd 	mov	x29, sp
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80e384:	b9401c02 	ldr	w2, [x0, #28]
	if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80e388:	51004040 	sub	w0, w2, #0x10
ffffffffea80e38c:	3100481f 	cmn	w0, #0x12
ffffffffea80e390:	540003c9 	b.ls	ffffffffea80e408 <trusty_sm_nopcall+0x90>  // b.plast
	switch (args->params[0]) {
ffffffffea80e394:	b9400420 	ldr	w0, [x1, #4]
ffffffffea80e398:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea80e39c:	72a64003 	movk	w3, #0x3200, lsl #16
ffffffffea80e3a0:	6b03001f 	cmp	w0, w3
ffffffffea80e3a4:	540002a0 	b.eq	ffffffffea80e3f8 <trusty_sm_nopcall+0x80>  // b.none
ffffffffea80e3a8:	52800342 	mov	w2, #0x1a                  	// #26
ffffffffea80e3ac:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e3b0:	6b02001f 	cmp	w0, w2
ffffffffea80e3b4:	540000e0 	b.eq	ffffffffea80e3d0 <trusty_sm_nopcall+0x58>  // b.none
ffffffffea80e3b8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80e3bc:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e3c0:	9103a000 	add	x0, x0, #0xe8
ffffffffea80e3c4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
}
ffffffffea80e3c8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80e3cc:	d65f03c0 	ret
		res = arm_gic_sim_irq_handler(args->params[1]);
ffffffffea80e3d0:	b9400820 	ldr	w0, [x1, #8]
ffffffffea80e3d4:	97ffda77 	bl	ffffffffea804db0 <arm_gic_sim_irq_handler>
ffffffffea80e3d8:	93407c00 	sxtw	x0, w0
	if (err >= 0) {
ffffffffea80e3dc:	b6ffff60 	tbz	x0, #63, ffffffffea80e3c8 <trusty_sm_nopcall+0x50>
ffffffffea80e3e0:	91006001 	add	x1, x0, #0x18
ffffffffea80e3e4:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80e3e8:	f100403f 	cmp	x1, #0x10
ffffffffea80e3ec:	54fffe89 	b.ls	ffffffffea80e3bc <trusty_sm_nopcall+0x44>  // b.plast
}
ffffffffea80e3f0:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80e3f4:	d65f03c0 	ret
		res = virtio_kick_vq(args->params[1], args->params[2], guest);
ffffffffea80e3f8:	29410420 	ldp	w0, w1, [x1, #8]
ffffffffea80e3fc:	940002db 	bl	ffffffffea80ef68 <virtio_kick_vq>
ffffffffea80e400:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80e404:	17fffff6 	b	ffffffffea80e3dc <trusty_sm_nopcall+0x64>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80e408:	2a0203e4 	mov	w4, w2
ffffffffea80e40c:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e410:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e414:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e418:	91072063 	add	x3, x3, #0x1c8
ffffffffea80e41c:	52801fe2 	mov	w2, #0xff                  	// #255
ffffffffea80e420:	91062021 	add	x1, x1, #0x188
ffffffffea80e424:	91086000 	add	x0, x0, #0x218
ffffffffea80e428:	9400160c 	bl	ffffffffea813c58 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80e42c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80e430:	17ffffe6 	b	ffffffffea80e3c8 <trusty_sm_nopcall+0x50>
ffffffffea80e434:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e438 <lock_bl_data_interface>:
}
ffffffffea80e438:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80e43c:	d65f03c0 	ret

ffffffffea80e440 <handle_bl_data_interface>:
}
ffffffffea80e440:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80e444:	d65f03c0 	ret

ffffffffea80e448 <set_root_of_trust_params>:
}
ffffffffea80e448:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80e44c:	d65f03c0 	ret

ffffffffea80e450 <trusty_sm_stdcall>:
{
ffffffffea80e450:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80e454:	910003fd 	mov	x29, sp
ffffffffea80e458:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e45c:	900002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
	uint32_t guest = args->params[SMC_ARGS_GUESTID];
ffffffffea80e460:	b9401c14 	ldr	w20, [x0, #28]
{
ffffffffea80e464:	f9402a61 	ldr	x1, [x19, #80]
ffffffffea80e468:	f9400022 	ldr	x2, [x1]
ffffffffea80e46c:	f9001fa2 	str	x2, [x29, #56]
ffffffffea80e470:	d2800002 	mov	x2, #0x0                   	// #0
	 if (((int32_t)guest != HV_GUEST_ID) &&
ffffffffea80e474:	51004281 	sub	w1, w20, #0x10
ffffffffea80e478:	3100483f 	cmn	w1, #0x12
ffffffffea80e47c:	54001289 	b.ls	ffffffffea80e6cc <trusty_sm_stdcall+0x27c>  // b.plast
	switch (args->smc_nr) {
ffffffffea80e480:	b9400001 	ldr	w1, [x0]
ffffffffea80e484:	528003c2 	mov	w2, #0x1e                  	// #30
ffffffffea80e488:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e48c:	aa0003e3 	mov	x3, x0
ffffffffea80e490:	6b02003f 	cmp	w1, w2
ffffffffea80e494:	54000e80 	b.eq	ffffffffea80e664 <trusty_sm_stdcall+0x214>  // b.none
ffffffffea80e498:	54000368 	b.hi	ffffffffea80e504 <trusty_sm_stdcall+0xb4>  // b.pmore
ffffffffea80e49c:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea80e4a0:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e4a4:	6b02003f 	cmp	w1, w2
ffffffffea80e4a8:	54000c60 	b.eq	ffffffffea80e634 <trusty_sm_stdcall+0x1e4>  // b.none
ffffffffea80e4ac:	540005a9 	b.ls	ffffffffea80e560 <trusty_sm_stdcall+0x110>  // b.plast
ffffffffea80e4b0:	528002e0 	mov	w0, #0x17                  	// #23
ffffffffea80e4b4:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80e4b8:	6b00003f 	cmp	w1, w0
ffffffffea80e4bc:	54000e80 	b.eq	ffffffffea80e68c <trusty_sm_stdcall+0x23c>  // b.none
ffffffffea80e4c0:	11000400 	add	w0, w0, #0x1
ffffffffea80e4c4:	6b00003f 	cmp	w1, w0
ffffffffea80e4c8:	540009c1 	b.ne	ffffffffea80e600 <trusty_sm_stdcall+0x1b0>  // b.any
		res = virtio_kick_vq(args->params[0], args->params[1], guest);
ffffffffea80e4cc:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80e4d0:	2a1403e2 	mov	w2, w20
ffffffffea80e4d4:	940002a5 	bl	ffffffffea80ef68 <virtio_kick_vq>
ffffffffea80e4d8:	93407c00 	sxtw	x0, w0
ffffffffea80e4dc:	d503201f 	nop
	if (err >= 0) {
ffffffffea80e4e0:	b7f80300 	tbnz	x0, #63, ffffffffea80e540 <trusty_sm_stdcall+0xf0>
}
ffffffffea80e4e4:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80e4e8:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea80e4ec:	f9400261 	ldr	x1, [x19]
ffffffffea80e4f0:	ca010041 	eor	x1, x2, x1
ffffffffea80e4f4:	b5001021 	cbnz	x1, ffffffffea80e6f8 <trusty_sm_stdcall+0x2a8>
ffffffffea80e4f8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e4fc:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80e500:	d65f03c0 	ret
	switch (args->smc_nr) {
ffffffffea80e504:	529fffa2 	mov	w2, #0xfffd                	// #65533
ffffffffea80e508:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e50c:	6b02003f 	cmp	w1, w2
ffffffffea80e510:	54000c80 	b.eq	ffffffffea80e6a0 <trusty_sm_stdcall+0x250>  // b.none
ffffffffea80e514:	540004c9 	b.ls	ffffffffea80e5ac <trusty_sm_stdcall+0x15c>  // b.plast
ffffffffea80e518:	529fffc0 	mov	w0, #0xfffe                	// #65534
ffffffffea80e51c:	72a64000 	movk	w0, #0x3200, lsl #16
ffffffffea80e520:	6b00003f 	cmp	w1, w0
ffffffffea80e524:	54000660 	b.eq	ffffffffea80e5f0 <trusty_sm_stdcall+0x1a0>  // b.none
ffffffffea80e528:	12b9bfe0 	mov	w0, #0x3200ffff            	// #838926335
ffffffffea80e52c:	6b00003f 	cmp	w1, w0
ffffffffea80e530:	54000681 	b.ne	ffffffffea80e600 <trusty_sm_stdcall+0x1b0>  // b.any
		res = set_root_of_trust_params((paddr_t)args->params[0],
ffffffffea80e534:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80e538:	97ffffc4 	bl	ffffffffea80e448 <set_root_of_trust_params>
	if (err >= 0) {
ffffffffea80e53c:	b6fffd40 	tbz	x0, #63, ffffffffea80e4e4 <trusty_sm_stdcall+0x94>
ffffffffea80e540:	91006001 	add	x1, x0, #0x18
ffffffffea80e544:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea80e548:	f100403f 	cmp	x1, #0x10
ffffffffea80e54c:	54fffcc8 	b.hi	ffffffffea80e4e4 <trusty_sm_stdcall+0x94>  // b.pmore
ffffffffea80e550:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e554:	9103a000 	add	x0, x0, #0xe8
ffffffffea80e558:	f8617800 	ldr	x0, [x0, x1, lsl #3]
ffffffffea80e55c:	17ffffe2 	b	ffffffffea80e4e4 <trusty_sm_stdcall+0x94>
	switch (args->smc_nr) {
ffffffffea80e560:	52800282 	mov	w2, #0x14                  	// #20
ffffffffea80e564:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e568:	6b02003f 	cmp	w1, w2
ffffffffea80e56c:	540004e0 	b.eq	ffffffffea80e608 <trusty_sm_stdcall+0x1b8>  // b.none
ffffffffea80e570:	11000442 	add	w2, w2, #0x1
ffffffffea80e574:	6b02003f 	cmp	w1, w2
ffffffffea80e578:	54000441 	b.ne	ffffffffea80e600 <trusty_sm_stdcall+0x1b0>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e57c:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e580:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e584:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e588:	97ffff6a 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e58c:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e590:	b5fffa80 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = virtio_start(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80e594:	29450ba1 	ldp	w1, w2, [x29, #40]
ffffffffea80e598:	2a1403e3 	mov	w3, w20
ffffffffea80e59c:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e5a0:	94000192 	bl	ffffffffea80ebe8 <virtio_start>
ffffffffea80e5a4:	93407c00 	sxtw	x0, w0
ffffffffea80e5a8:	17ffffce 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
	switch (args->smc_nr) {
ffffffffea80e5ac:	528003e2 	mov	w2, #0x1f                  	// #31
ffffffffea80e5b0:	72a64002 	movk	w2, #0x3200, lsl #16
ffffffffea80e5b4:	6b02003f 	cmp	w1, w2
ffffffffea80e5b8:	54000780 	b.eq	ffffffffea80e6a8 <trusty_sm_stdcall+0x258>  // b.none
ffffffffea80e5bc:	11000442 	add	w2, w2, #0x1
ffffffffea80e5c0:	6b02003f 	cmp	w1, w2
ffffffffea80e5c4:	540001e1 	b.ne	ffffffffea80e600 <trusty_sm_stdcall+0x1b0>  // b.any
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e5c8:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e5cc:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e5d0:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e5d4:	97ffff57 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e5d8:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e5dc:	b5fff820 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = ql_tipc_handle_cmd(ns_pa, ns_sz);
ffffffffea80e5e0:	b9402ba1 	ldr	w1, [x29, #40]
ffffffffea80e5e4:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e5e8:	94000822 	bl	ffffffffea810670 <ql_tipc_handle_cmd>
ffffffffea80e5ec:	17ffffbd 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = handle_bl_data_interface((long)args->params[0],
ffffffffea80e5f0:	29408460 	ldp	w0, w1, [x3, #4]
ffffffffea80e5f4:	b9400c62 	ldr	w2, [x3, #12]
ffffffffea80e5f8:	97ffff92 	bl	ffffffffea80e440 <handle_bl_data_interface>
		break;
ffffffffea80e5fc:	17ffffb9 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
	switch (args->smc_nr) {
ffffffffea80e600:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80e604:	17ffffd3 	b	ffffffffea80e550 <trusty_sm_stdcall+0x100>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e608:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e60c:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e610:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e614:	97ffff47 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e618:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e61c:	b5fff620 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = virtio_get_description(ns_pa, ns_sz,
ffffffffea80e620:	29450ba1 	ldp	w1, w2, [x29, #40]
ffffffffea80e624:	2a1403e3 	mov	w3, w20
ffffffffea80e628:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e62c:	940000e1 	bl	ffffffffea80e9b0 <virtio_get_description>
ffffffffea80e630:	17ffffac 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e634:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e638:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e63c:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e640:	97ffff3c 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e644:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR) {
ffffffffea80e648:	b5fff4c0 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = virtio_stop(ns_pa, ns_sz, ns_mmu_flags, guest);
ffffffffea80e64c:	29450ba1 	ldp	w1, w2, [x29, #40]
ffffffffea80e650:	2a1403e3 	mov	w3, w20
ffffffffea80e654:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e658:	940001d4 	bl	ffffffffea80eda8 <virtio_stop>
ffffffffea80e65c:	93407c00 	sxtw	x0, w0
ffffffffea80e660:	17ffffa0 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e664:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e668:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e66c:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e670:	97ffff30 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e674:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e678:	b5fff340 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = ql_tipc_create_device(ns_pa, ns_sz, ns_mmu_flags);
ffffffffea80e67c:	29450ba1 	ldp	w1, w2, [x29, #40]
ffffffffea80e680:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e684:	94000757 	bl	ffffffffea8103e0 <ql_tipc_create_device>
ffffffffea80e688:	17ffff96 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = virtio_device_reset(args->params[0], guest);
ffffffffea80e68c:	b9400460 	ldr	w0, [x3, #4]
ffffffffea80e690:	2a1403e1 	mov	w1, w20
ffffffffea80e694:	94000201 	bl	ffffffffea80ee98 <virtio_device_reset>
ffffffffea80e698:	93407c00 	sxtw	x0, w0
		break;
ffffffffea80e69c:	17ffff91 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = lock_bl_data_interface();
ffffffffea80e6a0:	97ffff66 	bl	ffffffffea80e438 <lock_bl_data_interface>
		break;
ffffffffea80e6a4:	17ffff8f 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		res = get_ns_mem_buf(args, &ns_pa, &ns_sz, &ns_mmu_flags);
ffffffffea80e6a8:	9100b3a3 	add	x3, x29, #0x2c
ffffffffea80e6ac:	9100a3a2 	add	x2, x29, #0x28
ffffffffea80e6b0:	9100c3a1 	add	x1, x29, #0x30
ffffffffea80e6b4:	97ffff1f 	bl	ffffffffea80e330 <get_ns_mem_buf>
ffffffffea80e6b8:	93407c00 	sxtw	x0, w0
		if (res == NO_ERROR)
ffffffffea80e6bc:	b5fff120 	cbnz	x0, ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
			res = ql_tipc_shutdown_device(ns_pa);
ffffffffea80e6c0:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80e6c4:	940007a5 	bl	ffffffffea810558 <ql_tipc_shutdown_device>
ffffffffea80e6c8:	17ffff86 	b	ffffffffea80e4e0 <trusty_sm_stdcall+0x90>
		TRACEF("%s: Error. Unexpected guestID %u\n",
ffffffffea80e6cc:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e6d0:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e6d4:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e6d8:	2a1403e4 	mov	w4, w20
ffffffffea80e6dc:	9106c063 	add	x3, x3, #0x1b0
ffffffffea80e6e0:	52801322 	mov	w2, #0x99                  	// #153
ffffffffea80e6e4:	9105c021 	add	x1, x1, #0x170
ffffffffea80e6e8:	91086000 	add	x0, x0, #0x218
ffffffffea80e6ec:	9400155b 	bl	ffffffffea813c58 <_printf>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea80e6f0:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea80e6f4:	17ffff7c 	b	ffffffffea80e4e4 <trusty_sm_stdcall+0x94>
}
ffffffffea80e6f8:	9400158c 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80e6fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e700 <smc_hv_init>:
}
ffffffffea80e700:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80e704:	d65f03c0 	ret

ffffffffea80e708 <map_descr>:
	.addl_guests_virtio_bus = NULL,
};

static status_t map_descr(ns_paddr_t buf_pa, void **buf_va, ns_size_t sz,
                          uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80e708:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80e70c:	910003fd 	mov	x29, sp
ffffffffea80e710:	f9001bf7 	str	x23, [sp, #48]
	status_t ret;
	size_t roundedup_sz;

	if (!buf_pa) {
ffffffffea80e714:	b4000640 	cbz	x0, ffffffffea80e7dc <map_descr+0xd4>
ffffffffea80e718:	f9000fb4 	str	x20, [x29, #24]
		LTRACEF("invalid descr addr 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}

	if (buf_pa & (PAGE_SIZE-1)) {
ffffffffea80e71c:	f2402c1f 	tst	x0, #0xfff
ffffffffea80e720:	aa0003f4 	mov	x20, x0
ffffffffea80e724:	54000561 	b.ne	ffffffffea80e7d0 <map_descr+0xc8>  // b.any
ffffffffea80e728:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80e72c:	2a0203f3 	mov	w19, w2
		LTRACEF("unsuported addr range 0x%llx\n", buf_pa);
		return ERR_INVALID_ARGS;
	}
#endif

	roundedup_sz = ROUNDUP(sz, PAGE_SIZE);
ffffffffea80e730:	913ffe73 	add	x19, x19, #0xfff
ffffffffea80e734:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80e738:	9274ce73 	and	x19, x19, #0xfffffffffffff000
ffffffffea80e73c:	2a0303f5 	mov	w21, w3
ffffffffea80e740:	aa0103f6 	mov	x22, x1
ffffffffea80e744:	2a0403e2 	mov	w2, w4
	ret = trusty_hyp_check_guest_pa_valid(buf_pa, roundedup_sz, guest_id);
ffffffffea80e748:	aa1303e1 	mov	x1, x19
ffffffffea80e74c:	97ffd02d 	bl	ffffffffea802800 <trusty_hyp_check_guest_pa_valid>
ffffffffea80e750:	2a0003f7 	mov	w23, w0
	if (ret != NO_ERROR) {
ffffffffea80e754:	35000200 	cbnz	w0, ffffffffea80e794 <map_descr+0x8c>
			__func__, ret);
		return ret;
	}

	/* map resource table into our address space */
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e758:	900002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80e75c:	2a1503e7 	mov	w7, w21
ffffffffea80e760:	aa1403e5 	mov	x5, x20
ffffffffea80e764:	aa1603e3 	mov	x3, x22
ffffffffea80e768:	aa1303e2 	mov	x2, x19
	                           roundedup_sz,
	                           buf_va, PAGE_SIZE_SHIFT,
	                           (paddr_t) buf_pa, 0, buf_mmu_flags);
}
ffffffffea80e76c:	f9401bf7 	ldr	x23, [sp, #48]
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e770:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e774:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e778:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80e77c:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea80e780:	f9408400 	ldr	x0, [x0, #264]
ffffffffea80e784:	52800184 	mov	w4, #0xc                   	// #12
}
ffffffffea80e788:	a8c47bfd 	ldp	x29, x30, [sp], #64
	return  vmm_alloc_physical(vmm_get_kernel_aspace(), "virtio",
ffffffffea80e78c:	910c4021 	add	x1, x1, #0x310
ffffffffea80e790:	14000d1a 	b	ffffffffea811bf8 <vmm_alloc_physical>
		TRACEF("%s: check_guest_pa_valid failed, error = %d",
ffffffffea80e794:	d0000045 	adrp	x5, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e798:	2a0003e4 	mov	w4, w0
ffffffffea80e79c:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e7a0:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e7a4:	910a2063 	add	x3, x3, #0x288
ffffffffea80e7a8:	52800e42 	mov	w2, #0x72                  	// #114
ffffffffea80e7ac:	91092021 	add	x1, x1, #0x248
ffffffffea80e7b0:	9102a0a0 	add	x0, x5, #0xa8
ffffffffea80e7b4:	94001529 	bl	ffffffffea813c58 <_printf>
		return ret;
ffffffffea80e7b8:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80e7bc:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea80e7c0:	2a1703e0 	mov	w0, w23
ffffffffea80e7c4:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80e7c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80e7cc:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e7d0:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e7d4:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80e7d8:	17fffffa 	b	ffffffffea80e7c0 <map_descr+0xb8>
ffffffffea80e7dc:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea80e7e0:	17fffff8 	b	ffffffffea80e7c0 <map_descr+0xb8>
ffffffffea80e7e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>:
	if (vb == NULL) {
		TRACEF("%s: Bad pointer. vb is NULL\n", __func__);
		return ERR_INVALID_ARGS;
	}

	if (guest_id > 0) {
ffffffffea80e7e8:	34000321 	cbz	w1, ffffffffea80e84c <get_guest_virtio_bus.constprop.2+0x64>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e7ec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80e7f0:	910003fd 	mov	x29, sp
ffffffffea80e7f4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e7f8:	aa0003f4 	mov	x20, x0
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e7fc:	f0000040 	adrp	x0, ffffffffea819000 <_mem_phys_base>
static status_t get_guest_virtio_bus(struct trusty_virtio_bus **vb,
ffffffffea80e800:	f90013f5 	str	x21, [sp, #32]
ffffffffea80e804:	2a0103f3 	mov	w19, w1
		if (guest_id >= guests_vbus_context.num_guests) {
ffffffffea80e808:	913a0015 	add	x21, x0, #0xe80
ffffffffea80e80c:	b94e8005 	ldr	w5, [x0, #3712]
ffffffffea80e810:	6b05003f 	cmp	w1, w5
ffffffffea80e814:	540002a2 	b.cs	ffffffffea80e868 <get_guest_virtio_bus.constprop.2+0x80>  // b.hs, b.nlast
				__func__, guest_id, guests_vbus_context.num_guests);
			return ERR_INVALID_ARGS;
		}

		/* Barrier against speculating addl_guests_virtio_bus[guest_id - 1] */
		platform_arch_speculation_barrier();
ffffffffea80e818:	97ffce82 	bl	ffffffffea802220 <platform_arch_speculation_barrier>

		if (guests_vbus_context.addl_guests_virtio_bus == NULL) {
ffffffffea80e81c:	f9401aa4 	ldr	x4, [x21, #48]
ffffffffea80e820:	b40003a4 	cbz	x4, ffffffffea80e894 <get_guest_virtio_bus.constprop.2+0xac>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
				 __func__);
			return ERR_NOT_READY;
		}

		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e824:	51000661 	sub	w1, w19, #0x1
ffffffffea80e828:	52800513 	mov	w19, #0x28                  	// #40
	} else {
		*vb = &guests_vbus_context.guest0_virtio_bus;
	}

	return NO_ERROR;
ffffffffea80e82c:	52800002 	mov	w2, #0x0                   	// #0
		*vb = guests_vbus_context.addl_guests_virtio_bus + (guest_id - 1);
ffffffffea80e830:	9bb31021 	umaddl	x1, w1, w19, x4
ffffffffea80e834:	f9000281 	str	x1, [x20]
}
ffffffffea80e838:	2a0203e0 	mov	w0, w2
ffffffffea80e83c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80e840:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e844:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e848:	d65f03c0 	ret
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e84c:	f0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea80e850:	913a0021 	add	x1, x1, #0xe80
ffffffffea80e854:	91002021 	add	x1, x1, #0x8
	return NO_ERROR;
ffffffffea80e858:	52800002 	mov	w2, #0x0                   	// #0
		*vb = &guests_vbus_context.guest0_virtio_bus;
ffffffffea80e85c:	f9000001 	str	x1, [x0]
}
ffffffffea80e860:	2a0203e0 	mov	w0, w2
ffffffffea80e864:	d65f03c0 	ret
			TRACEF("%s: Bad input, guest %d regd_guests %d\n",
ffffffffea80e868:	528014c2 	mov	w2, #0xa6                  	// #166
ffffffffea80e86c:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e870:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e874:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e878:	2a1303e4 	mov	w4, w19
ffffffffea80e87c:	910a6063 	add	x3, x3, #0x298
ffffffffea80e880:	91096021 	add	x1, x1, #0x258
ffffffffea80e884:	910ac000 	add	x0, x0, #0x2b0
ffffffffea80e888:	940014f4 	bl	ffffffffea813c58 <_printf>
			return ERR_INVALID_ARGS;
ffffffffea80e88c:	128000e2 	mov	w2, #0xfffffff8            	// #-8
ffffffffea80e890:	17ffffea 	b	ffffffffea80e838 <get_guest_virtio_bus.constprop.2+0x50>
			TRACEF("%s: addl_guests_virtio_bus init failed\n",
ffffffffea80e894:	528015e2 	mov	w2, #0xaf                  	// #175
ffffffffea80e898:	d0000043 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e89c:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e8a0:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80e8a4:	910a6063 	add	x3, x3, #0x298
ffffffffea80e8a8:	91096021 	add	x1, x1, #0x258
ffffffffea80e8ac:	910b8000 	add	x0, x0, #0x2e0
ffffffffea80e8b0:	940014ea 	bl	ffffffffea813c58 <_printf>
ffffffffea80e8b4:	12800042 	mov	w2, #0xfffffffd            	// #-3
ffffffffea80e8b8:	17ffffe0 	b	ffffffffea80e838 <get_guest_virtio_bus.constprop.2+0x50>
ffffffffea80e8bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80e8c0 <virtio_register_device>:

/*
 *     Register virtio device
 */
status_t virtio_register_device(struct vdev *vd, uint32_t guest_id)
{
ffffffffea80e8c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	status_t ret = ERR_BAD_STATE;
	struct trusty_virtio_bus *vb = NULL;

	guests_vbus_context.num_guests++;
ffffffffea80e8c4:	f0000043 	adrp	x3, ffffffffea819000 <_mem_phys_base>
{
ffffffffea80e8c8:	910003fd 	mov	x29, sp
ffffffffea80e8cc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80e8d0:	900002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e8d4:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80e8d8:	aa0003f3 	mov	x19, x0
ffffffffea80e8dc:	f9402a84 	ldr	x4, [x20, #80]
	guests_vbus_context.num_guests++;
ffffffffea80e8e0:	b94e8060 	ldr	w0, [x3, #3712]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e8e4:	f81f0c5f 	str	xzr, [x2, #-16]!
	guests_vbus_context.num_guests++;
ffffffffea80e8e8:	11000400 	add	w0, w0, #0x1
ffffffffea80e8ec:	b90e8060 	str	w0, [x3, #3712]
{
ffffffffea80e8f0:	f9400080 	ldr	x0, [x4]
ffffffffea80e8f4:	f90017a0 	str	x0, [x29, #40]
ffffffffea80e8f8:	d2800000 	mov	x0, #0x0                   	// #0

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e8fc:	aa0203e0 	mov	x0, x2
ffffffffea80e900:	97ffffba 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80e904:	350004c0 	cbnz	w0, ffffffffea80e99c <virtio_register_device+0xdc>
		return ERR_INVALID_ARGS;
	}

	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80e908:	f94013a1 	ldr	x1, [x29, #32]
ffffffffea80e90c:	b9401022 	ldr	w2, [x1, #16]
ffffffffea80e910:	350004a2 	cbnz	w2, ffffffffea80e9a4 <virtio_register_device+0xe4>
	if (!vd) {
ffffffffea80e914:	b4000453 	cbz	x19, ffffffffea80e99c <virtio_register_device+0xdc>
	if (!vd->ops) {
ffffffffea80e918:	f9401262 	ldr	x2, [x19, #32]
ffffffffea80e91c:	b4000402 	cbz	x2, ffffffffea80e99c <virtio_register_device+0xdc>
	if (!ops->descr_sz || !ops->get_descr ||
ffffffffea80e920:	f9400043 	ldr	x3, [x2]
ffffffffea80e924:	b40003c3 	cbz	x3, ffffffffea80e99c <virtio_register_device+0xdc>
ffffffffea80e928:	f9400443 	ldr	x3, [x2, #8]
ffffffffea80e92c:	b4000383 	cbz	x3, ffffffffea80e99c <virtio_register_device+0xdc>
ffffffffea80e930:	f9400843 	ldr	x3, [x2, #16]
ffffffffea80e934:	b4000343 	cbz	x3, ffffffffea80e99c <virtio_register_device+0xdc>
	    !ops->probe || !ops->reset || !ops->kick_vqueue) {
ffffffffea80e938:	f9400c43 	ldr	x3, [x2, #24]
ffffffffea80e93c:	b4000303 	cbz	x3, ffffffffea80e99c <virtio_register_device+0xdc>
ffffffffea80e940:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80e944:	b40002c2 	cbz	x2, ffffffffea80e99c <virtio_register_device+0xdc>
		ret = validate_vdev(vd);
		if (ret == NO_ERROR) {
			vb->vdev_cnt++;
			vd->devid = vb->next_dev_id++;
ffffffffea80e948:	29401423 	ldp	w3, w5, [x1]
	item->prev = list->prev;
ffffffffea80e94c:	aa0103e2 	mov	x2, x1
			list_add_tail(&vb->vdev_list, &vd->node);
ffffffffea80e950:	91004264 	add	x4, x19, #0x10
			vb->vdev_cnt++;
ffffffffea80e954:	11000463 	add	w3, w3, #0x1
			vd->devid = vb->next_dev_id++;
ffffffffea80e958:	110004a6 	add	w6, w5, #0x1
			vb->vdev_cnt++;
ffffffffea80e95c:	b9000023 	str	w3, [x1]
ffffffffea80e960:	f8418c43 	ldr	x3, [x2, #24]!
			vd->devid = vb->next_dev_id++;
ffffffffea80e964:	b9000426 	str	w6, [x1, #4]
	item->next = list;
ffffffffea80e968:	a9010a63 	stp	x3, x2, [x19, #16]
ffffffffea80e96c:	b9000665 	str	w5, [x19, #4]
	list->prev->next = item;
ffffffffea80e970:	f9400c22 	ldr	x2, [x1, #24]
ffffffffea80e974:	f9000444 	str	x4, [x2, #8]
	list->prev = item;
ffffffffea80e978:	f9000c24 	str	x4, [x1, #24]
		}
	}
	return ret;
}
ffffffffea80e97c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80e980:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80e984:	f9400281 	ldr	x1, [x20]
ffffffffea80e988:	ca010041 	eor	x1, x2, x1
ffffffffea80e98c:	b5000101 	cbnz	x1, ffffffffea80e9ac <virtio_register_device+0xec>
ffffffffea80e990:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80e994:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80e998:	d65f03c0 	ret
		return ERR_INVALID_ARGS;
ffffffffea80e99c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80e9a0:	17fffff7 	b	ffffffffea80e97c <virtio_register_device+0xbc>
	status_t ret = ERR_BAD_STATE;
ffffffffea80e9a4:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80e9a8:	17fffff5 	b	ffffffffea80e97c <virtio_register_device+0xbc>
}
ffffffffea80e9ac:	940014df 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80e9b0 <virtio_get_description>:
/*
 * Retrieve device description to be shared with NS side
 */
ssize_t virtio_get_description(ns_paddr_t buf_pa, ns_size_t buf_sz,
                               uint buf_mmu_flags, uint32_t guest_id)
{
ffffffffea80e9b0:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80e9b4:	910003fd 	mov	x29, sp
ffffffffea80e9b8:	f90013f5 	str	x21, [sp, #32]
	status_t ret;
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e9bc:	9101c3a4 	add	x4, x29, #0x70
{
ffffffffea80e9c0:	900002b5 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea80e9c4:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80e9c8:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80e9cc:	aa0003f9 	mov	x25, x0
ffffffffea80e9d0:	f9402aa0 	ldr	x0, [x21, #80]
ffffffffea80e9d4:	2a0103f8 	mov	w24, w1
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80e9d8:	f81e8c9f 	str	xzr, [x4, #-24]!
{
ffffffffea80e9dc:	2a0303f7 	mov	w23, w3
ffffffffea80e9e0:	f9400001 	ldr	x1, [x0]
ffffffffea80e9e4:	f90037a1 	str	x1, [x29, #104]
ffffffffea80e9e8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80e9ec:	2a0203fa 	mov	w26, w2

	LTRACEF("descr_buf: %u bytes @ 0x%llx\n", buf_sz, buf_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80e9f0:	2a0303e1 	mov	w1, w3
ffffffffea80e9f4:	aa0403e0 	mov	x0, x4
ffffffffea80e9f8:	97ffff7c 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80e9fc:	35000e40 	cbnz	w0, ffffffffea80ebc4 <virtio_get_description+0x214>
ffffffffea80ea00:	f90017b6 	str	x22, [x29, #40]
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ea04:	9101c3b6 	add	x22, x29, #0x70
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80ea08:	2a1703e1 	mov	w1, w23
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ea0c:	f81f0edf 	str	xzr, [x22, #-16]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80ea10:	aa1603e0 	mov	x0, x22
ffffffffea80ea14:	97ffff75 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80ea18:	35000c20 	cbnz	w0, ffffffffea80eb9c <virtio_get_description+0x1ec>
	if (vb->state == VIRTIO_BUS_STATE_UNINITIALIZED) {
ffffffffea80ea1c:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80ea20:	b9401020 	ldr	w0, [x1, #16]
ffffffffea80ea24:	35000360 	cbnz	w0, ffffffffea80ea90 <virtio_get_description+0xe0>
ffffffffea80ea28:	a90153b3 	stp	x19, x20, [x29, #16]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea2c:	91006020 	add	x0, x1, #0x18
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80ea30:	b9400034 	ldr	w20, [x1]
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea34:	f9401022 	ldr	x2, [x1, #32]
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80ea38:	11001294 	add	w20, w20, #0x4
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea3c:	d1004053 	sub	x19, x2, #0x10
ffffffffea80ea40:	eb02001f 	cmp	x0, x2
		uint32_t offset = sizeof(struct resource_table) +
ffffffffea80ea44:	531e7694 	lsl	w20, w20, #2
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea48:	540001c0 	b.eq	ffffffffea80ea80 <virtio_get_description+0xd0>  // b.none
ffffffffea80ea4c:	d503201f 	nop
			offset += vd->ops->descr_sz(vd);
ffffffffea80ea50:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80ea54:	aa1303e0 	mov	x0, x19
ffffffffea80ea58:	f9400021 	ldr	x1, [x1]
			vd->descr_offset = offset;
ffffffffea80ea5c:	b9000a74 	str	w20, [x19, #8]
			offset += vd->ops->descr_sz(vd);
ffffffffea80ea60:	d63f0020 	blr	x1
ffffffffea80ea64:	0b000294 	add	w20, w20, w0
		list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ea68:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80ea6c:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80ea70:	91006020 	add	x0, x1, #0x18
ffffffffea80ea74:	d1004053 	sub	x19, x2, #0x10
ffffffffea80ea78:	eb00005f 	cmp	x2, x0
ffffffffea80ea7c:	54fffea1 	b.ne	ffffffffea80ea50 <virtio_get_description+0xa0>  // b.any
		vb->descr_size = offset;
ffffffffea80ea80:	f9000434 	str	x20, [x1, #8]
		vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80ea84:	52800020 	mov	w0, #0x1                   	// #1
ffffffffea80ea88:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea80ea8c:	b9001020 	str	w0, [x1, #16]
	if (ret != NO_ERROR) {
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
		return ret;
	}

	if ((size_t)buf_sz < vb->descr_size) {
ffffffffea80ea90:	f9402fa0 	ldr	x0, [x29, #88]
ffffffffea80ea94:	f9400402 	ldr	x2, [x0, #8]
ffffffffea80ea98:	eb38405f 	cmp	x2, w24, uxtw
ffffffffea80ea9c:	54000988 	b.hi	ffffffffea80ebcc <virtio_get_description+0x21c>  // b.pmore
		return ERR_NOT_ENOUGH_BUFFER;
	}

	/* map in NS memory */
	void *va = NULL;
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80eaa0:	2a1703e4 	mov	w4, w23
ffffffffea80eaa4:	2a1a03e3 	mov	w3, w26
ffffffffea80eaa8:	aa1603e1 	mov	x1, x22
ffffffffea80eaac:	aa1903e0 	mov	x0, x25
	void *va = NULL;
ffffffffea80eab0:	f90033bf 	str	xzr, [x29, #96]
	ret = map_descr(buf_pa, &va, vb->descr_size, buf_mmu_flags, guest_id);
ffffffffea80eab4:	97ffff15 	bl	ffffffffea80e708 <map_descr>
	if (ret != NO_ERROR) {
ffffffffea80eab8:	340001a0 	cbz	w0, ffffffffea80eaec <virtio_get_description+0x13c>
		LTRACEF("failed (%d) to map in descriptor buffer\n",
			(int)ret);
		return ret;
ffffffffea80eabc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80eac0:	93407c00 	sxtw	x0, w0
	}

	unmap_descr(buf_pa, va, vb->descr_size);

	return vb->descr_size;
}
ffffffffea80eac4:	f9402ab5 	ldr	x21, [x21, #80]
ffffffffea80eac8:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80eacc:	f94002a1 	ldr	x1, [x21]
ffffffffea80ead0:	ca010041 	eor	x1, x2, x1
ffffffffea80ead4:	b5000821 	cbnz	x1, ffffffffea80ebd8 <virtio_get_description+0x228>
ffffffffea80ead8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80eadc:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80eae0:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80eae4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80eae8:	d65f03c0 	ret
	memset(va, 0, vb->descr_size);
ffffffffea80eaec:	a94583a2 	ldp	x2, x0, [x29, #88]
ffffffffea80eaf0:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80eaf4:	f9400442 	ldr	x2, [x2, #8]
ffffffffea80eaf8:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80eafc:	9400156f 	bl	ffffffffea8140b8 <memset>
	trusty_virtio_descr_t *descr = (trusty_virtio_descr_t *)va;
ffffffffea80eb00:	a945dba0 	ldp	x0, x22, [x29, #88]
	descr->ver = VIRTIO_FW_RSC_VER;
ffffffffea80eb04:	52800023 	mov	w3, #0x1                   	// #1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eb08:	91006001 	add	x1, x0, #0x18
	descr->num = vb->vdev_cnt;
ffffffffea80eb0c:	b9400002 	ldr	w2, [x0]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eb10:	f9401000 	ldr	x0, [x0, #32]
	descr->num = vb->vdev_cnt;
ffffffffea80eb14:	29000ac3 	stp	w3, w2, [x22]
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eb18:	d1004013 	sub	x19, x0, #0x10
ffffffffea80eb1c:	eb01001f 	cmp	x0, x1
ffffffffea80eb20:	540002c0 	b.eq	ffffffffea80eb78 <virtio_get_description+0x1c8>  // b.none
	uint32_t vdev_idx = 0;
ffffffffea80eb24:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80eb28:	f9000fb4 	str	x20, [x29, #24]
ffffffffea80eb2c:	d503201f 	nop
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80eb30:	f9401262 	ldr	x2, [x19, #32]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80eb34:	8b204ac3 	add	x3, x22, w0, uxtw #2
ffffffffea80eb38:	b9400a61 	ldr	w1, [x19, #8]
ffffffffea80eb3c:	11000414 	add	w20, w0, #0x1
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80eb40:	aa1303e0 	mov	x0, x19
ffffffffea80eb44:	f9400442 	ldr	x2, [x2, #8]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80eb48:	b9001061 	str	w1, [x3, #16]
		vd->ops->get_descr(vd, (uint8_t *)descr + vd->descr_offset);
ffffffffea80eb4c:	8b2142c1 	add	x1, x22, w1, uxtw
ffffffffea80eb50:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eb54:	f9402fa1 	ldr	x1, [x29, #88]
		descr->offset[vdev_idx++] = vd->descr_offset;
ffffffffea80eb58:	2a1403e0 	mov	w0, w20
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eb5c:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea80eb60:	91006021 	add	x1, x1, #0x18
ffffffffea80eb64:	d1004053 	sub	x19, x2, #0x10
ffffffffea80eb68:	eb01005f 	cmp	x2, x1
ffffffffea80eb6c:	54fffe21 	b.ne	ffffffffea80eb30 <virtio_get_description+0x180>  // b.any
ffffffffea80eb70:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea80eb74:	f94033b6 	ldr	x22, [x29, #96]
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80eb78:	900002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80eb7c:	aa1603e1 	mov	x1, x22
ffffffffea80eb80:	f9408400 	ldr	x0, [x0, #264]
ffffffffea80eb84:	94000c7f 	bl	ffffffffea811d80 <vmm_free_region>
	return vb->descr_size;
ffffffffea80eb88:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80eb8c:	f9402fa0 	ldr	x0, [x29, #88]
ffffffffea80eb90:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80eb94:	f9400400 	ldr	x0, [x0, #8]
ffffffffea80eb98:	17ffffcb 	b	ffffffffea80eac4 <virtio_get_description+0x114>
		TRACEF("failed (%d) finalize_vdev_registery\n", ret);
ffffffffea80eb9c:	d0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80eba0:	d0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80eba4:	128000e3 	mov	w3, #0xfffffff8            	// #-8
ffffffffea80eba8:	528020c2 	mov	w2, #0x106                 	// #262
ffffffffea80ebac:	9109c021 	add	x1, x1, #0x270
ffffffffea80ebb0:	910c6000 	add	x0, x0, #0x318
ffffffffea80ebb4:	94001429 	bl	ffffffffea813c58 <_printf>
		return ret;
ffffffffea80ebb8:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80ebbc:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80ebc0:	17ffffc1 	b	ffffffffea80eac4 <virtio_get_description+0x114>
		return ERR_INVALID_ARGS;
ffffffffea80ebc4:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea80ebc8:	17ffffbf 	b	ffffffffea80eac4 <virtio_get_description+0x114>
		return ERR_NOT_ENOUGH_BUFFER;
ffffffffea80ebcc:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea80ebd0:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea80ebd4:	17ffffbc 	b	ffffffffea80eac4 <virtio_get_description+0x114>
ffffffffea80ebd8:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea80ebdc:	f90017b6 	str	x22, [x29, #40]
}
ffffffffea80ebe0:	94001452 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80ebe4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80ebe8 <virtio_start>:
/*
 * Called by NS side to finalize device initialization
 */
status_t virtio_start(ns_paddr_t ns_descr_pa, ns_size_t descr_sz,
                      uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80ebe8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80ebec:	910003fd 	mov	x29, sp
ffffffffea80ebf0:	a90153f3 	stp	x19, x20, [sp, #16]
	status_t ret;
	int oldstate;
	void *descr_va;
	void *ns_descr_va = NULL;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ebf4:	9101c3a4 	add	x4, x29, #0x70
{
ffffffffea80ebf8:	900002b3 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea80ebfc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80ec00:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80ec04:	aa0003f6 	mov	x22, x0
ffffffffea80ec08:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea80ec0c:	2a0103f4 	mov	w20, w1
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ec10:	f81f0c9f 	str	xzr, [x4, #-16]!
{
ffffffffea80ec14:	2a0303f8 	mov	w24, w3
ffffffffea80ec18:	f9400001 	ldr	x1, [x0]
ffffffffea80ec1c:	f90037a1 	str	x1, [x29, #104]
ffffffffea80ec20:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80ec24:	2a0203f7 	mov	w23, w2

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, ns_descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80ec28:	2a0303e1 	mov	w1, w3
ffffffffea80ec2c:	aa0403e0 	mov	x0, x4
	void *ns_descr_va = NULL;
ffffffffea80ec30:	f9002fbf 	str	xzr, [x29, #88]
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80ec34:	97fffeed 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80ec38:	35000b00 	cbnz	w0, ffffffffea80ed98 <virtio_start+0x1b0>
    __atomic_compare_exchange_n(ptr, &oldval, newval, false,
ffffffffea80ec3c:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea80ec40:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80ec44:	91004021 	add	x1, x1, #0x10
ffffffffea80ec48:	885f7c20 	ldxr	w0, [x1]
ffffffffea80ec4c:	7100041f 	cmp	w0, #0x1
ffffffffea80ec50:	54000061 	b.ne	ffffffffea80ec5c <virtio_start+0x74>  // b.any
ffffffffea80ec54:	88037c22 	stxr	w3, w2, [x1]
ffffffffea80ec58:	35ffff83 	cbnz	w3, ffffffffea80ec48 <virtio_start+0x60>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_IDLE,
				  VIRTIO_BUS_STATE_ACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_IDLE) {
ffffffffea80ec5c:	7100041f 	cmp	w0, #0x1
ffffffffea80ec60:	54000981 	b.ne	ffffffffea80ed90 <virtio_start+0x1a8>  // b.any
		/* bus should be in initializing state */
		LTRACEF("unexpected state state (%d)\n", oldstate);
		return ERR_BAD_STATE;
	}

	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80ec64:	f94033a0 	ldr	x0, [x29, #96]
		LTRACEF("unexpected descriptor size (%zd vs. %zd)\n",
			(size_t)descr_sz, vb->descr_size);
		ret = ERR_INVALID_ARGS;
ffffffffea80ec68:	128000f5 	mov	w21, #0xfffffff8            	// #-8
	if ((size_t)descr_sz != vb->descr_size) {
ffffffffea80ec6c:	f9400401 	ldr	x1, [x0, #8]
ffffffffea80ec70:	eb01029f 	cmp	x20, x1
ffffffffea80ec74:	540001c0 	b.eq	ffffffffea80ecac <virtio_start+0xc4>  // b.none

err_map_in:
	free(descr_va);
err_alloc_descr:
err_bad_params:
	vb->state = oldstate;
ffffffffea80ec78:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea80ec7c:	b9001001 	str	w1, [x0, #16]
	return ret;
}
ffffffffea80ec80:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea80ec84:	2a1503e0 	mov	w0, w21
ffffffffea80ec88:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80ec8c:	f9400261 	ldr	x1, [x19]
ffffffffea80ec90:	ca010041 	eor	x1, x2, x1
ffffffffea80ec94:	b5000861 	cbnz	x1, ffffffffea80eda0 <virtio_start+0x1b8>
ffffffffea80ec98:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ec9c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80eca0:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80eca4:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80eca8:	d65f03c0 	ret
ffffffffea80ecac:	f90023b9 	str	x25, [x29, #64]
	descr_va = malloc(descr_sz);
ffffffffea80ecb0:	aa1403e0 	mov	x0, x20
ffffffffea80ecb4:	9400142d 	bl	ffffffffea813d68 <malloc>
ffffffffea80ecb8:	aa0003f9 	mov	x25, x0
	if (!descr_va) {
ffffffffea80ecbc:	b4000580 	cbz	x0, ffffffffea80ed6c <virtio_start+0x184>
	ret = map_descr(ns_descr_pa, &ns_descr_va, vb->descr_size, descr_mmu_flags, guest_id);
ffffffffea80ecc0:	f94033a2 	ldr	x2, [x29, #96]
ffffffffea80ecc4:	2a1803e4 	mov	w4, w24
ffffffffea80ecc8:	2a1703e3 	mov	w3, w23
ffffffffea80eccc:	910163a1 	add	x1, x29, #0x58
ffffffffea80ecd0:	aa1603e0 	mov	x0, x22
ffffffffea80ecd4:	b9400842 	ldr	w2, [x2, #8]
ffffffffea80ecd8:	97fffe8c 	bl	ffffffffea80e708 <map_descr>
ffffffffea80ecdc:	2a0003f5 	mov	w21, w0
	if (ret != NO_ERROR) {
ffffffffea80ece0:	350004e0 	cbnz	w0, ffffffffea80ed7c <virtio_start+0x194>
	memcpy(descr_va, ns_descr_va, descr_sz);
ffffffffea80ece4:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80ece8:	aa1403e2 	mov	x2, x20
ffffffffea80ecec:	aa1903e0 	mov	x0, x25
ffffffffea80ecf0:	94001436 	bl	ffffffffea813dc8 <memcpy>
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ecf4:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80ecf8:	91006001 	add	x1, x0, #0x18
ffffffffea80ecfc:	f9401000 	ldr	x0, [x0, #32]
ffffffffea80ed00:	d1004014 	sub	x20, x0, #0x10
ffffffffea80ed04:	eb00003f 	cmp	x1, x0
ffffffffea80ed08:	540001c0 	b.eq	ffffffffea80ed40 <virtio_start+0x158>  // b.none
ffffffffea80ed0c:	d503201f 	nop
		vd->ops->probe(vd, (void*)((uint8_t*)descr_va + vd->descr_offset));
ffffffffea80ed10:	f9401282 	ldr	x2, [x20, #32]
ffffffffea80ed14:	aa1403e0 	mov	x0, x20
ffffffffea80ed18:	b9400a81 	ldr	w1, [x20, #8]
ffffffffea80ed1c:	f9400842 	ldr	x2, [x2, #16]
ffffffffea80ed20:	8b010321 	add	x1, x25, x1
ffffffffea80ed24:	d63f0040 	blr	x2
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ed28:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80ed2c:	f9400e81 	ldr	x1, [x20, #24]
ffffffffea80ed30:	91006000 	add	x0, x0, #0x18
ffffffffea80ed34:	d1004034 	sub	x20, x1, #0x10
ffffffffea80ed38:	eb00003f 	cmp	x1, x0
ffffffffea80ed3c:	54fffea1 	b.ne	ffffffffea80ed10 <virtio_start+0x128>  // b.any
	return vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)va);
ffffffffea80ed40:	900002a0 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea80ed44:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea80ed48:	f9408400 	ldr	x0, [x0, #264]
ffffffffea80ed4c:	94000c0d 	bl	ffffffffea811d80 <vmm_free_region>
	free(descr_va);
ffffffffea80ed50:	aa1903e0 	mov	x0, x25
ffffffffea80ed54:	9400141b 	bl	ffffffffea813dc0 <free>
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80ed58:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80ed5c:	52800061 	mov	w1, #0x3                   	// #3
	return NO_ERROR;
ffffffffea80ed60:	f94023b9 	ldr	x25, [x29, #64]
	vb->state = VIRTIO_BUS_STATE_ACTIVE;
ffffffffea80ed64:	b9001001 	str	w1, [x0, #16]
	return NO_ERROR;
ffffffffea80ed68:	17ffffc6 	b	ffffffffea80ec80 <virtio_start+0x98>
		ret = ERR_NO_MEMORY;
ffffffffea80ed6c:	12800095 	mov	w21, #0xfffffffb            	// #-5
ffffffffea80ed70:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80ed74:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80ed78:	17ffffc0 	b	ffffffffea80ec78 <virtio_start+0x90>
	free(descr_va);
ffffffffea80ed7c:	aa1903e0 	mov	x0, x25
ffffffffea80ed80:	94001410 	bl	ffffffffea813dc0 <free>
ffffffffea80ed84:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea80ed88:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea80ed8c:	17ffffbb 	b	ffffffffea80ec78 <virtio_start+0x90>
		return ERR_BAD_STATE;
ffffffffea80ed90:	128003d5 	mov	w21, #0xffffffe1            	// #-31
ffffffffea80ed94:	17ffffbb 	b	ffffffffea80ec80 <virtio_start+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80ed98:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80ed9c:	17ffffb9 	b	ffffffffea80ec80 <virtio_start+0x98>
ffffffffea80eda0:	f90023b9 	str	x25, [x29, #64]
}
ffffffffea80eda4:	940013e1 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80eda8 <virtio_stop>:

status_t virtio_stop(ns_paddr_t descr_pa, ns_size_t descr_sz,
		     uint descr_mmu_flags, uint32_t guest_id)
{
ffffffffea80eda8:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	struct vdev *vd;
	struct trusty_virtio_bus *vb = NULL;

	LTRACEF("%u bytes @ 0x%llx\n", descr_sz, descr_pa);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80edac:	2a0303e1 	mov	w1, w3
{
ffffffffea80edb0:	910003fd 	mov	x29, sp
ffffffffea80edb4:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea80edb8:	900002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80edbc:	910103a0 	add	x0, x29, #0x40
{
ffffffffea80edc0:	f9402a82 	ldr	x2, [x20, #80]
ffffffffea80edc4:	f9400043 	ldr	x3, [x2]
ffffffffea80edc8:	f9001fa3 	str	x3, [x29, #56]
ffffffffea80edcc:	d2800003 	mov	x3, #0x0                   	// #0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80edd0:	f81f0c1f 	str	xzr, [x0, #-16]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80edd4:	97fffe85 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80edd8:	35000580 	cbnz	w0, ffffffffea80ee88 <virtio_stop+0xe0>
ffffffffea80eddc:	2a0003f5 	mov	w21, w0
ffffffffea80ede0:	f9401ba0 	ldr	x0, [x29, #48]
ffffffffea80ede4:	52800082 	mov	w2, #0x4                   	// #4
ffffffffea80ede8:	91004000 	add	x0, x0, #0x10
ffffffffea80edec:	885f7c01 	ldxr	w1, [x0]
ffffffffea80edf0:	71000c3f 	cmp	w1, #0x3
ffffffffea80edf4:	54000061 	b.ne	ffffffffea80ee00 <virtio_stop+0x58>  // b.any
ffffffffea80edf8:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80edfc:	35ffff83 	cbnz	w3, ffffffffea80edec <virtio_stop+0x44>

	oldstate = atomic_cmpxchg(&vb->state,
				  VIRTIO_BUS_STATE_ACTIVE,
				  VIRTIO_BUS_STATE_DEACTIVATING);

	if (oldstate != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80ee00:	71000c3f 	cmp	w1, #0x3
ffffffffea80ee04:	540003e1 	b.ne	ffffffffea80ee80 <virtio_stop+0xd8>  // b.any
		return ERR_BAD_STATE;
	}
	/* reset all devices */
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ee08:	f9401ba1 	ldr	x1, [x29, #48]
ffffffffea80ee0c:	91006022 	add	x2, x1, #0x18
ffffffffea80ee10:	f9401020 	ldr	x0, [x1, #32]
ffffffffea80ee14:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80ee18:	eb02001f 	cmp	x0, x2
ffffffffea80ee1c:	d1004013 	sub	x19, x0, #0x10
ffffffffea80ee20:	54000180 	b.eq	ffffffffea80ee50 <virtio_stop+0xa8>  // b.none
ffffffffea80ee24:	d503201f 	nop
		vd->ops->reset(vd);
ffffffffea80ee28:	f9401261 	ldr	x1, [x19, #32]
ffffffffea80ee2c:	aa1303e0 	mov	x0, x19
ffffffffea80ee30:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80ee34:	d63f0020 	blr	x1
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ee38:	f9401ba1 	ldr	x1, [x29, #48]
ffffffffea80ee3c:	f9400e60 	ldr	x0, [x19, #24]
ffffffffea80ee40:	91006022 	add	x2, x1, #0x18
ffffffffea80ee44:	d1004013 	sub	x19, x0, #0x10
ffffffffea80ee48:	eb02001f 	cmp	x0, x2
ffffffffea80ee4c:	54fffee1 	b.ne	ffffffffea80ee28 <virtio_stop+0x80>  // b.any
	}

	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80ee50:	52800020 	mov	w0, #0x1                   	// #1

	return NO_ERROR;
ffffffffea80ee54:	f9400bb3 	ldr	x19, [x29, #16]
	vb->state = VIRTIO_BUS_STATE_IDLE;
ffffffffea80ee58:	b9001020 	str	w0, [x1, #16]
}
ffffffffea80ee5c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80ee60:	2a1503e0 	mov	w0, w21
ffffffffea80ee64:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea80ee68:	f9400281 	ldr	x1, [x20]
ffffffffea80ee6c:	ca010041 	eor	x1, x2, x1
ffffffffea80ee70:	b5000101 	cbnz	x1, ffffffffea80ee90 <virtio_stop+0xe8>
ffffffffea80ee74:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea80ee78:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80ee7c:	d65f03c0 	ret
		return ERR_BAD_STATE;
ffffffffea80ee80:	128003d5 	mov	w21, #0xffffffe1            	// #-31
ffffffffea80ee84:	17fffff6 	b	ffffffffea80ee5c <virtio_stop+0xb4>
		return ERR_INVALID_ARGS;
ffffffffea80ee88:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea80ee8c:	17fffff4 	b	ffffffffea80ee5c <virtio_stop+0xb4>
ffffffffea80ee90:	f9000bb3 	str	x19, [x29, #16]
}
ffffffffea80ee94:	940013a5 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80ee98 <virtio_device_reset>:

/*
 *  Reset virtio device with specified device id
 */
status_t virtio_device_reset(uint devid, uint32_t guest_id)
{
ffffffffea80ee98:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea80ee9c:	910003fd 	mov	x29, sp
ffffffffea80eea0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80eea4:	900002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80eea8:	9100c3a2 	add	x2, x29, #0x30
{
ffffffffea80eeac:	2a0003f3 	mov	w19, w0
ffffffffea80eeb0:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80eeb4:	f9400003 	ldr	x3, [x0]
ffffffffea80eeb8:	f90017a3 	str	x3, [x29, #40]
ffffffffea80eebc:	d2800003 	mov	x3, #0x0                   	// #0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80eec0:	f81f0c5f 	str	xzr, [x2, #-16]!

	LTRACEF("dev=%d\n", devid);

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80eec4:	aa0203e0 	mov	x0, x2
ffffffffea80eec8:	97fffe48 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80eecc:	35000480 	cbnz	w0, ffffffffea80ef5c <virtio_device_reset+0xc4>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80eed0:	f94013a2 	ldr	x2, [x29, #32]
ffffffffea80eed4:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80eed8:	71000c1f 	cmp	w0, #0x3
ffffffffea80eedc:	540003c1 	b.ne	ffffffffea80ef54 <virtio_device_reset+0xbc>  // b.any
		return ERR_BAD_STATE;
	}

	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80eee0:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80eee4:	91006042 	add	x2, x2, #0x18
ffffffffea80eee8:	d1004020 	sub	x0, x1, #0x10
ffffffffea80eeec:	eb01005f 	cmp	x2, x1
ffffffffea80eef0:	54000180 	b.eq	ffffffffea80ef20 <virtio_device_reset+0x88>  // b.none
		if (vd->devid == devid) {
ffffffffea80eef4:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80eef8:	6b01027f 	cmp	w19, w1
ffffffffea80eefc:	540000a1 	b.ne	ffffffffea80ef10 <virtio_device_reset+0x78>  // b.any
ffffffffea80ef00:	14000011 	b	ffffffffea80ef44 <virtio_device_reset+0xac>
ffffffffea80ef04:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80ef08:	6b13003f 	cmp	w1, w19
ffffffffea80ef0c:	540001c0 	b.eq	ffffffffea80ef44 <virtio_device_reset+0xac>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80ef10:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80ef14:	d1004020 	sub	x0, x1, #0x10
ffffffffea80ef18:	eb01005f 	cmp	x2, x1
ffffffffea80ef1c:	54ffff41 	b.ne	ffffffffea80ef04 <virtio_device_reset+0x6c>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80ef20:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->reset(vd);
			break;
		}
	}
	return ret;
}
ffffffffea80ef24:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80ef28:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea80ef2c:	f9400281 	ldr	x1, [x20]
ffffffffea80ef30:	ca010041 	eor	x1, x2, x1
ffffffffea80ef34:	b5000181 	cbnz	x1, ffffffffea80ef64 <virtio_device_reset+0xcc>
ffffffffea80ef38:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80ef3c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea80ef40:	d65f03c0 	ret
			ret = vd->ops->reset(vd);
ffffffffea80ef44:	f9401001 	ldr	x1, [x0, #32]
ffffffffea80ef48:	f9400c21 	ldr	x1, [x1, #24]
ffffffffea80ef4c:	d63f0020 	blr	x1
			break;
ffffffffea80ef50:	17fffff5 	b	ffffffffea80ef24 <virtio_device_reset+0x8c>
		return ERR_BAD_STATE;
ffffffffea80ef54:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80ef58:	17fffff3 	b	ffffffffea80ef24 <virtio_device_reset+0x8c>
		return ERR_INVALID_ARGS;
ffffffffea80ef5c:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80ef60:	17fffff1 	b	ffffffffea80ef24 <virtio_device_reset+0x8c>
}
ffffffffea80ef64:	94001371 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80ef68 <virtio_kick_vq>:

/*
 *  Kick vq for virtio device with specified device id
 */
status_t virtio_kick_vq(uint devid, uint vqid, uint32_t guest_id)
{
ffffffffea80ef68:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea80ef6c:	910003fd 	mov	x29, sp
ffffffffea80ef70:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80ef74:	900002b4 	adrp	x20, ffffffffea862000 <__ctor_list>
	struct vdev *vd;
	status_t ret = ERR_NOT_FOUND;
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ef78:	910103a3 	add	x3, x29, #0x40
{
ffffffffea80ef7c:	2a0003f3 	mov	w19, w0
ffffffffea80ef80:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea80ef84:	f90013f5 	str	x21, [sp, #32]
ffffffffea80ef88:	2a0103f5 	mov	w21, w1

#if WITH_CHATTY_LTRACE
	LTRACEF("dev=%d\n", devid);
#endif

	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80ef8c:	2a0203e1 	mov	w1, w2
{
ffffffffea80ef90:	f9400002 	ldr	x2, [x0]
ffffffffea80ef94:	f9001fa2 	str	x2, [x29, #56]
ffffffffea80ef98:	d2800002 	mov	x2, #0x0                   	// #0
	struct trusty_virtio_bus *vb = NULL;
ffffffffea80ef9c:	f81f0c7f 	str	xzr, [x3, #-16]!
	if (get_guest_virtio_bus(&vb, guest_id)) {
ffffffffea80efa0:	aa0303e0 	mov	x0, x3
ffffffffea80efa4:	97fffe11 	bl	ffffffffea80e7e8 <get_guest_virtio_bus.constprop.2>
ffffffffea80efa8:	350004c0 	cbnz	w0, ffffffffea80f040 <virtio_kick_vq+0xd8>
		return ERR_INVALID_ARGS;
	}

	if (vb->state != VIRTIO_BUS_STATE_ACTIVE) {
ffffffffea80efac:	f9401ba2 	ldr	x2, [x29, #48]
ffffffffea80efb0:	b9401040 	ldr	w0, [x2, #16]
ffffffffea80efb4:	71000c1f 	cmp	w0, #0x3
ffffffffea80efb8:	54000401 	b.ne	ffffffffea80f038 <virtio_kick_vq+0xd0>  // b.any
		return ERR_BAD_STATE;
	}
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80efbc:	f9401041 	ldr	x1, [x2, #32]
ffffffffea80efc0:	91006042 	add	x2, x2, #0x18
ffffffffea80efc4:	d1004020 	sub	x0, x1, #0x10
ffffffffea80efc8:	eb01005f 	cmp	x2, x1
ffffffffea80efcc:	54000180 	b.eq	ffffffffea80effc <virtio_kick_vq+0x94>  // b.none
		if (vd->devid == devid) {
ffffffffea80efd0:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80efd4:	6b01027f 	cmp	w19, w1
ffffffffea80efd8:	540000a1 	b.ne	ffffffffea80efec <virtio_kick_vq+0x84>  // b.any
ffffffffea80efdc:	14000012 	b	ffffffffea80f024 <virtio_kick_vq+0xbc>
ffffffffea80efe0:	b85f4021 	ldur	w1, [x1, #-12]
ffffffffea80efe4:	6b13003f 	cmp	w1, w19
ffffffffea80efe8:	540001e0 	b.eq	ffffffffea80f024 <virtio_kick_vq+0xbc>  // b.none
	list_for_every_entry(&vb->vdev_list, vd, struct vdev, node) {
ffffffffea80efec:	f9400c01 	ldr	x1, [x0, #24]
ffffffffea80eff0:	d1004020 	sub	x0, x1, #0x10
ffffffffea80eff4:	eb01005f 	cmp	x2, x1
ffffffffea80eff8:	54ffff41 	b.ne	ffffffffea80efe0 <virtio_kick_vq+0x78>  // b.any
	status_t ret = ERR_NOT_FOUND;
ffffffffea80effc:	12800020 	mov	w0, #0xfffffffe            	// #-2
			ret = vd->ops->kick_vqueue(vd, vqid);
			break;
		}
	}
	return ret;
}
ffffffffea80f000:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea80f004:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea80f008:	f9400281 	ldr	x1, [x20]
ffffffffea80f00c:	ca010041 	eor	x1, x2, x1
ffffffffea80f010:	b50001c1 	cbnz	x1, ffffffffea80f048 <virtio_kick_vq+0xe0>
ffffffffea80f014:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f018:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80f01c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea80f020:	d65f03c0 	ret
			ret = vd->ops->kick_vqueue(vd, vqid);
ffffffffea80f024:	f9401002 	ldr	x2, [x0, #32]
ffffffffea80f028:	2a1503e1 	mov	w1, w21
ffffffffea80f02c:	f9401042 	ldr	x2, [x2, #32]
ffffffffea80f030:	d63f0040 	blr	x2
			break;
ffffffffea80f034:	17fffff3 	b	ffffffffea80f000 <virtio_kick_vq+0x98>
		return ERR_BAD_STATE;
ffffffffea80f038:	128003c0 	mov	w0, #0xffffffe1            	// #-31
ffffffffea80f03c:	17fffff1 	b	ffffffffea80f000 <virtio_kick_vq+0x98>
		return ERR_INVALID_ARGS;
ffffffffea80f040:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea80f044:	17ffffef 	b	ffffffffea80f000 <virtio_kick_vq+0x98>
}
ffffffffea80f048:	94001338 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea80f04c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80f050 <tipc_descr_size>:

static size_t tipc_descr_size(struct vdev *vd)
{
	struct tipc_dev *dev = vdev_to_dev(vd);
	return dev->descr_size;
}
ffffffffea80f050:	f9402000 	ldr	x0, [x0, #64]
ffffffffea80f054:	d65f03c0 	ret

ffffffffea80f058 <tipc_tx_vq_notify_cb>:
{
ffffffffea80f058:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80f05c:	910003fd 	mov	x29, sp
	vqueue_signal_avail(vq);
ffffffffea80f060:	97fffb28 	bl	ffffffffea80dd00 <vqueue_signal_avail>
}
ffffffffea80f064:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f068:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80f06c:	d65f03c0 	ret

ffffffffea80f070 <_send_buf>:
	uint8_t  *data;
	size_t    len;
};

static int _send_buf(uint8_t *dst, size_t sz, void *ctx)
{
ffffffffea80f070:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80f074:	910003fd 	mov	x29, sp
	DEBUG_ASSERT(dst);
	DEBUG_ASSERT(buf);
	DEBUG_ASSERT(buf->data);
	DEBUG_ASSERT(sz <= buf->len);

	memcpy (dst, buf->data,  sz);
ffffffffea80f078:	f9400043 	ldr	x3, [x2]
ffffffffea80f07c:	aa0103e2 	mov	x2, x1
{
ffffffffea80f080:	f9000bf3 	str	x19, [sp, #16]
ffffffffea80f084:	aa0103f3 	mov	x19, x1
	memcpy (dst, buf->data,  sz);
ffffffffea80f088:	aa0303e1 	mov	x1, x3
ffffffffea80f08c:	9400134f 	bl	ffffffffea813dc8 <memcpy>

	return (int) sz;
}
ffffffffea80f090:	2a1303e0 	mov	w0, w19
ffffffffea80f094:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea80f098:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80f09c:	d65f03c0 	ret

ffffffffea80f0a0 <tipc_get_vdev_descr>:
{
ffffffffea80f0a0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea80f0a4:	910003fd 	mov	x29, sp
ffffffffea80f0a8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80f0ac:	aa0003f3 	mov	x19, x0
ffffffffea80f0b0:	aa0103f4 	mov	x20, x1
	memcpy(vdev_descr, dev->descr_ptr, dev->descr_size);
ffffffffea80f0b4:	aa0103e0 	mov	x0, x1
ffffffffea80f0b8:	a9438a61 	ldp	x1, x2, [x19, #56]
ffffffffea80f0bc:	94001343 	bl	ffffffffea813dc8 <memcpy>
	vdev_descr->vdev.notifyid = vd->devid;
ffffffffea80f0c0:	b9400660 	ldr	w0, [x19, #4]
ffffffffea80f0c4:	b9000a80 	str	w0, [x20, #8]
}
ffffffffea80f0c8:	f9402260 	ldr	x0, [x19, #64]
ffffffffea80f0cc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f0d0:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea80f0d4:	d65f03c0 	ret

ffffffffea80f0d8 <tx_data_cb>:
{
ffffffffea80f0d8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80f0dc:	52800025 	mov	w5, #0x1                   	// #1
{
ffffffffea80f0e0:	910003fd 	mov	x29, sp
ffffffffea80f0e4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80f0e8:	aa0203f4 	mov	x20, x2
ffffffffea80f0ec:	f0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80f0f0:	9100e3a4 	add	x4, x29, #0x38
	iovec_kern_t dst_iov = { buf, buf_len };
ffffffffea80f0f4:	a90387a0 	stp	x0, x1, [x29, #56]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80f0f8:	52800002 	mov	w2, #0x0                   	// #0
{
ffffffffea80f0fc:	f9402a73 	ldr	x19, [x19, #80]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80f100:	910123a3 	add	x3, x29, #0x48
ffffffffea80f104:	b9400e81 	ldr	w1, [x20, #12]
ffffffffea80f108:	f9400280 	ldr	x0, [x20]
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80f10c:	b9004ba5 	str	w5, [x29, #72]
{
ffffffffea80f110:	f9400265 	ldr	x5, [x19]
ffffffffea80f114:	f90037a5 	str	x5, [x29, #104]
ffffffffea80f118:	d2800005 	mov	x5, #0x0                   	// #0
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80f11c:	f9002ba4 	str	x4, [x29, #80]
{
ffffffffea80f120:	f90013f5 	str	x21, [sp, #32]
	ipc_msg_kern_t dst_kern_msg = {
ffffffffea80f124:	b9005bbf 	str	wzr, [x29, #88]
ffffffffea80f128:	f90033bf 	str	xzr, [x29, #96]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80f12c:	97fff8f9 	bl	ffffffffea80d510 <ipc_read_msg>
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80f130:	b9400e81 	ldr	w1, [x20, #12]
	rc = ipc_read_msg(cb_ctx->chan, cb_ctx->msg_inf.id, 0,
ffffffffea80f134:	2a0003f5 	mov	w21, w0
	ipc_put_msg(cb_ctx->chan, cb_ctx->msg_inf.id);
ffffffffea80f138:	f9400280 	ldr	x0, [x20]
ffffffffea80f13c:	97fff845 	bl	ffffffffea80d250 <ipc_put_msg>
}
ffffffffea80f140:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea80f144:	f9400261 	ldr	x1, [x19]
ffffffffea80f148:	ca010041 	eor	x1, x2, x1
ffffffffea80f14c:	b50000c1 	cbnz	x1, ffffffffea80f164 <tx_data_cb+0x8c>
ffffffffea80f150:	2a1503e0 	mov	w0, w21
ffffffffea80f154:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea80f158:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f15c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80f160:	d65f03c0 	ret
ffffffffea80f164:	940012f1 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80f168 <tipc_vdev_kick_vq>:
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_TX])) {
ffffffffea80f168:	b9404802 	ldr	w2, [x0, #72]
ffffffffea80f16c:	6b02003f 	cmp	w1, w2
ffffffffea80f170:	54000120 	b.eq	ffffffffea80f194 <tipc_vdev_kick_vq+0x2c>  // b.none
	if (vqid == vqueue_id(&dev->vqs[TIPC_VQ_RX])) {
ffffffffea80f174:	b940d802 	ldr	w2, [x0, #216]
ffffffffea80f178:	6b02003f 	cmp	w1, w2
ffffffffea80f17c:	54000161 	b.ne	ffffffffea80f1a8 <tipc_vdev_kick_vq+0x40>  // b.any
		return vqueue_notify(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80f180:	91036000 	add	x0, x0, #0xd8
	return vq->id;
}

static inline int vqueue_notify(struct vqueue *vq)
{
	if (vq->notify_cb){
ffffffffea80f184:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80f188:	b40000c2 	cbz	x2, ffffffffea80f1a0 <tipc_vdev_kick_vq+0x38>
		return vq->notify_cb(vq, vq->priv);
ffffffffea80f18c:	f9404401 	ldr	x1, [x0, #136]
ffffffffea80f190:	d61f0040 	br	x2
		return vqueue_notify(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80f194:	91012000 	add	x0, x0, #0x48
	if (vq->notify_cb){
ffffffffea80f198:	f9403c02 	ldr	x2, [x0, #120]
ffffffffea80f19c:	b5ffff82 	cbnz	x2, ffffffffea80f18c <tipc_vdev_kick_vq+0x24>
	}
	return 0;
ffffffffea80f1a0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea80f1a4:	d65f03c0 	ret
	return ERR_NOT_FOUND;
ffffffffea80f1a8:	12800020 	mov	w0, #0xfffffffe            	// #-2
}
ffffffffea80f1ac:	d65f03c0 	ret

ffffffffea80f1b0 <tipc_send_data.constprop.3>:
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80f1b0:	a9b27bfd 	stp	x29, x30, [sp, #-224]!
ffffffffea80f1b4:	910003fd 	mov	x29, sp
ffffffffea80f1b8:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80f1bc:	f0000297 	adrp	x23, ffffffffea862000 <__ctor_list>
ffffffffea80f1c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea80f1c4:	aa0003f8 	mov	x24, x0
	struct vqueue *vq = &dev->vqs[TIPC_VQ_TX];
ffffffffea80f1c8:	91012014 	add	x20, x0, #0x48
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80f1cc:	f9402ae0 	ldr	x0, [x23, #80]
	memset(&buf, 0, sizeof(buf));
ffffffffea80f1d0:	9101e3b3 	add	x19, x29, #0x78
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80f1d4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80f1d8:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80f1dc:	2a0203fa 	mov	w26, w2
ffffffffea80f1e0:	a90573fb 	stp	x27, x28, [sp, #80]
	memset(&buf, 0, sizeof(buf));
ffffffffea80f1e4:	d2800902 	mov	x2, #0x48                  	// #72
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80f1e8:	2a0103fb 	mov	w27, w1
ffffffffea80f1ec:	aa0403fc 	mov	x28, x4
ffffffffea80f1f0:	f9400001 	ldr	x1, [x0]
ffffffffea80f1f4:	f9006fa1 	str	x1, [x29, #216]
ffffffffea80f1f8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80f1fc:	12003cb9 	and	w25, w5, #0xffff
	memset(&buf, 0, sizeof(buf));
ffffffffea80f200:	aa1303e0 	mov	x0, x19
tipc_send_data(struct tipc_dev *dev, uint32_t local, uint32_t remote,
ffffffffea80f204:	f90037a3 	str	x3, [x29, #104]
	memset(&buf, 0, sizeof(buf));
ffffffffea80f208:	940013ac 	bl	ffffffffea8140b8 <memset>
		event_wait(&vq->avail_event);
ffffffffea80f20c:	91024316 	add	x22, x24, #0x90
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80f210:	52800022 	mov	w2, #0x1                   	// #1
	buf.out_iovs.phys = out_phys;
ffffffffea80f214:	910303a1 	add	x1, x29, #0xc0
	buf.out_iovs.iovs = out_iovs;
ffffffffea80f218:	910323a0 	add	x0, x29, #0xc8
		if (dev->tx_stop) {
ffffffffea80f21c:	91400715 	add	x21, x24, #0x1, lsl #12
	buf.out_iovs.cnt  = MAX_TX_IOVS;
ffffffffea80f220:	b900a3a2 	str	w2, [x29, #160]
	buf.out_iovs.iovs = out_iovs;
ffffffffea80f224:	a90b03a1 	stp	x1, x0, [x29, #176]
ffffffffea80f228:	14000008 	b	ffffffffea80f248 <tipc_send_data.constprop.3+0x98>
		if (ret != ERR_NOT_ENOUGH_BUFFER || !wait) {
ffffffffea80f22c:	3100241f 	cmn	w0, #0x9
ffffffffea80f230:	54000361 	b.ne	ffffffffea80f29c <tipc_send_data.constprop.3+0xec>  // b.any
ffffffffea80f234:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f238:	aa1603e0 	mov	x0, x22
ffffffffea80f23c:	97ffd919 	bl	ffffffffea8056a0 <event_wait_timeout>
		if (dev->tx_stop) {
ffffffffea80f240:	394942a0 	ldrb	w0, [x21, #592]
ffffffffea80f244:	35000440 	cbnz	w0, ffffffffea80f2cc <tipc_send_data.constprop.3+0x11c>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80f248:	aa1303e1 	mov	x1, x19
ffffffffea80f24c:	aa1403e0 	mov	x0, x20
ffffffffea80f250:	97fffae2 	bl	ffffffffea80ddd8 <vqueue_get_avail_buf>
		if (ret == NO_ERROR) {
ffffffffea80f254:	35fffec0 	cbnz	w0, ffffffffea80f22c <tipc_send_data.constprop.3+0x7c>
	if (buf.out_iovs.used == 0) {
ffffffffea80f258:	b940a7a0 	ldr	w0, [x29, #164]
ffffffffea80f25c:	12800102 	mov	w2, #0xfffffff7            	// #-9
ffffffffea80f260:	34000180 	cbz	w0, ffffffffea80f290 <tipc_send_data.constprop.3+0xe0>
	if (sizeof(struct tipc_hdr) > buf.out_iovs.iovs[0].len) {
ffffffffea80f264:	f9405fa0 	ldr	x0, [x29, #184]
ffffffffea80f268:	f9400400 	ldr	x0, [x0, #8]
ffffffffea80f26c:	f1003c1f 	cmp	x0, #0xf
ffffffffea80f270:	54000109 	b.ls	ffffffffea80f290 <tipc_send_data.constprop.3+0xe0>  // b.plast
	ret = vqueue_map_iovs(&buf.out_iovs, map_flags, dev->guest);
ffffffffea80f274:	b9402b02 	ldr	w2, [x24, #40]
ffffffffea80f278:	9100a276 	add	x22, x19, #0x28
ffffffffea80f27c:	52800601 	mov	w1, #0x30                  	// #48
ffffffffea80f280:	aa1603e0 	mov	x0, x22
ffffffffea80f284:	97fffb5f 	bl	ffffffffea80e000 <vqueue_map_iovs>
ffffffffea80f288:	2a0003e2 	mov	w2, w0
	if (ret == NO_ERROR) {
ffffffffea80f28c:	34000240 	cbz	w0, ffffffffea80f2d4 <tipc_send_data.constprop.3+0x124>
	ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80f290:	aa1303e1 	mov	x1, x19
ffffffffea80f294:	aa1403e0 	mov	x0, x20
ffffffffea80f298:	97fffbd2 	bl	ffffffffea80e1e0 <vqueue_add_buf>
}
ffffffffea80f29c:	f9402af7 	ldr	x23, [x23, #80]
ffffffffea80f2a0:	f9406fa2 	ldr	x2, [x29, #216]
ffffffffea80f2a4:	f94002e1 	ldr	x1, [x23]
ffffffffea80f2a8:	ca010041 	eor	x1, x2, x1
ffffffffea80f2ac:	b5000441 	cbnz	x1, ffffffffea80f334 <tipc_send_data.constprop.3+0x184>
ffffffffea80f2b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f2b4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80f2b8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80f2bc:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80f2c0:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80f2c4:	a8ce7bfd 	ldp	x29, x30, [sp], #224
ffffffffea80f2c8:	d65f03c0 	ret
			return ERR_CHANNEL_CLOSED;
ffffffffea80f2cc:	128001c0 	mov	w0, #0xfffffff1            	// #-15
ffffffffea80f2d0:	17fffff3 	b	ffffffffea80f29c <tipc_send_data.constprop.3+0xec>
		struct tipc_hdr *hdr = buf.out_iovs.iovs[0].base;
ffffffffea80f2d4:	f9405fa1 	ldr	x1, [x29, #184]
	sizeof(struct tipc_hdr) + data_len;
ffffffffea80f2d8:	92403f24 	and	x4, x25, #0xffff
	size_t ttl_len =
ffffffffea80f2dc:	91004085 	add	x5, x4, #0x10
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80f2e0:	aa1c03e2 	mov	x2, x28
		if (ttl_len > buf.out_iovs.iovs[0].len) {
ffffffffea80f2e4:	a9400c20 	ldp	x0, x3, [x1]
		hdr->dst = remote;
ffffffffea80f2e8:	2900681b 	stp	w27, w26, [x0]
		hdr->reserved = 0;
ffffffffea80f2ec:	b900081f 	str	wzr, [x0, #8]
ffffffffea80f2f0:	eb0300bf 	cmp	x5, x3
ffffffffea80f2f4:	51004063 	sub	w3, w3, #0x10
ffffffffea80f2f8:	92403c61 	and	x1, x3, #0xffff
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80f2fc:	f94037a3 	ldr	x3, [x29, #104]
		hdr->len = data_len;
ffffffffea80f300:	79001819 	strh	w25, [x0, #12]
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80f304:	9a848021 	csel	x1, x1, x4, hi  // hi = pmore
		hdr->flags = 0;
ffffffffea80f308:	79001c1f 	strh	wzr, [x0, #14]
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80f30c:	91004000 	add	x0, x0, #0x10
ffffffffea80f310:	d63f0060 	blr	x3
			ret += sizeof(struct tipc_hdr);
ffffffffea80f314:	7100001f 	cmp	w0, #0x0
		ret = cb(hdr->data, data_len, cb_ctx);
ffffffffea80f318:	2a0003f5 	mov	w21, w0
			ret += sizeof(struct tipc_hdr);
ffffffffea80f31c:	11004000 	add	w0, w0, #0x10
ffffffffea80f320:	1a95a015 	csel	w21, w0, w21, ge  // ge = tcont
		vqueue_unmap_iovs(&buf.out_iovs);
ffffffffea80f324:	aa1603e0 	mov	x0, x22
ffffffffea80f328:	97fffb92 	bl	ffffffffea80e170 <vqueue_unmap_iovs>
ffffffffea80f32c:	2a1503e2 	mov	w2, w21
ffffffffea80f330:	17ffffd8 	b	ffffffffea80f290 <tipc_send_data.constprop.3+0xe0>
}
ffffffffea80f334:	9400127d 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80f338 <tipc_vdev_probe>:
{
ffffffffea80f338:	d102c3ff 	sub	sp, sp, #0xb0
ffffffffea80f33c:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea80f340:	910043fd 	add	x29, sp, #0x10
ffffffffea80f344:	a904e7f8 	stp	x24, x25, [sp, #72]
ffffffffea80f348:	f0000299 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea80f34c:	f90017f4 	str	x20, [sp, #40]
ffffffffea80f350:	aa0003f4 	mov	x20, x0
ffffffffea80f354:	f9402b20 	ldr	x0, [x25, #80]
ffffffffea80f358:	f90037fc 	str	x28, [sp, #104]
ffffffffea80f35c:	aa0103fc 	mov	x28, x1
ffffffffea80f360:	f9400001 	ldr	x1, [x0]
ffffffffea80f364:	f9004fa1 	str	x1, [x29, #152]
ffffffffea80f368:	d2800001 	mov	x1, #0x0                   	// #0
	if (dev->vd.state != VDEV_STATE_RESET) {
ffffffffea80f36c:	b9400280 	ldr	w0, [x20]
ffffffffea80f370:	35000fa0 	cbnz	w0, ffffffffea80f564 <tipc_vdev_probe+0x22c>
	if (vdev_descr->hdr.type != RSC_VDEV) {
ffffffffea80f374:	b9400380 	ldr	w0, [x28]
ffffffffea80f378:	71000c1f 	cmp	w0, #0x3
ffffffffea80f37c:	54000f01 	b.ne	ffffffffea80f55c <tipc_vdev_probe+0x224>  // b.any
	if (vdev_descr->vdev.id != VIRTIO_ID_TIPC) {
ffffffffea80f380:	b9400780 	ldr	w0, [x28, #4]
ffffffffea80f384:	7100341f 	cmp	w0, #0xd
ffffffffea80f388:	54000ea1 	b.ne	ffffffffea80f55c <tipc_vdev_probe+0x224>  // b.any
	if (vdev_descr->vdev.num_of_vrings != TIPC_VQ_NUM) {
ffffffffea80f38c:	39406780 	ldrb	w0, [x28, #25]
ffffffffea80f390:	7100081f 	cmp	w0, #0x2
ffffffffea80f394:	54000e41 	b.ne	ffffffffea80f55c <tipc_vdev_probe+0x224>  // b.any
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80f398:	39406380 	ldrb	w0, [x28, #24]
ffffffffea80f39c:	71001c1f 	cmp	w0, #0x7
ffffffffea80f3a0:	54000de1 	b.ne	ffffffffea80f55c <tipc_vdev_probe+0x224>  // b.any
ffffffffea80f3a4:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea80f3a8:	9101229a 	add	x26, x20, #0x48
ffffffffea80f3ac:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f3b0:	90000006 	adrp	x6, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80f3b4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f3b8:	d000005b 	adrp	x27, ffffffffea819000 <_mem_phys_base>
ffffffffea80f3bc:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80f3c0:	aa1a03f6 	mov	x22, x26
ffffffffea80f3c4:	910160c6 	add	x6, x6, #0x58
ffffffffea80f3c8:	913b837b 	add	x27, x27, #0xee0
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80f3cc:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea80f3d0:	91007393 	add	x19, x28, #0x1c
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80f3d4:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea80f3d8:	14000009 	b	ffffffffea80f3fc <tipc_vdev_probe+0xc4>
	for (vring_cnt = 0; vring_cnt < dscr->vdev.num_of_vrings; vring_cnt++) {
ffffffffea80f3dc:	39406780 	ldrb	w0, [x28, #25]
ffffffffea80f3e0:	110006b5 	add	w21, w21, #0x1
ffffffffea80f3e4:	91005273 	add	x19, x19, #0x14
ffffffffea80f3e8:	910242d6 	add	x22, x22, #0x90
ffffffffea80f3ec:	910022f7 	add	x23, x23, #0x8
ffffffffea80f3f0:	6b0002bf 	cmp	w21, w0
ffffffffea80f3f4:	540004a2 	b.cs	ffffffffea80f488 <tipc_vdev_probe+0x150>  // b.hs, b.nlast
ffffffffea80f3f8:	f87b6ae6 	ldr	x6, [x23, x27]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80f3fc:	29401260 	ldp	w0, w4, [x19]
ffffffffea80f400:	d2800007 	mov	x7, #0x0                   	// #0
ffffffffea80f404:	29410663 	ldp	w3, w1, [x19, #8]
		uint64_t pa64 = ((uint64_t)vring->reserved << 32) | vring->da;
ffffffffea80f408:	b9401262 	ldr	w2, [x19, #16]
		ret = vqueue_init(&dev->vqs[vring_cnt],
ffffffffea80f40c:	b9402a85 	ldr	w5, [x20, #40]
ffffffffea80f410:	b90003e5 	str	w5, [sp]
ffffffffea80f414:	aa1403e5 	mov	x5, x20
ffffffffea80f418:	aa028002 	orr	x2, x0, x2, lsl #32
ffffffffea80f41c:	aa1603e0 	mov	x0, x22
ffffffffea80f420:	97fff9b0 	bl	ffffffffea80dae0 <vqueue_init>
ffffffffea80f424:	2a0003f8 	mov	w24, w0
		if (ret) {
ffffffffea80f428:	34fffda0 	cbz	w0, ffffffffea80f3dc <tipc_vdev_probe+0xa4>
ffffffffea80f42c:	d1012294 	sub	x20, x20, #0x48
	while (vring_cnt--) {
ffffffffea80f430:	340000d5 	cbz	w21, ffffffffea80f448 <tipc_vdev_probe+0x110>
		vqueue_destroy(&dev->vqs[vring_cnt]);
ffffffffea80f434:	aa1a03e0 	mov	x0, x26
ffffffffea80f438:	d102435a 	sub	x26, x26, #0x90
ffffffffea80f43c:	97fffa0b 	bl	ffffffffea80dc68 <vqueue_destroy>
	while (vring_cnt--) {
ffffffffea80f440:	eb1a029f 	cmp	x20, x26
ffffffffea80f444:	54ffff81 	b.ne	ffffffffea80f434 <tipc_vdev_probe+0xfc>  // b.any
ffffffffea80f448:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f44c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f450:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80f454:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea80f458:	2a1803e0 	mov	w0, w24
ffffffffea80f45c:	f9402b39 	ldr	x25, [x25, #80]
ffffffffea80f460:	f9404fa2 	ldr	x2, [x29, #152]
ffffffffea80f464:	f9400321 	ldr	x1, [x25]
ffffffffea80f468:	ca010041 	eor	x1, x2, x1
ffffffffea80f46c:	b5000801 	cbnz	x1, ffffffffea80f56c <tipc_vdev_probe+0x234>
ffffffffea80f470:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea80f474:	f94017f4 	ldr	x20, [sp, #40]
ffffffffea80f478:	a944e7f8 	ldp	x24, x25, [sp, #72]
ffffffffea80f47c:	f94037fc 	ldr	x28, [sp, #104]
ffffffffea80f480:	9102c3ff 	add	sp, sp, #0xb0
ffffffffea80f484:	d65f03c0 	ret
	snprintf(tname, sizeof(tname), "tipc-dev%d-rx", dev->vd.devid);
ffffffffea80f488:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80f48c:	9101e3b3 	add	x19, x29, #0x78
ffffffffea80f490:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80f494:	b0000042 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f498:	aa1303e0 	mov	x0, x19
ffffffffea80f49c:	91120042 	add	x2, x2, #0x480
ffffffffea80f4a0:	940011c4 	bl	ffffffffea813bb0 <snprintf>
		thread_create(tname, tipc_rx_thread_func, dev,
ffffffffea80f4a4:	90000001 	adrp	x1, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80f4a8:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80f4ac:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80f4b0:	aa1403e2 	mov	x2, x20
ffffffffea80f4b4:	91160021 	add	x1, x1, #0x580
ffffffffea80f4b8:	aa1303e0 	mov	x0, x19
ffffffffea80f4bc:	97ffdb0b 	bl	ffffffffea8060e8 <thread_create>
	dev->rx_thread =
ffffffffea80f4c0:	f9092280 	str	x0, [x20, #4672]
	if (dev->rx_thread) {
ffffffffea80f4c4:	b4000040 	cbz	x0, ffffffffea80f4cc <tipc_vdev_probe+0x194>
		thread_resume(dev->rx_thread);
ffffffffea80f4c8:	97ffdb68 	bl	ffffffffea806268 <thread_resume>
	snprintf(tname, sizeof(tname), "tipc-dev%d-tx", dev->vd.devid);
ffffffffea80f4cc:	b9400683 	ldr	w3, [x20, #4]
ffffffffea80f4d0:	d2800401 	mov	x1, #0x20                  	// #32
ffffffffea80f4d4:	b0000042 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f4d8:	aa1303e0 	mov	x0, x19
ffffffffea80f4dc:	91124042 	add	x2, x2, #0x490
ffffffffea80f4e0:	940011b4 	bl	ffffffffea813bb0 <snprintf>
		thread_create(tname, tipc_tx_thread_func, dev,
ffffffffea80f4e4:	90000001 	adrp	x1, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80f4e8:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea80f4ec:	52800203 	mov	w3, #0x10                  	// #16
ffffffffea80f4f0:	aa1403e2 	mov	x2, x20
ffffffffea80f4f4:	91360021 	add	x1, x1, #0xd80
ffffffffea80f4f8:	aa1303e0 	mov	x0, x19
ffffffffea80f4fc:	97ffdafb 	bl	ffffffffea8060e8 <thread_create>
	dev->tx_thread =
ffffffffea80f500:	f9092680 	str	x0, [x20, #4680]
	if (dev->tx_thread) {
ffffffffea80f504:	b4000040 	cbz	x0, ffffffffea80f50c <tipc_vdev_probe+0x1d4>
		thread_resume(dev->tx_thread);
ffffffffea80f508:	97ffdb58 	bl	ffffffffea806268 <thread_resume>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80f50c:	910283a0 	add	x0, x29, #0xa0
ffffffffea80f510:	d2800033 	mov	x19, #0x1                   	// #1

static int
tipc_send_buf(struct tipc_dev *dev, uint32_t local, uint32_t remote,
              void *data, uint16_t data_len, bool wait)
{
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f514:	d2800105 	mov	x5, #0x8                   	// #8

	return tipc_send_data(dev, local, remote,
ffffffffea80f518:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80f51c:	90000003 	adrp	x3, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80f520:	9101a3a4 	add	x4, x29, #0x68
	msg.hdr.type = TIPC_CTRL_MSGTYPE_GO_ONLINE;
ffffffffea80f524:	f81c0c13 	str	x19, [x0, #-64]!
	return tipc_send_data(dev, local, remote,
ffffffffea80f528:	9101c063 	add	x3, x3, #0x70
ffffffffea80f52c:	2a0203e1 	mov	w1, w2
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f530:	a90697a0 	stp	x0, x5, [x29, #104]
	return tipc_send_data(dev, local, remote,
ffffffffea80f534:	aa1403e0 	mov	x0, x20
ffffffffea80f538:	97ffff1e 	bl	ffffffffea80f1b0 <tipc_send_data.constprop.3>
ffffffffea80f53c:	2a0003f8 	mov	w24, w0
	if (ret == NO_ERROR) {
ffffffffea80f540:	35fff840 	cbnz	w0, ffffffffea80f448 <tipc_vdev_probe+0x110>
ffffffffea80f544:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80f548:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea80f54c:	a944efba 	ldp	x26, x27, [x29, #72]
		dev->vd.state = VDEV_STATE_ACTIVE;
ffffffffea80f550:	b9000293 	str	w19, [x20]
ffffffffea80f554:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80f558:	17ffffc0 	b	ffffffffea80f458 <tipc_vdev_probe+0x120>
	if (vdev_descr->vdev.status != (VIRTIO_CONFIG_S_ACKNOWLEDGE |
ffffffffea80f55c:	128000f8 	mov	w24, #0xfffffff8            	// #-8
	return tipc_dev_probe(dev, descr);
ffffffffea80f560:	17ffffbe 	b	ffffffffea80f458 <tipc_vdev_probe+0x120>
		return ERR_BAD_STATE;
ffffffffea80f564:	128003d8 	mov	w24, #0xffffffe1            	// #-31
ffffffffea80f568:	17ffffbc 	b	ffffffffea80f458 <tipc_vdev_probe+0x120>
ffffffffea80f56c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80f570:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80f574:	f9001bb7 	str	x23, [x29, #48]
ffffffffea80f578:	a904efba 	stp	x26, x27, [x29, #72]
}
ffffffffea80f57c:	940011eb 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea80f580 <tipc_rx_thread_func>:
{
ffffffffea80f580:	d108c3ff 	sub	sp, sp, #0x230
	mutex_acquire(&dev->ept_lock);
ffffffffea80f584:	d2824106 	mov	x6, #0x1208                	// #4616
	memset(&buf, 0, sizeof(buf));
ffffffffea80f588:	d2800902 	mov	x2, #0x48                  	// #72
ffffffffea80f58c:	52800001 	mov	w1, #0x0                   	// #0
{
ffffffffea80f590:	a9007bfd 	stp	x29, x30, [sp]
ffffffffea80f594:	910003fd 	mov	x29, sp
ffffffffea80f598:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea80f59c:	f0000298 	adrp	x24, ffffffffea862000 <__ctor_list>
ffffffffea80f5a0:	a90153f3 	stp	x19, x20, [sp, #16]
	memset(&buf, 0, sizeof(buf));
ffffffffea80f5a4:	9102e3b3 	add	x19, x29, #0xb8
{
ffffffffea80f5a8:	f9402b03 	ldr	x3, [x24, #80]
ffffffffea80f5ac:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea80f5b0:	aa0003f5 	mov	x21, x0
ffffffffea80f5b4:	f9400064 	ldr	x4, [x3]
ffffffffea80f5b8:	f90117a4 	str	x4, [x29, #552]
ffffffffea80f5bc:	d2800004 	mov	x4, #0x0                   	// #0
ffffffffea80f5c0:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea80f5c4:	a90573fb 	stp	x27, x28, [sp, #80]
	memset(&buf, 0, sizeof(buf));
ffffffffea80f5c8:	aa1303e0 	mov	x0, x19
	mutex_acquire(&dev->ept_lock);
ffffffffea80f5cc:	8b0602b9 	add	x25, x21, x6
ffffffffea80f5d0:	f9003fbe 	str	x30, [x29, #120]
	struct vqueue *vq = &dev->vqs[TIPC_VQ_RX];
ffffffffea80f5d4:	910362b4 	add	x20, x21, #0xd8
	memset(&buf, 0, sizeof(buf));
ffffffffea80f5d8:	940012b8 	bl	ffffffffea8140b8 <memset>
ffffffffea80f5dc:	914006b6 	add	x22, x21, #0x1, lsl #12
		event_wait(&vq->avail_event);
ffffffffea80f5e0:	910482b7 	add	x23, x21, #0x120
	ipc_msg_kern_t msg = {
ffffffffea80f5e4:	910463ba 	add	x26, x29, #0x118
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80f5e8:	52800022 	mov	w2, #0x1                   	// #1
	buf.in_iovs.phys = in_phys;
ffffffffea80f5ec:	910403a1 	add	x1, x29, #0x100
	buf.in_iovs.iovs = in_iovs;
ffffffffea80f5f0:	910423a0 	add	x0, x29, #0x108
	buf.in_iovs.cnt  = MAX_RX_IOVS;
ffffffffea80f5f4:	b900c3a2 	str	w2, [x29, #192]
	buf.in_iovs.iovs = in_iovs;
ffffffffea80f5f8:	a90d03a1 	stp	x1, x0, [x29, #208]
ffffffffea80f5fc:	d503201f 	nop
	while(!dev->rx_stop) {
ffffffffea80f600:	394946c0 	ldrb	w0, [x22, #593]
ffffffffea80f604:	350007a0 	cbnz	w0, ffffffffea80f6f8 <tipc_rx_thread_func+0x178>
ffffffffea80f608:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f60c:	aa1703e0 	mov	x0, x23
ffffffffea80f610:	97ffd824 	bl	ffffffffea8056a0 <event_wait_timeout>
		ret = vqueue_get_avail_buf(vq, &buf);
ffffffffea80f614:	aa1303e1 	mov	x1, x19
ffffffffea80f618:	aa1403e0 	mov	x0, x20
ffffffffea80f61c:	97fff9ef 	bl	ffffffffea80ddd8 <vqueue_get_avail_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80f620:	31003c1f 	cmn	w0, #0xf
ffffffffea80f624:	540006a0 	b.eq	ffffffffea80f6f8 <tipc_rx_thread_func+0x178>  // b.none
		if (ret == ERR_NOT_ENOUGH_BUFFER) {
ffffffffea80f628:	3100241f 	cmn	w0, #0x9
ffffffffea80f62c:	54fffea0 	b.eq	ffffffffea80f600 <tipc_rx_thread_func+0x80>  // b.none
ffffffffea80f630:	2a0003fc 	mov	w28, w0
		if (likely(ret == NO_ERROR)) {
ffffffffea80f634:	350002e0 	cbnz	w0, ffffffffea80f690 <tipc_rx_thread_func+0x110>
	if (buf->in_iovs.used == 0) {
ffffffffea80f638:	b940c7a0 	ldr	w0, [x29, #196]
ffffffffea80f63c:	34001380 	cbz	w0, ffffffffea80f8ac <tipc_rx_thread_func+0x32c>
	int ret = vqueue_map_iovs(&buf->in_iovs, map_flags, dev->guest);
ffffffffea80f640:	b9402aa2 	ldr	w2, [x21, #40]
ffffffffea80f644:	52800701 	mov	w1, #0x38                  	// #56
ffffffffea80f648:	91002260 	add	x0, x19, #0x8
ffffffffea80f64c:	97fffa6d 	bl	ffffffffea80e000 <vqueue_map_iovs>
	if (ret) {
ffffffffea80f650:	35000380 	cbnz	w0, ffffffffea80f6c0 <tipc_rx_thread_func+0x140>
	if (buf->in_iovs.iovs[0].len < sizeof(struct tipc_hdr)) {
ffffffffea80f654:	f9406fa1 	ldr	x1, [x29, #216]
ffffffffea80f658:	128000fc 	mov	w28, #0xfffffff8            	// #-8
ffffffffea80f65c:	f9400420 	ldr	x0, [x1, #8]
ffffffffea80f660:	f1003c1f 	cmp	x0, #0xf
ffffffffea80f664:	54000129 	b.ls	ffffffffea80f688 <tipc_rx_thread_func+0x108>  // b.plast
	ns_hdr  = buf->in_iovs.iovs[0].base;
ffffffffea80f668:	f9400021 	ldr	x1, [x1]
	ns_data_len = ns_hdr->len;
ffffffffea80f66c:	79401822 	ldrh	w2, [x1, #12]
	src_addr = ns_hdr->src;
ffffffffea80f670:	b940003b 	ldr	w27, [x1]
	dst_addr = ns_hdr->dst;
ffffffffea80f674:	b9400423 	ldr	w3, [x1, #4]
	ns_data_len = ns_hdr->len;
ffffffffea80f678:	92403c42 	and	x2, x2, #0xffff
	if (ns_data_len + sizeof(struct tipc_hdr) != buf->in_iovs.iovs[0].len) {
ffffffffea80f67c:	91004044 	add	x4, x2, #0x10
ffffffffea80f680:	eb04001f 	cmp	x0, x4
ffffffffea80f684:	54000560 	b.eq	ffffffffea80f730 <tipc_rx_thread_func+0x1b0>  // b.none
	vqueue_unmap_iovs(&buf->in_iovs);
ffffffffea80f688:	91002260 	add	x0, x19, #0x8
ffffffffea80f68c:	97fffab9 	bl	ffffffffea80e170 <vqueue_unmap_iovs>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80f690:	2a1c03e2 	mov	w2, w28
ffffffffea80f694:	aa1303e1 	mov	x1, x19
ffffffffea80f698:	aa1403e0 	mov	x0, x20
ffffffffea80f69c:	97fffad1 	bl	ffffffffea80e1e0 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80f6a0:	31003c1f 	cmn	w0, #0xf
ffffffffea80f6a4:	540002a0 	b.eq	ffffffffea80f6f8 <tipc_rx_thread_func+0x178>  // b.none
		if (ret != NO_ERROR) {
ffffffffea80f6a8:	34fffac0 	cbz	w0, ffffffffea80f600 <tipc_rx_thread_func+0x80>
			panic("Unable (%d) to return buffer to vqueue\n", ret);
ffffffffea80f6ac:	2a0003e2 	mov	w2, w0
ffffffffea80f6b0:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea80f6b4:	b0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f6b8:	910f8021 	add	x1, x1, #0x3e0
ffffffffea80f6bc:	94000bb1 	bl	ffffffffea812580 <_panic>
		TRACEF("failed to map iovs %d\n", ret);
ffffffffea80f6c0:	2a0003e3 	mov	w3, w0
ffffffffea80f6c4:	b0000044 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f6c8:	2a0303fc 	mov	w28, w3
ffffffffea80f6cc:	52803e62 	mov	w2, #0x1f3                 	// #499
ffffffffea80f6d0:	910e6080 	add	x0, x4, #0x398
ffffffffea80f6d4:	b0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f6d8:	910d6021 	add	x1, x1, #0x358
ffffffffea80f6dc:	9400115f 	bl	ffffffffea813c58 <_printf>
		ret = vqueue_add_buf(vq, &buf, ret);
ffffffffea80f6e0:	2a1c03e2 	mov	w2, w28
ffffffffea80f6e4:	aa1303e1 	mov	x1, x19
ffffffffea80f6e8:	aa1403e0 	mov	x0, x20
ffffffffea80f6ec:	97fffabd 	bl	ffffffffea80e1e0 <vqueue_add_buf>
		if (ret == ERR_CHANNEL_CLOSED) {
ffffffffea80f6f0:	31003c1f 	cmn	w0, #0xf
ffffffffea80f6f4:	54fffda1 	b.ne	ffffffffea80f6a8 <tipc_rx_thread_func+0x128>  // b.any
}
ffffffffea80f6f8:	f9402b18 	ldr	x24, [x24, #80]
ffffffffea80f6fc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80f700:	f94117a2 	ldr	x2, [x29, #552]
ffffffffea80f704:	f9400301 	ldr	x1, [x24]
ffffffffea80f708:	ca010041 	eor	x1, x2, x1
ffffffffea80f70c:	b5002081 	cbnz	x1, ffffffffea80fb1c <tipc_rx_thread_func+0x59c>
ffffffffea80f710:	a9407bfd 	ldp	x29, x30, [sp]
ffffffffea80f714:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea80f718:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea80f71c:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea80f720:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea80f724:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea80f728:	9108c3ff 	add	sp, sp, #0x230
ffffffffea80f72c:	d65f03c0 	ret
	if (dst_addr == TIPC_CTRL_ADDR) {
ffffffffea80f730:	7100d47f 	cmp	w3, #0x35
ffffffffea80f734:	54000480 	b.eq	ffffffffea80f7c4 <tipc_rx_thread_func+0x244>  // b.none
	ipc_msg_kern_t msg = {
ffffffffea80f738:	910273a0 	add	x0, x29, #0x9c
ffffffffea80f73c:	52800024 	mov	w4, #0x1                   	// #1
ffffffffea80f740:	b90073a3 	str	w3, [x29, #112]
ffffffffea80f744:	a9007c1f 	stp	xzr, xzr, [x0]
	ns_data = buf->in_iovs.iovs[0].base + sizeof(struct tipc_hdr);
ffffffffea80f748:	91004020 	add	x0, x1, #0x10
	ipc_msg_kern_t msg = {
ffffffffea80f74c:	b9009ba4 	str	w4, [x29, #152]
ffffffffea80f750:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f754:	f90053ba 	str	x26, [x29, #160]
ffffffffea80f758:	f80ac3bf 	stur	xzr, [x29, #172]
ffffffffea80f75c:	b900b7bf 	str	wzr, [x29, #180]
		.iov		= (iovec_kern_t []) {
ffffffffea80f760:	a9118ba0 	stp	x0, x2, [x29, #280]
ffffffffea80f764:	aa1903e0 	mov	x0, x25
ffffffffea80f768:	97ffd848 	bl	ffffffffea805888 <mutex_acquire_timeout>
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80f76c:	b94073a3 	ldr	w3, [x29, #112]
ffffffffea80f770:	510fa063 	sub	w3, w3, #0x3e8
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f774:	7103fc7f 	cmp	w3, #0xff
ffffffffea80f778:	54001588 	b.hi	ffffffffea80fa28 <tipc_rx_thread_func+0x4a8>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80f77c:	2a0303e0 	mov	w0, w3
ffffffffea80f780:	d346fc01 	lsr	x1, x0, #6
ffffffffea80f784:	8b010ea1 	add	x1, x21, x1, lsl #3
ffffffffea80f788:	f948b421 	ldr	x1, [x1, #4456]
ffffffffea80f78c:	9ac32423 	lsr	x3, x1, x3
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f790:	360014c3 	tbz	w3, #0, ffffffffea80fa28 <tipc_rx_thread_func+0x4a8>
ffffffffea80f794:	8b0012a0 	add	x0, x21, x0, lsl #4
	if (ept && ept->remote == remote) {
ffffffffea80f798:	b9416801 	ldr	w1, [x0, #360]
ffffffffea80f79c:	6b01037f 	cmp	w27, w1
ffffffffea80f7a0:	54001441 	b.ne	ffffffffea80fa28 <tipc_rx_thread_func+0x4a8>  // b.any
		if (ept->chan){
ffffffffea80f7a4:	f940b800 	ldr	x0, [x0, #368]
ffffffffea80f7a8:	b4001400 	cbz	x0, ffffffffea80fa28 <tipc_rx_thread_func+0x4a8>
			ret = ipc_send_msg(ept->chan, &msg);
ffffffffea80f7ac:	910263a1 	add	x1, x29, #0x98
ffffffffea80f7b0:	97fff5ee 	bl	ffffffffea80cf68 <ipc_send_msg>
ffffffffea80f7b4:	2a0003fc 	mov	w28, w0
	mutex_release(&dev->ept_lock);
ffffffffea80f7b8:	aa1903e0 	mov	x0, x25
ffffffffea80f7bc:	97ffd85f 	bl	ffffffffea805938 <mutex_release>
ffffffffea80f7c0:	17ffffb2 	b	ffffffffea80f688 <tipc_rx_thread_func+0x108>
	if (msg_len < sizeof(struct tipc_ctrl_msg_hdr)) {
ffffffffea80f7c4:	f1001c5f 	cmp	x2, #0x7
ffffffffea80f7c8:	54000ba9 	b.ls	ffffffffea80f93c <tipc_rx_thread_func+0x3bc>  // b.plast
	msg_type = ns_msg_hdr->type;
ffffffffea80f7cc:	b9401027 	ldr	w7, [x1, #16]
	msg_body_len = ns_msg_hdr->body_len;
ffffffffea80f7d0:	b940143c 	ldr	w28, [x1, #20]
ffffffffea80f7d4:	2a1c03fc 	mov	w28, w28
	if (sizeof(struct tipc_ctrl_msg_hdr) + msg_body_len != msg_len) {
ffffffffea80f7d8:	91002380 	add	x0, x28, #0x8
ffffffffea80f7dc:	eb00005f 	cmp	x2, x0
ffffffffea80f7e0:	54000ae1 	b.ne	ffffffffea80f93c <tipc_rx_thread_func+0x3bc>  // b.any
	switch (msg_type) {
ffffffffea80f7e4:	71000cff 	cmp	w7, #0x3
ffffffffea80f7e8:	54000660 	b.eq	ffffffffea80f8b4 <tipc_rx_thread_func+0x334>  // b.none
ffffffffea80f7ec:	710014ff 	cmp	w7, #0x5
ffffffffea80f7f0:	54000a61 	b.ne	ffffffffea80f93c <tipc_rx_thread_func+0x3bc>  // b.any
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80f7f4:	f100139f 	cmp	x28, #0x4
ffffffffea80f7f8:	54000a21 	b.ne	ffffffffea80f93c <tipc_rx_thread_func+0x3bc>  // b.any
	uint32_t target = ns_req->target;
ffffffffea80f7fc:	b940183c 	ldr	w28, [x1, #24]
ffffffffea80f800:	aa1903e0 	mov	x0, x25
ffffffffea80f804:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80f808:	97ffd820 	bl	ffffffffea805888 <mutex_acquire_timeout>
	return (uint)(addr - TIPC_ADDR_BASE);
ffffffffea80f80c:	510fa381 	sub	w1, w28, #0x3e8
ffffffffea80f810:	d2822d02 	mov	x2, #0x1168                	// #4456
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f814:	7103fc3f 	cmp	w1, #0xff
ffffffffea80f818:	8b0202a2 	add	x2, x21, x2
ffffffffea80f81c:	54000949 	b.ls	ffffffffea80f944 <tipc_rx_thread_func+0x3c4>  // b.plast
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f820:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80f824:	14000004 	b	ffffffffea80f834 <tipc_rx_thread_func+0x2b4>
ffffffffea80f828:	91000400 	add	x0, x0, #0x1
		for (uint slot  = 0; slot < countof(dev->epts); slot++) {
ffffffffea80f82c:	f104001f 	cmp	x0, #0x100
ffffffffea80f830:	54000360 	b.eq	ffffffffea80f89c <tipc_rx_thread_func+0x31c>  // b.none
ffffffffea80f834:	d346fc01 	lsr	x1, x0, #6
ffffffffea80f838:	f8617841 	ldr	x1, [x2, x1, lsl #3]
ffffffffea80f83c:	9ac02421 	lsr	x1, x1, x0
			if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f840:	3607ff41 	tbz	w1, #0, ffffffffea80f828 <tipc_rx_thread_func+0x2a8>
				if (dev->epts[slot].remote == remote) {
ffffffffea80f844:	8b0012a1 	add	x1, x21, x0, lsl #4
ffffffffea80f848:	b9416821 	ldr	w1, [x1, #360]
ffffffffea80f84c:	6b01037f 	cmp	w27, w1
ffffffffea80f850:	54fffec1 	b.ne	ffffffffea80f828 <tipc_rx_thread_func+0x2a8>  // b.any
					ept = &dev->epts[slot];
ffffffffea80f854:	8b0012a0 	add	x0, x21, x0, lsl #4
ffffffffea80f858:	9105a01c 	add	x28, x0, #0x168
		handle_t *chan = ept->chan;
ffffffffea80f85c:	f940079b 	ldr	x27, [x28, #8]
		if (chan) {
ffffffffea80f860:	b400015b 	cbz	x27, ffffffffea80f888 <tipc_rx_thread_func+0x308>
			handle_list_del(&dev->handle_list, chan);
ffffffffea80f864:	aa1b03e1 	mov	x1, x27
ffffffffea80f868:	f9003ba2 	str	x2, [x29, #112]
ffffffffea80f86c:	d2823700 	mov	x0, #0x11b8                	// #4536
ffffffffea80f870:	8b0002a0 	add	x0, x21, x0
ffffffffea80f874:	97ffeb45 	bl	ffffffffea80a588 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80f878:	f9001b7f 	str	xzr, [x27, #48]
			handle_close(chan);
ffffffffea80f87c:	aa1b03e0 	mov	x0, x27
ffffffffea80f880:	97ffea96 	bl	ffffffffea80a2d8 <handle_close>
ffffffffea80f884:	f9403ba2 	ldr	x2, [x29, #112]
	return slot_to_addr(ept - dev->epts);
ffffffffea80f888:	9105a2a0 	add	x0, x21, #0x168
ffffffffea80f88c:	cb000380 	sub	x0, x28, x0
ffffffffea80f890:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80f894:	7103fc1f 	cmp	w0, #0xff
ffffffffea80f898:	54000aa9 	b.ls	ffffffffea80f9ec <tipc_rx_thread_func+0x46c>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80f89c:	aa1903e0 	mov	x0, x25
ffffffffea80f8a0:	5280001c 	mov	w28, #0x0                   	// #0
ffffffffea80f8a4:	97ffd825 	bl	ffffffffea805938 <mutex_release>
ffffffffea80f8a8:	17ffff78 	b	ffffffffea80f688 <tipc_rx_thread_func+0x108>
	if (buf->in_iovs.used == 0) {
ffffffffea80f8ac:	128000fc 	mov	w28, #0xfffffff8            	// #-8
ffffffffea80f8b0:	17ffff78 	b	ffffffffea80f690 <tipc_rx_thread_func+0x110>
ffffffffea80f8b4:	b90073a7 	str	w7, [x29, #112]
		if (msg_body_len != sizeof(struct tipc_conn_req_body)) {
ffffffffea80f8b8:	f104039f 	cmp	x28, #0x100
ffffffffea80f8bc:	54000401 	b.ne	ffffffffea80f93c <tipc_rx_thread_func+0x3bc>  // b.any
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80f8c0:	9104a3a8 	add	x8, x29, #0x128
ffffffffea80f8c4:	aa1c03e2 	mov	x2, x28
ffffffffea80f8c8:	91006021 	add	x1, x1, #0x18
ffffffffea80f8cc:	aa0803e0 	mov	x0, x8
ffffffffea80f8d0:	f90037a8 	str	x8, [x29, #104]
	handle_t *chan = NULL;
ffffffffea80f8d4:	f90043bf 	str	xzr, [x29, #128]
	strncpy(req.name, (const char *)ns_req->name, sizeof(req.name));
ffffffffea80f8d8:	94001264 	bl	ffffffffea814268 <strncpy>
	err = ipc_port_connect_async(dev->guest, dev->uuid, req.name, sizeof(req.name),
ffffffffea80f8dc:	f94037a8 	ldr	x8, [x29, #104]
ffffffffea80f8e0:	aa1c03e3 	mov	x3, x28
ffffffffea80f8e4:	b9402aa0 	ldr	w0, [x21, #40]
ffffffffea80f8e8:	910203a5 	add	x5, x29, #0x80
ffffffffea80f8ec:	f9401aa1 	ldr	x1, [x21, #48]
ffffffffea80f8f0:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea80f8f4:	aa0803e2 	mov	x2, x8
ffffffffea80f8f8:	97fff22a 	bl	ffffffffea80c1a0 <ipc_port_connect_async>
ffffffffea80f8fc:	2a0003e3 	mov	w3, w0
	if (err == NO_ERROR) {
ffffffffea80f900:	b94073a7 	ldr	w7, [x29, #112]
ffffffffea80f904:	34000960 	cbz	w0, ffffffffea80fa30 <tipc_rx_thread_func+0x4b0>
	if (chan) {
ffffffffea80f908:	f94043a1 	ldr	x1, [x29, #128]
	return NULL;
ffffffffea80f90c:	d2800000 	mov	x0, #0x0                   	// #0
	if (chan) {
ffffffffea80f910:	b4000361 	cbz	x1, ffffffffea80f97c <tipc_rx_thread_func+0x3fc>
ffffffffea80f914:	f9001820 	str	x0, [x1, #48]
		handle_list_add(&dev->handle_list, chan);
ffffffffea80f918:	d2823703 	mov	x3, #0x11b8                	// #4536
ffffffffea80f91c:	8b0302a0 	add	x0, x21, x3
		event_signal(&dev->have_handles, false);
ffffffffea80f920:	5280001c 	mov	w28, #0x0                   	// #0
		handle_list_add(&dev->handle_list, chan);
ffffffffea80f924:	97ffeaef 	bl	ffffffffea80a4e0 <handle_list_add>
		event_signal(&dev->have_handles, false);
ffffffffea80f928:	d2823104 	mov	x4, #0x1188                	// #4488
ffffffffea80f92c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80f930:	8b0402a0 	add	x0, x21, x4
ffffffffea80f934:	97ffd77f 	bl	ffffffffea805730 <event_signal>
ffffffffea80f938:	17ffff54 	b	ffffffffea80f688 <tipc_rx_thread_func+0x108>
		if (msg_body_len != sizeof(struct tipc_disc_req_body)) {
ffffffffea80f93c:	128000dc 	mov	w28, #0xfffffff9            	// #-7
ffffffffea80f940:	17ffff52 	b	ffffffffea80f688 <tipc_rx_thread_func+0x108>
ffffffffea80f944:	2a0103e0 	mov	w0, w1
ffffffffea80f948:	d346fc03 	lsr	x3, x0, #6
ffffffffea80f94c:	f8637843 	ldr	x3, [x2, x3, lsl #3]
ffffffffea80f950:	9ac12461 	lsr	x1, x3, x1
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea80f954:	3607f661 	tbz	w1, #0, ffffffffea80f820 <tipc_rx_thread_func+0x2a0>
	if (!ept || ept->remote != remote) {
ffffffffea80f958:	91005800 	add	x0, x0, #0x16
ffffffffea80f95c:	d37cec00 	lsl	x0, x0, #4
ffffffffea80f960:	8b0002a1 	add	x1, x21, x0
ffffffffea80f964:	b9400821 	ldr	w1, [x1, #8]
ffffffffea80f968:	6b01037f 	cmp	w27, w1
ffffffffea80f96c:	54fff5a1 	b.ne	ffffffffea80f820 <tipc_rx_thread_func+0x2a0>  // b.any
			return &dev->epts[slot];
ffffffffea80f970:	91002000 	add	x0, x0, #0x8
ffffffffea80f974:	8b0002bc 	add	x28, x21, x0
ffffffffea80f978:	17ffffb9 	b	ffffffffea80f85c <tipc_rx_thread_func+0x2dc>
	return NULL;
ffffffffea80f97c:	52800000 	mov	w0, #0x0                   	// #0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f980:	d2800081 	mov	x1, #0x4                   	// #4
	msg.body.status = status;
ffffffffea80f984:	29140fbb 	stp	w27, w3, [x29, #160]
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f988:	f2c00281 	movk	x1, #0x14, lsl #32
	msg.body.remote = local;
ffffffffea80f98c:	b900aba0 	str	w0, [x29, #168]
	return tipc_send_data(dev, local, remote,
ffffffffea80f990:	90000003 	adrp	x3, ffffffffea80f000 <virtio_kick_vq+0x98>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f994:	910263a0 	add	x0, x29, #0x98
	return tipc_send_data(dev, local, remote,
ffffffffea80f998:	9101c063 	add	x3, x3, #0x70
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f99c:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80f9a0:	528006a2 	mov	w2, #0x35                  	// #53
	struct buf_ctx ctx = {data, data_len};
ffffffffea80f9a4:	f90047a0 	str	x0, [x29, #136]
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80f9a8:	a90907a5 	stp	x5, x1, [x29, #144]
	return tipc_send_data(dev, local, remote,
ffffffffea80f9ac:	910223a4 	add	x4, x29, #0x88
	msg.body.max_msg_size = msg_sz;
ffffffffea80f9b0:	f80ac3bf 	stur	xzr, [x29, #172]
	return tipc_send_data(dev, local, remote,
ffffffffea80f9b4:	2a0203e1 	mov	w1, w2
ffffffffea80f9b8:	aa1503e0 	mov	x0, x21
	if (err) {
ffffffffea80f9bc:	5280001c 	mov	w28, #0x0                   	// #0
	return tipc_send_data(dev, local, remote,
ffffffffea80f9c0:	97fffdfc 	bl	ffffffffea80f1b0 <tipc_send_data.constprop.3>
ffffffffea80f9c4:	2a0003e3 	mov	w3, w0
	if (err) {
ffffffffea80f9c8:	34ffe600 	cbz	w0, ffffffffea80f688 <tipc_rx_thread_func+0x108>
		TRACEF("failed (%d) to send response\n", err);
ffffffffea80f9cc:	b0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f9d0:	b0000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80f9d4:	52802982 	mov	w2, #0x14c                 	// #332
ffffffffea80f9d8:	910d2021 	add	x1, x1, #0x348
ffffffffea80f9dc:	2a0303fc 	mov	w28, w3
ffffffffea80f9e0:	910ee000 	add	x0, x0, #0x3b8
ffffffffea80f9e4:	9400109d 	bl	ffffffffea813c58 <_printf>
ffffffffea80f9e8:	17ffff28 	b	ffffffffea80f688 <tipc_rx_thread_func+0x108>
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80f9ec:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80f9f0:	52800023 	mov	w3, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80f9f4:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
ffffffffea80f9f8:	1ac02063 	lsl	w3, w3, w0
ffffffffea80f9fc:	8b010042 	add	x2, x2, x1
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80fa00:	2a2303e1 	mvn	w1, w3
ffffffffea80fa04:	885f7c43 	ldxr	w3, [x2]
ffffffffea80fa08:	0a010063 	and	w3, w3, w1
ffffffffea80fa0c:	88047c43 	stxr	w4, w3, [x2]
ffffffffea80fa10:	35ffffa4 	cbnz	w4, ffffffffea80fa04 <tipc_rx_thread_func+0x484>
ffffffffea80fa14:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea80fa18:	8b0002a0 	add	x0, x21, x0
		dev->epts[slot].remote = 0;
ffffffffea80fa1c:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80fa20:	f900b81f 	str	xzr, [x0, #368]
ffffffffea80fa24:	17ffff9e 	b	ffffffffea80f89c <tipc_rx_thread_func+0x31c>
		if (ept->chan){
ffffffffea80fa28:	1280003c 	mov	w28, #0xfffffffe            	// #-2
ffffffffea80fa2c:	17ffff63 	b	ffffffffea80f7b8 <tipc_rx_thread_func+0x238>
ffffffffea80fa30:	b9006ba3 	str	w3, [x29, #104]
ffffffffea80fa34:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80fa38:	b90073a7 	str	w7, [x29, #112]
ffffffffea80fa3c:	aa1903e0 	mov	x0, x25
ffffffffea80fa40:	97ffd792 	bl	ffffffffea805888 <mutex_acquire_timeout>
		if (bitmap[i] == ~0UL)
ffffffffea80fa44:	f948b6a0 	ldr	x0, [x21, #4456]
	int slot = bitmap_ffz(dev->inuse, TIPC_ADDR_MAX_NUM);
ffffffffea80fa48:	d2822d05 	mov	x5, #0x1168                	// #4456
ffffffffea80fa4c:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea80fa50:	8b0502a4 	add	x4, x21, x5
ffffffffea80fa54:	b9406ba3 	ldr	w3, [x29, #104]
ffffffffea80fa58:	b100041f 	cmn	x0, #0x1
ffffffffea80fa5c:	b94073a7 	ldr	w7, [x29, #112]
		local = alloc_local_addr(dev, remote, chan);
ffffffffea80fa60:	f94043a8 	ldr	x8, [x29, #128]
ffffffffea80fa64:	54000440 	b.eq	ffffffffea80faec <tipc_rx_thread_func+0x56c>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea80fa68:	aa2003e1 	mvn	x1, x0
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fa6c:	52800025 	mov	w5, #0x1                   	// #1
	return __builtin_ffsl(~x) - 1;
ffffffffea80fa70:	dac00020 	rbit	x0, x1
ffffffffea80fa74:	f100003f 	cmp	x1, #0x0
ffffffffea80fa78:	dac01000 	clz	x0, x0
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea80fa7c:	f9003ba4 	str	x4, [x29, #112]
ffffffffea80fa80:	5a9f1000 	csinv	w0, w0, wzr, ne  // ne = any
		bit = i * BITMAP_BITS_PER_WORD + _ffz(bitmap[i]);
ffffffffea80fa84:	0b02001c 	add	w28, w0, w2
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fa88:	290cf3a3 	stp	w3, w28, [x29, #100]
	return atomic_or(&((int*)bitmap)[BITMAP_INT(bit)], mask) & mask ? 1 : 0;
ffffffffea80fa8c:	d345ff80 	lsr	x0, x28, #5
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fa90:	1adc20a1 	lsl	w1, w5, w28
ffffffffea80fa94:	8b000880 	add	x0, x4, x0, lsl #2
ffffffffea80fa98:	885f7c02 	ldxr	w2, [x0]
ffffffffea80fa9c:	2a010042 	orr	w2, w2, w1
ffffffffea80faa0:	88037c02 	stxr	w3, w2, [x0]
ffffffffea80faa4:	35ffffa3 	cbnz	w3, ffffffffea80fa98 <tipc_rx_thread_func+0x518>
ffffffffea80faa8:	8b1c12a1 	add	x1, x21, x28, lsl #4
		mutex_release(&dev->ept_lock);
ffffffffea80faac:	aa1903e0 	mov	x0, x25
		dev->epts[slot].remote = remote;
ffffffffea80fab0:	b901683b 	str	w27, [x1, #360]
		dev->epts[slot].chan = chan;
ffffffffea80fab4:	f900b828 	str	x8, [x1, #368]
		mutex_release(&dev->ept_lock);
ffffffffea80fab8:	97ffd7a0 	bl	ffffffffea805938 <mutex_release>
	if (chan) {
ffffffffea80fabc:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80fac0:	294c8ba3 	ldp	w3, w2, [x29, #100]
ffffffffea80fac4:	f9403ba4 	ldr	x4, [x29, #112]
ffffffffea80fac8:	b40002c1 	cbz	x1, ffffffffea80fb20 <tipc_rx_thread_func+0x5a0>
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80facc:	d346ff83 	lsr	x3, x28, #6
			return &dev->epts[slot];
ffffffffea80fad0:	8b1c12a0 	add	x0, x21, x28, lsl #4
ffffffffea80fad4:	9105a000 	add	x0, x0, #0x168
ffffffffea80fad8:	f8637883 	ldr	x3, [x4, x3, lsl #3]
ffffffffea80fadc:	9ac22462 	lsr	x2, x3, x2
ffffffffea80fae0:	f240005f 	tst	x2, #0x1
ffffffffea80fae4:	9a9f1000 	csel	x0, x0, xzr, ne  // ne = any
ffffffffea80fae8:	17ffff8b 	b	ffffffffea80f914 <tipc_rx_thread_func+0x394>
		if (bitmap[i] == ~0UL)
ffffffffea80faec:	f948baa0 	ldr	x0, [x21, #4464]
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80faf0:	52800022 	mov	w2, #0x1                   	// #1
		if (bitmap[i] == ~0UL)
ffffffffea80faf4:	b100041f 	cmn	x0, #0x1
ffffffffea80faf8:	54000060 	b.eq	ffffffffea80fb04 <tipc_rx_thread_func+0x584>  // b.none
ffffffffea80fafc:	531a6442 	lsl	w2, w2, #6
ffffffffea80fb00:	17ffffda 	b	ffffffffea80fa68 <tipc_rx_thread_func+0x4e8>
ffffffffea80fb04:	f948bea0 	ldr	x0, [x21, #4472]
ffffffffea80fb08:	b100041f 	cmn	x0, #0x1
ffffffffea80fb0c:	540000e0 	b.eq	ffffffffea80fb28 <tipc_rx_thread_func+0x5a8>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80fb10:	52800042 	mov	w2, #0x2                   	// #2
ffffffffea80fb14:	531a6442 	lsl	w2, w2, #6
ffffffffea80fb18:	17ffffd4 	b	ffffffffea80fa68 <tipc_rx_thread_func+0x4e8>
}
ffffffffea80fb1c:	94001083 	bl	ffffffffea813d28 <__stack_chk_fail>
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80fb20:	110fa040 	add	w0, w2, #0x3e8
ffffffffea80fb24:	17ffff97 	b	ffffffffea80f980 <tipc_rx_thread_func+0x400>
		if (bitmap[i] == ~0UL)
ffffffffea80fb28:	f948c2a0 	ldr	x0, [x21, #4480]
ffffffffea80fb2c:	b100041f 	cmn	x0, #0x1
ffffffffea80fb30:	54000080 	b.eq	ffffffffea80fb40 <tipc_rx_thread_func+0x5c0>  // b.none
	for (i = 0; i < BITMAP_NUM_WORDS(numbits); i++) {
ffffffffea80fb34:	2a0703e2 	mov	w2, w7
ffffffffea80fb38:	531a6442 	lsl	w2, w2, #6
ffffffffea80fb3c:	17ffffcb 	b	ffffffffea80fa68 <tipc_rx_thread_func+0x4e8>
			handle_close(chan);
ffffffffea80fb40:	aa0803e0 	mov	x0, x8
ffffffffea80fb44:	b90073a3 	str	w3, [x29, #112]
ffffffffea80fb48:	97ffe9e4 	bl	ffffffffea80a2d8 <handle_close>
			chan = NULL;
ffffffffea80fb4c:	f90043bf 	str	xzr, [x29, #128]
		mutex_release(&dev->ept_lock);
ffffffffea80fb50:	aa1903e0 	mov	x0, x25
ffffffffea80fb54:	97ffd779 	bl	ffffffffea805938 <mutex_release>
	if (chan) {
ffffffffea80fb58:	f94043a1 	ldr	x1, [x29, #128]
ffffffffea80fb5c:	b94073a3 	ldr	w3, [x29, #112]
ffffffffea80fb60:	b4fff0e1 	cbz	x1, ffffffffea80f97c <tipc_rx_thread_func+0x3fc>
	return NULL;
ffffffffea80fb64:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea80fb68:	17ffff6b 	b	ffffffffea80f914 <tipc_rx_thread_func+0x394>
ffffffffea80fb6c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80fb70 <tipc_rx_vq_notify_cb>:
ffffffffea80fb70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
ffffffffea80fb74:	910003fd 	mov	x29, sp
ffffffffea80fb78:	97fff862 	bl	ffffffffea80dd00 <vqueue_signal_avail>
ffffffffea80fb7c:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80fb80:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea80fb84:	d65f03c0 	ret

ffffffffea80fb88 <tipc_vdev_reset>:
	if (dev->vd.state == VDEV_STATE_RESET) {
ffffffffea80fb88:	b9400001 	ldr	w1, [x0]
ffffffffea80fb8c:	35000061 	cbnz	w1, ffffffffea80fb98 <tipc_vdev_reset+0x10>
}
ffffffffea80fb90:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80fb94:	d65f03c0 	ret
{
ffffffffea80fb98:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea80fb9c:	910003fd 	mov	x29, sp
ffffffffea80fba0:	f90023f9 	str	x25, [sp, #64]
	dev->rx_stop = true;
ffffffffea80fba4:	91400419 	add	x25, x0, #0x1, lsl #12
{
ffffffffea80fba8:	f9000ff4 	str	x20, [sp, #24]
	dev->rx_stop = true;
ffffffffea80fbac:	52800034 	mov	w20, #0x1                   	// #1
{
ffffffffea80fbb0:	f9001bf7 	str	x23, [sp, #48]
ffffffffea80fbb4:	aa0003f7 	mov	x23, x0
ffffffffea80fbb8:	f9002bfb 	str	x27, [sp, #80]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80fbbc:	9103601b 	add	x27, x0, #0xd8
	dev->rx_stop = true;
ffffffffea80fbc0:	39094734 	strb	w20, [x25, #593]
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80fbc4:	aa1b03e0 	mov	x0, x27
ffffffffea80fbc8:	f90037be 	str	x30, [x29, #104]
ffffffffea80fbcc:	97fff84d 	bl	ffffffffea80dd00 <vqueue_signal_avail>
	rc = thread_join(dev->rx_thread, NULL, 1000);
ffffffffea80fbd0:	f94922e0 	ldr	x0, [x23, #4672]
ffffffffea80fbd4:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80fbd8:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80fbdc:	97ffdb6d 	bl	ffffffffea806990 <thread_join>
ffffffffea80fbe0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80fbe4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80fbe8:	f9001fb8 	str	x24, [x29, #56]
ffffffffea80fbec:	f90027ba 	str	x26, [x29, #72]
ffffffffea80fbf0:	f9002fbc 	str	x28, [x29, #88]
	if (rc != NO_ERROR) {
ffffffffea80fbf4:	35000b00 	cbnz	w0, ffffffffea80fd54 <tipc_vdev_reset+0x1cc>
	dev->rx_thread = NULL;
ffffffffea80fbf8:	f90922ff 	str	xzr, [x23, #4672]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fbfc:	d2823702 	mov	x2, #0x11b8                	// #4536
	mutex_acquire(&dev->ept_lock);
ffffffffea80fc00:	d2824103 	mov	x3, #0x1208                	// #4616
	dev->tx_stop = true;
ffffffffea80fc04:	39094334 	strb	w20, [x25, #592]
	dev->rx_stop = false;
ffffffffea80fc08:	3909473f 	strb	wzr, [x25, #593]
	ept = dev->epts;
ffffffffea80fc0c:	9105a2f5 	add	x21, x23, #0x168
ffffffffea80fc10:	d2822d01 	mov	x1, #0x1168                	// #4456
	mutex_acquire(&dev->ept_lock);
ffffffffea80fc14:	8b0302fc 	add	x28, x23, x3
ffffffffea80fc18:	8b0102fa 	add	x26, x23, x1
	ept = dev->epts;
ffffffffea80fc1c:	aa1503f3 	mov	x19, x21
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fc20:	8b0202f6 	add	x22, x23, x2
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fc24:	52800038 	mov	w24, #0x1                   	// #1
ffffffffea80fc28:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80fc2c:	aa1c03e0 	mov	x0, x28
	ept = dev->epts;
ffffffffea80fc30:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea80fc34:	97ffd715 	bl	ffffffffea805888 <mutex_acquire_timeout>
ffffffffea80fc38:	14000005 	b	ffffffffea80fc4c <tipc_vdev_reset+0xc4>
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80fc3c:	91004273 	add	x19, x19, #0x10
ffffffffea80fc40:	91000694 	add	x20, x20, #0x1
ffffffffea80fc44:	eb1a027f 	cmp	x19, x26
ffffffffea80fc48:	54000440 	b.eq	ffffffffea80fcd0 <tipc_vdev_reset+0x148>  // b.none
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea80fc4c:	d346fe80 	lsr	x0, x20, #6
ffffffffea80fc50:	f8607b40 	ldr	x0, [x26, x0, lsl #3]
ffffffffea80fc54:	9ad42400 	lsr	x0, x0, x20
		if (!bitmap_test(dev->inuse, slot)) {
ffffffffea80fc58:	3607ff20 	tbz	w0, #0, ffffffffea80fc3c <tipc_vdev_reset+0xb4>
		if (!ept->chan) {
ffffffffea80fc5c:	f9400661 	ldr	x1, [x19, #8]
ffffffffea80fc60:	b4fffee1 	cbz	x1, ffffffffea80fc3c <tipc_vdev_reset+0xb4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea80fc64:	aa1603e0 	mov	x0, x22
ffffffffea80fc68:	97ffea48 	bl	ffffffffea80a588 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea80fc6c:	f9400661 	ldr	x1, [x19, #8]
		handle_close(ept->chan);
ffffffffea80fc70:	aa0103e0 	mov	x0, x1
ffffffffea80fc74:	f900183f 	str	xzr, [x1, #48]
ffffffffea80fc78:	97ffe998 	bl	ffffffffea80a2d8 <handle_close>
	return slot_to_addr(ept - dev->epts);
ffffffffea80fc7c:	cb150260 	sub	x0, x19, x21
ffffffffea80fc80:	9344fc00 	asr	x0, x0, #4
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80fc84:	7103fc1f 	cmp	w0, #0xff
ffffffffea80fc88:	54fffda8 	b.hi	ffffffffea80fc3c <tipc_vdev_reset+0xb4>  // b.pmore
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80fc8c:	93437c01 	sbfx	x1, x0, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea80fc90:	1ac02303 	lsl	w3, w24, w0
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea80fc94:	927ee821 	and	x1, x1, #0x1ffffffffffffffc
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea80fc98:	2a2303e3 	mvn	w3, w3
ffffffffea80fc9c:	8b010341 	add	x1, x26, x1
ffffffffea80fca0:	885f7c22 	ldxr	w2, [x1]
ffffffffea80fca4:	0a030042 	and	w2, w2, w3
ffffffffea80fca8:	88047c22 	stxr	w4, w2, [x1]
ffffffffea80fcac:	35ffffa4 	cbnz	w4, ffffffffea80fca0 <tipc_vdev_reset+0x118>
ffffffffea80fcb0:	d37c7c00 	ubfiz	x0, x0, #4, #32
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80fcb4:	91004273 	add	x19, x19, #0x10
ffffffffea80fcb8:	8b0002e0 	add	x0, x23, x0
ffffffffea80fcbc:	91000694 	add	x20, x20, #0x1
ffffffffea80fcc0:	eb1a027f 	cmp	x19, x26
		dev->epts[slot].remote = 0;
ffffffffea80fcc4:	b901681f 	str	wzr, [x0, #360]
		dev->epts[slot].chan = NULL;
ffffffffea80fcc8:	f900b81f 	str	xzr, [x0, #368]
	for (uint slot  = 0; slot < countof(dev->epts); slot++, ept++) {
ffffffffea80fccc:	54fffc01 	b.ne	ffffffffea80fc4c <tipc_vdev_reset+0xc4>  // b.any
	mutex_release(&dev->ept_lock);
ffffffffea80fcd0:	aa1c03e0 	mov	x0, x28
ffffffffea80fcd4:	97ffd719 	bl	ffffffffea805938 <mutex_release>
	event_signal(&dev->have_handles, false);
ffffffffea80fcd8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80fcdc:	d2823100 	mov	x0, #0x1188                	// #4488
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80fce0:	910122f3 	add	x19, x23, #0x48
	event_signal(&dev->have_handles, false);
ffffffffea80fce4:	8b0002e0 	add	x0, x23, x0
ffffffffea80fce8:	97ffd692 	bl	ffffffffea805730 <event_signal>
	vqueue_signal_avail(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80fcec:	aa1303e0 	mov	x0, x19
ffffffffea80fcf0:	97fff804 	bl	ffffffffea80dd00 <vqueue_signal_avail>
	rc = thread_join(dev->tx_thread, NULL, 1000);
ffffffffea80fcf4:	f94926e0 	ldr	x0, [x23, #4680]
ffffffffea80fcf8:	52807d02 	mov	w2, #0x3e8                 	// #1000
ffffffffea80fcfc:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea80fd00:	97ffdb24 	bl	ffffffffea806990 <thread_join>
	if (rc != NO_ERROR) {
ffffffffea80fd04:	35000320 	cbnz	w0, ffffffffea80fd68 <tipc_vdev_reset+0x1e0>
	dev->tx_thread = NULL;
ffffffffea80fd08:	f90926ff 	str	xzr, [x23, #4680]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80fd0c:	aa1b03e0 	mov	x0, x27
	dev->tx_stop = false;
ffffffffea80fd10:	3909433f 	strb	wzr, [x25, #592]
	vqueue_destroy(&dev->vqs[TIPC_VQ_RX]);
ffffffffea80fd14:	97fff7d5 	bl	ffffffffea80dc68 <vqueue_destroy>
	vqueue_destroy(&dev->vqs[TIPC_VQ_TX]);
ffffffffea80fd18:	aa1303e0 	mov	x0, x19
ffffffffea80fd1c:	97fff7d3 	bl	ffffffffea80dc68 <vqueue_destroy>
}
ffffffffea80fd20:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea80fd24:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea80fd28:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea80fd2c:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea80fd30:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea80fd34:	f9402fbc 	ldr	x28, [x29, #88]
ffffffffea80fd38:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea80fd3c:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea80fd40:	f9402bfb 	ldr	x27, [sp, #80]
	dev->vd.state = VDEV_STATE_RESET;
ffffffffea80fd44:	b90002ff 	str	wzr, [x23]
}
ffffffffea80fd48:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea80fd4c:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea80fd50:	d65f03c0 	ret
		panic("unable to shutdown rx thread: %d\n", rc);
ffffffffea80fd54:	2a0003e2 	mov	w2, w0
ffffffffea80fd58:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80fd5c:	b0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80fd60:	91128021 	add	x1, x1, #0x4a0
ffffffffea80fd64:	94000a07 	bl	ffffffffea812580 <_panic>
		panic("unable to shutdown tx thread: %d\n", rc);
ffffffffea80fd68:	2a0003e2 	mov	w2, w0
ffffffffea80fd6c:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea80fd70:	b0000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80fd74:	91132021 	add	x1, x1, #0x4c8
ffffffffea80fd78:	94000a02 	bl	ffffffffea812580 <_panic>
ffffffffea80fd7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea80fd80 <tipc_tx_thread_func>:
{
ffffffffea80fd80:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
ffffffffea80fd84:	f0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea80fd88:	910003fd 	mov	x29, sp
ffffffffea80fd8c:	f9402821 	ldr	x1, [x1, #80]
ffffffffea80fd90:	f9400022 	ldr	x2, [x1]
ffffffffea80fd94:	f90067a2 	str	x2, [x29, #200]
ffffffffea80fd98:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea80fd9c:	f9000ff4 	str	x20, [sp, #24]
ffffffffea80fda0:	aa0003f4 	mov	x20, x0
	while (!dev->tx_stop) {
ffffffffea80fda4:	91400400 	add	x0, x0, #0x1, lsl #12
ffffffffea80fda8:	f9003fa0 	str	x0, [x29, #120]
ffffffffea80fdac:	f90037be 	str	x30, [x29, #104]
ffffffffea80fdb0:	39494000 	ldrb	w0, [x0, #592]
ffffffffea80fdb4:	350013a0 	cbnz	w0, ffffffffea810028 <tipc_tx_thread_func+0x2a8>
ffffffffea80fdb8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea80fdbc:	d2823707 	mov	x7, #0x11b8                	// #4536
ffffffffea80fdc0:	a9046bb9 	stp	x25, x26, [x29, #64]
		ret = tipc_send_data(dev, local, remote,
ffffffffea80fdc4:	90000018 	adrp	x24, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80fdc8:	a90573bb 	stp	x27, x28, [x29, #80]
ffffffffea80fdcc:	8b070299 	add	x25, x20, x7
ffffffffea80fdd0:	910233bb 	add	x27, x29, #0x8c
ffffffffea80fdd4:	910243ba 	add	x26, x29, #0x90
ffffffffea80fdd8:	91036318 	add	x24, x24, #0xd8
ffffffffea80fddc:	d2823106 	mov	x6, #0x1188                	// #4488
ffffffffea80fde0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea80fde4:	8b060280 	add	x0, x20, x6
ffffffffea80fde8:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea80fdec:	f9003ba0 	str	x0, [x29, #112]
ffffffffea80fdf0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea80fdf4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80fdf8:	97ffd62a 	bl	ffffffffea8056a0 <event_wait_timeout>
ffffffffea80fdfc:	14000005 	b	ffffffffea80fe10 <tipc_tx_thread_func+0x90>
		} else if (chan_event & IPC_HANDLE_POLL_MSG) {
ffffffffea80fe00:	37180620 	tbnz	w0, #3, ffffffffea80fec4 <tipc_tx_thread_func+0x144>
		} else if (chan_event & IPC_HANDLE_POLL_HUP) {
ffffffffea80fe04:	37100b60 	tbnz	w0, #2, ffffffffea80ff70 <tipc_tx_thread_func+0x1f0>
		handle_decref(chan);
ffffffffea80fe08:	aa1303e0 	mov	x0, x19
ffffffffea80fe0c:	97ffe90b 	bl	ffffffffea80a238 <handle_decref>
		ret = handle_list_wait(&dev->handle_list, &chan,
ffffffffea80fe10:	12800003 	mov	w3, #0xffffffff            	// #-1
ffffffffea80fe14:	aa1b03e2 	mov	x2, x27
ffffffffea80fe18:	aa1a03e1 	mov	x1, x26
ffffffffea80fe1c:	aa1903e0 	mov	x0, x25
ffffffffea80fe20:	97ffe9ec 	bl	ffffffffea80a5d0 <handle_list_wait>
		if (ret == ERR_NOT_FOUND) {
ffffffffea80fe24:	3100081f 	cmn	w0, #0x2
ffffffffea80fe28:	54000f00 	b.eq	ffffffffea810008 <tipc_tx_thread_func+0x288>  // b.none
		if (ret < 0) {
ffffffffea80fe2c:	37f814e0 	tbnz	w0, #31, ffffffffea8100c8 <tipc_tx_thread_func+0x348>
		if (chan_event & IPC_HANDLE_POLL_READY) {
ffffffffea80fe30:	b9408fa0 	ldr	w0, [x29, #140]
ffffffffea80fe34:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea80fe38:	3607fe40 	tbz	w0, #0, ffffffffea80fe00 <tipc_tx_thread_func+0x80>
	mutex_acquire(&dev->ept_lock);
ffffffffea80fe3c:	d2824105 	mov	x5, #0x1208                	// #4616
ffffffffea80fe40:	8b050295 	add	x21, x20, x5
ffffffffea80fe44:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80fe48:	aa1503e0 	mov	x0, x21
ffffffffea80fe4c:	97ffd68f 	bl	ffffffffea805888 <mutex_acquire_timeout>
	return handle->cookie;
ffffffffea80fe50:	f9401a73 	ldr	x19, [x19, #48]
	if (ept) {
ffffffffea80fe54:	b4000793 	cbz	x19, ffffffffea80ff44 <tipc_tx_thread_func+0x1c4>
		remote = ept->remote;
ffffffffea80fe58:	b9400276 	ldr	w22, [x19]
	mutex_release(&dev->ept_lock);
ffffffffea80fe5c:	aa1503e0 	mov	x0, x21
ffffffffea80fe60:	97ffd6b6 	bl	ffffffffea805938 <mutex_release>
	struct buf_ctx ctx = {data, data_len};
ffffffffea80fe64:	9102a3b5 	add	x21, x29, #0xa8
	return slot_to_addr(ept - dev->epts);
ffffffffea80fe68:	9105a280 	add	x0, x20, #0x168
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80fe6c:	d2800081 	mov	x1, #0x4                   	// #4
	return slot_to_addr(ept - dev->epts);
ffffffffea80fe70:	cb000260 	sub	x0, x19, x0
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80fe74:	f2c00281 	movk	x1, #0x14, lsl #32
	struct buf_ctx ctx = {data, data_len};
ffffffffea80fe78:	d2800385 	mov	x5, #0x1c                  	// #28
	return tipc_send_data(dev, local, remote,
ffffffffea80fe7c:	528006a2 	mov	w2, #0x35                  	// #53
	return slot_to_addr(ept - dev->epts);
ffffffffea80fe80:	9344fc00 	asr	x0, x0, #4
	struct buf_ctx ctx = {data, data_len};
ffffffffea80fe84:	a90997b5 	stp	x21, x5, [x29, #152]
	return (uint32_t) (slot + TIPC_ADDR_BASE);
ffffffffea80fe88:	110fa000 	add	w0, w0, #0x3e8
	msg.body.remote = local;
ffffffffea80fe8c:	b900bba0 	str	w0, [x29, #184]
	msg.body.max_msg_size = msg_sz;
ffffffffea80fe90:	d2820000 	mov	x0, #0x1000                	// #4096
	msg.hdr.type = TIPC_CTRL_MSGTYPE_CONN_RSP;
ffffffffea80fe94:	f90057a1 	str	x1, [x29, #168]
	msg.body.max_msg_size = msg_sz;
ffffffffea80fe98:	f2c00020 	movk	x0, #0x1, lsl #32
	return tipc_send_data(dev, local, remote,
ffffffffea80fe9c:	90000003 	adrp	x3, ffffffffea80f000 <virtio_kick_vq+0x98>
ffffffffea80fea0:	910263a4 	add	x4, x29, #0x98
	msg.body.status = status;
ffffffffea80fea4:	29167fb6 	stp	w22, wzr, [x29, #176]
	msg.body.max_msg_size = msg_sz;
ffffffffea80fea8:	f80bc3a0 	stur	x0, [x29, #188]
	return tipc_send_data(dev, local, remote,
ffffffffea80feac:	9101c063 	add	x3, x3, #0x70
ffffffffea80feb0:	2a0203e1 	mov	w1, w2
ffffffffea80feb4:	aa1403e0 	mov	x0, x20
ffffffffea80feb8:	97fffcbe 	bl	ffffffffea80f1b0 <tipc_send_data.constprop.3>
ffffffffea80febc:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea80fec0:	17ffffd2 	b	ffffffffea80fe08 <tipc_tx_thread_func+0x88>
	mutex_acquire(&dev->ept_lock);
ffffffffea80fec4:	d2824104 	mov	x4, #0x1208                	// #4616
ffffffffea80fec8:	8b040295 	add	x21, x20, x4
ffffffffea80fecc:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80fed0:	aa1503e0 	mov	x0, x21
	data_cb_ctx_t cb_ctx = { .chan = chan };
ffffffffea80fed4:	a90affb3 	stp	x19, xzr, [x29, #168]
ffffffffea80fed8:	97ffd66c 	bl	ffffffffea805888 <mutex_acquire_timeout>
ffffffffea80fedc:	f9401a60 	ldr	x0, [x19, #48]
	if (!ept) {
ffffffffea80fee0:	b4000320 	cbz	x0, ffffffffea80ff44 <tipc_tx_thread_func+0x1c4>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80fee4:	b000005c 	adrp	x28, ffffffffea818000 <zero_uuid+0x8>
	remote = ept->remote;
ffffffffea80fee8:	b9400017 	ldr	w23, [x0]
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80feec:	910da39c 	add	x28, x28, #0x368
	mutex_release(&dev->ept_lock);
ffffffffea80fef0:	aa1503e0 	mov	x0, x21
ffffffffea80fef4:	9102a3b5 	add	x21, x29, #0xa8
ffffffffea80fef8:	97ffd690 	bl	ffffffffea805938 <mutex_release>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80fefc:	910022b6 	add	x22, x21, #0x8
ffffffffea80ff00:	1400000a 	b	ffffffffea80ff28 <tipc_tx_thread_func+0x1a8>
		if (ret != NO_ERROR) {
ffffffffea80ff04:	35000d40 	cbnz	w0, ffffffffea8100ac <tipc_tx_thread_func+0x32c>
		ret = tipc_send_data(dev, local, remote,
ffffffffea80ff08:	794163a5 	ldrh	w5, [x29, #176]
ffffffffea80ff0c:	aa1503e4 	mov	x4, x21
ffffffffea80ff10:	aa1803e3 	mov	x3, x24
ffffffffea80ff14:	2a1703e2 	mov	w2, w23
ffffffffea80ff18:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea80ff1c:	aa1403e0 	mov	x0, x20
ffffffffea80ff20:	97fffca4 	bl	ffffffffea80f1b0 <tipc_send_data.constprop.3>
		if (ret != NO_ERROR) {
ffffffffea80ff24:	35000180 	cbnz	w0, ffffffffea80ff54 <tipc_tx_thread_func+0x1d4>
		ret = ipc_get_msg(chan, &cb_ctx.msg_inf);
ffffffffea80ff28:	aa1603e1 	mov	x1, x22
ffffffffea80ff2c:	aa1303e0 	mov	x0, x19
ffffffffea80ff30:	97fff494 	bl	ffffffffea80d180 <ipc_get_msg>
		if (ret == ERR_NO_MSG) {
ffffffffea80ff34:	3100101f 	cmn	w0, #0x4
ffffffffea80ff38:	54fffe61 	b.ne	ffffffffea80ff04 <tipc_tx_thread_func+0x184>  // b.any
ffffffffea80ff3c:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea80ff40:	17ffffb2 	b	ffffffffea80fe08 <tipc_tx_thread_func+0x88>
		mutex_release(&dev->ept_lock);
ffffffffea80ff44:	aa1503e0 	mov	x0, x21
ffffffffea80ff48:	97ffd67c 	bl	ffffffffea805938 <mutex_release>
ffffffffea80ff4c:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea80ff50:	17ffffae 	b	ffffffffea80fe08 <tipc_tx_thread_func+0x88>
			TRACEF("tipc_send_data failed (%d)\n", ret);
ffffffffea80ff54:	b0000044 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea80ff58:	2a0003e3 	mov	w3, w0
ffffffffea80ff5c:	528051c2 	mov	w2, #0x28e                 	// #654
ffffffffea80ff60:	aa1c03e1 	mov	x1, x28
ffffffffea80ff64:	91116080 	add	x0, x4, #0x458
ffffffffea80ff68:	94000f3c 	bl	ffffffffea813c58 <_printf>
ffffffffea80ff6c:	17ffffe4 	b	ffffffffea80fefc <tipc_tx_thread_func+0x17c>
	mutex_acquire(&dev->ept_lock);
ffffffffea80ff70:	d2824103 	mov	x3, #0x1208                	// #4616
ffffffffea80ff74:	8b030296 	add	x22, x20, x3
ffffffffea80ff78:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea80ff7c:	aa1603e0 	mov	x0, x22
ffffffffea80ff80:	97ffd642 	bl	ffffffffea805888 <mutex_acquire_timeout>
ffffffffea80ff84:	f9401a62 	ldr	x2, [x19, #48]
	if (ept) {
ffffffffea80ff88:	b4000642 	cbz	x2, ffffffffea810050 <tipc_tx_thread_func+0x2d0>
		handle_list_del(&dev->handle_list, chan);
ffffffffea80ff8c:	aa1303e1 	mov	x1, x19
	return slot_to_addr(ept - dev->epts);
ffffffffea80ff90:	9105a295 	add	x21, x20, #0x168
ffffffffea80ff94:	cb150055 	sub	x21, x2, x21
		handle_list_del(&dev->handle_list, chan);
ffffffffea80ff98:	aa1903e0 	mov	x0, x25
		remote = ept->remote;
ffffffffea80ff9c:	b9400057 	ldr	w23, [x2]
		handle_list_del(&dev->handle_list, chan);
ffffffffea80ffa0:	97ffe97a 	bl	ffffffffea80a588 <handle_list_del>
	handle->cookie = cookie;
ffffffffea80ffa4:	f9001a7f 	str	xzr, [x19, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea80ffa8:	9344feb5 	asr	x21, x21, #4
		handle_close(chan);
ffffffffea80ffac:	aa1303e0 	mov	x0, x19
ffffffffea80ffb0:	97ffe8ca 	bl	ffffffffea80a2d8 <handle_close>
	if (slot < TIPC_ADDR_MAX_NUM) {
ffffffffea80ffb4:	7103febf 	cmp	w21, #0xff
ffffffffea80ffb8:	54000549 	b.ls	ffffffffea810060 <tipc_tx_thread_func+0x2e0>  // b.plast
	mutex_release(&dev->ept_lock);
ffffffffea80ffbc:	aa1603e0 	mov	x0, x22
ffffffffea80ffc0:	97ffd65e 	bl	ffffffffea805938 <mutex_release>
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80ffc4:	d28000a0 	mov	x0, #0x5                   	// #5
	struct buf_ctx ctx = {data, data_len};
ffffffffea80ffc8:	d2800185 	mov	x5, #0xc                   	// #12
	msg.hdr.type = TIPC_CTRL_MSGTYPE_DISC_REQ;
ffffffffea80ffcc:	f2c00080 	movk	x0, #0x4, lsl #32
ffffffffea80ffd0:	f9004fa0 	str	x0, [x29, #152]
	struct buf_ctx ctx = {data, data_len};
ffffffffea80ffd4:	910263a0 	add	x0, x29, #0x98
	return tipc_send_data(dev, local, remote,
ffffffffea80ffd8:	90000003 	adrp	x3, ffffffffea80f000 <virtio_kick_vq+0x98>
	msg.body.target = remote;
ffffffffea80ffdc:	b900a3b7 	str	w23, [x29, #160]
	return tipc_send_data(dev, local, remote,
ffffffffea80ffe0:	9102a3a4 	add	x4, x29, #0xa8
	struct buf_ctx ctx = {data, data_len};
ffffffffea80ffe4:	f90057a0 	str	x0, [x29, #168]
	return tipc_send_data(dev, local, remote,
ffffffffea80ffe8:	9101c063 	add	x3, x3, #0x70
ffffffffea80ffec:	528006a2 	mov	w2, #0x35                  	// #53
ffffffffea80fff0:	110fa2a1 	add	w1, w21, #0x3e8
	struct buf_ctx ctx = {data, data_len};
ffffffffea80fff4:	f9005ba5 	str	x5, [x29, #176]
	return tipc_send_data(dev, local, remote,
ffffffffea80fff8:	aa1403e0 	mov	x0, x20
ffffffffea80fffc:	97fffc6d 	bl	ffffffffea80f1b0 <tipc_send_data.constprop.3>
ffffffffea810000:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea810004:	17ffff81 	b	ffffffffea80fe08 <tipc_tx_thread_func+0x88>
	while (!dev->tx_stop) {
ffffffffea810008:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea81000c:	39494000 	ldrb	w0, [x0, #592]
ffffffffea810010:	34ffef00 	cbz	w0, ffffffffea80fdf0 <tipc_tx_thread_func+0x70>
ffffffffea810014:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea810018:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea81001c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea810020:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea810024:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea810028:	d0000280 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea81002c:	f9402801 	ldr	x1, [x0, #80]
ffffffffea810030:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea810034:	f94067a2 	ldr	x2, [x29, #200]
ffffffffea810038:	f9400021 	ldr	x1, [x1]
ffffffffea81003c:	ca010041 	eor	x1, x2, x1
ffffffffea810040:	b5000521 	cbnz	x1, ffffffffea8100e4 <tipc_tx_thread_func+0x364>
ffffffffea810044:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea810048:	a8cd7bfd 	ldp	x29, x30, [sp], #208
ffffffffea81004c:	d65f03c0 	ret
	mutex_release(&dev->ept_lock);
ffffffffea810050:	aa1603e0 	mov	x0, x22
ffffffffea810054:	97ffd639 	bl	ffffffffea805938 <mutex_release>
ffffffffea810058:	f9404bb3 	ldr	x19, [x29, #144]
ffffffffea81005c:	17ffff6b 	b	ffffffffea80fe08 <tipc_tx_thread_func+0x88>
ffffffffea810060:	93437ea0 	sbfx	x0, x21, #3, #29
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea810064:	52800021 	mov	w1, #0x1                   	// #1
ffffffffea810068:	927ee800 	and	x0, x0, #0x1ffffffffffffffc
ffffffffea81006c:	1ad52021 	lsl	w1, w1, w21
ffffffffea810070:	8b000280 	add	x0, x20, x0
ffffffffea810074:	d2822d02 	mov	x2, #0x1168                	// #4456
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea810078:	2a2103e1 	mvn	w1, w1
ffffffffea81007c:	8b020000 	add	x0, x0, x2
ffffffffea810080:	885f7c02 	ldxr	w2, [x0]
ffffffffea810084:	0a010042 	and	w2, w2, w1
ffffffffea810088:	88037c02 	stxr	w3, w2, [x0]
ffffffffea81008c:	35ffffa3 	cbnz	w3, ffffffffea810080 <tipc_tx_thread_func+0x300>
ffffffffea810090:	d37c7ea1 	ubfiz	x1, x21, #4, #32
ffffffffea810094:	aa1603e0 	mov	x0, x22
ffffffffea810098:	8b010281 	add	x1, x20, x1
		dev->epts[slot].remote = 0;
ffffffffea81009c:	b901683f 	str	wzr, [x1, #360]
		dev->epts[slot].chan = NULL;
ffffffffea8100a0:	f900b83f 	str	xzr, [x1, #368]
	mutex_release(&dev->ept_lock);
ffffffffea8100a4:	97ffd625 	bl	ffffffffea805938 <mutex_release>
ffffffffea8100a8:	17ffffc7 	b	ffffffffea80ffc4 <tipc_tx_thread_func+0x244>
			panic ("%s: failed (%d) to get message\n",
ffffffffea8100ac:	2a0003e3 	mov	w3, w0
ffffffffea8100b0:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8100b4:	90000042 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8100b8:	90000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8100bc:	910de042 	add	x2, x2, #0x378
ffffffffea8100c0:	9110e021 	add	x1, x1, #0x438
ffffffffea8100c4:	9400092f 	bl	ffffffffea812580 <_panic>
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea8100c8:	2a0003e3 	mov	w3, w0
ffffffffea8100cc:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea8100d0:	90000042 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8100d4:	90000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8100d8:	910e2042 	add	x2, x2, #0x388
ffffffffea8100dc:	91102021 	add	x1, x1, #0x408
ffffffffea8100e0:	94000928 	bl	ffffffffea812580 <_panic>
ffffffffea8100e4:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8100e8:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8100ec:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8100f0:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea8100f4:	a90573bb 	stp	x27, x28, [x29, #80]
}
ffffffffea8100f8:	94000f0c 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8100fc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810100 <create_tipc_device>:
};

status_t create_tipc_device(const struct tipc_vdev_descr *descr, size_t size,
                            const uuid_t *uuid, uint32_t guest,
                            struct tipc_dev **dev_ptr)
{
ffffffffea810100:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea810104:	910003fd 	mov	x29, sp
ffffffffea810108:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea81010c:	2a0303f4 	mov	w20, w3
ffffffffea810110:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea810114:	aa0403f5 	mov	x21, x4
ffffffffea810118:	f9001ff8 	str	x24, [sp, #56]
ffffffffea81011c:	aa0003f7 	mov	x23, x0
ffffffffea810120:	aa0103f6 	mov	x22, x1

	DEBUG_ASSERT(uuid);
	DEBUG_ASSERT(descr);
	DEBUG_ASSERT(size);

	dev = calloc(1, sizeof(*dev));
ffffffffea810124:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea810128:	d2824b01 	mov	x1, #0x1258                	// #4696
{
ffffffffea81012c:	aa0203f8 	mov	x24, x2
	dev = calloc(1, sizeof(*dev));
ffffffffea810130:	94000f14 	bl	ffffffffea813d80 <calloc>
	if (!dev) {
ffffffffea810134:	b4000640 	cbz	x0, ffffffffea8101fc <create_tipc_device+0xfc>
ffffffffea810138:	f9000bb3 	str	x19, [x29, #16]
ffffffffea81013c:	aa0003f3 	mov	x19, x0
		return ERR_NO_MEMORY;
	}
	mutex_init(&dev->ept_lock);
ffffffffea810140:	d2824100 	mov	x0, #0x1208                	// #4616
ffffffffea810144:	8b000260 	add	x0, x19, x0
ffffffffea810148:	97ffd5c4 	bl	ffffffffea805858 <mutex_init>
	dev->vd.ops = &_tipc_dev_ops;
	dev->uuid = uuid;
	dev->guest = guest;
	dev->descr_ptr = descr;
	dev->descr_size = size;
	handle_list_init(&dev->handle_list);
ffffffffea81014c:	d2823701 	mov	x1, #0x11b8                	// #4536
ffffffffea810150:	8b010260 	add	x0, x19, x1
	dev->vd.ops = &_tipc_dev_ops;
ffffffffea810154:	b0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea810158:	913ae021 	add	x1, x1, #0xeb8
ffffffffea81015c:	f9001261 	str	x1, [x19, #32]
	dev->guest = guest;
ffffffffea810160:	b9002a74 	str	w20, [x19, #40]
	dev->descr_ptr = descr;
ffffffffea810164:	a9035e78 	stp	x24, x23, [x19, #48]
	dev->descr_size = size;
ffffffffea810168:	f9002276 	str	x22, [x19, #64]
	handle_list_init(&dev->handle_list);
ffffffffea81016c:	97ffe8cf 	bl	ffffffffea80a4a8 <handle_list_init>
	event_init(&dev->have_handles, false, EVENT_FLAG_AUTOUNSIGNAL);
ffffffffea810170:	d2823103 	mov	x3, #0x1188                	// #4488
ffffffffea810174:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea810178:	8b030260 	add	x0, x19, x3
ffffffffea81017c:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea810180:	97ffd512 	bl	ffffffffea8055c8 <event_init>

	ret = virtio_register_device(&dev->vd, guest);
ffffffffea810184:	2a1403e1 	mov	w1, w20
ffffffffea810188:	aa1303e0 	mov	x0, x19
ffffffffea81018c:	97fff9cd 	bl	ffffffffea80e8c0 <virtio_register_device>
ffffffffea810190:	2a0003f4 	mov	w20, w0
	if (ret != NO_ERROR) {
ffffffffea810194:	35000140 	cbnz	w0, ffffffffea8101bc <create_tipc_device+0xbc>
		goto err_register;
	}
	if (dev_ptr) {
ffffffffea810198:	b4000255 	cbz	x21, ffffffffea8101e0 <create_tipc_device+0xe0>
		*dev_ptr = dev;
ffffffffea81019c:	f90002b3 	str	x19, [x21]
ffffffffea8101a0:	f9400bb3 	ldr	x19, [x29, #16]
	return NO_ERROR;

err_register:
	free(dev);
	return ret;
}
ffffffffea8101a4:	2a1403e0 	mov	w0, w20
ffffffffea8101a8:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8101ac:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8101b0:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8101b4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8101b8:	d65f03c0 	ret
	free(dev);
ffffffffea8101bc:	aa1303e0 	mov	x0, x19
ffffffffea8101c0:	94000f00 	bl	ffffffffea813dc0 <free>
}
ffffffffea8101c4:	2a1403e0 	mov	w0, w20
	return ret;
ffffffffea8101c8:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8101cc:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8101d0:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8101d4:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8101d8:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8101dc:	d65f03c0 	ret
ffffffffea8101e0:	2a1403e0 	mov	w0, w20
ffffffffea8101e4:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea8101e8:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea8101ec:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea8101f0:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea8101f4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8101f8:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea8101fc:	12800094 	mov	w20, #0xfffffffb            	// #-5
ffffffffea810200:	17ffffe9 	b	ffffffffea8101a4 <create_tipc_device+0xa4>
ffffffffea810204:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810208 <dev_connect>:
	return err;
}

static int dev_connect(struct ql_tipc_dev *dev, void *ns_payload,
                       size_t ns_payload_len)
{
ffffffffea810208:	a9a97bfd 	stp	x29, x30, [sp, #-368]!
	struct {
		struct tipc_connect_req hdr;
		uint8_t body[TIPC_MAX_SRV_NAME_LEN + 1];
	} req;

	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea81020c:	f100405f 	cmp	x2, #0x10
{
ffffffffea810210:	910003fd 	mov	x29, sp
ffffffffea810214:	f90013f5 	str	x21, [sp, #32]
ffffffffea810218:	d0000295 	adrp	x21, ffffffffea862000 <__ctor_list>
ffffffffea81021c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810220:	aa0003f3 	mov	x19, x0
ffffffffea810224:	f9402aa0 	ldr	x0, [x21, #80]
ffffffffea810228:	f9001bf7 	str	x23, [sp, #48]
ffffffffea81022c:	f9400003 	ldr	x3, [x0]
ffffffffea810230:	f900b7a3 	str	x3, [x29, #360]
ffffffffea810234:	d2800003 	mov	x3, #0x0                   	// #0
	handle_t *chan = NULL;
ffffffffea810238:	f90027bf 	str	xzr, [x29, #72]
	struct tipc_cmd_hdr *ns_hdr = dev->ns_va;
ffffffffea81023c:	f9403a77 	ldr	x23, [x19, #112]
	if (ns_payload_len <= sizeof(req.hdr))
ffffffffea810240:	54000a29 	b.ls	ffffffffea810384 <dev_connect+0x17c>  // b.plast
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	if (ns_payload_len >= sizeof(req))
ffffffffea810244:	f1045c5f 	cmp	x2, #0x117
ffffffffea810248:	540009e8 	b.hi	ffffffffea810384 <dev_connect+0x17c>  // b.pmore
ffffffffea81024c:	f90017b6 	str	x22, [x29, #40]
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);

	/* copy out and zero terminate */
	memcpy(&req, ns_payload, ns_payload_len);
ffffffffea810250:	910143b6 	add	x22, x29, #0x50
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea810254:	d1004054 	sub	x20, x2, #0x10
	memcpy(&req, ns_payload, ns_payload_len);
ffffffffea810258:	aa1603e0 	mov	x0, x22
ffffffffea81025c:	94000edb 	bl	ffffffffea813dc8 <memcpy>

	/* open ipc channel */
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea810260:	b9407a60 	ldr	w0, [x19, #120]
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea810264:	910183a6 	add	x6, x29, #0x60
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea810268:	f9404261 	ldr	x1, [x19, #128]
ffffffffea81026c:	aa1403e3 	mov	x3, x20
ffffffffea810270:	910123a5 	add	x5, x29, #0x48
ffffffffea810274:	52800004 	mov	w4, #0x0                   	// #0
	req.body[ns_payload_len - sizeof(req.hdr)] = 0;
ffffffffea810278:	383468df 	strb	wzr, [x6, x20]
	rc = ipc_port_connect_async(dev->guest, dev->uuid, (const char *)req.body,
ffffffffea81027c:	910042c2 	add	x2, x22, #0x10
ffffffffea810280:	97ffefc8 	bl	ffffffffea80c1a0 <ipc_port_connect_async>
ffffffffea810284:	2a0003f4 	mov	w20, w0
				    ns_payload_len - sizeof(req.hdr), 0, &chan);
	if (rc != NO_ERROR) {
ffffffffea810288:	34000280 	cbz	w0, ffffffffea8102d8 <dev_connect+0xd0>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea81028c:	531f7c01 	lsr	w1, w0, #31
		LTRACEF("failed to open ipc channel: %d\n", rc);
		return set_status(dev, opcode, rc, 0);
ffffffffea810290:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810294:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea810298:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea81029c:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8102a0:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea8102a4:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, rc, 0);
ffffffffea8102a8:	f94017b6 	ldr	x22, [x29, #40]
	handle_set_cookie(chan, ept_lookup(dev, local));
	handle_list_add(&dev->handle_list, chan);
	ns_hdr->handle = local;

	return set_status(dev, opcode, 0, 0);
}
ffffffffea8102ac:	f9402ab5 	ldr	x21, [x21, #80]
ffffffffea8102b0:	2a1403e0 	mov	w0, w20
ffffffffea8102b4:	f940b7a2 	ldr	x2, [x29, #360]
ffffffffea8102b8:	f94002a1 	ldr	x1, [x21]
ffffffffea8102bc:	ca010041 	eor	x1, x2, x1
ffffffffea8102c0:	b50008a1 	cbnz	x1, ffffffffea8103d4 <dev_connect+0x1cc>
ffffffffea8102c4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8102c8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8102cc:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea8102d0:	a8d77bfd 	ldp	x29, x30, [sp], #368
ffffffffea8102d4:	d65f03c0 	ret
		if (bitmap[i] == ~0UL)
ffffffffea8102d8:	f9404661 	ldr	x1, [x19, #136]
	int slot = bitmap_ffz(dev->inuse, QL_TIPC_ADDR_MAX_NUM);
ffffffffea8102dc:	91022263 	add	x3, x19, #0x88
	local = alloc_local_addr(dev, chan, req.hdr.cookie);
ffffffffea8102e0:	a9449ba0 	ldp	x0, x6, [x29, #72]
ffffffffea8102e4:	b100043f 	cmn	x1, #0x1
ffffffffea8102e8:	540005e0 	b.eq	ffffffffea8103a4 <dev_connect+0x19c>  // b.none
	return __builtin_ffsl(~x) - 1;
ffffffffea8102ec:	aa2103e2 	mvn	x2, x1
ffffffffea8102f0:	dac00041 	rbit	x1, x2
ffffffffea8102f4:	f100005f 	cmp	x2, #0x0
ffffffffea8102f8:	dac01021 	clz	x1, x1
ffffffffea8102fc:	9a8107e1 	csinc	x1, xzr, x1, eq  // eq = none
ffffffffea810300:	51000424 	sub	w4, w1, #0x1
		if (bit < numbits)
ffffffffea810304:	71007c9f 	cmp	w4, #0x1f
ffffffffea810308:	540004ec 	b.gt	ffffffffea8103a4 <dev_connect+0x19c>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea81030c:	52800022 	mov	w2, #0x1                   	// #1
ffffffffea810310:	1ac42042 	lsl	w2, w2, w4
    return __atomic_fetch_or(ptr, val, __ATOMIC_RELAXED);
ffffffffea810314:	885f7c65 	ldxr	w5, [x3]
ffffffffea810318:	2a0200a5 	orr	w5, w5, w2
ffffffffea81031c:	88077c65 	stxr	w7, w5, [x3]
ffffffffea810320:	35ffffa7 	cbnz	w7, ffffffffea810314 <dev_connect+0x10c>
ffffffffea810324:	8b21d263 	add	x3, x19, w1, sxtw #4
	return NULL;
ffffffffea810328:	d37c7c82 	ubfiz	x2, x4, #4, #32
	handle_set_cookie(chan, ept_lookup(dev, local));
ffffffffea81032c:	f94027a5 	ldr	x5, [x29, #72]
	return NULL;
ffffffffea810330:	91024042 	add	x2, x2, #0x90
ffffffffea810334:	8b020262 	add	x2, x19, x2
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea810338:	11007c36 	add	w22, w1, #0x1f
		dev->epts[slot].cookie = cookie;
ffffffffea81033c:	a9081860 	stp	x0, x6, [x3, #128]
	handle_list_add(&dev->handle_list, chan);
ffffffffea810340:	aa0503e1 	mov	x1, x5
ffffffffea810344:	91004260 	add	x0, x19, #0x10
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea810348:	f9404663 	ldr	x3, [x19, #136]
ffffffffea81034c:	9ac42463 	lsr	x3, x3, x4
	return NULL;
ffffffffea810350:	f240007f 	tst	x3, #0x1
ffffffffea810354:	9a9f1042 	csel	x2, x2, xzr, ne  // ne = any
ffffffffea810358:	f90018a2 	str	x2, [x5, #48]
	handle_list_add(&dev->handle_list, chan);
ffffffffea81035c:	97ffe861 	bl	ffffffffea80a4e0 <handle_list_add>
	return set_status(dev, opcode, 0, 0);
ffffffffea810360:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810364:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
	ns_hdr->handle = local;
ffffffffea810368:	b9000af6 	str	w22, [x23, #8]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81036c:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810370:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810374:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810378:	d5033abf 	dmb	ishst
ffffffffea81037c:	f94017b6 	ldr	x22, [x29, #40]
	return set_status(dev, opcode, 0, 0);
ffffffffea810380:	17ffffcb 	b	ffffffffea8102ac <dev_connect+0xa4>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810384:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810388:	128fffc1 	mov	w1, #0xffff8001            	// #-32767
ffffffffea81038c:	790002e1 	strh	w1, [x23]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810390:	b90006e0 	str	w0, [x23, #4]
	ns_hdr->payload_len = len;
ffffffffea810394:	b9000eff 	str	wzr, [x23, #12]
	smp_wmb();
ffffffffea810398:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea81039c:	128000f4 	mov	w20, #0xfffffff8            	// #-8
ffffffffea8103a0:	17ffffc3 	b	ffffffffea8102ac <dev_connect+0xa4>
		handle_close(chan);
ffffffffea8103a4:	97ffe7cd 	bl	ffffffffea80a2d8 <handle_close>
		chan = NULL;
ffffffffea8103a8:	f90027bf 	str	xzr, [x29, #72]
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea8103ac:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103b0:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8103b4:	128fffc2 	mov	w2, #0xffff8001            	// #-32767
ffffffffea8103b8:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8103bc:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8103c0:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea8103c4:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_NO_RESOURCES, 0);
ffffffffea8103c8:	12800514 	mov	w20, #0xffffffd7            	// #-41
ffffffffea8103cc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8103d0:	17ffffb7 	b	ffffffffea8102ac <dev_connect+0xa4>
ffffffffea8103d4:	f90017b6 	str	x22, [x29, #40]
}
ffffffffea8103d8:	94000e54 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8103dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8103e0 <ql_tipc_create_device>:
	}
}

long ql_tipc_create_device(ns_addr_t buf_pa, ns_size_t buf_sz,
                           uint buf_mmu_flags)
{
ffffffffea8103e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea8103e4:	910003fd 	mov	x29, sp
ffffffffea8103e8:	f90017f6 	str	x22, [sp, #40]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea8103ec:	b0000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea8103f0:	913bc2c5 	add	x5, x22, #0xef0
ffffffffea8103f4:	f94004a3 	ldr	x3, [x5, #8]
ffffffffea8103f8:	eb05007f 	cmp	x3, x5
ffffffffea8103fc:	540000a1 	b.ne	ffffffffea810410 <ql_tipc_create_device+0x30>  // b.any
ffffffffea810400:	1400000b 	b	ffffffffea81042c <ql_tipc_create_device+0x4c>
ffffffffea810404:	f9400463 	ldr	x3, [x3, #8]
ffffffffea810408:	eb05007f 	cmp	x3, x5
ffffffffea81040c:	54000100 	b.eq	ffffffffea81042c <ql_tipc_create_device+0x4c>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea810410:	f9403464 	ldr	x4, [x3, #104]
ffffffffea810414:	eb04001f 	cmp	x0, x4
ffffffffea810418:	54ffff61 	b.ne	ffffffffea810404 <ql_tipc_create_device+0x24>  // b.any
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea81041c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
	return dev_create(buf_pa, buf_sz, buf_mmu_flags);
}
ffffffffea810420:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea810424:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea810428:	d65f03c0 	ret
	if (!buf_sz) {
ffffffffea81042c:	f2402c1f 	tst	x0, #0xfff
ffffffffea810430:	7a400824 	ccmp	w1, #0x0, #0x4, eq  // eq = none
ffffffffea810434:	54ffff40 	b.eq	ffffffffea81041c <ql_tipc_create_device+0x3c>  // b.none
ffffffffea810438:	f90023b9 	str	x25, [x29, #64]
	if (buf_sz & (PAGE_SIZE-1)) {
ffffffffea81043c:	f2402c3f 	tst	x1, #0xfff
ffffffffea810440:	2a0103f9 	mov	w25, w1
ffffffffea810444:	54000841 	b.ne	ffffffffea81054c <ql_tipc_create_device+0x16c>  // b.any
ffffffffea810448:	f9001fb8 	str	x24, [x29, #56]
	if (_dev_cnt >= QL_TIPC_DEV_MAX_NUM) {
ffffffffea81044c:	d0000318 	adrp	x24, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea810450:	b94f3f03 	ldr	w3, [x24, #3900]
ffffffffea810454:	7100047f 	cmp	w3, #0x1
ffffffffea810458:	54000648 	b.hi	ffffffffea810520 <ql_tipc_create_device+0x140>  // b.pmore
ffffffffea81045c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea810460:	aa0003f3 	mov	x19, x0
ffffffffea810464:	f90013b5 	str	x21, [x29, #32]
	dev = calloc(1, sizeof(*dev));
ffffffffea810468:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea81046c:	f9001bb7 	str	x23, [x29, #48]
ffffffffea810470:	2a0103f5 	mov	w21, w1
ffffffffea810474:	2a0203f7 	mov	w23, w2
ffffffffea810478:	d2805201 	mov	x1, #0x290                 	// #656
ffffffffea81047c:	94000e41 	bl	ffffffffea813d80 <calloc>
ffffffffea810480:	aa0003f4 	mov	x20, x0
	if (!dev) {
ffffffffea810484:	b4000580 	cbz	x0, ffffffffea810534 <ql_tipc_create_device+0x154>
	dev->uuid = &zero_uuid;
ffffffffea810488:	d0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
	item->prev = item->next = 0;
ffffffffea81048c:	f900041f 	str	xzr, [x0, #8]
	dev->guest = 0;
ffffffffea810490:	b900781f 	str	wzr, [x0, #120]
	dev->uuid = &zero_uuid;
ffffffffea810494:	f9405421 	ldr	x1, [x1, #168]
ffffffffea810498:	f9004001 	str	x1, [x0, #128]
ffffffffea81049c:	f801041f 	str	xzr, [x0], #16
	handle_list_init(&dev->handle_list);
ffffffffea8104a0:	97ffe802 	bl	ffffffffea80a4a8 <handle_list_init>
	dev->ns_sz = buf_sz;
ffffffffea8104a4:	290c5697 	stp	w23, w21, [x20, #96]
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea8104a8:	d0000280 	adrp	x0, ffffffffea862000 <__ctor_list>
	                         ROUNDUP(buf_sz, PAGE_SIZE),
ffffffffea8104ac:	913fff22 	add	x2, x25, #0xfff
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea8104b0:	90000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8104b4:	2a1703e7 	mov	w7, w23
ffffffffea8104b8:	f9408400 	ldr	x0, [x0, #264]
ffffffffea8104bc:	52800006 	mov	w6, #0x0                   	// #0
ffffffffea8104c0:	aa1303e5 	mov	x5, x19
ffffffffea8104c4:	52800184 	mov	w4, #0xc                   	// #12
ffffffffea8104c8:	9101c283 	add	x3, x20, #0x70
ffffffffea8104cc:	92745042 	and	x2, x2, #0x1fffff000
ffffffffea8104d0:	91140021 	add	x1, x1, #0x500
	dev->ns_pa = buf_pa;
ffffffffea8104d4:	f9003693 	str	x19, [x20, #104]
	res = vmm_alloc_physical(vmm_get_kernel_aspace(), "tipc",
ffffffffea8104d8:	940005c8 	bl	ffffffffea811bf8 <vmm_alloc_physical>
	if (res != NO_ERROR) {
ffffffffea8104dc:	35000280 	cbnz	w0, ffffffffea81052c <ql_tipc_create_device+0x14c>
	item->next = list->next;
ffffffffea8104e0:	913bc2d6 	add	x22, x22, #0xef0
	_dev_cnt++;
ffffffffea8104e4:	b94f3f01 	ldr	w1, [x24, #3900]
ffffffffea8104e8:	f94013b5 	ldr	x21, [x29, #32]
	return 0;
ffffffffea8104ec:	d2800000 	mov	x0, #0x0                   	// #0
	_dev_cnt++;
ffffffffea8104f0:	11000421 	add	w1, w1, #0x1
ffffffffea8104f4:	b90f3f01 	str	w1, [x24, #3900]
ffffffffea8104f8:	f94006c1 	ldr	x1, [x22, #8]
ffffffffea8104fc:	a9000696 	stp	x22, x1, [x20]
ffffffffea810500:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea810504:	f94023b9 	ldr	x25, [x29, #64]
	list->next->prev = item;
ffffffffea810508:	f9000034 	str	x20, [x1]
	list->next = item;
ffffffffea81050c:	f90006d4 	str	x20, [x22, #8]
ffffffffea810510:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea810514:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea810518:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea81051c:	d65f03c0 	ret
		return SM_ERR_NOT_ALLOWED;
ffffffffea810520:	92800100 	mov	x0, #0xfffffffffffffff7    	// #-9
ffffffffea810524:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea810528:	17ffffbe 	b	ffffffffea810420 <ql_tipc_create_device+0x40>
		free(dev);
ffffffffea81052c:	aa1403e0 	mov	x0, x20
ffffffffea810530:	94000e24 	bl	ffffffffea813dc0 <free>
		return SM_ERR_INTERNAL_FAILURE;
ffffffffea810534:	928000c0 	mov	x0, #0xfffffffffffffff9    	// #-7
ffffffffea810538:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea81053c:	a94153b3 	ldp	x19, x20, [x29, #16]
ffffffffea810540:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea810544:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea810548:	17ffffb6 	b	ffffffffea810420 <ql_tipc_create_device+0x40>
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea81054c:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea810550:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea810554:	17ffffb3 	b	ffffffffea810420 <ql_tipc_create_device+0x40>

ffffffffea810558 <ql_tipc_shutdown_device>:

long ql_tipc_shutdown_device(ns_addr_t buf_pa)
{
ffffffffea810558:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea81055c:	b0000041 	adrp	x1, ffffffffea819000 <_mem_phys_base>
ffffffffea810560:	913bc021 	add	x1, x1, #0xef0
{
ffffffffea810564:	910003fd 	mov	x29, sp
ffffffffea810568:	f90013f5 	str	x21, [sp, #32]
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea81056c:	f9400435 	ldr	x21, [x1, #8]
ffffffffea810570:	eb0102bf 	cmp	x21, x1
ffffffffea810574:	540007a0 	b.eq	ffffffffea810668 <ql_tipc_shutdown_device+0x110>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea810578:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea81057c:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea810580:	f90017b6 	str	x22, [x29, #40]
ffffffffea810584:	eb02001f 	cmp	x0, x2
ffffffffea810588:	540000a1 	b.ne	ffffffffea81059c <ql_tipc_shutdown_device+0x44>  // b.any
ffffffffea81058c:	1400000d 	b	ffffffffea8105c0 <ql_tipc_shutdown_device+0x68>
ffffffffea810590:	f94036a2 	ldr	x2, [x21, #104]
ffffffffea810594:	eb02001f 	cmp	x0, x2
ffffffffea810598:	54000140 	b.eq	ffffffffea8105c0 <ql_tipc_shutdown_device+0x68>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea81059c:	f94006b5 	ldr	x21, [x21, #8]
ffffffffea8105a0:	eb0102bf 	cmp	x21, x1
ffffffffea8105a4:	54ffff61 	b.ne	ffffffffea810590 <ql_tipc_shutdown_device+0x38>  // b.any
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8105a8:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea8105ac:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8105b0:	a94153b3 	ldp	x19, x20, [x29, #16]
	}
	dev_shutdown(dev);
	return 0;
}
ffffffffea8105b4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8105b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8105bc:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea8105c0:	a9400ea2 	ldp	x2, x3, [x21]
	_dev_cnt--;
ffffffffea8105c4:	d0000304 	adrp	x4, ffffffffea872000 <idle_threads+0xeb0>
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea8105c8:	f9403aa1 	ldr	x1, [x21, #112]
ffffffffea8105cc:	d0000280 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea8105d0:	910242b4 	add	x20, x21, #0x90
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea8105d4:	910042b6 	add	x22, x21, #0x10
ffffffffea8105d8:	f9000062 	str	x2, [x3]
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea8105dc:	52800013 	mov	w19, #0x0                   	// #0
	_dev_cnt--;
ffffffffea8105e0:	b94f3c82 	ldr	w2, [x4, #3900]
	item->prev->next = item->next;
ffffffffea8105e4:	f94002a5 	ldr	x5, [x21]
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea8105e8:	f9408400 	ldr	x0, [x0, #264]
	_dev_cnt--;
ffffffffea8105ec:	51000442 	sub	w2, w2, #0x1
ffffffffea8105f0:	b90f3c82 	str	w2, [x4, #3900]
ffffffffea8105f4:	f90004a3 	str	x3, [x5, #8]
	item->prev = item->next = 0;
ffffffffea8105f8:	a9007ebf 	stp	xzr, xzr, [x21]
	vmm_free_region(vmm_get_kernel_aspace(), (vaddr_t)dev->ns_va);
ffffffffea8105fc:	940005e1 	bl	ffffffffea811d80 <vmm_free_region>
	dev->ns_va = NULL;
ffffffffea810600:	f9003abf 	str	xzr, [x21, #112]
ffffffffea810604:	d503201f 	nop
ffffffffea810608:	f94046a1 	ldr	x1, [x21, #136]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea81060c:	aa1603e0 	mov	x0, x22
ffffffffea810610:	9ad32421 	lsr	x1, x1, x19
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea810614:	11000673 	add	w19, w19, #0x1
		if (!bitmap_test(dev->inuse, slot))
ffffffffea810618:	36000121 	tbz	w1, #0, ffffffffea81063c <ql_tipc_shutdown_device+0xe4>
		if (!ept->chan)
ffffffffea81061c:	f9400282 	ldr	x2, [x20]
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea810620:	aa0203e1 	mov	x1, x2
		if (!ept->chan)
ffffffffea810624:	b40000c2 	cbz	x2, ffffffffea81063c <ql_tipc_shutdown_device+0xe4>
		handle_list_del(&dev->handle_list, ept->chan);
ffffffffea810628:	97ffe7d8 	bl	ffffffffea80a588 <handle_list_del>
		handle_set_cookie(ept->chan, NULL);
ffffffffea81062c:	f9400281 	ldr	x1, [x20]
		handle_close(ept->chan);
ffffffffea810630:	aa0103e0 	mov	x0, x1
ffffffffea810634:	f900183f 	str	xzr, [x1, #48]
ffffffffea810638:	97ffe728 	bl	ffffffffea80a2d8 <handle_close>
ffffffffea81063c:	91004294 	add	x20, x20, #0x10
	for (uint slot = 0; slot < countof(dev->epts); slot++) {
ffffffffea810640:	7100827f 	cmp	w19, #0x20
ffffffffea810644:	54fffe21 	b.ne	ffffffffea810608 <ql_tipc_shutdown_device+0xb0>  // b.any
	free(dev);
ffffffffea810648:	aa1503e0 	mov	x0, x21
ffffffffea81064c:	94000ddd 	bl	ffffffffea813dc0 <free>
ffffffffea810650:	a94153b3 	ldp	x19, x20, [x29, #16]
	return 0;
ffffffffea810654:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea810658:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea81065c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea810660:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea810664:	d65f03c0 	ret
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea810668:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea81066c:	17fffffc 	b	ffffffffea81065c <ql_tipc_shutdown_device+0x104>

ffffffffea810670 <ql_tipc_handle_cmd>:

long ql_tipc_handle_cmd(ns_addr_t buf_pa, ns_size_t cmd_sz)
{
ffffffffea810670:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea810674:	b0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea810678:	913bc042 	add	x2, x2, #0xef0
{
ffffffffea81067c:	910003fd 	mov	x29, sp
ffffffffea810680:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810684:	2a0103f4 	mov	w20, w1
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea810688:	f9400453 	ldr	x19, [x2, #8]
{
ffffffffea81068c:	f90013f5 	str	x21, [sp, #32]
ffffffffea810690:	d0000295 	adrp	x21, ffffffffea862000 <__ctor_list>
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea810694:	eb02027f 	cmp	x19, x2
{
ffffffffea810698:	f9402aa3 	ldr	x3, [x21, #80]
ffffffffea81069c:	f9400061 	ldr	x1, [x3]
ffffffffea8106a0:	f9004fa1 	str	x1, [x29, #152]
ffffffffea8106a4:	d2800001 	mov	x1, #0x0                   	// #0
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea8106a8:	540001e0 	b.eq	ffffffffea8106e4 <ql_tipc_handle_cmd+0x74>  // b.none
		if(dev->ns_pa == buf_pa) {
ffffffffea8106ac:	f9403661 	ldr	x1, [x19, #104]
ffffffffea8106b0:	f90017b6 	str	x22, [x29, #40]
ffffffffea8106b4:	aa1e03f6 	mov	x22, x30
ffffffffea8106b8:	eb01001f 	cmp	x0, x1
ffffffffea8106bc:	54000280 	b.eq	ffffffffea81070c <ql_tipc_handle_cmd+0x9c>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea8106c0:	aa0203e1 	mov	x1, x2
ffffffffea8106c4:	14000004 	b	ffffffffea8106d4 <ql_tipc_handle_cmd+0x64>
		if(dev->ns_pa == buf_pa) {
ffffffffea8106c8:	f9403662 	ldr	x2, [x19, #104]
ffffffffea8106cc:	eb02001f 	cmp	x0, x2
ffffffffea8106d0:	540001e0 	b.eq	ffffffffea81070c <ql_tipc_handle_cmd+0x9c>  // b.none
	list_for_every_entry(&_dev_list, dev, struct ql_tipc_dev, node) {
ffffffffea8106d4:	f9400673 	ldr	x19, [x19, #8]
ffffffffea8106d8:	eb01027f 	cmp	x19, x1
ffffffffea8106dc:	54ffff61 	b.ne	ffffffffea8106c8 <ql_tipc_handle_cmd+0x58>  // b.any
ffffffffea8106e0:	f94017b6 	ldr	x22, [x29, #40]

	/* lookup device */
	struct ql_tipc_dev *dev = dev_lookup(buf_pa);
	if (!dev) {
		LTRACEF("0x%llx: device not found\n", buf_pa);
		return SM_ERR_INVALID_PARAMETERS;
ffffffffea8106e4:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
		LTRACEF("malformed command\n");
		return SM_ERR_INVALID_PARAMETERS;
	}

	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
}
ffffffffea8106e8:	f9402ab5 	ldr	x21, [x21, #80]
ffffffffea8106ec:	f9404fa2 	ldr	x2, [x29, #152]
ffffffffea8106f0:	f94002a1 	ldr	x1, [x21]
ffffffffea8106f4:	ca010041 	eor	x1, x2, x1
ffffffffea8106f8:	b50023c1 	cbnz	x1, ffffffffea810b70 <ql_tipc_handle_cmd+0x500>
ffffffffea8106fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810700:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea810704:	a8ca7bfd 	ldp	x29, x30, [sp], #160
ffffffffea810708:	d65f03c0 	ret
	if (cmd_sz < sizeof(cmd_hdr)) {
ffffffffea81070c:	71003e9f 	cmp	w20, #0xf
ffffffffea810710:	54fffe89 	b.ls	ffffffffea8106e0 <ql_tipc_handle_cmd+0x70>  // b.plast
	memcpy(&cmd_hdr, dev->ns_va, sizeof(cmd_hdr));
ffffffffea810714:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea810718:	d2800202 	mov	x2, #0x10                  	// #16
ffffffffea81071c:	910123a0 	add	x0, x29, #0x48
	if (cmd_hdr.payload_len != (cmd_sz - sizeof(cmd_hdr))) {
ffffffffea810720:	d1004294 	sub	x20, x20, #0x10
	memcpy(&cmd_hdr, dev->ns_va, sizeof(cmd_hdr));
ffffffffea810724:	94000da9 	bl	ffffffffea813dc8 <memcpy>
	if (cmd_hdr.payload_len != (cmd_sz - sizeof(cmd_hdr))) {
ffffffffea810728:	b94057a3 	ldr	w3, [x29, #84]
ffffffffea81072c:	2a0303e2 	mov	w2, w3
ffffffffea810730:	eb14005f 	cmp	x2, x20
ffffffffea810734:	54fffd61 	b.ne	ffffffffea8106e0 <ql_tipc_handle_cmd+0x70>  // b.any
	switch (cmd->opcode) {
ffffffffea810738:	794093a0 	ldrh	w0, [x29, #72]
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea81073c:	f9403a74 	ldr	x20, [x19, #112]
	switch (cmd->opcode) {
ffffffffea810740:	71000c1f 	cmp	w0, #0x3
	return dev_handle_cmd(dev, &cmd_hdr, dev->ns_va + sizeof(cmd_hdr));
ffffffffea810744:	91004281 	add	x1, x20, #0x10
	switch (cmd->opcode) {
ffffffffea810748:	54000f80 	b.eq	ffffffffea810938 <ql_tipc_handle_cmd+0x2c8>  // b.none
ffffffffea81074c:	540005c8 	b.hi	ffffffffea810804 <ql_tipc_handle_cmd+0x194>  // b.pmore
ffffffffea810750:	7100041f 	cmp	w0, #0x1
ffffffffea810754:	54000b80 	b.eq	ffffffffea8108c4 <ql_tipc_handle_cmd+0x254>  // b.none
ffffffffea810758:	7100081f 	cmp	w0, #0x2
ffffffffea81075c:	54000a21 	b.ne	ffffffffea8108a0 <ql_tipc_handle_cmd+0x230>  // b.any
ffffffffea810760:	f9001fb8 	str	x24, [x29, #56]
	if (ns_sz < sizeof(req))
ffffffffea810764:	71001c7f 	cmp	w3, #0x7
	uint32_t  chan_event = 0;
ffffffffea810768:	b90043bf 	str	wzr, [x29, #64]
			return dev_get_event(dev, ns_payload, cmd->payload_len, cmd->handle);
ffffffffea81076c:	b94053b8 	ldr	w24, [x29, #80]
	if (ns_sz < sizeof(req))
ffffffffea810770:	54001c49 	b.ls	ffffffffea810af8 <ql_tipc_handle_cmd+0x488>  // b.plast
	if (target) {
ffffffffea810774:	34001738 	cbz	w24, ffffffffea810a58 <ql_tipc_handle_cmd+0x3e8>
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea810778:	51008300 	sub	w0, w24, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea81077c:	71007c1f 	cmp	w0, #0x1f
ffffffffea810780:	54001bc8 	b.hi	ffffffffea810af8 <ql_tipc_handle_cmd+0x488>  // b.pmore
ffffffffea810784:	f9404661 	ldr	x1, [x19, #136]
ffffffffea810788:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea81078c:	36001b61 	tbz	w1, #0, ffffffffea810af8 <ql_tipc_handle_cmd+0x488>
ffffffffea810790:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea810794:	f9001bb7 	str	x23, [x29, #48]
ffffffffea810798:	8b000277 	add	x23, x19, x0
		if (!ept || !ept->chan)
ffffffffea81079c:	f9404ae0 	ldr	x0, [x23, #144]
ffffffffea8107a0:	b4001aa0 	cbz	x0, ffffffffea810af4 <ql_tipc_handle_cmd+0x484>
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea8107a4:	52800002 	mov	w2, #0x0                   	// #0
ffffffffea8107a8:	910103a1 	add	x1, x29, #0x40
		chan = ept->chan;
ffffffffea8107ac:	f9002fa0 	str	x0, [x29, #88]
		rc = handle_wait(chan, &chan_event, 0);
ffffffffea8107b0:	97ffe6d6 	bl	ffffffffea80a308 <handle_wait>
		if (rc == ERR_TIMED_OUT) {
ffffffffea8107b4:	3100341f 	cmn	w0, #0xd
ffffffffea8107b8:	54001800 	b.eq	ffffffffea810ab8 <ql_tipc_handle_cmd+0x448>  // b.none
		else if (rc < 0) {
ffffffffea8107bc:	37f81e20 	tbnz	w0, #31, ffffffffea810b80 <ql_tipc_handle_cmd+0x510>
			evt->cookie = ept->cookie;
ffffffffea8107c0:	f9404ee1 	ldr	x1, [x23, #152]
ffffffffea8107c4:	f9401bb7 	ldr	x23, [x29, #48]
			evt->handle = target;
ffffffffea8107c8:	b9001698 	str	w24, [x20, #20]
			evt->event  = chan_event;
ffffffffea8107cc:	b94043a0 	ldr	w0, [x29, #64]
ffffffffea8107d0:	b9001280 	str	w0, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea8107d4:	f9000e81 	str	x1, [x20, #24]
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea8107d8:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->payload_len = len;
ffffffffea8107dc:	52800201 	mov	w1, #0x10                  	// #16
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8107e0:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea8107e4:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8107e8:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea8107ec:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea8107f0:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, sizeof(*evt));
ffffffffea8107f4:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8107f8:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8107fc:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea810800:	17ffffba 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	switch (cmd->opcode) {
ffffffffea810804:	7100101f 	cmp	w0, #0x4
ffffffffea810808:	54000680 	b.eq	ffffffffea8108d8 <ql_tipc_handle_cmd+0x268>  // b.none
ffffffffea81080c:	7100141f 	cmp	w0, #0x5
ffffffffea810810:	54000481 	b.ne	ffffffffea8108a0 <ql_tipc_handle_cmd+0x230>  // b.any
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea810814:	b94053b4 	ldr	w20, [x29, #80]
ffffffffea810818:	51008294 	sub	w20, w20, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea81081c:	71007e9f 	cmp	w20, #0x1f
ffffffffea810820:	54fff608 	b.hi	ffffffffea8106e0 <ql_tipc_handle_cmd+0x70>  // b.pmore
ffffffffea810824:	f9404660 	ldr	x0, [x19, #136]
ffffffffea810828:	9ad42400 	lsr	x0, x0, x20
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea81082c:	3607f5a0 	tbz	w0, #0, ffffffffea8106e0 <ql_tipc_handle_cmd+0x70>
ffffffffea810830:	d37c7e96 	ubfiz	x22, x20, #4, #32
ffffffffea810834:	8b160276 	add	x22, x19, x22
	if (!ept || !ept->chan)
ffffffffea810838:	f9404ac1 	ldr	x1, [x22, #144]
ffffffffea81083c:	b4fff521 	cbz	x1, ffffffffea8106e0 <ql_tipc_handle_cmd+0x70>
	handle_list_del(&dev->handle_list, ept->chan);
ffffffffea810840:	91004260 	add	x0, x19, #0x10
ffffffffea810844:	97ffe751 	bl	ffffffffea80a588 <handle_list_del>
	handle_set_cookie(ept->chan, NULL);
ffffffffea810848:	f9404ac1 	ldr	x1, [x22, #144]
	handle_close(ept->chan);
ffffffffea81084c:	aa0103e0 	mov	x0, x1
ffffffffea810850:	f900183f 	str	xzr, [x1, #48]
ffffffffea810854:	97ffe6a1 	bl	ffffffffea80a2d8 <handle_close>
	unsigned long mask = 1 << BITMAP_BIT_IN_INT(bit);
ffffffffea810858:	52800020 	mov	w0, #0x1                   	// #1
    return __atomic_fetch_and(ptr, val, __ATOMIC_RELAXED);
ffffffffea81085c:	91022261 	add	x1, x19, #0x88
ffffffffea810860:	1ad42000 	lsl	w0, w0, w20
	return atomic_and(&((int*)bitmap)[BITMAP_INT(bit)], ~mask) & mask ? 1:0;
ffffffffea810864:	2a2003e0 	mvn	w0, w0
ffffffffea810868:	885f7c22 	ldxr	w2, [x1]
ffffffffea81086c:	0a000042 	and	w2, w2, w0
ffffffffea810870:	88037c22 	stxr	w3, w2, [x1]
ffffffffea810874:	35ffffa3 	cbnz	w3, ffffffffea810868 <ql_tipc_handle_cmd+0x1f8>
		dev->epts[slot].cookie = 0;
ffffffffea810878:	a9097edf 	stp	xzr, xzr, [x22, #144]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea81087c:	128fff41 	mov	w1, #0xffff8005            	// #-32763
	return set_status(dev, opcode, 0, 0);
ffffffffea810880:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810884:	79000001 	strh	w1, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810888:	b900041f 	str	wzr, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea81088c:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810890:	d5033abf 	dmb	ishst
	return set_status(dev, opcode, 0, 0);
ffffffffea810894:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea810898:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea81089c:	17ffff93 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8108a0:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea8108a4:	32114000 	orr	w0, w0, #0xffff8000
ffffffffea8108a8:	79000280 	strh	w0, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea8108ac:	b9000681 	str	w1, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea8108b0:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea8108b4:	d5033abf 	dmb	ishst
			return set_status(dev, cmd->opcode, ERR_NOT_SUPPORTED, 0);
ffffffffea8108b8:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
ffffffffea8108bc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8108c0:	17ffff8a 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
			return dev_connect(dev, ns_payload, cmd->payload_len);
ffffffffea8108c4:	aa1303e0 	mov	x0, x19
ffffffffea8108c8:	97fffe50 	bl	ffffffffea810208 <dev_connect>
ffffffffea8108cc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea8108d0:	93407c00 	sxtw	x0, w0
ffffffffea8108d4:	17ffff85 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea8108d8:	b94053a0 	ldr	w0, [x29, #80]
ffffffffea8108dc:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea8108e0:	71007c1f 	cmp	w0, #0x1f
ffffffffea8108e4:	54001028 	b.hi	ffffffffea810ae8 <ql_tipc_handle_cmd+0x478>  // b.pmore
	return BIT_SET(bitmap[BITMAP_WORD(bit)], BITMAP_BIT_IN_WORD(bit));
ffffffffea8108e8:	f9404661 	ldr	x1, [x19, #136]
ffffffffea8108ec:	9ac02421 	lsr	x1, x1, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea8108f0:	36000fc1 	tbz	w1, #0, ffffffffea810ae8 <ql_tipc_handle_cmd+0x478>
ffffffffea8108f4:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea8108f8:	8b000276 	add	x22, x19, x0
	if (!ept || !ept->chan)
ffffffffea8108fc:	f9404ac0 	ldr	x0, [x22, #144]
ffffffffea810900:	b4000f40 	cbz	x0, ffffffffea810ae8 <ql_tipc_handle_cmd+0x478>
	rc = ipc_get_msg(ept->chan, &mi);
ffffffffea810904:	910103a1 	add	x1, x29, #0x40
ffffffffea810908:	97fff21e 	bl	ffffffffea80d180 <ipc_get_msg>
	if (rc < 0)
ffffffffea81090c:	36f804a0 	tbz	w0, #31, ffffffffea8109a0 <ql_tipc_handle_cmd+0x330>
		return set_status(dev, opcode, rc, 0);
ffffffffea810910:	f9403a61 	ldr	x1, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810914:	52800022 	mov	w2, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810918:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea81091c:	79000023 	strh	w3, [x1]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810920:	b9000422 	str	w2, [x1, #4]
	ns_hdr->payload_len = len;
ffffffffea810924:	b9000c3f 	str	wzr, [x1, #12]
	smp_wmb();
ffffffffea810928:	d5033abf 	dmb	ishst
	return err;
ffffffffea81092c:	93407c00 	sxtw	x0, w0
ffffffffea810930:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810934:	17ffff6d 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	return (uint)(addr - QL_TIPC_ADDR_BASE);
ffffffffea810938:	b94053a0 	ldr	w0, [x29, #80]
ffffffffea81093c:	51008000 	sub	w0, w0, #0x20
	if (slot < QL_TIPC_ADDR_MAX_NUM) {
ffffffffea810940:	71007c1f 	cmp	w0, #0x1f
ffffffffea810944:	54000c08 	b.hi	ffffffffea810ac4 <ql_tipc_handle_cmd+0x454>  // b.pmore
ffffffffea810948:	f9404663 	ldr	x3, [x19, #136]
ffffffffea81094c:	9ac02463 	lsr	x3, x3, x0
		if (bitmap_test(dev->inuse, slot)) {
ffffffffea810950:	36000ba3 	tbz	w3, #0, ffffffffea810ac4 <ql_tipc_handle_cmd+0x454>
	if (!ept || !ept->chan)
ffffffffea810954:	d37c7c00 	ubfiz	x0, x0, #4, #32
ffffffffea810958:	91024000 	add	x0, x0, #0x90
ffffffffea81095c:	f8606a60 	ldr	x0, [x19, x0]
ffffffffea810960:	b4000b20 	cbz	x0, ffffffffea810ac4 <ql_tipc_handle_cmd+0x454>
	ipc_msg_kern_t msg = {
ffffffffea810964:	910173a3 	add	x3, x29, #0x5c
		.iov = (iovec_kern_t[]) {
ffffffffea810968:	a9078ba1 	stp	x1, x2, [x29, #120]
	ipc_msg_kern_t msg = {
ffffffffea81096c:	9101e3a2 	add	x2, x29, #0x78
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea810970:	910163a1 	add	x1, x29, #0x58
	ipc_msg_kern_t msg = {
ffffffffea810974:	a9007c7f 	stp	xzr, xzr, [x3]
ffffffffea810978:	52800023 	mov	w3, #0x1                   	// #1
ffffffffea81097c:	b9005ba3 	str	w3, [x29, #88]
ffffffffea810980:	f90033a2 	str	x2, [x29, #96]
ffffffffea810984:	f806c3bf 	stur	xzr, [x29, #108]
ffffffffea810988:	b90077bf 	str	wzr, [x29, #116]
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea81098c:	97fff177 	bl	ffffffffea80cf68 <ipc_send_msg>
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810990:	128fff83 	mov	w3, #0xffff8003            	// #-32765
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810994:	531f7c02 	lsr	w2, w0, #31
	return set_status(dev, opcode, ipc_send_msg(ept->chan, &msg), 0);
ffffffffea810998:	f9403a61 	ldr	x1, [x19, #112]
ffffffffea81099c:	17ffffe0 	b	ffffffffea81091c <ql_tipc_handle_cmd+0x2ac>
	ipc_msg_kern_t msg = {
ffffffffea8109a0:	910173a4 	add	x4, x29, #0x5c
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea8109a4:	b9406662 	ldr	w2, [x19, #100]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea8109a8:	f9404ac0 	ldr	x0, [x22, #144]
ffffffffea8109ac:	b94047a1 	ldr	w1, [x29, #68]
				.len  = dev->ns_sz - sizeof(struct tipc_cmd_hdr),
ffffffffea8109b0:	d1004042 	sub	x2, x2, #0x10
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea8109b4:	f9403a63 	ldr	x3, [x19, #112]
	ipc_msg_kern_t msg = {
ffffffffea8109b8:	a9007c9f 	stp	xzr, xzr, [x4]
ffffffffea8109bc:	52800024 	mov	w4, #0x1                   	// #1
				.base = dev->ns_va + sizeof(struct tipc_cmd_hdr),
ffffffffea8109c0:	91004063 	add	x3, x3, #0x10
		.iov = (iovec_kern_t[]) {
ffffffffea8109c4:	a9088ba3 	stp	x3, x2, [x29, #136]
	ipc_msg_kern_t msg = {
ffffffffea8109c8:	910223a2 	add	x2, x29, #0x88
ffffffffea8109cc:	b9005ba4 	str	w4, [x29, #88]
ffffffffea8109d0:	f90033a2 	str	x2, [x29, #96]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea8109d4:	910163a3 	add	x3, x29, #0x58
	ipc_msg_kern_t msg = {
ffffffffea8109d8:	f806c3bf 	stur	xzr, [x29, #108]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea8109dc:	52800002 	mov	w2, #0x0                   	// #0
	ipc_msg_kern_t msg = {
ffffffffea8109e0:	b90077bf 	str	wzr, [x29, #116]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea8109e4:	97fff2cb 	bl	ffffffffea80d510 <ipc_read_msg>
	ipc_put_msg(ept->chan, mi.id);
ffffffffea8109e8:	b94047a1 	ldr	w1, [x29, #68]
	rc = ipc_read_msg(ept->chan, mi.id, 0, &msg);
ffffffffea8109ec:	2a0003f4 	mov	w20, w0
	ipc_put_msg(ept->chan, mi.id);
ffffffffea8109f0:	f9404ac0 	ldr	x0, [x22, #144]
ffffffffea8109f4:	97fff217 	bl	ffffffffea80d250 <ipc_put_msg>
	if (rc < 0)
ffffffffea8109f8:	37f801d4 	tbnz	w20, #31, ffffffffea810a30 <ql_tipc_handle_cmd+0x3c0>
	if (rc < (int)mi.len)
ffffffffea8109fc:	b94043a1 	ldr	w1, [x29, #64]
ffffffffea810a00:	f9403a60 	ldr	x0, [x19, #112]
ffffffffea810a04:	6b01029f 	cmp	w20, w1
ffffffffea810a08:	540008cb 	b.lt	ffffffffea810b20 <ql_tipc_handle_cmd+0x4b0>  // b.tstop
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810a0c:	531f7e82 	lsr	w2, w20, #31
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810a10:	128fff63 	mov	w3, #0xffff8004            	// #-32764
ffffffffea810a14:	79000003 	strh	w3, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810a18:	b9000402 	str	w2, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810a1c:	b9000c01 	str	w1, [x0, #12]
	smp_wmb();
ffffffffea810a20:	d5033abf 	dmb	ishst
	return err;
ffffffffea810a24:	93407e80 	sxtw	x0, w20
ffffffffea810a28:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810a2c:	17ffff2f 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
		return set_status(dev, opcode, rc, 0);
ffffffffea810a30:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810a34:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810a38:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea810a3c:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810a40:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810a44:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810a48:	d5033abf 	dmb	ishst
	return err;
ffffffffea810a4c:	93407e80 	sxtw	x0, w20
ffffffffea810a50:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810a54:	17ffff25 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
		rc = handle_list_wait(&dev->handle_list, &chan,
ffffffffea810a58:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea810a5c:	910103a2 	add	x2, x29, #0x40
ffffffffea810a60:	910163a1 	add	x1, x29, #0x58
ffffffffea810a64:	91004260 	add	x0, x19, #0x10
ffffffffea810a68:	97ffe6da 	bl	ffffffffea80a5d0 <handle_list_wait>
		if (rc == ERR_NOT_FOUND) {
ffffffffea810a6c:	3100081f 	cmn	w0, #0x2
ffffffffea810a70:	540006a0 	b.eq	ffffffffea810b44 <ql_tipc_handle_cmd+0x4d4>  // b.none
		if (rc == ERR_TIMED_OUT) {
ffffffffea810a74:	3100341f 	cmn	w0, #0xd
ffffffffea810a78:	54000040 	b.eq	ffffffffea810a80 <ql_tipc_handle_cmd+0x410>  // b.none
		if (rc < 0 && rc != ERR_TIMED_OUT) {
ffffffffea810a7c:	37f80800 	tbnz	w0, #31, ffffffffea810b7c <ql_tipc_handle_cmd+0x50c>
			ept = handle_get_cookie(chan);
ffffffffea810a80:	f9402fa2 	ldr	x2, [x29, #88]
	return slot_to_addr(ept - dev->epts);
ffffffffea810a84:	91024261 	add	x1, x19, #0x90
			handle_decref(chan);
ffffffffea810a88:	aa0203e0 	mov	x0, x2
	return handle->cookie;
ffffffffea810a8c:	f9401842 	ldr	x2, [x2, #48]
	return slot_to_addr(ept - dev->epts);
ffffffffea810a90:	cb010041 	sub	x1, x2, x1
			evt->cookie = ept->cookie;
ffffffffea810a94:	f9400442 	ldr	x2, [x2, #8]
	return slot_to_addr(ept - dev->epts);
ffffffffea810a98:	9344fc21 	asr	x1, x1, #4
	return (uint32_t) (slot + QL_TIPC_ADDR_BASE);
ffffffffea810a9c:	11008021 	add	w1, w1, #0x20
			evt->handle = ept_to_addr(dev, ept);
ffffffffea810aa0:	b9001681 	str	w1, [x20, #20]
			evt->event  = chan_event;
ffffffffea810aa4:	b94043a1 	ldr	w1, [x29, #64]
ffffffffea810aa8:	b9001281 	str	w1, [x20, #16]
			evt->cookie = ept->cookie;
ffffffffea810aac:	f9000e82 	str	x2, [x20, #24]
			handle_decref(chan);
ffffffffea810ab0:	97ffe5e2 	bl	ffffffffea80a238 <handle_decref>
ffffffffea810ab4:	17ffff49 	b	ffffffffea8107d8 <ql_tipc_handle_cmd+0x168>
			evt->handle = 0;
ffffffffea810ab8:	a9017e9f 	stp	xzr, xzr, [x20, #16]
ffffffffea810abc:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea810ac0:	17ffff46 	b	ffffffffea8107d8 <ql_tipc_handle_cmd+0x168>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810ac4:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810ac8:	128fff81 	mov	w1, #0xffff8003            	// #-32765
ffffffffea810acc:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810ad0:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea810ad4:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea810ad8:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea810adc:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea810ae0:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810ae4:	17ffff01 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810ae8:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810aec:	128fff61 	mov	w1, #0xffff8004            	// #-32764
ffffffffea810af0:	17fffff7 	b	ffffffffea810acc <ql_tipc_handle_cmd+0x45c>
ffffffffea810af4:	f9401bb7 	ldr	x23, [x29, #48]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810af8:	52800020 	mov	w0, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810afc:	128fffa1 	mov	w1, #0xffff8002            	// #-32766
ffffffffea810b00:	79000281 	strh	w1, [x20]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810b04:	b9000680 	str	w0, [x20, #4]
	ns_hdr->payload_len = len;
ffffffffea810b08:	b9000e9f 	str	wzr, [x20, #12]
	smp_wmb();
ffffffffea810b0c:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, ERR_INVALID_ARGS, 0);
ffffffffea810b10:	928000e0 	mov	x0, #0xfffffffffffffff8    	// #-8
ffffffffea810b14:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810b18:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea810b1c:	17fffef3 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810b20:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810b24:	128fff62 	mov	w2, #0xffff8004            	// #-32764
ffffffffea810b28:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810b2c:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810b30:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810b34:	d5033abf 	dmb	ishst
		return set_status(dev, opcode, ERR_BAD_LEN, 0);
ffffffffea810b38:	928003e0 	mov	x0, #0xffffffffffffffe0    	// #-32
ffffffffea810b3c:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810b40:	17fffeea 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
			return set_status(dev, opcode, rc, 0);
ffffffffea810b44:	f9403a60 	ldr	x0, [x19, #112]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810b48:	52800021 	mov	w1, #0x1                   	// #1
	ns_hdr->opcode = cmd | QL_TIPC_DEV_RESP;
ffffffffea810b4c:	128fffa2 	mov	w2, #0xffff8002            	// #-32766
ffffffffea810b50:	79000002 	strh	w2, [x0]
	ns_hdr->status = (err < 0) ? 1 : 0;
ffffffffea810b54:	b9000401 	str	w1, [x0, #4]
	ns_hdr->payload_len = len;
ffffffffea810b58:	b9000c1f 	str	wzr, [x0, #12]
	smp_wmb();
ffffffffea810b5c:	d5033abf 	dmb	ishst
			return set_status(dev, opcode, rc, 0);
ffffffffea810b60:	92800020 	mov	x0, #0xfffffffffffffffe    	// #-2
ffffffffea810b64:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea810b68:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea810b6c:	17fffedf 	b	ffffffffea8106e8 <ql_tipc_handle_cmd+0x78>
ffffffffea810b70:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea810b74:	f9001fb8 	str	x24, [x29, #56]
}
ffffffffea810b78:	94000c6c 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea810b7c:	f9001bb7 	str	x23, [x29, #48]
			panic("%s: couldn't wait for handle events (%d)\n",
ffffffffea810b80:	90000042 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea810b84:	90000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea810b88:	2a0003e3 	mov	w3, w0
ffffffffea810b8c:	9113c042 	add	x2, x2, #0x4f0
ffffffffea810b90:	91102021 	add	x1, x1, #0x408
ffffffffea810b94:	aa1603e0 	mov	x0, x22
ffffffffea810b98:	9400067a 	bl	ffffffffea812580 <_panic>
ffffffffea810b9c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810ba0 <tipc_init>:
	}
	return false;
}

static void tipc_init(uint level)
{
ffffffffea810ba0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	status_t res;

	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea810ba4:	d0000282 	adrp	x2, ffffffffea862000 <__ctor_list>
ffffffffea810ba8:	90000040 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea810bac:	d2800004 	mov	x4, #0x0                   	// #0
{
ffffffffea810bb0:	910003fd 	mov	x29, sp
	res = create_tipc_device(&_descr0, sizeof(_descr0), &zero_uuid, 0, NULL);
ffffffffea810bb4:	f9405442 	ldr	x2, [x2, #168]
ffffffffea810bb8:	52800003 	mov	w3, #0x0                   	// #0
ffffffffea810bbc:	d2800d81 	mov	x1, #0x6c                  	// #108
ffffffffea810bc0:	91146000 	add	x0, x0, #0x518
ffffffffea810bc4:	97fffd4f 	bl	ffffffffea810100 <create_tipc_device>
	if (res != NO_ERROR) {
ffffffffea810bc8:	35000060 	cbnz	w0, ffffffffea810bd4 <tipc_init+0x34>
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
	}
}
ffffffffea810bcc:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea810bd0:	d65f03c0 	ret
ffffffffea810bd4:	a8c17bfd 	ldp	x29, x30, [sp], #16
		TRACEF("WARNING: failed (%d) to register tipc device\n", res);
ffffffffea810bd8:	90000044 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea810bdc:	2a0003e3 	mov	w3, w0
ffffffffea810be0:	90000041 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea810be4:	52800c42 	mov	w2, #0x62                  	// #98
ffffffffea810be8:	91142021 	add	x1, x1, #0x508
ffffffffea810bec:	91162080 	add	x0, x4, #0x588
ffffffffea810bf0:	14000c1a 	b	ffffffffea813c58 <_printf>
ffffffffea810bf4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810bf8 <is_ns_client>:
	if (uuid == &zero_uuid) {
ffffffffea810bf8:	d0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea810bfc:	f9405421 	ldr	x1, [x1, #168]
ffffffffea810c00:	eb00003f 	cmp	x1, x0
}
ffffffffea810c04:	1a9f17e0 	cset	w0, eq  // eq = none
ffffffffea810c08:	d65f03c0 	ret
ffffffffea810c0c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c10 <target_early_init>:
 * chooses not to implement.
 */

__WEAK void target_early_init(void)
{
}
ffffffffea810c10:	d65f03c0 	ret
ffffffffea810c14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c18 <target_init>:
ffffffffea810c18:	d65f03c0 	ret
ffffffffea810c1c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c20 <boot_alloc_mem>:

void *boot_alloc_mem(size_t len)
{
    uintptr_t ptr;

    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea810c20:	b0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea810c24:	91001c01 	add	x1, x0, #0x7
ffffffffea810c28:	927df021 	and	x1, x1, #0xfffffffffffffff8
    ptr = ALIGN(boot_alloc_end, 8);
ffffffffea810c2c:	f9478040 	ldr	x0, [x2, #3840]
ffffffffea810c30:	91001c00 	add	x0, x0, #0x7
ffffffffea810c34:	927df000 	and	x0, x0, #0xfffffffffffffff8
    boot_alloc_end = (ptr + ALIGN(len, 8));
ffffffffea810c38:	8b000021 	add	x1, x1, x0
ffffffffea810c3c:	f9078041 	str	x1, [x2, #3840]

    LTRACEF("len %zu, ptr %p\n", len, (void *)ptr);

    return (void *)ptr;
}
ffffffffea810c40:	d65f03c0 	ret
ffffffffea810c44:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810c48 <pmm_alloc_contiguous.part.0>:
        return NULL;

    return paddr_to_kvaddr(pa);
}

uint pmm_alloc_contiguous(uint count, uint8_t alignment_log2, paddr_t *pa, struct list_node *list)
ffffffffea810c48:	12001c21 	and	w1, w1, #0xff
ffffffffea810c4c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea810c50:	7100303f 	cmp	w1, #0xc
ffffffffea810c54:	910003fd 	mov	x29, sp
ffffffffea810c58:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810c5c:	2a0003f4 	mov	w20, w0
ffffffffea810c60:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea810c64:	aa0303f3 	mov	x19, x3
ffffffffea810c68:	aa0203f6 	mov	x22, x2
ffffffffea810c6c:	f9001bf7 	str	x23, [sp, #48]
ffffffffea810c70:	52800195 	mov	w21, #0xc                   	// #12
ffffffffea810c74:	b0000057 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea810c78:	1a952035 	csel	w21, w1, w21, cs  // cs = hs, nlast
ffffffffea810c7c:	913c82e0 	add	x0, x23, #0xf20
ffffffffea810c80:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea810c84:	97ffd301 	bl	ffffffffea805888 <mutex_acquire_timeout>
        alignment_log2 = PAGE_SIZE_SHIFT;

    mutex_acquire(&lock);

    pmm_arena_t *a;
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810c88:	b0000042 	adrp	x2, ffffffffea819000 <_mem_phys_base>
ffffffffea810c8c:	913c4042 	add	x2, x2, #0xf10
ffffffffea810c90:	f9400446 	ldr	x6, [x2, #8]
ffffffffea810c94:	eb0200df 	cmp	x6, x2
ffffffffea810c98:	54000ce0 	b.eq	ffffffffea810e34 <pmm_alloc_contiguous.part.0+0x1ec>  // b.none
ffffffffea810c9c:	12001ea3 	and	w3, w21, #0xff
                for (uint i = 0; i < count; i++) {
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
                        /* this run is broken, break out of the inner loop.
                         * start over at the next alignment boundary
                         */
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810ca0:	51003060 	sub	w0, w3, #0xc
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810ca4:	d2800023 	mov	x3, #0x1                   	// #1
ffffffffea810ca8:	9ad52061 	lsl	x1, x3, x21
ffffffffea810cac:	d100042c 	sub	x12, x1, #0x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810cb0:	9ac02063 	lsl	x3, x3, x0
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810cb4:	cb0103e0 	neg	x0, x1
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810cb8:	2a0303ed 	mov	w13, w3
ffffffffea810cbc:	4b0303ea 	neg	w10, w3
        if (a->flags & PMM_ARENA_FLAG_KMAP) {
ffffffffea810cc0:	b94018c1 	ldr	w1, [x6, #24]
ffffffffea810cc4:	36000b21 	tbz	w1, #0, ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>
            paddr_t rounded_base = ROUNDUP(a->base, 1UL << alignment_log2);
ffffffffea810cc8:	f94010c7 	ldr	x7, [x6, #32]
ffffffffea810ccc:	8b0c00e1 	add	x1, x7, x12
ffffffffea810cd0:	8a000021 	and	x1, x1, x0
            if (rounded_base < a->base || rounded_base > a->base + a->size - 1)
ffffffffea810cd4:	eb0100ff 	cmp	x7, x1
ffffffffea810cd8:	54000a88 	b.hi	ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>  // b.pmore
ffffffffea810cdc:	f94014c3 	ldr	x3, [x6, #40]
ffffffffea810ce0:	8b0300e4 	add	x4, x7, x3
ffffffffea810ce4:	d1000484 	sub	x4, x4, #0x1
ffffffffea810ce8:	eb04003f 	cmp	x1, x4
ffffffffea810cec:	540009e8 	b.hi	ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>  // b.pmore
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810cf0:	cb070021 	sub	x1, x1, x7
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810cf4:	d34cfc68 	lsr	x8, x3, #12
            uint aligned_offset = (rounded_base - a->base) / PAGE_SIZE;
ffffffffea810cf8:	d34cfc21 	lsr	x1, x1, #12
ffffffffea810cfc:	92407c2b 	and	x11, x1, #0xffffffff
ffffffffea810d00:	2a0103ef 	mov	w15, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810d04:	eb0b011f 	cmp	x8, x11
ffffffffea810d08:	54000909 	b.ls	ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>  // b.plast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea810d0c:	0b010289 	add	w9, w20, w1
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810d10:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea810d14:	540008a3 	b.cc	ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>  // b.lo, b.ul, b.last
                vm_page_t *p = &a->page_array[start];
ffffffffea810d18:	f9401cce 	ldr	x14, [x6, #56]
ffffffffea810d1c:	4b0101b0 	sub	w16, w13, w1
ffffffffea810d20:	8b0b0564 	add	x4, x11, x11, lsl #1
ffffffffea810d24:	8b040dc4 	add	x4, x14, x4, lsl #3
                for (uint i = 0; i < count; i++) {
ffffffffea810d28:	34000174 	cbz	w20, ffffffffea810d54 <pmm_alloc_contiguous.part.0+0x10c>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810d2c:	39404083 	ldrb	w3, [x4, #16]
ffffffffea810d30:	37000683 	tbnz	w3, #0, ffffffffea810e00 <pmm_alloc_contiguous.part.0+0x1b8>
                for (uint i = 0; i < count; i++) {
ffffffffea810d34:	52800005 	mov	w5, #0x0                   	// #0
ffffffffea810d38:	14000003 	b	ffffffffea810d44 <pmm_alloc_contiguous.part.0+0xfc>
                    if (p->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea810d3c:	39404083 	ldrb	w3, [x4, #16]
ffffffffea810d40:	370005e3 	tbnz	w3, #0, ffffffffea810dfc <pmm_alloc_contiguous.part.0+0x1b4>
                for (uint i = 0; i < count; i++) {
ffffffffea810d44:	110004a5 	add	w5, w5, #0x1
                        goto retry;
                    }
                    p++;
ffffffffea810d48:	91006084 	add	x4, x4, #0x18
                for (uint i = 0; i < count; i++) {
ffffffffea810d4c:	6b1400bf 	cmp	w5, w20
ffffffffea810d50:	54ffff61 	b.ne	ffffffffea810d3c <pmm_alloc_contiguous.part.0+0xf4>  // b.any

                /* we found a run */
                LTRACEF("found run from pn %u to %u\n", start, start + count);

                /* remove the pages from the run out of the free list */
                for (uint i = start; i < start + count; i++) {
ffffffffea810d54:	6b01013f 	cmp	w9, w1
ffffffffea810d58:	540003c9 	b.ls	ffffffffea810dd0 <pmm_alloc_contiguous.part.0+0x188>  // b.plast
ffffffffea810d5c:	51000529 	sub	w9, w9, #0x1
ffffffffea810d60:	52800302 	mov	w2, #0x18                  	// #24
ffffffffea810d64:	4b010129 	sub	w9, w9, w1
ffffffffea810d68:	910061c0 	add	x0, x14, #0x18
ffffffffea810d6c:	8b214124 	add	x4, x9, w1, uxtw
ffffffffea810d70:	f94018c5 	ldr	x5, [x6, #48]
ffffffffea810d74:	9ba23821 	umaddl	x1, w1, w2, x14
ffffffffea810d78:	8b040484 	add	x4, x4, x4, lsl #1
ffffffffea810d7c:	8b040c04 	add	x4, x0, x4, lsl #3
	item->next->prev = item->prev;
ffffffffea810d80:	a9400022 	ldp	x2, x0, [x1]
ffffffffea810d84:	f9000002 	str	x2, [x0]
	item->prev->next = item->next;
ffffffffea810d88:	f9400022 	ldr	x2, [x1]
ffffffffea810d8c:	f9000440 	str	x0, [x2, #8]
	item->prev = item->next = 0;
ffffffffea810d90:	a9007c3f 	stp	xzr, xzr, [x1]
                    p = &a->page_array[i];
                    DEBUG_ASSERT(!(p->flags & VM_PAGE_FLAG_NONFREE));
                    DEBUG_ASSERT(list_in_list(&p->node));

                    list_delete(&p->node);
                    p->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea810d94:	39404023 	ldrb	w3, [x1, #16]
ffffffffea810d98:	32000063 	orr	w3, w3, #0x1
ffffffffea810d9c:	39004023 	strb	w3, [x1, #16]
                    a->free_count--;

                    if (list)
ffffffffea810da0:	b40000d3 	cbz	x19, ffffffffea810db8 <pmm_alloc_contiguous.part.0+0x170>
	item->prev = list->prev;
ffffffffea810da4:	f9400260 	ldr	x0, [x19]
	item->next = list;
ffffffffea810da8:	a9004c20 	stp	x0, x19, [x1]
	list->prev->next = item;
ffffffffea810dac:	f9400260 	ldr	x0, [x19]
ffffffffea810db0:	f9000401 	str	x1, [x0, #8]
	list->prev = item;
ffffffffea810db4:	f9000261 	str	x1, [x19]
ffffffffea810db8:	91006021 	add	x1, x1, #0x18
                for (uint i = start; i < start + count; i++) {
ffffffffea810dbc:	eb04003f 	cmp	x1, x4
ffffffffea810dc0:	54fffe01 	b.ne	ffffffffea810d80 <pmm_alloc_contiguous.part.0+0x138>  // b.any
ffffffffea810dc4:	d10004a5 	sub	x5, x5, #0x1
ffffffffea810dc8:	cb0900a9 	sub	x9, x5, x9
ffffffffea810dcc:	f90018c9 	str	x9, [x6, #48]
                        list_add_tail(list, &p->node);
                }

                if (pa)
ffffffffea810dd0:	b4000076 	cbz	x22, ffffffffea810ddc <pmm_alloc_contiguous.part.0+0x194>
                    *pa = a->base + start * PAGE_SIZE;
ffffffffea810dd4:	8b0b30e7 	add	x7, x7, x11, lsl #12
ffffffffea810dd8:	f90002c7 	str	x7, [x22]

                mutex_release(&lock);
ffffffffea810ddc:	913c82e0 	add	x0, x23, #0xf20
ffffffffea810de0:	97ffd2d6 	bl	ffffffffea805938 <mutex_release>
ffffffffea810de4:	2a1403e0 	mov	w0, w20

    mutex_release(&lock);

    LTRACEF("couldn't find run\n");
    return 0;
}
ffffffffea810de8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea810dec:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810df0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810df4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea810df8:	d65f03c0 	ret
ffffffffea810dfc:	0b050021 	add	w1, w1, w5
                        start = ROUNDUP(start - aligned_offset + i + 1, 1UL << (alignment_log2 - PAGE_SIZE_SHIFT)) + aligned_offset;
ffffffffea810e00:	0b010201 	add	w1, w16, w1
ffffffffea810e04:	0a0a0021 	and	w1, w1, w10
ffffffffea810e08:	0b0f002b 	add	w11, w1, w15
ffffffffea810e0c:	aa0b03e1 	mov	x1, x11
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810e10:	eb08017f 	cmp	x11, x8
ffffffffea810e14:	540000a2 	b.cs	ffffffffea810e28 <pmm_alloc_contiguous.part.0+0x1e0>  // b.hs, b.nlast
                   ((start + count) <= a->size / PAGE_SIZE)) {
ffffffffea810e18:	0b140169 	add	w9, w11, w20
            while ((start < a->size / PAGE_SIZE) &&
ffffffffea810e1c:	eb29411f 	cmp	x8, w9, uxtw
ffffffffea810e20:	54fff802 	b.cs	ffffffffea810d20 <pmm_alloc_contiguous.part.0+0xd8>  // b.hs, b.nlast
ffffffffea810e24:	d503201f 	nop
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810e28:	f94004c6 	ldr	x6, [x6, #8]
ffffffffea810e2c:	eb0200df 	cmp	x6, x2
ffffffffea810e30:	54fff481 	b.ne	ffffffffea810cc0 <pmm_alloc_contiguous.part.0+0x78>  // b.any
    mutex_release(&lock);
ffffffffea810e34:	913c82e0 	add	x0, x23, #0xf20
ffffffffea810e38:	97ffd2c0 	bl	ffffffffea805938 <mutex_release>
    return 0;
ffffffffea810e3c:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea810e40:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea810e44:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea810e48:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea810e4c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea810e50:	d65f03c0 	ret
ffffffffea810e54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810e58 <page_to_address>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810e58:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810e5c:	913c4084 	add	x4, x4, #0xf10
ffffffffea810e60:	f9400481 	ldr	x1, [x4, #8]
ffffffffea810e64:	eb04003f 	cmp	x1, x4
ffffffffea810e68:	540001c0 	b.eq	ffffffffea810ea0 <page_to_address+0x48>  // b.none
ffffffffea810e6c:	d503201f 	nop
        if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea810e70:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea810e74:	eb00007f 	cmp	x3, x0
ffffffffea810e78:	540000e8 	b.hi	ffffffffea810e94 <page_to_address+0x3c>  // b.pmore
ffffffffea810e7c:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810e80:	d34cfc42 	lsr	x2, x2, #12
ffffffffea810e84:	8b020442 	add	x2, x2, x2, lsl #1
ffffffffea810e88:	8b020c62 	add	x2, x3, x2, lsl #3
ffffffffea810e8c:	eb00005f 	cmp	x2, x0
ffffffffea810e90:	540000c8 	b.hi	ffffffffea810ea8 <page_to_address+0x50>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810e94:	f9400421 	ldr	x1, [x1, #8]
ffffffffea810e98:	eb04003f 	cmp	x1, x4
ffffffffea810e9c:	54fffea1 	b.ne	ffffffffea810e70 <page_to_address+0x18>  // b.any
    return -1;
ffffffffea810ea0:	92800000 	mov	x0, #0xffffffffffffffff    	// #-1
}
ffffffffea810ea4:	d65f03c0 	ret
            return PAGE_ADDRESS_FROM_ARENA(page, a);
ffffffffea810ea8:	cb030000 	sub	x0, x0, x3
ffffffffea810eac:	b201f3e3 	mov	x3, #0xaaaaaaaaaaaaaaaa    	// #-6148914691236517206
ffffffffea810eb0:	f2955563 	movk	x3, #0xaaab
ffffffffea810eb4:	f9401021 	ldr	x1, [x1, #32]
ffffffffea810eb8:	9bc37c00 	umulh	x0, x0, x3
ffffffffea810ebc:	d344fc00 	lsr	x0, x0, #4
ffffffffea810ec0:	8b003020 	add	x0, x1, x0, lsl #12
}
ffffffffea810ec4:	d65f03c0 	ret

ffffffffea810ec8 <address_to_page>:
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810ec8:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810ecc:	913c4084 	add	x4, x4, #0xf10
ffffffffea810ed0:	f9400481 	ldr	x1, [x4, #8]
ffffffffea810ed4:	eb04003f 	cmp	x1, x4
ffffffffea810ed8:	540001a0 	b.eq	ffffffffea810f0c <address_to_page+0x44>  // b.none
ffffffffea810edc:	d503201f 	nop
        if (addr >= a->base && addr <= a->base + a->size - 1) {
ffffffffea810ee0:	f9401023 	ldr	x3, [x1, #32]
ffffffffea810ee4:	eb00007f 	cmp	x3, x0
ffffffffea810ee8:	540000c8 	b.hi	ffffffffea810f00 <address_to_page+0x38>  // b.pmore
ffffffffea810eec:	f9401422 	ldr	x2, [x1, #40]
ffffffffea810ef0:	8b020062 	add	x2, x3, x2
ffffffffea810ef4:	d1000442 	sub	x2, x2, #0x1
ffffffffea810ef8:	eb00005f 	cmp	x2, x0
ffffffffea810efc:	540000c2 	b.cs	ffffffffea810f14 <address_to_page+0x4c>  // b.hs, b.nlast
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810f00:	f9400421 	ldr	x1, [x1, #8]
ffffffffea810f04:	eb04003f 	cmp	x1, x4
ffffffffea810f08:	54fffec1 	b.ne	ffffffffea810ee0 <address_to_page+0x18>  // b.any
    return NULL;
ffffffffea810f0c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea810f10:	d65f03c0 	ret
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea810f14:	cb030000 	sub	x0, x0, x3
            return &a->page_array[index];
ffffffffea810f18:	f9401c21 	ldr	x1, [x1, #56]
            size_t index = (addr - a->base) / PAGE_SIZE;
ffffffffea810f1c:	d34cfc00 	lsr	x0, x0, #12
            return &a->page_array[index];
ffffffffea810f20:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea810f24:	8b000c20 	add	x0, x1, x0, lsl #3
}
ffffffffea810f28:	d65f03c0 	ret
ffffffffea810f2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea810f30 <pmm_add_arena>:
{
ffffffffea810f30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810f34:	b0000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea810f38:	913c4082 	add	x2, x4, #0xf10
{
ffffffffea810f3c:	910003fd 	mov	x29, sp
ffffffffea810f40:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea810f44:	aa0003f3 	mov	x19, x0
ffffffffea810f48:	a9025bf5 	stp	x21, x22, [sp, #32]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810f4c:	f9400440 	ldr	x0, [x2, #8]
ffffffffea810f50:	eb02001f 	cmp	x0, x2
ffffffffea810f54:	54000180 	b.eq	ffffffffea810f84 <pmm_add_arena+0x54>  // b.none
        if (a->priority > arena->priority) {
ffffffffea810f58:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810f5c:	b9401e63 	ldr	w3, [x19, #28]
ffffffffea810f60:	6b01007f 	cmp	w3, w1
ffffffffea810f64:	540000a2 	b.cs	ffffffffea810f78 <pmm_add_arena+0x48>  // b.hs, b.nlast
ffffffffea810f68:	1400002d 	b	ffffffffea81101c <pmm_add_arena+0xec>
ffffffffea810f6c:	b9401c01 	ldr	w1, [x0, #28]
ffffffffea810f70:	6b03003f 	cmp	w1, w3
ffffffffea810f74:	54000548 	b.hi	ffffffffea81101c <pmm_add_arena+0xec>  // b.pmore
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea810f78:	f9400400 	ldr	x0, [x0, #8]
ffffffffea810f7c:	eb02001f 	cmp	x0, x2
ffffffffea810f80:	54ffff61 	b.ne	ffffffffea810f6c <pmm_add_arena+0x3c>  // b.any
	item->prev = list->prev;
ffffffffea810f84:	f9478881 	ldr	x1, [x4, #3856]
ffffffffea810f88:	913c4080 	add	x0, x4, #0xf10
	item->next = list;
ffffffffea810f8c:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea810f90:	f9478880 	ldr	x0, [x4, #3856]
	list->prev = item;
ffffffffea810f94:	f9078893 	str	x19, [x4, #3856]
	list->prev->next = item;
ffffffffea810f98:	f9000413 	str	x19, [x0, #8]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea810f9c:	f9401676 	ldr	x22, [x19, #40]
    list_initialize(&arena->free_list);
ffffffffea810fa0:	91010275 	add	x21, x19, #0x40
    arena->free_count = 0;
ffffffffea810fa4:	f9001a7f 	str	xzr, [x19, #48]
	list->prev = list->next = list;
ffffffffea810fa8:	a9045675 	stp	x21, x21, [x19, #64]
    size_t page_count = arena->size / PAGE_SIZE;
ffffffffea810fac:	d34cfed6 	lsr	x22, x22, #12
    arena->page_array = boot_alloc_mem(page_count * sizeof(vm_page_t));
ffffffffea810fb0:	8b1606c2 	add	x2, x22, x22, lsl #1
ffffffffea810fb4:	d37df054 	lsl	x20, x2, #3
ffffffffea810fb8:	aa1403e0 	mov	x0, x20
ffffffffea810fbc:	97ffff19 	bl	ffffffffea810c20 <boot_alloc_mem>
ffffffffea810fc0:	f9001e60 	str	x0, [x19, #56]
    memset(arena->page_array, 0, page_count * sizeof(vm_page_t));
ffffffffea810fc4:	aa1403e2 	mov	x2, x20
ffffffffea810fc8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea810fcc:	94000c3b 	bl	ffffffffea8140b8 <memset>
    for (size_t i = 0; i < page_count; i++) {
ffffffffea810fd0:	b40001d6 	cbz	x22, ffffffffea811008 <pmm_add_arena+0xd8>
ffffffffea810fd4:	a9430264 	ldp	x4, x0, [x19, #48]
ffffffffea810fd8:	f9402261 	ldr	x1, [x19, #64]
ffffffffea810fdc:	8b000282 	add	x2, x20, x0
	item->next = list;
ffffffffea810fe0:	a9005401 	stp	x1, x21, [x0]
        list_add_tail(&arena->free_list, &p->node);
ffffffffea810fe4:	aa0003e1 	mov	x1, x0
	list->prev->next = item;
ffffffffea810fe8:	f9402263 	ldr	x3, [x19, #64]
ffffffffea810fec:	f9000460 	str	x0, [x3, #8]
	list->prev = item;
ffffffffea810ff0:	f9002260 	str	x0, [x19, #64]
ffffffffea810ff4:	91006000 	add	x0, x0, #0x18
    for (size_t i = 0; i < page_count; i++) {
ffffffffea810ff8:	eb02001f 	cmp	x0, x2
ffffffffea810ffc:	54ffff21 	b.ne	ffffffffea810fe0 <pmm_add_arena+0xb0>  // b.any
ffffffffea811000:	8b160084 	add	x4, x4, x22
ffffffffea811004:	f9001a64 	str	x4, [x19, #48]
}
ffffffffea811008:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81100c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811010:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811014:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811018:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea81101c:	f9400001 	ldr	x1, [x0]
	item->next = list;
ffffffffea811020:	a9000261 	stp	x1, x0, [x19]
	list->prev->next = item;
ffffffffea811024:	f9400001 	ldr	x1, [x0]
ffffffffea811028:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea81102c:	f9000013 	str	x19, [x0]
ffffffffea811030:	17ffffdb 	b	ffffffffea810f9c <pmm_add_arena+0x6c>
ffffffffea811034:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811038 <pmm_alloc_pages>:
{
ffffffffea811038:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81103c:	910003fd 	mov	x29, sp
ffffffffea811040:	f9000ff4 	str	x20, [sp, #24]
ffffffffea811044:	2a0003f4 	mov	w20, w0
    if (count == 0)
ffffffffea811048:	350000a0 	cbnz	w0, ffffffffea81105c <pmm_alloc_pages+0x24>
}
ffffffffea81104c:	2a1403e0 	mov	w0, w20
ffffffffea811050:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea811054:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811058:	d65f03c0 	ret
ffffffffea81105c:	f9000bb3 	str	x19, [x29, #16]
ffffffffea811060:	aa0103f3 	mov	x19, x1
ffffffffea811064:	f90013b5 	str	x21, [x29, #32]
ffffffffea811068:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea81106c:	90000055 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea811070:	913c82a0 	add	x0, x21, #0xf20
ffffffffea811074:	97ffd205 	bl	ffffffffea805888 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea811078:	90000048 	adrp	x8, ffffffffea819000 <_mem_phys_base>
ffffffffea81107c:	913c4108 	add	x8, x8, #0xf10
    uint allocated = 0;
ffffffffea811080:	52800002 	mov	w2, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea811084:	f9400505 	ldr	x5, [x8, #8]
ffffffffea811088:	eb0800bf 	cmp	x5, x8
ffffffffea81108c:	540005e0 	b.eq	ffffffffea811148 <pmm_alloc_pages+0x110>  // b.none
        while (allocated < count) {
ffffffffea811090:	6b02029f 	cmp	w20, w2
ffffffffea811094:	540003c9 	b.ls	ffffffffea81110c <pmm_alloc_pages+0xd4>  // b.plast
	if (list->next != list) {
ffffffffea811098:	f94024a0 	ldr	x0, [x5, #72]
            vm_page_t *page = list_remove_head_type(&a->free_list, vm_page_t, node);
ffffffffea81109c:	910100a7 	add	x7, x5, #0x40
ffffffffea8110a0:	eb07001f 	cmp	x0, x7
ffffffffea8110a4:	540003a0 	b.eq	ffffffffea811118 <pmm_alloc_pages+0xe0>  // b.none
ffffffffea8110a8:	f94018a3 	ldr	x3, [x5, #48]
ffffffffea8110ac:	d1000463 	sub	x3, x3, #0x1
ffffffffea8110b0:	14000005 	b	ffffffffea8110c4 <pmm_alloc_pages+0x8c>
ffffffffea8110b4:	f94024a0 	ldr	x0, [x5, #72]
ffffffffea8110b8:	eb07001f 	cmp	x0, x7
ffffffffea8110bc:	54000320 	b.eq	ffffffffea811120 <pmm_alloc_pages+0xe8>  // b.none
ffffffffea8110c0:	aa0603e3 	mov	x3, x6
	item->next->prev = item->prev;
ffffffffea8110c4:	a9400404 	ldp	x4, x1, [x0]
            allocated++;
ffffffffea8110c8:	11000442 	add	w2, w2, #0x1
ffffffffea8110cc:	d1000466 	sub	x6, x3, #0x1
        while (allocated < count) {
ffffffffea8110d0:	6b02029f 	cmp	w20, w2
ffffffffea8110d4:	f9000024 	str	x4, [x1]
	item->prev->next = item->next;
ffffffffea8110d8:	f9400004 	ldr	x4, [x0]
ffffffffea8110dc:	f9000481 	str	x1, [x4, #8]
	item->prev = item->next = 0;
ffffffffea8110e0:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea8110e4:	39404001 	ldrb	w1, [x0, #16]
ffffffffea8110e8:	32000021 	orr	w1, w1, #0x1
ffffffffea8110ec:	39004001 	strb	w1, [x0, #16]
	item->prev = list->prev;
ffffffffea8110f0:	f9400261 	ldr	x1, [x19]
	item->next = list;
ffffffffea8110f4:	a9004c01 	stp	x1, x19, [x0]
	list->prev->next = item;
ffffffffea8110f8:	f9400261 	ldr	x1, [x19]
ffffffffea8110fc:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea811100:	f9000260 	str	x0, [x19]
        while (allocated < count) {
ffffffffea811104:	54fffd81 	b.ne	ffffffffea8110b4 <pmm_alloc_pages+0x7c>  // b.any
ffffffffea811108:	f90018a3 	str	x3, [x5, #48]
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea81110c:	f94004a5 	ldr	x5, [x5, #8]
ffffffffea811110:	eb0800bf 	cmp	x5, x8
ffffffffea811114:	54fffbe1 	b.ne	ffffffffea811090 <pmm_alloc_pages+0x58>  // b.any
	if (list->next != list) {
ffffffffea811118:	2a0203f4 	mov	w20, w2
ffffffffea81111c:	14000003 	b	ffffffffea811128 <pmm_alloc_pages+0xf0>
            allocated++;
ffffffffea811120:	2a0203f4 	mov	w20, w2
ffffffffea811124:	f90018a3 	str	x3, [x5, #48]
    mutex_release(&lock);
ffffffffea811128:	913c82a0 	add	x0, x21, #0xf20
ffffffffea81112c:	97ffd203 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea811130:	2a1403e0 	mov	w0, w20
    mutex_release(&lock);
ffffffffea811134:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea811138:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea81113c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea811140:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811144:	d65f03c0 	ret
    uint allocated = 0;
ffffffffea811148:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea81114c:	17fffff7 	b	ffffffffea811128 <pmm_alloc_pages+0xf0>

ffffffffea811150 <pmm_alloc_range>:
{
ffffffffea811150:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811154:	910003fd 	mov	x29, sp
ffffffffea811158:	f90013f5 	str	x21, [sp, #32]
ffffffffea81115c:	2a0103f5 	mov	w21, w1
    if (count == 0)
ffffffffea811160:	350000a1 	cbnz	w1, ffffffffea811174 <pmm_alloc_range+0x24>
}
ffffffffea811164:	2a1503e0 	mov	w0, w21
ffffffffea811168:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea81116c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811170:	d65f03c0 	ret
ffffffffea811174:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea811178:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea81117c:	f90017b6 	str	x22, [x29, #40]
ffffffffea811180:	aa0203f4 	mov	x20, x2
    address = ROUNDDOWN(address, PAGE_SIZE);
ffffffffea811184:	9274cc13 	and	x19, x0, #0xfffffffffffff000
ffffffffea811188:	90000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea81118c:	913c82c0 	add	x0, x22, #0xf20
ffffffffea811190:	97ffd1be 	bl	ffffffffea805888 <mutex_acquire_timeout>
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea811194:	9000004a 	adrp	x10, ffffffffea819000 <_mem_phys_base>
ffffffffea811198:	913c414a 	add	x10, x10, #0xf10
    uint allocated = 0;
ffffffffea81119c:	52800003 	mov	w3, #0x0                   	// #0
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8111a0:	f9400549 	ldr	x9, [x10, #8]
ffffffffea8111a4:	eb0a013f 	cmp	x9, x10
ffffffffea8111a8:	54000640 	b.eq	ffffffffea811270 <pmm_alloc_range+0x120>  // b.none
ffffffffea8111ac:	d503201f 	nop
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea8111b0:	6b0302bf 	cmp	w21, w3
ffffffffea8111b4:	54000709 	b.ls	ffffffffea811294 <pmm_alloc_range+0x144>  // b.plast
ffffffffea8111b8:	f9401124 	ldr	x4, [x9, #32]
ffffffffea8111bc:	eb13009f 	cmp	x4, x19
ffffffffea8111c0:	540006c8 	b.hi	ffffffffea811298 <pmm_alloc_range+0x148>  // b.pmore
ffffffffea8111c4:	f9401527 	ldr	x7, [x9, #40]
ffffffffea8111c8:	8b070087 	add	x7, x4, x7
ffffffffea8111cc:	d10004e7 	sub	x7, x7, #0x1
ffffffffea8111d0:	eb1300ff 	cmp	x7, x19
ffffffffea8111d4:	54000623 	b.cc	ffffffffea811298 <pmm_alloc_range+0x148>  // b.lo, b.ul, b.last
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea8111d8:	cb040260 	sub	x0, x19, x4
            vm_page_t *page = &a->page_array[index];
ffffffffea8111dc:	f9401d28 	ldr	x8, [x9, #56]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea8111e0:	d34cfc00 	lsr	x0, x0, #12
            vm_page_t *page = &a->page_array[index];
ffffffffea8111e4:	8b000400 	add	x0, x0, x0, lsl #1
ffffffffea8111e8:	8b000d00 	add	x0, x8, x0, lsl #3
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea8111ec:	39404001 	ldrb	w1, [x0, #16]
ffffffffea8111f0:	37000541 	tbnz	w1, #0, ffffffffea811298 <pmm_alloc_range+0x148>
ffffffffea8111f4:	f9401925 	ldr	x5, [x9, #48]
ffffffffea8111f8:	14000007 	b	ffffffffea811214 <pmm_alloc_range+0xc4>
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea8111fc:	eb04027f 	cmp	x19, x4
ffffffffea811200:	54000543 	b.cc	ffffffffea8112a8 <pmm_alloc_range+0x158>  // b.lo, b.ul, b.last
ffffffffea811204:	eb07027f 	cmp	x19, x7
ffffffffea811208:	54000508 	b.hi	ffffffffea8112a8 <pmm_alloc_range+0x158>  // b.pmore
            if (page->flags & VM_PAGE_FLAG_NONFREE) {
ffffffffea81120c:	39404001 	ldrb	w1, [x0, #16]
ffffffffea811210:	370004c1 	tbnz	w1, #0, ffffffffea8112a8 <pmm_alloc_range+0x158>
	item->next->prev = item->prev;
ffffffffea811214:	a9400806 	ldp	x6, x2, [x0]
            address += PAGE_SIZE;
ffffffffea811218:	91400673 	add	x19, x19, #0x1, lsl #12
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea81121c:	cb040261 	sub	x1, x19, x4
            allocated++;
ffffffffea811220:	11000463 	add	w3, w3, #0x1
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea811224:	6b0302bf 	cmp	w21, w3
            a->free_count--;
ffffffffea811228:	d10004a5 	sub	x5, x5, #0x1
ffffffffea81122c:	f9000046 	str	x6, [x2]
            size_t index = (address - a->base) / PAGE_SIZE;
ffffffffea811230:	d34cfc21 	lsr	x1, x1, #12
	item->prev->next = item->next;
ffffffffea811234:	f9400006 	ldr	x6, [x0]
            vm_page_t *page = &a->page_array[index];
ffffffffea811238:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea81123c:	f90004c2 	str	x2, [x6, #8]
	item->prev = item->next = 0;
ffffffffea811240:	f900001f 	str	xzr, [x0]
            page->flags |= VM_PAGE_FLAG_NONFREE;
ffffffffea811244:	39404002 	ldrb	w2, [x0, #16]
ffffffffea811248:	32000042 	orr	w2, w2, #0x1
ffffffffea81124c:	39004002 	strb	w2, [x0, #16]
	item->prev = list->prev;
ffffffffea811250:	f9400282 	ldr	x2, [x20]
	item->next = list;
ffffffffea811254:	a9005002 	stp	x2, x20, [x0]
	list->prev->next = item;
ffffffffea811258:	f9400282 	ldr	x2, [x20]
ffffffffea81125c:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea811260:	f9000280 	str	x0, [x20]
            vm_page_t *page = &a->page_array[index];
ffffffffea811264:	8b010d00 	add	x0, x8, x1, lsl #3
        while (allocated < count && ADDRESS_IN_ARENA(address, a)) {
ffffffffea811268:	54fffca1 	b.ne	ffffffffea8111fc <pmm_alloc_range+0xac>  // b.any
ffffffffea81126c:	f9001925 	str	x5, [x9, #48]
    return allocated;
ffffffffea811270:	2a0303f5 	mov	w21, w3
    mutex_release(&lock);
ffffffffea811274:	913c82c0 	add	x0, x22, #0xf20
ffffffffea811278:	97ffd1b0 	bl	ffffffffea805938 <mutex_release>
    return allocated;
ffffffffea81127c:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea811280:	2a1503e0 	mov	w0, w21
ffffffffea811284:	f94013f5 	ldr	x21, [sp, #32]
    return allocated;
ffffffffea811288:	a94153b3 	ldp	x19, x20, [x29, #16]
}
ffffffffea81128c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811290:	d65f03c0 	ret
        if (allocated == count)
ffffffffea811294:	54fffee0 	b.eq	ffffffffea811270 <pmm_alloc_range+0x120>  // b.none
    list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea811298:	f9400529 	ldr	x9, [x9, #8]
ffffffffea81129c:	eb0a013f 	cmp	x9, x10
ffffffffea8112a0:	54fff881 	b.ne	ffffffffea8111b0 <pmm_alloc_range+0x60>  // b.any
ffffffffea8112a4:	17fffff3 	b	ffffffffea811270 <pmm_alloc_range+0x120>
ffffffffea8112a8:	f9001925 	str	x5, [x9, #48]
ffffffffea8112ac:	f9400529 	ldr	x9, [x9, #8]
ffffffffea8112b0:	eb0a013f 	cmp	x9, x10
ffffffffea8112b4:	54fff7e1 	b.ne	ffffffffea8111b0 <pmm_alloc_range+0x60>  // b.any
ffffffffea8112b8:	17ffffee 	b	ffffffffea811270 <pmm_alloc_range+0x120>
ffffffffea8112bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8112c0 <pmm_free>:
{
ffffffffea8112c0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8112c4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8112c8:	910003fd 	mov	x29, sp
ffffffffea8112cc:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8112d0:	aa0003f3 	mov	x19, x0
ffffffffea8112d4:	f90013f5 	str	x21, [sp, #32]
ffffffffea8112d8:	90000055 	adrp	x21, ffffffffea819000 <_mem_phys_base>
ffffffffea8112dc:	913c82a0 	add	x0, x21, #0xf20
ffffffffea8112e0:	97ffd16a 	bl	ffffffffea805888 <mutex_acquire_timeout>
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea8112e4:	90000044 	adrp	x4, ffffffffea819000 <_mem_phys_base>
ffffffffea8112e8:	913c4084 	add	x4, x4, #0xf10
    uint count = 0;
ffffffffea8112ec:	52800014 	mov	w20, #0x0                   	// #0
	return (list->next == list) ? true : false;
ffffffffea8112f0:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea8112f4:	eb02027f 	cmp	x19, x2
ffffffffea8112f8:	540004c0 	b.eq	ffffffffea811390 <pmm_free+0xd0>  // b.none
	item->next->prev = item->prev;
ffffffffea8112fc:	a9400041 	ldp	x1, x0, [x2]
ffffffffea811300:	f9000001 	str	x1, [x0]
	item->prev->next = item->next;
ffffffffea811304:	f9400041 	ldr	x1, [x2]
ffffffffea811308:	f9000420 	str	x0, [x1, #8]
	item->prev = item->next = 0;
ffffffffea81130c:	a9007c5f 	stp	xzr, xzr, [x2]
        list_for_every_entry(&arena_list, a, pmm_arena_t, node) {
ffffffffea811310:	f9400480 	ldr	x0, [x4, #8]
ffffffffea811314:	eb04001f 	cmp	x0, x4
ffffffffea811318:	540000a1 	b.ne	ffffffffea81132c <pmm_free+0x6c>  // b.any
ffffffffea81131c:	17fffff5 	b	ffffffffea8112f0 <pmm_free+0x30>
ffffffffea811320:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811324:	eb04001f 	cmp	x0, x4
ffffffffea811328:	54fffe40 	b.eq	ffffffffea8112f0 <pmm_free+0x30>  // b.none
            if (PAGE_BELONGS_TO_ARENA(page, a)) {
ffffffffea81132c:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea811330:	eb02007f 	cmp	x3, x2
ffffffffea811334:	54ffff68 	b.hi	ffffffffea811320 <pmm_free+0x60>  // b.pmore
ffffffffea811338:	f9401401 	ldr	x1, [x0, #40]
ffffffffea81133c:	d34cfc21 	lsr	x1, x1, #12
ffffffffea811340:	8b010421 	add	x1, x1, x1, lsl #1
ffffffffea811344:	8b010c61 	add	x1, x3, x1, lsl #3
ffffffffea811348:	eb02003f 	cmp	x1, x2
ffffffffea81134c:	54fffea9 	b.ls	ffffffffea811320 <pmm_free+0x60>  // b.plast
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea811350:	39404043 	ldrb	w3, [x2, #16]
                list_add_head(&a->free_list, &page->node);
ffffffffea811354:	91010005 	add	x5, x0, #0x40
                a->free_count++;
ffffffffea811358:	f9401801 	ldr	x1, [x0, #48]
                count++;
ffffffffea81135c:	11000694 	add	w20, w20, #0x1
                page->flags &= ~VM_PAGE_FLAG_NONFREE;
ffffffffea811360:	121f7863 	and	w3, w3, #0xfffffffe
ffffffffea811364:	39004043 	strb	w3, [x2, #16]
                a->free_count++;
ffffffffea811368:	91000421 	add	x1, x1, #0x1
	item->next = list->next;
ffffffffea81136c:	f9402403 	ldr	x3, [x0, #72]
ffffffffea811370:	a9000c45 	stp	x5, x3, [x2]
	list->next->prev = item;
ffffffffea811374:	f9402403 	ldr	x3, [x0, #72]
ffffffffea811378:	f9000062 	str	x2, [x3]
	list->next = item;
ffffffffea81137c:	f9002402 	str	x2, [x0, #72]
ffffffffea811380:	f9001801 	str	x1, [x0, #48]
	return (list->next == list) ? true : false;
ffffffffea811384:	f9400662 	ldr	x2, [x19, #8]
    while (!list_is_empty(list)) {
ffffffffea811388:	eb02027f 	cmp	x19, x2
ffffffffea81138c:	54fffb81 	b.ne	ffffffffea8112fc <pmm_free+0x3c>  // b.any
    mutex_release(&lock);
ffffffffea811390:	913c82a0 	add	x0, x21, #0xf20
ffffffffea811394:	97ffd169 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea811398:	2a1403e0 	mov	w0, w20
ffffffffea81139c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8113a0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8113a4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8113a8:	d65f03c0 	ret
ffffffffea8113ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8113b0 <pmm_free_page>:
{
ffffffffea8113b0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea8113b4:	aa0003e2 	mov	x2, x0
ffffffffea8113b8:	910003fd 	mov	x29, sp
ffffffffea8113bc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8113c0:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
	item->next = list->next;
ffffffffea8113c4:	9100a3a1 	add	x1, x29, #0x28
ffffffffea8113c8:	f9000401 	str	x1, [x0, #8]
ffffffffea8113cc:	f9402a73 	ldr	x19, [x19, #80]
	list->next = item;
ffffffffea8113d0:	a90283a0 	stp	x0, x0, [x29, #40]
    return pmm_free(&list);
ffffffffea8113d4:	aa0103e0 	mov	x0, x1
{
ffffffffea8113d8:	f9400263 	ldr	x3, [x19]
ffffffffea8113dc:	f9001fa3 	str	x3, [x29, #56]
ffffffffea8113e0:	d2800003 	mov	x3, #0x0                   	// #0
	item->prev = list;
ffffffffea8113e4:	f9000041 	str	x1, [x2]
    return pmm_free(&list);
ffffffffea8113e8:	97ffffb6 	bl	ffffffffea8112c0 <pmm_free>
}
ffffffffea8113ec:	f9401fa2 	ldr	x2, [x29, #56]
ffffffffea8113f0:	f9400261 	ldr	x1, [x19]
ffffffffea8113f4:	ca010041 	eor	x1, x2, x1
ffffffffea8113f8:	b5000081 	cbnz	x1, ffffffffea811408 <pmm_free_page+0x58>
ffffffffea8113fc:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811400:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea811404:	d65f03c0 	ret
ffffffffea811408:	94000a48 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea81140c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811410 <pmm_alloc_kpages>:
{
ffffffffea811410:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811414:	910003fd 	mov	x29, sp
ffffffffea811418:	f9000bf3 	str	x19, [sp, #16]
ffffffffea81141c:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea811420:	f9402a62 	ldr	x2, [x19, #80]
ffffffffea811424:	f9400043 	ldr	x3, [x2]
ffffffffea811428:	f90017a3 	str	x3, [x29, #40]
ffffffffea81142c:	d2800003 	mov	x3, #0x0                   	// #0
    if (count == 0)
ffffffffea811430:	34000200 	cbz	w0, ffffffffea811470 <pmm_alloc_kpages+0x60>
ffffffffea811434:	aa0103e3 	mov	x3, x1
ffffffffea811438:	910083a2 	add	x2, x29, #0x20
ffffffffea81143c:	52800181 	mov	w1, #0xc                   	// #12
ffffffffea811440:	97fffe02 	bl	ffffffffea810c48 <pmm_alloc_contiguous.part.0>
    if (alloc_count == 0)
ffffffffea811444:	34000160 	cbz	w0, ffffffffea811470 <pmm_alloc_kpages+0x60>
    return paddr_to_kvaddr(pa);
ffffffffea811448:	f94013a0 	ldr	x0, [x29, #32]
ffffffffea81144c:	94000083 	bl	ffffffffea811658 <paddr_to_kvaddr>
}
ffffffffea811450:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea811454:	f94017a2 	ldr	x2, [x29, #40]
ffffffffea811458:	f9400261 	ldr	x1, [x19]
ffffffffea81145c:	ca010041 	eor	x1, x2, x1
ffffffffea811460:	b50000c1 	cbnz	x1, ffffffffea811478 <pmm_alloc_kpages+0x68>
ffffffffea811464:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811468:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81146c:	d65f03c0 	ret
        return NULL;
ffffffffea811470:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea811474:	17fffff7 	b	ffffffffea811450 <pmm_alloc_kpages+0x40>
}
ffffffffea811478:	94000a2c 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea81147c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811480 <pmm_alloc_contiguous>:
{
ffffffffea811480:	12001c21 	and	w1, w1, #0xff
    if (count == 0)
ffffffffea811484:	34000040 	cbz	w0, ffffffffea81148c <pmm_alloc_contiguous+0xc>
ffffffffea811488:	17fffdf0 	b	ffffffffea810c48 <pmm_alloc_contiguous.part.0>
}
ffffffffea81148c:	d65f03c0 	ret

ffffffffea811490 <mark_pages_in_use>:
extern int _end;

/* mark the physical pages backing a range of virtual as in use.
 * allocate the physical pages and throw them away */
static void mark_pages_in_use(vaddr_t va, size_t len)
{
ffffffffea811490:	a9b87bfd 	stp	x29, x30, [sp, #-128]!

    struct list_node list;
    list_initialize(&list);

    /* make sure we are inclusive of all of the pages in the address range */
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea811494:	913ffc21 	add	x1, x1, #0xfff
{
ffffffffea811498:	910003fd 	mov	x29, sp
ffffffffea81149c:	f90023f9 	str	x25, [sp, #64]
ffffffffea8114a0:	b0000299 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea8114a4:	f9000ff4 	str	x20, [sp, #24]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea8114a8:	92402c14 	and	x20, x0, #0xfff
{
ffffffffea8114ac:	f9402b22 	ldr	x2, [x25, #80]
    len = PAGE_ALIGN(len + (va & (PAGE_SIZE - 1)));
ffffffffea8114b0:	8b010294 	add	x20, x20, x1
{
ffffffffea8114b4:	f90017f6 	str	x22, [sp, #40]
	list->prev = list->next = list;
ffffffffea8114b8:	9101a3b6 	add	x22, x29, #0x68
ffffffffea8114bc:	f9400043 	ldr	x3, [x2]
ffffffffea8114c0:	f9003fa3 	str	x3, [x29, #120]
ffffffffea8114c4:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea8114c8:	a906dbb6 	stp	x22, x22, [x29, #104]
    va = ROUNDDOWN(va, PAGE_SIZE);

    LTRACEF("aligned va 0x%lx, len 0x%zx\n", va, len);

    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea8114cc:	f274ce94 	ands	x20, x20, #0xfffffffffffff000
ffffffffea8114d0:	54000340 	b.eq	ffffffffea811538 <mark_pages_in_use+0xa8>  // b.none
ffffffffea8114d4:	f90013b5 	str	x21, [x29, #32]
ffffffffea8114d8:	9274cc15 	and	x21, x0, #0xfffffffffffff000
ffffffffea8114dc:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8114e0:	910173b8 	add	x24, x29, #0x5c
ffffffffea8114e4:	f90027ba 	str	x26, [x29, #72]
ffffffffea8114e8:	910183b7 	add	x23, x29, #0x60
ffffffffea8114ec:	aa1e03fa 	mov	x26, x30
ffffffffea8114f0:	f9000bb3 	str	x19, [x29, #16]
ffffffffea8114f4:	d2800013 	mov	x19, #0x0                   	// #0
        uint flags;
        paddr_t pa;

        status_t err = arch_mmu_query(va + offset, &pa, &flags);
ffffffffea8114f8:	aa1803e2 	mov	x2, x24
ffffffffea8114fc:	aa1703e1 	mov	x1, x23
ffffffffea811500:	8b1302a0 	add	x0, x21, x19
ffffffffea811504:	97ffc811 	bl	ffffffffea803548 <arch_mmu_query>
        if (err >= 0) {
ffffffffea811508:	37f802c0 	tbnz	w0, #31, ffffffffea811560 <mark_pages_in_use+0xd0>
            //LTRACEF("va 0x%x, pa 0x%x, flags 0x%x, err %d\n", va + offset, pa, flags, err);

            /* alloate the range, throw the results away */
            pmm_alloc_range(pa, 1, &list);
ffffffffea81150c:	f94033a0 	ldr	x0, [x29, #96]
ffffffffea811510:	aa1603e2 	mov	x2, x22
ffffffffea811514:	52800021 	mov	w1, #0x1                   	// #1
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea811518:	91400673 	add	x19, x19, #0x1, lsl #12
            pmm_alloc_range(pa, 1, &list);
ffffffffea81151c:	97ffff0d 	bl	ffffffffea811150 <pmm_alloc_range>
    for (size_t offset = 0; offset < len; offset += PAGE_SIZE) {
ffffffffea811520:	eb13029f 	cmp	x20, x19
ffffffffea811524:	54fffea8 	b.hi	ffffffffea8114f8 <mark_pages_in_use+0x68>  // b.pmore
ffffffffea811528:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea81152c:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea811530:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea811534:	f94027ba 	ldr	x26, [x29, #72]
        } else {
            panic("Could not find pa for va 0x%lx\n", va);
        }
    }
}
ffffffffea811538:	f9402b39 	ldr	x25, [x25, #80]
ffffffffea81153c:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea811540:	f9400320 	ldr	x0, [x25]
ffffffffea811544:	ca000020 	eor	x0, x1, x0
ffffffffea811548:	b5000160 	cbnz	x0, ffffffffea811574 <mark_pages_in_use+0xe4>
ffffffffea81154c:	f9400ff4 	ldr	x20, [sp, #24]
ffffffffea811550:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea811554:	f94023f9 	ldr	x25, [sp, #64]
ffffffffea811558:	a8c87bfd 	ldp	x29, x30, [sp], #128
ffffffffea81155c:	d65f03c0 	ret
            panic("Could not find pa for va 0x%lx\n", va);
ffffffffea811560:	f0000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea811564:	aa1503e2 	mov	x2, x21
ffffffffea811568:	91170021 	add	x1, x1, #0x5c0
ffffffffea81156c:	aa1a03e0 	mov	x0, x26
ffffffffea811570:	94000404 	bl	ffffffffea812580 <_panic>
ffffffffea811574:	f9000bb3 	str	x19, [x29, #16]
ffffffffea811578:	f90013b5 	str	x21, [x29, #32]
ffffffffea81157c:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea811580:	f90027ba 	str	x26, [x29, #72]
}
ffffffffea811584:	940009e9 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea811588 <vm_init_preheap>:

static void vm_init_preheap(uint level)
{
ffffffffea811588:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    LTRACE_ENTRY;

    /* mark all of the kernel pages in use */
    LTRACEF("marking all kernel pages as used\n");
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea81158c:	b0000282 	adrp	x2, ffffffffea862000 <__ctor_list>
ffffffffea811590:	b0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
{
ffffffffea811594:	910003fd 	mov	x29, sp
    mark_pages_in_use((vaddr_t)&_start, ((uintptr_t)&_end - (uintptr_t)&_start));
ffffffffea811598:	f9406842 	ldr	x2, [x2, #208]
ffffffffea81159c:	f9408c21 	ldr	x1, [x1, #280]
ffffffffea8115a0:	aa0203e0 	mov	x0, x2
ffffffffea8115a4:	cb020021 	sub	x1, x1, x2
ffffffffea8115a8:	97ffffba 	bl	ffffffffea811490 <mark_pages_in_use>

    /* mark the physical pages used by the boot time allocator */
    if (boot_alloc_end != boot_alloc_start) {
ffffffffea8115ac:	b0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea8115b0:	b0000280 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea8115b4:	f9403821 	ldr	x1, [x1, #112]
ffffffffea8115b8:	f9407400 	ldr	x0, [x0, #232]
ffffffffea8115bc:	f9400021 	ldr	x1, [x1]
ffffffffea8115c0:	f9400000 	ldr	x0, [x0]
ffffffffea8115c4:	eb00003f 	cmp	x1, x0
ffffffffea8115c8:	54000080 	b.eq	ffffffffea8115d8 <vm_init_preheap+0x50>  // b.none
        LTRACEF("marking boot alloc used from 0x%lx to 0x%lx\n", boot_alloc_start, boot_alloc_end);

        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
    }
}
ffffffffea8115cc:	a8c17bfd 	ldp	x29, x30, [sp], #16
        mark_pages_in_use(boot_alloc_start, boot_alloc_end - boot_alloc_start);
ffffffffea8115d0:	cb000021 	sub	x1, x1, x0
ffffffffea8115d4:	17ffffaf 	b	ffffffffea811490 <mark_pages_in_use>
}
ffffffffea8115d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8115dc:	d65f03c0 	ret

ffffffffea8115e0 <vm_init_postheap>:

static void vm_init_postheap(uint level)
{
ffffffffea8115e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8115e4:	910003fd 	mov	x29, sp
ffffffffea8115e8:	f9000bf3 	str	x19, [sp, #16]

    vmm_init();

    /* create vmm regions to cover what is already there from the initial mapping table */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea8115ec:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
    vmm_init();
ffffffffea8115f0:	94000046 	bl	ffffffffea811708 <vmm_init>
    while (map->size > 0) {
ffffffffea8115f4:	f9408273 	ldr	x19, [x19, #256]
ffffffffea8115f8:	f9400a62 	ldr	x2, [x19, #16]
ffffffffea8115fc:	b4000262 	cbz	x2, ffffffffea811648 <vm_init_postheap+0x68>
ffffffffea811600:	f9000fb4 	str	x20, [x29, #24]
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea811604:	b0000294 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea811608:	91002273 	add	x19, x19, #0x8
ffffffffea81160c:	f9408694 	ldr	x20, [x20, #264]
ffffffffea811610:	14000004 	b	ffffffffea811620 <vm_init_postheap+0x40>
ffffffffea811614:	9100a273 	add	x19, x19, #0x28
    while (map->size > 0) {
ffffffffea811618:	f9400662 	ldr	x2, [x19, #8]
ffffffffea81161c:	b4000142 	cbz	x2, ffffffffea811644 <vm_init_postheap+0x64>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY)) {
ffffffffea811620:	b9401260 	ldr	w0, [x19, #16]
ffffffffea811624:	3707ff80 	tbnz	w0, #0, ffffffffea811614 <vm_init_postheap+0x34>
            vmm_reserve_space(vmm_get_kernel_aspace(), map->name, map->size, map->virt);
ffffffffea811628:	f9400263 	ldr	x3, [x19]
ffffffffea81162c:	9100a273 	add	x19, x19, #0x28
ffffffffea811630:	f85f0261 	ldur	x1, [x19, #-16]
ffffffffea811634:	aa1403e0 	mov	x0, x20
ffffffffea811638:	94000112 	bl	ffffffffea811a80 <vmm_reserve_space>
    while (map->size > 0) {
ffffffffea81163c:	f9400662 	ldr	x2, [x19, #8]
ffffffffea811640:	b5ffff02 	cbnz	x2, ffffffffea811620 <vm_init_postheap+0x40>
ffffffffea811644:	f9400fb4 	ldr	x20, [x29, #24]
        }

        map++;
    }
}
ffffffffea811648:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea81164c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811650:	d65f03c0 	ret
ffffffffea811654:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811658 <paddr_to_kvaddr>:

void *paddr_to_kvaddr(paddr_t pa)
{
    /* slow path to do reverse lookup */
    struct mmu_initial_mapping *map = mmu_initial_mappings;
    while (map->size > 0) {
ffffffffea811658:	b0000281 	adrp	x1, ffffffffea862000 <__ctor_list>
ffffffffea81165c:	f9408021 	ldr	x1, [x1, #256]
ffffffffea811660:	f9400822 	ldr	x2, [x1, #16]
ffffffffea811664:	b40001a2 	cbz	x2, ffffffffea811698 <paddr_to_kvaddr+0x40>
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea811668:	b9401823 	ldr	w3, [x1, #24]
ffffffffea81166c:	37000103 	tbnz	w3, #0, ffffffffea81168c <paddr_to_kvaddr+0x34>
            pa >= map->phys &&
ffffffffea811670:	f9400024 	ldr	x4, [x1]
            pa <= map->phys + map->size - 1) {
ffffffffea811674:	d1000483 	sub	x3, x4, #0x1
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea811678:	eb00009f 	cmp	x4, x0
            pa <= map->phys + map->size - 1) {
ffffffffea81167c:	8b020062 	add	x2, x3, x2
        if (!(map->flags & MMU_INITIAL_MAPPING_TEMPORARY) &&
ffffffffea811680:	54000068 	b.hi	ffffffffea81168c <paddr_to_kvaddr+0x34>  // b.pmore
            pa >= map->phys &&
ffffffffea811684:	eb00005f 	cmp	x2, x0
ffffffffea811688:	540000c2 	b.cs	ffffffffea8116a0 <paddr_to_kvaddr+0x48>  // b.hs, b.nlast
            return (void *)(map->virt + (pa - map->phys));
        }
        map++;
ffffffffea81168c:	9100a021 	add	x1, x1, #0x28
    while (map->size > 0) {
ffffffffea811690:	f9400822 	ldr	x2, [x1, #16]
ffffffffea811694:	b5fffea2 	cbnz	x2, ffffffffea811668 <paddr_to_kvaddr+0x10>
    }
    return NULL;
ffffffffea811698:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea81169c:	d65f03c0 	ret
            return (void *)(map->virt + (pa - map->phys));
ffffffffea8116a0:	f9400421 	ldr	x1, [x1, #8]
ffffffffea8116a4:	cb040024 	sub	x4, x1, x4
ffffffffea8116a8:	8b000080 	add	x0, x4, x0
}
ffffffffea8116ac:	d65f03c0 	ret

ffffffffea8116b0 <kvaddr_to_paddr>:

paddr_t kvaddr_to_paddr(void *ptr)
{
ffffffffea8116b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    status_t rc;
    paddr_t  pa;

    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea8116b4:	d2800002 	mov	x2, #0x0                   	// #0
{
ffffffffea8116b8:	910003fd 	mov	x29, sp
ffffffffea8116bc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8116c0:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea8116c4:	910083a1 	add	x1, x29, #0x20
{
ffffffffea8116c8:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea8116cc:	f9400263 	ldr	x3, [x19]
ffffffffea8116d0:	f90017a3 	str	x3, [x29, #40]
ffffffffea8116d4:	d2800003 	mov	x3, #0x0                   	// #0
    rc = arch_mmu_query((vaddr_t)ptr, &pa, NULL);
ffffffffea8116d8:	97ffc79c 	bl	ffffffffea803548 <arch_mmu_query>
    if (rc)
        return (paddr_t) NULL;
    return pa;
ffffffffea8116dc:	7100001f 	cmp	w0, #0x0
ffffffffea8116e0:	f94013a2 	ldr	x2, [x29, #32]
}
ffffffffea8116e4:	f94017a0 	ldr	x0, [x29, #40]
ffffffffea8116e8:	f9400261 	ldr	x1, [x19]
ffffffffea8116ec:	ca010001 	eor	x1, x0, x1
ffffffffea8116f0:	9a9f0040 	csel	x0, x2, xzr, eq  // eq = none
ffffffffea8116f4:	b5000081 	cbnz	x1, ffffffffea811704 <kvaddr_to_paddr+0x54>
ffffffffea8116f8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8116fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811700:	d65f03c0 	ret
ffffffffea811704:	94000989 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea811708 <vmm_init>:
static mutex_t vmm_lock = MUTEX_INITIAL_VALUE(vmm_lock);

vmm_aspace_t _kernel_aspace;

void vmm_init(void)
{
ffffffffea811708:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    /* initialize the kernel address space */
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea81170c:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea811710:	f0000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea811714:	9117e021 	add	x1, x1, #0x5f8
{
ffffffffea811718:	910003fd 	mov	x29, sp
ffffffffea81171c:	f9000bf3 	str	x19, [sp, #16]
    strlcpy(_kernel_aspace.name, "kernel", sizeof(_kernel_aspace.name));
ffffffffea811720:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea811724:	f9408673 	ldr	x19, [x19, #264]
ffffffffea811728:	91004260 	add	x0, x19, #0x10
ffffffffea81172c:	94000aa5 	bl	ffffffffea8141c0 <strlcpy>
	item->next = list->next;
ffffffffea811730:	90000040 	adrp	x0, ffffffffea819000 <_mem_phys_base>
ffffffffea811734:	913d6000 	add	x0, x0, #0xf58
	list->prev = list->next = list;
ffffffffea811738:	91012262 	add	x2, x19, #0x48
    _kernel_aspace.base = KERNEL_ASPACE_BASE,
ffffffffea81173c:	b2638be4 	mov	x4, #0xffffffffe0000000    	// #-536870912
ffffffffea811740:	a9048a62 	stp	x2, x2, [x19, #72]
    _kernel_aspace.size = KERNEL_ASPACE_SIZE,
ffffffffea811744:	d2a40003 	mov	x3, #0x20000000            	// #536870912
	item->next = list->next;
ffffffffea811748:	f9400401 	ldr	x1, [x0, #8]
ffffffffea81174c:	a9000660 	stp	x0, x1, [x19]
ffffffffea811750:	a9038e64 	stp	x4, x3, [x19, #56]
	list->next->prev = item;
ffffffffea811754:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea811758:	f9000413 	str	x19, [x0, #8]
    list_initialize(&_kernel_aspace.region_list);

    list_add_head(&aspace_list, &_kernel_aspace.node);
}
ffffffffea81175c:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811760:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811764:	d65f03c0 	ret

ffffffffea811768 <arch_mmu_pick_spot>:
__WEAK vaddr_t arch_mmu_pick_spot(vaddr_t base, uint prev_region_arch_mmu_flags,
                                  vaddr_t end,  uint next_region_arch_mmu_flags,
                                  vaddr_t align, size_t size, uint arch_mmu_flags)
{
    /* just align it by default */
    return ALIGN(base, align);
ffffffffea811768:	d1000400 	sub	x0, x0, #0x1
ffffffffea81176c:	8b040000 	add	x0, x0, x4
ffffffffea811770:	cb0403e4 	neg	x4, x4
}
ffffffffea811774:	8a040000 	and	x0, x0, x4
ffffffffea811778:	d65f03c0 	ret
ffffffffea81177c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811780 <alloc_region>:

/* allocate a region structure and stick it in the address space */
static vmm_region_t *alloc_region(vmm_aspace_t *aspace, const char *name, size_t size,
        vaddr_t vaddr, uint8_t align_pow2,
        uint vmm_flags, uint region_flags, uint arch_mmu_flags)
{
ffffffffea811780:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea811784:	910003fd 	mov	x29, sp
ffffffffea811788:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81178c:	aa0303f4 	mov	x20, x3
ffffffffea811790:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea811794:	aa0203f6 	mov	x22, x2
ffffffffea811798:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea81179c:	2a0503f5 	mov	w21, w5
ffffffffea8117a0:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea8117a4:	aa0003f7 	mov	x23, x0
ffffffffea8117a8:	f9002bfb 	str	x27, [sp, #80]
ffffffffea8117ac:	12001c99 	and	w25, w4, #0xff
ffffffffea8117b0:	2a0603fa 	mov	w26, w6
ffffffffea8117b4:	2a0703f8 	mov	w24, w7
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea8117b8:	d2800b00 	mov	x0, #0x58                  	// #88
{
ffffffffea8117bc:	aa0103fb 	mov	x27, x1
    vmm_region_t *r = malloc(sizeof(vmm_region_t));
ffffffffea8117c0:	9400096a 	bl	ffffffffea813d68 <malloc>
ffffffffea8117c4:	aa0003f3 	mov	x19, x0
    if (!r)
ffffffffea8117c8:	b40006e0 	cbz	x0, ffffffffea8118a4 <alloc_region+0x124>
    strlcpy(r->name, name, sizeof(r->name));
ffffffffea8117cc:	d2800402 	mov	x2, #0x20                  	// #32
ffffffffea8117d0:	aa1b03e1 	mov	x1, x27
ffffffffea8117d4:	91004000 	add	x0, x0, #0x10
ffffffffea8117d8:	94000a7a 	bl	ffffffffea8141c0 <strlcpy>
    list_initialize(&r->page_list);
ffffffffea8117dc:	91012260 	add	x0, x19, #0x48
    r->arch_mmu_flags = arch_mmu_flags;
ffffffffea8117e0:	2906627a 	stp	w26, w24, [x19, #48]
    r->size = size;
ffffffffea8117e4:	a903da74 	stp	x20, x22, [x19, #56]
	list->prev = list->next = list;
ffffffffea8117e8:	a9048260 	stp	x0, x0, [x19, #72]
    vmm_region_t *r = alloc_region_struct(name, vaddr, size, region_flags, arch_mmu_flags);
    if (!r)
        return NULL;

    /* if they ask us for a specific spot, put it there */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea8117ec:	360006d5 	tbz	w21, #0, ffffffffea8118c4 <alloc_region+0x144>
    if (r->size == 0 || !is_region_inside_aspace(aspace, r->base, r->size)) {
ffffffffea8117f0:	b4000556 	cbz	x22, ffffffffea811898 <alloc_region+0x118>
    if (!is_inside_aspace(aspace, vaddr))
ffffffffea8117f4:	f9401ee0 	ldr	x0, [x23, #56]
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea8117f8:	eb00029f 	cmp	x20, x0
ffffffffea8117fc:	540004e3 	b.cc	ffffffffea811898 <alloc_region+0x118>  // b.lo, b.ul, b.last
ffffffffea811800:	f94022e1 	ldr	x1, [x23, #64]
ffffffffea811804:	8b010000 	add	x0, x0, x1
ffffffffea811808:	d1000400 	sub	x0, x0, #0x1
ffffffffea81180c:	eb00029f 	cmp	x20, x0
ffffffffea811810:	54000448 	b.hi	ffffffffea811898 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 < vaddr)
ffffffffea811814:	d10006d6 	sub	x22, x22, #0x1
ffffffffea811818:	8b1402d6 	add	x22, x22, x20
ffffffffea81181c:	eb16029f 	cmp	x20, x22
ffffffffea811820:	540003c8 	b.hi	ffffffffea811898 <alloc_region+0x118>  // b.pmore
    if (vaddr + size - 1 > aspace->base + aspace->size - 1)
ffffffffea811824:	eb16001f 	cmp	x0, x22
ffffffffea811828:	54000383 	b.cc	ffffffffea811898 <alloc_region+0x118>  // b.lo, b.ul, b.last
	if (list->next != list) {
ffffffffea81182c:	f9402ae0 	ldr	x0, [x23, #80]
    last = list_peek_head_type(&aspace->region_list, vmm_region_t, node);
ffffffffea811830:	910122e2 	add	x2, x23, #0x48
ffffffffea811834:	f100001f 	cmp	x0, #0x0
ffffffffea811838:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea81183c:	54001000 	b.eq	ffffffffea811a3c <alloc_region+0x2bc>  // b.none
    if (!last || r_end < last->base) {
ffffffffea811840:	f9401c03 	ldr	x3, [x0, #56]
ffffffffea811844:	eb16007f 	cmp	x3, x22
ffffffffea811848:	54000fa8 	b.hi	ffffffffea811a3c <alloc_region+0x2bc>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea81184c:	eb00005f 	cmp	x2, x0
ffffffffea811850:	54000061 	b.ne	ffffffffea81185c <alloc_region+0xdc>  // b.any
ffffffffea811854:	14000011 	b	ffffffffea811898 <alloc_region+0x118>
ffffffffea811858:	f9401c03 	ldr	x3, [x0, #56]
        if (r->base > last->base + last->size - 1) {
ffffffffea81185c:	f9402001 	ldr	x1, [x0, #64]
ffffffffea811860:	d1000421 	sub	x1, x1, #0x1
ffffffffea811864:	8b030021 	add	x1, x1, x3
ffffffffea811868:	eb01029f 	cmp	x20, x1
ffffffffea81186c:	54000109 	b.ls	ffffffffea81188c <alloc_region+0x10c>  // b.plast
ffffffffea811870:	f9400401 	ldr	x1, [x0, #8]
	if (item->next != list)
ffffffffea811874:	eb01005f 	cmp	x2, x1
ffffffffea811878:	54000f80 	b.eq	ffffffffea811a68 <alloc_region+0x2e8>  // b.none
            vmm_region_t *next = list_next_type(&aspace->region_list, &last->node, vmm_region_t, node);
ffffffffea81187c:	b4000f61 	cbz	x1, ffffffffea811a68 <alloc_region+0x2e8>
            if (!next || (r_end < next->base)) {
ffffffffea811880:	f9401c23 	ldr	x3, [x1, #56]
ffffffffea811884:	eb16007f 	cmp	x3, x22
ffffffffea811888:	54000f08 	b.hi	ffffffffea811a68 <alloc_region+0x2e8>  // b.pmore
    list_for_every_entry(&aspace->region_list, last, vmm_region_t, node) {
ffffffffea81188c:	f9400400 	ldr	x0, [x0, #8]
ffffffffea811890:	eb00005f 	cmp	x2, x0
ffffffffea811894:	54fffe21 	b.ne	ffffffffea811858 <alloc_region+0xd8>  // b.any
        vaddr = alloc_spot(aspace, size, align_pow2, arch_mmu_flags, &before);
        LTRACEF("alloc_spot returns 0x%lx, before %p\n", vaddr, before);

        if (vaddr == (vaddr_t)-1) {
            LTRACEF("failed to find spot\n");
            free(r);
ffffffffea811898:	aa1303e0 	mov	x0, x19
            return NULL;
ffffffffea81189c:	d2800013 	mov	x19, #0x0                   	// #0
            free(r);
ffffffffea8118a0:	94000948 	bl	ffffffffea813dc0 <free>
        /* add it to the region list */
        list_add_after(before, &r->node);
    }

    return r;
}
ffffffffea8118a4:	aa1303e0 	mov	x0, x19
ffffffffea8118a8:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea8118ac:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8118b0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8118b4:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8118b8:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea8118bc:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8118c0:	d65f03c0 	ret
    vaddr_t align = 1UL << align_pow2;
ffffffffea8118c4:	7100333f 	cmp	w25, #0xc
	if (list->next != list) {
ffffffffea8118c8:	f9402af4 	ldr	x20, [x23, #80]
ffffffffea8118cc:	52800180 	mov	w0, #0xc                   	// #12
ffffffffea8118d0:	1a802339 	csel	w25, w25, w0, cs  // cs = hs, nlast
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea8118d4:	910122fb 	add	x27, x23, #0x48
    vaddr_t align = 1UL << align_pow2;
ffffffffea8118d8:	d2800020 	mov	x0, #0x1                   	// #1
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea8118dc:	f100029f 	cmp	x20, #0x0
    vaddr_t align = 1UL << align_pow2;
ffffffffea8118e0:	9ad92019 	lsl	x25, x0, x25
ffffffffea8118e4:	f9401efa 	ldr	x26, [x23, #56]
                  list_peek_head_type(&aspace->region_list, vmm_region_t, node),
ffffffffea8118e8:	fa541364 	ccmp	x27, x20, #0x4, ne  // ne = any
ffffffffea8118ec:	54000101 	b.ne	ffffffffea81190c <alloc_region+0x18c>  // b.any
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea8118f0:	f94022f5 	ldr	x21, [x23, #64]
ffffffffea8118f4:	8b150355 	add	x21, x26, x21
ffffffffea8118f8:	eb15035f 	cmp	x26, x21
ffffffffea8118fc:	54fffce0 	b.eq	ffffffffea811898 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea811900:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811904:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea811908:	14000006 	b	ffffffffea811920 <alloc_region+0x1a0>
        if (gap_beg == next->base)
ffffffffea81190c:	f9401e95 	ldr	x21, [x20, #56]
ffffffffea811910:	eb1a02bf 	cmp	x21, x26
ffffffffea811914:	54000260 	b.eq	ffffffffea811960 <alloc_region+0x1e0>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811918:	b9403683 	ldr	w3, [x20, #52]
        gap_end = next->base - 1;
ffffffffea81191c:	d10006b5 	sub	x21, x21, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811920:	2a1803e6 	mov	w6, w24
ffffffffea811924:	aa1603e5 	mov	x5, x22
ffffffffea811928:	aa1903e4 	mov	x4, x25
ffffffffea81192c:	aa1503e2 	mov	x2, x21
ffffffffea811930:	52801001 	mov	w1, #0x80                  	// #128
ffffffffea811934:	aa1a03e0 	mov	x0, x26
ffffffffea811938:	97ffff8c 	bl	ffffffffea811768 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea81193c:	eb00035f 	cmp	x26, x0
ffffffffea811940:	54fffac8 	b.hi	ffffffffea811898 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea811944:	eb15001f 	cmp	x0, x21
ffffffffea811948:	540000a2 	b.cs	ffffffffea81195c <alloc_region+0x1dc>  // b.hs, b.nlast
ffffffffea81194c:	910006b5 	add	x21, x21, #0x1
ffffffffea811950:	cb0002b5 	sub	x21, x21, x0
ffffffffea811954:	eb1502df 	cmp	x22, x21
ffffffffea811958:	540003e9 	b.ls	ffffffffea8119d4 <alloc_region+0x254>  // b.plast
ffffffffea81195c:	f9402af4 	ldr	x20, [x23, #80]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811960:	eb14037f 	cmp	x27, x20
ffffffffea811964:	54fff9a0 	b.eq	ffffffffea811898 <alloc_region+0x118>  // b.none
                      list_next_type(&aspace->region_list, &r->node, vmm_region_t, node),
ffffffffea811968:	f9400680 	ldr	x0, [x20, #8]
ffffffffea81196c:	a943ea81 	ldp	x1, x26, [x20, #56]
ffffffffea811970:	f100001f 	cmp	x0, #0x0
ffffffffea811974:	fa401364 	ccmp	x27, x0, #0x4, ne  // ne = any
ffffffffea811978:	8b01035a 	add	x26, x26, x1
ffffffffea81197c:	54000500 	b.eq	ffffffffea811a1c <alloc_region+0x29c>  // b.none
        if (gap_beg == next->base)
ffffffffea811980:	f9401c02 	ldr	x2, [x0, #56]
ffffffffea811984:	eb02035f 	cmp	x26, x2
ffffffffea811988:	54000460 	b.eq	ffffffffea811a14 <alloc_region+0x294>  // b.none
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea81198c:	b9403403 	ldr	w3, [x0, #52]
        gap_end = next->base - 1;
ffffffffea811990:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811994:	b9403681 	ldr	w1, [x20, #52]
ffffffffea811998:	2a1803e6 	mov	w6, w24
ffffffffea81199c:	aa1603e5 	mov	x5, x22
ffffffffea8119a0:	aa1903e4 	mov	x4, x25
ffffffffea8119a4:	aa1503e2 	mov	x2, x21
ffffffffea8119a8:	aa1a03e0 	mov	x0, x26
ffffffffea8119ac:	97ffff6f 	bl	ffffffffea811768 <arch_mmu_pick_spot>
    if (*pva < gap_beg)
ffffffffea8119b0:	eb00035f 	cmp	x26, x0
ffffffffea8119b4:	54fff728 	b.hi	ffffffffea811898 <alloc_region+0x118>  // b.pmore
    if (*pva < gap_end && ((gap_end - *pva + 1) >= size)) {
ffffffffea8119b8:	eb15001f 	cmp	x0, x21
ffffffffea8119bc:	54000282 	b.cs	ffffffffea811a0c <alloc_region+0x28c>  // b.hs, b.nlast
ffffffffea8119c0:	910006a2 	add	x2, x21, #0x1
ffffffffea8119c4:	cb000042 	sub	x2, x2, x0
ffffffffea8119c8:	eb0202df 	cmp	x22, x2
ffffffffea8119cc:	54000208 	b.hi	ffffffffea811a0c <alloc_region+0x28c>  // b.pmore
        *before = r ? &r->node : &aspace->region_list;
ffffffffea8119d0:	aa1403fb 	mov	x27, x20
	item->next = list->next;
ffffffffea8119d4:	f9400761 	ldr	x1, [x27, #8]
ffffffffea8119d8:	a900067b 	stp	x27, x1, [x19]
        r->base = (vaddr_t)vaddr;
ffffffffea8119dc:	f9001e60 	str	x0, [x19, #56]
	list->next->prev = item;
ffffffffea8119e0:	f9400760 	ldr	x0, [x27, #8]
}
ffffffffea8119e4:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8119e8:	f9000013 	str	x19, [x0]
ffffffffea8119ec:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea8119f0:	f9000773 	str	x19, [x27, #8]
ffffffffea8119f4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8119f8:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8119fc:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea811a00:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea811a04:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811a08:	d65f03c0 	ret
ffffffffea811a0c:	f9400694 	ldr	x20, [x20, #8]
ffffffffea811a10:	17ffffd4 	b	ffffffffea811960 <alloc_region+0x1e0>
        if (gap_beg == next->base)
ffffffffea811a14:	aa0003f4 	mov	x20, x0
ffffffffea811a18:	17ffffd2 	b	ffffffffea811960 <alloc_region+0x1e0>
        if (gap_beg == (aspace->base + aspace->size))
ffffffffea811a1c:	a9438af5 	ldp	x21, x2, [x23, #56]
ffffffffea811a20:	8b150042 	add	x2, x2, x21
ffffffffea811a24:	eb1a005f 	cmp	x2, x26
ffffffffea811a28:	54fff380 	b.eq	ffffffffea811898 <alloc_region+0x118>  // b.none
        gap_end = aspace->base + aspace->size - 1;
ffffffffea811a2c:	d1000455 	sub	x21, x2, #0x1
    *pva = arch_mmu_pick_spot(gap_beg, prev ? prev->arch_mmu_flags : ARCH_MMU_FLAG_INVALID,
ffffffffea811a30:	52801003 	mov	w3, #0x80                  	// #128
ffffffffea811a34:	b9403681 	ldr	w1, [x20, #52]
ffffffffea811a38:	17ffffd8 	b	ffffffffea811998 <alloc_region+0x218>
	item->next = list->next;
ffffffffea811a3c:	a9000262 	stp	x2, x0, [x19]
	list->next->prev = item;
ffffffffea811a40:	f9000013 	str	x19, [x0]
}
ffffffffea811a44:	aa1303e0 	mov	x0, x19
	list->next = item;
ffffffffea811a48:	f9002af3 	str	x19, [x23, #80]
ffffffffea811a4c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811a50:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811a54:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea811a58:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea811a5c:	f9402bfb 	ldr	x27, [sp, #80]
ffffffffea811a60:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811a64:	d65f03c0 	ret
	item->next = list->next;
ffffffffea811a68:	a9000660 	stp	x0, x1, [x19]
	list->next->prev = item;
ffffffffea811a6c:	f9400401 	ldr	x1, [x0, #8]
ffffffffea811a70:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea811a74:	f9000413 	str	x19, [x0, #8]
ffffffffea811a78:	17ffff8b 	b	ffffffffea8118a4 <alloc_region+0x124>
ffffffffea811a7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811a80 <vmm_reserve_space>:

status_t vmm_reserve_space(vmm_aspace_t *aspace, const char *name, size_t size, vaddr_t vaddr)
{
ffffffffea811a80:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea811a84:	910003fd 	mov	x29, sp
ffffffffea811a88:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811a8c:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea811a90:	f9001ff8 	str	x24, [sp, #56]
ffffffffea811a94:	aa0003f8 	mov	x24, x0
ffffffffea811a98:	f9402a64 	ldr	x4, [x19, #80]
ffffffffea811a9c:	f90013f5 	str	x21, [sp, #32]
ffffffffea811aa0:	aa0103f5 	mov	x21, x1
ffffffffea811aa4:	f9400080 	ldr	x0, [x4]
ffffffffea811aa8:	f90027a0 	str	x0, [x29, #72]
ffffffffea811aac:	d2800000 	mov	x0, #0x0                   	// #0
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(vaddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea811ab0:	b0000021 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea811ab4:	f10002bf 	cmp	x21, #0x0
ffffffffea811ab8:	91188021 	add	x1, x1, #0x620
ffffffffea811abc:	9a950035 	csel	x21, x1, x21, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea811ac0:	b40006a2 	cbz	x2, ffffffffea811b94 <vmm_reserve_space+0x114>
ffffffffea811ac4:	f9000fb4 	str	x20, [x29, #24]
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(vaddr) || !IS_PAGE_ALIGNED(size))
ffffffffea811ac8:	aa030040 	orr	x0, x2, x3
ffffffffea811acc:	f90017b6 	str	x22, [x29, #40]
ffffffffea811ad0:	aa0203f4 	mov	x20, x2
ffffffffea811ad4:	aa0303f6 	mov	x22, x3
ffffffffea811ad8:	f2402c1f 	tst	x0, #0xfff
ffffffffea811adc:	54000801 	b.ne	ffffffffea811bdc <vmm_reserve_space+0x15c>  // b.any
        return ERR_INVALID_ARGS;

    if (!is_inside_aspace(aspace, vaddr))
ffffffffea811ae0:	f9401f01 	ldr	x1, [x24, #56]
        return ERR_OUT_OF_RANGE;
ffffffffea811ae4:	12800480 	mov	w0, #0xffffffdb            	// #-37
    return (vaddr >= aspace->base && vaddr <= aspace->base + aspace->size - 1);
ffffffffea811ae8:	eb01007f 	cmp	x3, x1
ffffffffea811aec:	540006a3 	b.cc	ffffffffea811bc0 <vmm_reserve_space+0x140>  // b.lo, b.ul, b.last
ffffffffea811af0:	f9402302 	ldr	x2, [x24, #64]
ffffffffea811af4:	f9001bb7 	str	x23, [x29, #48]
ffffffffea811af8:	8b010043 	add	x3, x2, x1
ffffffffea811afc:	d1000463 	sub	x3, x3, #0x1
ffffffffea811b00:	eb0302df 	cmp	x22, x3
ffffffffea811b04:	54000668 	b.hi	ffffffffea811bd0 <vmm_reserve_space+0x150>  // b.pmore
    size_t offset = vaddr - aspace->base;
ffffffffea811b08:	cb0102c0 	sub	x0, x22, x1
    if (offset + size < offset)
ffffffffea811b0c:	8b000281 	add	x1, x20, x0
ffffffffea811b10:	eb01001f 	cmp	x0, x1
ffffffffea811b14:	54000069 	b.ls	ffffffffea811b20 <vmm_reserve_space+0xa0>  // b.plast
        size = ULONG_MAX - offset - 1;
ffffffffea811b18:	92800021 	mov	x1, #0xfffffffffffffffe    	// #-2
ffffffffea811b1c:	cb000034 	sub	x20, x1, x0
    if (offset + size >= aspace->size - 1)
ffffffffea811b20:	d1000443 	sub	x3, x2, #0x1
        size = aspace->size - offset;
ffffffffea811b24:	cb000040 	sub	x0, x2, x0
ffffffffea811b28:	eb03003f 	cmp	x1, x3
ffffffffea811b2c:	90000057 	adrp	x23, ffffffffea819000 <_mem_phys_base>
ffffffffea811b30:	913da2f7 	add	x23, x23, #0xf68
ffffffffea811b34:	9a942014 	csel	x20, x0, x20, cs  // cs = hs, nlast
ffffffffea811b38:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811b3c:	aa1703e0 	mov	x0, x23
ffffffffea811b40:	97ffcf52 	bl	ffffffffea805888 <mutex_acquire_timeout>
    size = trim_to_aspace(aspace, vaddr, size);

    mutex_acquire(&vmm_lock);

    /* lookup how it's already mapped */
    uint arch_mmu_flags = 0;
ffffffffea811b44:	910143a2 	add	x2, x29, #0x50
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea811b48:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea811b4c:	aa1603e0 	mov	x0, x22
    uint arch_mmu_flags = 0;
ffffffffea811b50:	b81f4c5f 	str	wzr, [x2, #-12]!
    arch_mmu_query(vaddr, NULL, &arch_mmu_flags);
ffffffffea811b54:	97ffc67d 	bl	ffffffffea803548 <arch_mmu_query>

    /* build a new region structure */
    vmm_region_t *r = alloc_region(aspace, name, size, vaddr, 0, VMM_FLAG_VALLOC_SPECIFIC, VMM_REGION_FLAG_RESERVED, arch_mmu_flags);
ffffffffea811b58:	b94047a7 	ldr	w7, [x29, #68]
ffffffffea811b5c:	52800026 	mov	w6, #0x1                   	// #1
ffffffffea811b60:	aa1403e2 	mov	x2, x20
ffffffffea811b64:	aa1603e3 	mov	x3, x22
ffffffffea811b68:	2a0603e5 	mov	w5, w6
ffffffffea811b6c:	aa1503e1 	mov	x1, x21
ffffffffea811b70:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea811b74:	aa1803e0 	mov	x0, x24
ffffffffea811b78:	97ffff02 	bl	ffffffffea811780 <alloc_region>
ffffffffea811b7c:	aa0003f4 	mov	x20, x0

    mutex_release(&vmm_lock);
ffffffffea811b80:	aa1703e0 	mov	x0, x23
ffffffffea811b84:	97ffcf6d 	bl	ffffffffea805938 <mutex_release>
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea811b88:	b4000234 	cbz	x20, ffffffffea811bcc <vmm_reserve_space+0x14c>
ffffffffea811b8c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811b90:	a942dfb6 	ldp	x22, x23, [x29, #40]
        return NO_ERROR;
ffffffffea811b94:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea811b98:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea811b9c:	f94027a2 	ldr	x2, [x29, #72]
ffffffffea811ba0:	f9400261 	ldr	x1, [x19]
ffffffffea811ba4:	ca010041 	eor	x1, x2, x1
ffffffffea811ba8:	b5000221 	cbnz	x1, ffffffffea811bec <vmm_reserve_space+0x16c>
ffffffffea811bac:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811bb0:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea811bb4:	f9401ff8 	ldr	x24, [sp, #56]
ffffffffea811bb8:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea811bbc:	d65f03c0 	ret
ffffffffea811bc0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811bc4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea811bc8:	17fffff4 	b	ffffffffea811b98 <vmm_reserve_space+0x118>
    return r ? NO_ERROR : ERR_NO_MEMORY;
ffffffffea811bcc:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea811bd0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811bd4:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811bd8:	17fffff0 	b	ffffffffea811b98 <vmm_reserve_space+0x118>
        return ERR_INVALID_ARGS;
ffffffffea811bdc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea811be0:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811be4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea811be8:	17ffffec 	b	ffffffffea811b98 <vmm_reserve_space+0x118>
ffffffffea811bec:	f9000fb4 	str	x20, [x29, #24]
ffffffffea811bf0:	a902dfb6 	stp	x22, x23, [x29, #40]
}
ffffffffea811bf4:	9400084d 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea811bf8 <vmm_alloc_physical>:

status_t vmm_alloc_physical(vmm_aspace_t *aspace, const char *name, size_t size, void **ptr, uint8_t align_log2, paddr_t paddr, uint vmm_flags, uint arch_mmu_flags)
{
ffffffffea811bf8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea811bfc:	910003fd 	mov	x29, sp
ffffffffea811c00:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811c04:	aa0103f3 	mov	x19, x1
    DEBUG_ASSERT(aspace);
    DEBUG_ASSERT(IS_PAGE_ALIGNED(paddr));
    DEBUG_ASSERT(IS_PAGE_ALIGNED(size));

    if (!name)
        name = "";
ffffffffea811c08:	f100027f 	cmp	x19, #0x0
ffffffffea811c0c:	b0000021 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea811c10:	91188021 	add	x1, x1, #0x620
ffffffffea811c14:	9a930033 	csel	x19, x1, x19, eq  // eq = none

    if (!aspace)
        return ERR_INVALID_ARGS;
    if (size == 0)
ffffffffea811c18:	b40006a2 	cbz	x2, ffffffffea811cec <vmm_alloc_physical+0xf4>
ffffffffea811c1c:	f9000fb4 	str	x20, [x29, #24]
ffffffffea811c20:	aa0203f4 	mov	x20, x2
ffffffffea811c24:	f9001bb7 	str	x23, [x29, #48]
ffffffffea811c28:	aa0503f7 	mov	x23, x5
ffffffffea811c2c:	f90027ba 	str	x26, [x29, #72]
ffffffffea811c30:	aa0003fa 	mov	x26, x0
        return NO_ERROR;
    if (!IS_PAGE_ALIGNED(paddr) || !IS_PAGE_ALIGNED(size))
ffffffffea811c34:	aa050040 	orr	x0, x2, x5
ffffffffea811c38:	f2402c1f 	tst	x0, #0xfff
ffffffffea811c3c:	540008a1 	b.ne	ffffffffea811d50 <vmm_alloc_physical+0x158>  // b.any
ffffffffea811c40:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea811c44:	aa0303f5 	mov	x21, x3
ffffffffea811c48:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea811c4c:	2a0603f6 	mov	w22, w6
ffffffffea811c50:	f9002bbb 	str	x27, [x29, #80]
ffffffffea811c54:	2a0703f8 	mov	w24, w7
ffffffffea811c58:	12001c9b 	and	w27, w4, #0xff
        return ERR_INVALID_ARGS;

    /* if they're asking for a specific spot, copy the address */
    if (vmm_flags & VMM_FLAG_VALLOC_SPECIFIC) {
ffffffffea811c5c:	36000536 	tbz	w22, #0, ffffffffea811d00 <vmm_alloc_physical+0x108>
        /* can't ask for a specific spot and then not provide one */
        if (!ptr) {
ffffffffea811c60:	b4000823 	cbz	x3, ffffffffea811d64 <vmm_alloc_physical+0x16c>
ffffffffea811c64:	f9002fbc 	str	x28, [x29, #88]
ffffffffea811c68:	12800001 	mov	w1, #0xffffffff            	// #-1
            return ERR_INVALID_ARGS;
        }
        vaddr = (vaddr_t)*ptr;
ffffffffea811c6c:	f940007c 	ldr	x28, [x3]
ffffffffea811c70:	90000059 	adrp	x25, ffffffffea819000 <_mem_phys_base>
ffffffffea811c74:	913da320 	add	x0, x25, #0xf68
ffffffffea811c78:	97ffcf04 	bl	ffffffffea805888 <mutex_acquire_timeout>
    }

    mutex_acquire(&vmm_lock);

    /* allocate a region and put it in the aspace list */
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea811c7c:	2a1803e7 	mov	w7, w24
ffffffffea811c80:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea811c84:	2a1603e5 	mov	w5, w22
ffffffffea811c88:	2a1b03e4 	mov	w4, w27
ffffffffea811c8c:	aa1c03e3 	mov	x3, x28
ffffffffea811c90:	aa1403e2 	mov	x2, x20
ffffffffea811c94:	aa1303e1 	mov	x1, x19
ffffffffea811c98:	aa1a03e0 	mov	x0, x26
ffffffffea811c9c:	97fffeb9 	bl	ffffffffea811780 <alloc_region>
    if (!r) {
ffffffffea811ca0:	b4000520 	cbz	x0, ffffffffea811d44 <vmm_alloc_physical+0x14c>
ffffffffea811ca4:	f9401c00 	ldr	x0, [x0, #56]
ffffffffea811ca8:	f9402fbc 	ldr	x28, [x29, #88]
        goto err_alloc_region;
    }

    /* return the vaddr if requested */
    if (ptr)
        *ptr = (void *)r->base;
ffffffffea811cac:	f90002a0 	str	x0, [x21]

    /* map all of the pages */
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
    LTRACEF("arch_mmu_map returns %d\n", err);

    ret = NO_ERROR;
ffffffffea811cb0:	52800013 	mov	w19, #0x0                   	// #0
    err = arch_mmu_map(r->base, paddr, size / PAGE_SIZE, arch_mmu_flags);
ffffffffea811cb4:	2a1803e3 	mov	w3, w24
ffffffffea811cb8:	d34cae82 	ubfx	x2, x20, #12, #32
ffffffffea811cbc:	aa1703e1 	mov	x1, x23
ffffffffea811cc0:	97ffc7ba 	bl	ffffffffea803ba8 <arch_mmu_map>

err_alloc_region:
    mutex_release(&vmm_lock);
ffffffffea811cc4:	913da320 	add	x0, x25, #0xf68
ffffffffea811cc8:	97ffcf1c 	bl	ffffffffea805938 <mutex_release>
    return ret;
ffffffffea811ccc:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea811cd0:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811cd4:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea811cd8:	a944efba 	ldp	x26, x27, [x29, #72]
}
ffffffffea811cdc:	2a1303e0 	mov	w0, w19
ffffffffea811ce0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811ce4:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811ce8:	d65f03c0 	ret
        return NO_ERROR;
ffffffffea811cec:	52800013 	mov	w19, #0x0                   	// #0
}
ffffffffea811cf0:	2a1303e0 	mov	w0, w19
ffffffffea811cf4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811cf8:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea811cfc:	d65f03c0 	ret
ffffffffea811d00:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811d04:	90000059 	adrp	x25, ffffffffea819000 <_mem_phys_base>
ffffffffea811d08:	913da320 	add	x0, x25, #0xf68
ffffffffea811d0c:	97ffcedf 	bl	ffffffffea805888 <mutex_acquire_timeout>
    r = alloc_region(aspace, name, size, vaddr, align_log2, vmm_flags, VMM_REGION_FLAG_PHYSICAL, arch_mmu_flags);
ffffffffea811d10:	2a1803e7 	mov	w7, w24
ffffffffea811d14:	52800046 	mov	w6, #0x2                   	// #2
ffffffffea811d18:	2a1603e5 	mov	w5, w22
ffffffffea811d1c:	2a1b03e4 	mov	w4, w27
ffffffffea811d20:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea811d24:	aa1403e2 	mov	x2, x20
ffffffffea811d28:	aa1303e1 	mov	x1, x19
ffffffffea811d2c:	aa1a03e0 	mov	x0, x26
ffffffffea811d30:	97fffe94 	bl	ffffffffea811780 <alloc_region>
    if (!r) {
ffffffffea811d34:	b40000a0 	cbz	x0, ffffffffea811d48 <vmm_alloc_physical+0x150>
ffffffffea811d38:	f9401c00 	ldr	x0, [x0, #56]
    if (ptr)
ffffffffea811d3c:	b4fffbb5 	cbz	x21, ffffffffea811cb0 <vmm_alloc_physical+0xb8>
ffffffffea811d40:	17ffffdb 	b	ffffffffea811cac <vmm_alloc_physical+0xb4>
ffffffffea811d44:	f9402fbc 	ldr	x28, [x29, #88]
        ret = ERR_NO_MEMORY;
ffffffffea811d48:	12800093 	mov	w19, #0xfffffffb            	// #-5
ffffffffea811d4c:	17ffffde 	b	ffffffffea811cc4 <vmm_alloc_physical+0xcc>
        return ERR_INVALID_ARGS;
ffffffffea811d50:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea811d54:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea811d58:	f9401bb7 	ldr	x23, [x29, #48]
ffffffffea811d5c:	f94027ba 	ldr	x26, [x29, #72]
ffffffffea811d60:	17ffffdf 	b	ffffffffea811cdc <vmm_alloc_physical+0xe4>
ffffffffea811d64:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea811d68:	a941d7b4 	ldp	x20, x21, [x29, #24]
ffffffffea811d6c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea811d70:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea811d74:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea811d78:	17ffffd9 	b	ffffffffea811cdc <vmm_alloc_physical+0xe4>
ffffffffea811d7c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811d80 <vmm_free_region>:

    return NULL;
}

status_t vmm_free_region(vmm_aspace_t *aspace, vaddr_t vaddr)
{
ffffffffea811d80:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811d84:	910003fd 	mov	x29, sp
ffffffffea811d88:	a901d7f4 	stp	x20, x21, [sp, #24]
ffffffffea811d8c:	aa0003f4 	mov	x20, x0
ffffffffea811d90:	f90017f6 	str	x22, [sp, #40]
ffffffffea811d94:	aa0103f5 	mov	x21, x1
ffffffffea811d98:	90000056 	adrp	x22, ffffffffea819000 <_mem_phys_base>
ffffffffea811d9c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea811da0:	913da2c0 	add	x0, x22, #0xf68
ffffffffea811da4:	97ffceb9 	bl	ffffffffea805888 <mutex_acquire_timeout>
    if (!aspace)
ffffffffea811da8:	b4000254 	cbz	x20, ffffffffea811df0 <vmm_free_region+0x70>
ffffffffea811dac:	f9000bb3 	str	x19, [x29, #16]
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811db0:	91012283 	add	x3, x20, #0x48
ffffffffea811db4:	f9402a93 	ldr	x19, [x20, #80]
ffffffffea811db8:	eb13007f 	cmp	x3, x19
ffffffffea811dbc:	54000180 	b.eq	ffffffffea811dec <vmm_free_region+0x6c>  // b.none
        if ((vaddr >= r->base) && (vaddr <= r->base + r->size - 1))
ffffffffea811dc0:	f9401e60 	ldr	x0, [x19, #56]
ffffffffea811dc4:	eb0002bf 	cmp	x21, x0
ffffffffea811dc8:	540000c3 	b.cc	ffffffffea811de0 <vmm_free_region+0x60>  // b.lo, b.ul, b.last
ffffffffea811dcc:	f9402261 	ldr	x1, [x19, #64]
ffffffffea811dd0:	8b010002 	add	x2, x0, x1
ffffffffea811dd4:	d1000442 	sub	x2, x2, #0x1
ffffffffea811dd8:	eb0202bf 	cmp	x21, x2
ffffffffea811ddc:	54000189 	b.ls	ffffffffea811e0c <vmm_free_region+0x8c>  // b.plast
    list_for_every_entry(&aspace->region_list, r, vmm_region_t, node) {
ffffffffea811de0:	f9400673 	ldr	x19, [x19, #8]
ffffffffea811de4:	eb03027f 	cmp	x19, x3
ffffffffea811de8:	54fffec1 	b.ne	ffffffffea811dc0 <vmm_free_region+0x40>  // b.any
ffffffffea811dec:	f9400bb3 	ldr	x19, [x29, #16]
    mutex_acquire(&vmm_lock);

    vmm_region_t *r = vmm_find_region (aspace, vaddr);
    if (!r) {
        mutex_release(&vmm_lock);
ffffffffea811df0:	913da2c0 	add	x0, x22, #0xf68
ffffffffea811df4:	97ffced1 	bl	ffffffffea805938 <mutex_release>
        return ERR_NOT_FOUND;
ffffffffea811df8:	12800020 	mov	w0, #0xfffffffe            	// #-2

    /* free it */
    free (r);

    return NO_ERROR;
}
ffffffffea811dfc:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea811e00:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811e04:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811e08:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea811e0c:	a9400a63 	ldp	x3, x2, [x19]
	item->prev = item->next = 0;
ffffffffea811e10:	aa1303f4 	mov	x20, x19
    arch_mmu_unmap(r->base, r->size / PAGE_SIZE);
ffffffffea811e14:	d34cac21 	ubfx	x1, x1, #12, #32
	item->next->prev = item->prev;
ffffffffea811e18:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea811e1c:	f9400263 	ldr	x3, [x19]
ffffffffea811e20:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea811e24:	f900067f 	str	xzr, [x19, #8]
ffffffffea811e28:	f804869f 	str	xzr, [x20], #72
ffffffffea811e2c:	97ffc793 	bl	ffffffffea803c78 <arch_mmu_unmap>
    mutex_release(&vmm_lock);
ffffffffea811e30:	913da2c0 	add	x0, x22, #0xf68
ffffffffea811e34:	97ffcec1 	bl	ffffffffea805938 <mutex_release>
    pmm_free (&r->page_list);
ffffffffea811e38:	aa1403e0 	mov	x0, x20
ffffffffea811e3c:	97fffd21 	bl	ffffffffea8112c0 <pmm_free>
    free (r);
ffffffffea811e40:	aa1303e0 	mov	x0, x19
ffffffffea811e44:	940007df 	bl	ffffffffea813dc0 <free>
    return NO_ERROR;
ffffffffea811e48:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea811e4c:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea811e50:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea811e54:	f94017f6 	ldr	x22, [sp, #40]
ffffffffea811e58:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811e5c:	d65f03c0 	ret

ffffffffea811e60 <__debug_stdio_fgetc>:
{
	return _dputs(s);
}

static int __debug_stdio_fgetc(void *ctx)
{
ffffffffea811e60:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
	return platform_dgetc(c, true);
ffffffffea811e64:	52800021 	mov	w1, #0x1                   	// #1
{
ffffffffea811e68:	910003fd 	mov	x29, sp
ffffffffea811e6c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea811e70:	b0000293 	adrp	x19, ffffffffea862000 <__ctor_list>
	return platform_dgetc(c, true);
ffffffffea811e74:	91009fa0 	add	x0, x29, #0x27
{
ffffffffea811e78:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea811e7c:	f9400262 	ldr	x2, [x19]
ffffffffea811e80:	f90017a2 	str	x2, [x29, #40]
ffffffffea811e84:	d2800002 	mov	x2, #0x0                   	// #0
	return platform_dgetc(c, true);
ffffffffea811e88:	97ffc072 	bl	ffffffffea802050 <platform_dgetc>
	int err;

	err = input_char(&c);
	if (err < 0)
		return err;
	return (unsigned char)c;
ffffffffea811e8c:	7100001f 	cmp	w0, #0x0
ffffffffea811e90:	39409fa2 	ldrb	w2, [x29, #39]
}
ffffffffea811e94:	f94017a3 	ldr	x3, [x29, #40]
ffffffffea811e98:	f9400261 	ldr	x1, [x19]
ffffffffea811e9c:	ca010061 	eor	x1, x3, x1
ffffffffea811ea0:	1a80a040 	csel	w0, w2, w0, ge  // ge = tcont
ffffffffea811ea4:	b5000081 	cbnz	x1, ffffffffea811eb4 <__debug_stdio_fgetc+0x54>
ffffffffea811ea8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea811eac:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811eb0:	d65f03c0 	ret
ffffffffea811eb4:	9400079d 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea811eb8 <out_count>:
{
ffffffffea811eb8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811ebc:	52800004 	mov	w4, #0x0                   	// #0
ffffffffea811ec0:	910003fd 	mov	x29, sp
ffffffffea811ec4:	a9025bf5 	stp	x21, x22, [sp, #32]
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea811ec8:	b0000055 	adrp	x21, ffffffffea81a000 <__stdio_FILEs+0x60>
ffffffffea811ecc:	910062b5 	add	x21, x21, #0x18
{
ffffffffea811ed0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811ed4:	aa0103f6 	mov	x22, x1
ffffffffea811ed8:	aa0003f4 	mov	x20, x0
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea811edc:	f94006b3 	ldr	x19, [x21, #8]
ffffffffea811ee0:	eb15027f 	cmp	x19, x21
ffffffffea811ee4:	54000200 	b.eq	ffffffffea811f24 <out_count+0x6c>  // b.none
		if (cb->print) {
ffffffffea811ee8:	f9400a63 	ldr	x3, [x19, #16]
			cb->print(cb, str, len);
ffffffffea811eec:	aa1303e0 	mov	x0, x19
ffffffffea811ef0:	aa1603e2 	mov	x2, x22
ffffffffea811ef4:	aa1403e1 	mov	x1, x20
		if (cb->print) {
ffffffffea811ef8:	b4000063 	cbz	x3, ffffffffea811f04 <out_count+0x4c>
			cb->print(cb, str, len);
ffffffffea811efc:	d63f0060 	blr	x3
			reg_logger = 1;
ffffffffea811f00:	52800024 	mov	w4, #0x1                   	// #1
	list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
ffffffffea811f04:	f9400673 	ldr	x19, [x19, #8]
ffffffffea811f08:	eb15027f 	cmp	x19, x21
ffffffffea811f0c:	54fffee1 	b.ne	ffffffffea811ee8 <out_count+0x30>  // b.any
	if(!reg_logger) {
ffffffffea811f10:	340000a4 	cbz	w4, ffffffffea811f24 <out_count+0x6c>
}
ffffffffea811f14:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811f18:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea811f1c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea811f20:	d65f03c0 	ret
ffffffffea811f24:	aa1403f3 	mov	x19, x20
ffffffffea811f28:	8b160294 	add	x20, x20, x22
		for (i = 0; i < len; i++)
ffffffffea811f2c:	b4ffff56 	cbz	x22, ffffffffea811f14 <out_count+0x5c>
			platform_dputc(str[i]);
ffffffffea811f30:	38401660 	ldrb	w0, [x19], #1
ffffffffea811f34:	97ffc025 	bl	ffffffffea801fc8 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea811f38:	eb14027f 	cmp	x19, x20
ffffffffea811f3c:	54fffec0 	b.eq	ffffffffea811f14 <out_count+0x5c>  // b.none
			platform_dputc(str[i]);
ffffffffea811f40:	38401660 	ldrb	w0, [x19], #1
ffffffffea811f44:	97ffc021 	bl	ffffffffea801fc8 <platform_dputc>
		for (i = 0; i < len; i++)
ffffffffea811f48:	eb14027f 	cmp	x19, x20
ffffffffea811f4c:	54ffff21 	b.ne	ffffffffea811f30 <out_count+0x78>  // b.any
ffffffffea811f50:	17fffff1 	b	ffffffffea811f14 <out_count+0x5c>
ffffffffea811f54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811f58 <_dprintf_output_func>:

	return 0;
}

static int _dprintf_output_func(const char *str, size_t len, void *state)
{
ffffffffea811f58:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea811f5c:	910003fd 	mov	x29, sp
ffffffffea811f60:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811f64:	aa0003f4 	mov	x20, x0
	size_t n = strnlen(str, len);
ffffffffea811f68:	940008e0 	bl	ffffffffea8142e8 <strnlen>
ffffffffea811f6c:	aa0003f3 	mov	x19, x0

	out_count(str, n);
ffffffffea811f70:	aa0003e1 	mov	x1, x0
ffffffffea811f74:	aa1403e0 	mov	x0, x20
ffffffffea811f78:	97ffffd0 	bl	ffffffffea811eb8 <out_count>
	return n;
}
ffffffffea811f7c:	2a1303e0 	mov	w0, w19
ffffffffea811f80:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea811f84:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea811f88:	d65f03c0 	ret
ffffffffea811f8c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea811f90 <register_print_callback>:
{
ffffffffea811f90:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea811f94:	910003fd 	mov	x29, sp
ffffffffea811f98:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea811f9c:	aa0003f3 	mov	x19, x0
ffffffffea811fa0:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811fa4:	d53b4220 	mrs	x0, daif
ffffffffea811fa8:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea811fac:	37380060 	tbnz	w0, #7, ffffffffea811fb8 <register_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea811fb0:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea811fb4:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea811fb8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea811fbc:	373002e0 	tbnz	w0, #6, ffffffffea812018 <register_print_callback+0x88>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea811fc0:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea811fc4:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea811fc8:	b0000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea811fcc:	913d02b5 	add	x21, x21, #0xf40
ffffffffea811fd0:	aa1503e0 	mov	x0, x21
ffffffffea811fd4:	97ffc23b 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea811fd8:	b0000041 	adrp	x1, ffffffffea81a000 <__stdio_FILEs+0x60>
ffffffffea811fdc:	91006021 	add	x1, x1, #0x18
    arch_spin_unlock(lock);
ffffffffea811fe0:	aa1503e0 	mov	x0, x21
ffffffffea811fe4:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811fe8:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea811fec:	f9400422 	ldr	x2, [x1, #8]
ffffffffea811ff0:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea811ff4:	f9000433 	str	x19, [x1, #8]
ffffffffea811ff8:	97ffc23a 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea811ffc:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea812000:	36000054 	tbz	w20, #0, ffffffffea812008 <register_print_callback+0x78>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812004:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea812008:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81200c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812010:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812014:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea812018:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea81201c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812020:	aa1503e0 	mov	x0, x21
ffffffffea812024:	97ffc227 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea812028:	90000041 	adrp	x1, ffffffffea81a000 <__stdio_FILEs+0x60>
ffffffffea81202c:	91006021 	add	x1, x1, #0x18
    arch_spin_unlock(lock);
ffffffffea812030:	aa1503e0 	mov	x0, x21
ffffffffea812034:	f9400422 	ldr	x2, [x1, #8]
ffffffffea812038:	a9000a61 	stp	x1, x2, [x19]
	list->next->prev = item;
ffffffffea81203c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea812040:	f9000053 	str	x19, [x2]
	list->next = item;
ffffffffea812044:	f9000433 	str	x19, [x1, #8]
ffffffffea812048:	97ffc226 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea81204c:	17ffffed 	b	ffffffffea812000 <register_print_callback+0x70>

ffffffffea812050 <unregister_print_callback>:
{
ffffffffea812050:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea812054:	910003fd 	mov	x29, sp
ffffffffea812058:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81205c:	aa0003f3 	mov	x19, x0
ffffffffea812060:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812064:	d53b4220 	mrs	x0, daif
ffffffffea812068:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea81206c:	37380060 	tbnz	w0, #7, ffffffffea812078 <unregister_print_callback+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812070:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea812074:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812078:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea81207c:	373002a0 	tbnz	w0, #6, ffffffffea8120d0 <unregister_print_callback+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea812080:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea812084:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea812088:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea81208c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812090:	aa1503e0 	mov	x0, x21
ffffffffea812094:	97ffc20b 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea812098:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea81209c:	aa1503e0 	mov	x0, x21
ffffffffea8120a0:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea8120a4:	f9400262 	ldr	x2, [x19]
ffffffffea8120a8:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8120ac:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea8120b0:	97ffc20c 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea8120b4:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea8120b8:	36000054 	tbz	w20, #0, ffffffffea8120c0 <unregister_print_callback+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea8120bc:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea8120c0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8120c4:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8120c8:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8120cc:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8120d0:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8120d4:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8120d8:	aa1503e0 	mov	x0, x21
ffffffffea8120dc:	97ffc1f9 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next->prev = item->prev;
ffffffffea8120e0:	a9400662 	ldp	x2, x1, [x19]
    arch_spin_unlock(lock);
ffffffffea8120e4:	aa1503e0 	mov	x0, x21
ffffffffea8120e8:	f9000022 	str	x2, [x1]
	item->prev->next = item->next;
ffffffffea8120ec:	f9400262 	ldr	x2, [x19]
ffffffffea8120f0:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea8120f4:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea8120f8:	97ffc1fa 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8120fc:	17ffffef 	b	ffffffffea8120b8 <unregister_print_callback+0x68>

ffffffffea812100 <_dputc>:
{
ffffffffea812100:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea812104:	910003fd 	mov	x29, sp
ffffffffea812108:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81210c:	90000293 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea812110:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea812114:	12001c16 	and	w22, w0, #0xff
ffffffffea812118:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea81211c:	f9400001 	ldr	x1, [x0]
ffffffffea812120:	f9001fa1 	str	x1, [x29, #56]
ffffffffea812124:	d2800001 	mov	x1, #0x0                   	// #0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812128:	d53b4220 	mrs	x0, daif
ffffffffea81212c:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea812130:	37380060 	tbnz	w0, #7, ffffffffea81213c <_dputc+0x3c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812134:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea812138:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea81213c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea812140:	37300320 	tbnz	w0, #6, ffffffffea8121a4 <_dputc+0xa4>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea812144:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea812148:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea81214c:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812150:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812154:	aa1503e0 	mov	x0, x21
ffffffffea812158:	97ffc1da 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea81215c:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea812160:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea812164:	381f7c16 	strb	w22, [x0, #-9]!
ffffffffea812168:	97ffff54 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea81216c:	aa1503e0 	mov	x0, x21
ffffffffea812170:	97ffc1dc 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea812174:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea812178:	36000054 	tbz	w20, #0, ffffffffea812180 <_dputc+0x80>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea81217c:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea812180:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea812184:	f9401fa1 	ldr	x1, [x29, #56]
ffffffffea812188:	f9400260 	ldr	x0, [x19]
ffffffffea81218c:	ca000020 	eor	x0, x1, x0
ffffffffea812190:	b5000200 	cbnz	x0, ffffffffea8121d0 <_dputc+0xd0>
ffffffffea812194:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812198:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81219c:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea8121a0:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8121a4:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8121a8:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8121ac:	aa1503e0 	mov	x0, x21
ffffffffea8121b0:	97ffc1c4 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea8121b4:	910103a0 	add	x0, x29, #0x40
	out_count(&c, 1);
ffffffffea8121b8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8121bc:	381f7c16 	strb	w22, [x0, #-9]!
ffffffffea8121c0:	97ffff3e 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea8121c4:	aa1503e0 	mov	x0, x21
ffffffffea8121c8:	97ffc1c6 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8121cc:	17ffffeb 	b	ffffffffea812178 <_dputc+0x78>
}
ffffffffea8121d0:	940006d6 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8121d4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8121d8 <__debug_stdio_fputc>:
{
ffffffffea8121d8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
	_dputc(c);
ffffffffea8121dc:	2a0103e0 	mov	w0, w1
{
ffffffffea8121e0:	910003fd 	mov	x29, sp
	_dputc(c);
ffffffffea8121e4:	97ffffc7 	bl	ffffffffea812100 <_dputc>
}
ffffffffea8121e8:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea8121ec:	a8c17bfd 	ldp	x29, x30, [sp], #16
ffffffffea8121f0:	d65f03c0 	ret
ffffffffea8121f4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8121f8 <_dputs>:
{
ffffffffea8121f8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8121fc:	910003fd 	mov	x29, sp
ffffffffea812200:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea812204:	aa0003f4 	mov	x20, x0
ffffffffea812208:	f90013f5 	str	x21, [sp, #32]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea81220c:	d53b4220 	mrs	x0, daif
ffffffffea812210:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea812214:	37380060 	tbnz	w0, #7, ffffffffea812220 <_dputs+0x28>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812218:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea81221c:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812220:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea812224:	373002c0 	tbnz	w0, #6, ffffffffea81227c <_dputs+0x84>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea812228:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea81222c:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea812230:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812234:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812238:	aa1503e0 	mov	x0, x21
ffffffffea81223c:	97ffc1a1 	bl	ffffffffea8028c0 <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea812240:	aa1403e0 	mov	x0, x20
ffffffffea812244:	940007ff 	bl	ffffffffea814240 <strlen>
ffffffffea812248:	aa0003e1 	mov	x1, x0
ffffffffea81224c:	aa1403e0 	mov	x0, x20
ffffffffea812250:	97ffff1a 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea812254:	aa1503e0 	mov	x0, x21
ffffffffea812258:	97ffc1a2 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea81225c:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea812260:	36000053 	tbz	w19, #0, ffffffffea812268 <_dputs+0x70>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812264:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea812268:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea81226c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812270:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812274:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812278:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea81227c:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812280:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812284:	aa1503e0 	mov	x0, x21
ffffffffea812288:	97ffc18e 	bl	ffffffffea8028c0 <arch_spin_lock>
	out_count(str, strlen(str));
ffffffffea81228c:	aa1403e0 	mov	x0, x20
ffffffffea812290:	940007ec 	bl	ffffffffea814240 <strlen>
ffffffffea812294:	aa0003e1 	mov	x1, x0
ffffffffea812298:	aa1403e0 	mov	x0, x20
ffffffffea81229c:	97ffff07 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea8122a0:	aa1503e0 	mov	x0, x21
ffffffffea8122a4:	97ffc18f 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8122a8:	17ffffee 	b	ffffffffea812260 <_dputs+0x68>
ffffffffea8122ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8122b0 <__debug_stdio_fputs>:
	return _dputs(s);
ffffffffea8122b0:	aa0103e0 	mov	x0, x1
ffffffffea8122b4:	17ffffd1 	b	ffffffffea8121f8 <_dputs>

ffffffffea8122b8 <_dwrite>:
{
ffffffffea8122b8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea8122bc:	910003fd 	mov	x29, sp
ffffffffea8122c0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8122c4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8122c8:	aa0003f5 	mov	x21, x0
ffffffffea8122cc:	aa0103f6 	mov	x22, x1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8122d0:	d53b4220 	mrs	x0, daif
ffffffffea8122d4:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8122d8:	37380060 	tbnz	w0, #7, ffffffffea8122e4 <_dwrite+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8122dc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8122e0:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8122e4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8122e8:	37300280 	tbnz	w0, #6, ffffffffea812338 <_dwrite+0x80>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8122ec:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8122f0:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8122f4:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8122f8:	913d0294 	add	x20, x20, #0xf40
ffffffffea8122fc:	aa1403e0 	mov	x0, x20
ffffffffea812300:	97ffc170 	bl	ffffffffea8028c0 <arch_spin_lock>
	out_count(ptr, len);
ffffffffea812304:	aa1603e1 	mov	x1, x22
ffffffffea812308:	aa1503e0 	mov	x0, x21
ffffffffea81230c:	97fffeeb 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea812310:	aa1403e0 	mov	x0, x20
ffffffffea812314:	97ffc173 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea812318:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea81231c:	36000053 	tbz	w19, #0, ffffffffea812324 <_dwrite+0x6c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812320:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea812324:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea812328:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81232c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812330:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812334:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea812338:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea81233c:	913d0294 	add	x20, x20, #0xf40
ffffffffea812340:	aa1403e0 	mov	x0, x20
ffffffffea812344:	97ffc15f 	bl	ffffffffea8028c0 <arch_spin_lock>
	out_count(ptr, len);
ffffffffea812348:	aa1603e1 	mov	x1, x22
ffffffffea81234c:	aa1503e0 	mov	x0, x21
ffffffffea812350:	97fffeda 	bl	ffffffffea811eb8 <out_count>
    arch_spin_unlock(lock);
ffffffffea812354:	aa1403e0 	mov	x0, x20
ffffffffea812358:	97ffc162 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea81235c:	17fffff0 	b	ffffffffea81231c <_dwrite+0x64>

ffffffffea812360 <_dprintf>:

int _dprintf(const char *fmt, ...)
{
ffffffffea812360:	a9b47bfd 	stp	x29, x30, [sp, #-192]!
	spin_lock_saved_state_t state;
	int err;
	va_list ap;

	va_start(ap, fmt);
ffffffffea812364:	128006e8 	mov	w8, #0xffffffc8            	// #-56
{
ffffffffea812368:	910003fd 	mov	x29, sp
ffffffffea81236c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea812370:	90000293 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea812374:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea812378:	aa0003f6 	mov	x22, x0
ffffffffea81237c:	a9088ba1 	stp	x1, x2, [x29, #136]
	va_start(ap, fmt);
ffffffffea812380:	910203a9 	add	x9, x29, #0x80
{
ffffffffea812384:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea812388:	a90993a3 	stp	x3, x4, [x29, #152]
ffffffffea81238c:	a90a9ba5 	stp	x5, x6, [x29, #168]
ffffffffea812390:	f9005fa7 	str	x7, [x29, #184]
	va_start(ap, fmt);
ffffffffea812394:	f90037a9 	str	x9, [x29, #104]
{
ffffffffea812398:	f9400001 	ldr	x1, [x0]
ffffffffea81239c:	f9003fa1 	str	x1, [x29, #120]
ffffffffea8123a0:	d2800001 	mov	x1, #0x0                   	// #0
	va_start(ap, fmt);
ffffffffea8123a4:	290e7fa8 	stp	w8, wzr, [x29, #112]
ffffffffea8123a8:	910303a0 	add	x0, x29, #0xc0
ffffffffea8123ac:	a90583a0 	stp	x0, x0, [x29, #88]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8123b0:	d53b4220 	mrs	x0, daif
ffffffffea8123b4:	52800014 	mov	w20, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8123b8:	37380060 	tbnz	w0, #7, ffffffffea8123c4 <_dprintf+0x64>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8123bc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8123c0:	52800034 	mov	w20, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8123c4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8123c8:	37300420 	tbnz	w0, #6, ffffffffea81244c <_dprintf+0xec>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8123cc:	321f0294 	orr	w20, w20, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8123d0:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8123d4:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8123d8:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8123dc:	aa1503e0 	mov	x0, x21
ffffffffea8123e0:	97ffc138 	bl	ffffffffea8028c0 <arch_spin_lock>
	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea8123e4:	a9459fa6 	ldp	x6, x7, [x29, #88]
ffffffffea8123e8:	aa1603e2 	mov	x2, x22
ffffffffea8123ec:	a94697a4 	ldp	x4, x5, [x29, #104]
ffffffffea8123f0:	9100c3a3 	add	x3, x29, #0x30
ffffffffea8123f4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8123f8:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea8123fc:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea812400:	f0ffffe0 	adrp	x0, ffffffffea811000 <pmm_add_arena+0xd0>
ffffffffea812404:	913d6000 	add	x0, x0, #0xf58
ffffffffea812408:	94000326 	bl	ffffffffea8130a0 <_printf_engine>
ffffffffea81240c:	2a0003f6 	mov	w22, w0
    arch_spin_unlock(lock);
ffffffffea812410:	aa1503e0 	mov	x0, x21
ffffffffea812414:	97ffc133 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea812418:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea81241c:	36000054 	tbz	w20, #0, ffffffffea812424 <_dprintf+0xc4>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812420:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
	va_end(ap);

	return err;
}
ffffffffea812424:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea812428:	2a1603e0 	mov	w0, w22
ffffffffea81242c:	f9403fa2 	ldr	x2, [x29, #120]
ffffffffea812430:	f9400261 	ldr	x1, [x19]
ffffffffea812434:	ca010041 	eor	x1, x2, x1
ffffffffea812438:	b50002e1 	cbnz	x1, ffffffffea812494 <_dprintf+0x134>
ffffffffea81243c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812440:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812444:	a8cc7bfd 	ldp	x29, x30, [sp], #192
ffffffffea812448:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea81244c:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812450:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812454:	aa1503e0 	mov	x0, x21
ffffffffea812458:	97ffc11a 	bl	ffffffffea8028c0 <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea81245c:	a9459fa6 	ldp	x6, x7, [x29, #88]
ffffffffea812460:	aa1603e2 	mov	x2, x22
ffffffffea812464:	a94697a4 	ldp	x4, x5, [x29, #104]
ffffffffea812468:	9100c3a3 	add	x3, x29, #0x30
ffffffffea81246c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea812470:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea812474:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea812478:	f0ffffe0 	adrp	x0, ffffffffea811000 <pmm_add_arena+0xd0>
ffffffffea81247c:	913d6000 	add	x0, x0, #0xf58
ffffffffea812480:	94000308 	bl	ffffffffea8130a0 <_printf_engine>
ffffffffea812484:	2a0003f6 	mov	w22, w0
    arch_spin_unlock(lock);
ffffffffea812488:	aa1503e0 	mov	x0, x21
ffffffffea81248c:	97ffc115 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea812490:	17ffffe3 	b	ffffffffea81241c <_dprintf+0xbc>
}
ffffffffea812494:	94000625 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea812498 <_dvprintf>:

int _dvprintf(const char *fmt, va_list ap)
{
ffffffffea812498:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea81249c:	910003fd 	mov	x29, sp
ffffffffea8124a0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8124a4:	aa0103f4 	mov	x20, x1
ffffffffea8124a8:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8124ac:	aa0003f6 	mov	x22, x0
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8124b0:	d53b4220 	mrs	x0, daif
ffffffffea8124b4:	52800013 	mov	w19, #0x0                   	// #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8124b8:	37380060 	tbnz	w0, #7, ffffffffea8124c4 <_dvprintf+0x2c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8124bc:	d50342df 	msr	daifset, #0x2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea8124c0:	52800033 	mov	w19, #0x1                   	// #1
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8124c4:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_FIQ) && !arch_fiqs_disabled()) {
ffffffffea8124c8:	37300380 	tbnz	w0, #6, ffffffffea812538 <_dvprintf+0xa0>
        state |= SPIN_LOCK_STATE_RESTORE_FIQ;
ffffffffea8124cc:	321f0273 	orr	w19, w19, #0x2
    __asm__ volatile("msr daifset, #1" ::: "memory");
ffffffffea8124d0:	d50341df 	msr	daifset, #0x1
    arch_spin_lock(lock);
ffffffffea8124d4:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8124d8:	913d02b5 	add	x21, x21, #0xf40
ffffffffea8124dc:	aa1503e0 	mov	x0, x21
ffffffffea8124e0:	97ffc0f8 	bl	ffffffffea8028c0 <arch_spin_lock>
	spin_lock_saved_state_t state;
	int err;

	spin_lock_save(&print_spin_lock, &state, PRINT_LOCK_FLAGS);
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea8124e4:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea8124e8:	9100c3a3 	add	x3, x29, #0x30
ffffffffea8124ec:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea8124f0:	aa1603e2 	mov	x2, x22
ffffffffea8124f4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8124f8:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea8124fc:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea812500:	f0ffffe0 	adrp	x0, ffffffffea811000 <pmm_add_arena+0xd0>
ffffffffea812504:	913d6000 	add	x0, x0, #0xf58
ffffffffea812508:	940002e6 	bl	ffffffffea8130a0 <_printf_engine>
ffffffffea81250c:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea812510:	aa1503e0 	mov	x0, x21
ffffffffea812514:	97ffc0f3 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #1" ::: "memory");
ffffffffea812518:	d50341ff 	msr	daifclr, #0x1
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea81251c:	36000053 	tbz	w19, #0, ffffffffea812524 <_dvprintf+0x8c>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812520:	d50342ff 	msr	daifclr, #0x2
	spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);

	return err;
}
ffffffffea812524:	2a1403e0 	mov	w0, w20
ffffffffea812528:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81252c:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea812530:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea812534:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea812538:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea81253c:	913d02b5 	add	x21, x21, #0xf40
ffffffffea812540:	aa1503e0 	mov	x0, x21
ffffffffea812544:	97ffc0df 	bl	ffffffffea8028c0 <arch_spin_lock>
	err = _printf_engine(&_dprintf_output_func, NULL, fmt, ap);
ffffffffea812548:	a9401e86 	ldp	x6, x7, [x20]
ffffffffea81254c:	9100c3a3 	add	x3, x29, #0x30
ffffffffea812550:	a9411684 	ldp	x4, x5, [x20, #16]
ffffffffea812554:	aa1603e2 	mov	x2, x22
ffffffffea812558:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea81255c:	a9031fa6 	stp	x6, x7, [x29, #48]
ffffffffea812560:	a90417a4 	stp	x4, x5, [x29, #64]
ffffffffea812564:	f0ffffe0 	adrp	x0, ffffffffea811000 <pmm_add_arena+0xd0>
ffffffffea812568:	913d6000 	add	x0, x0, #0xf58
ffffffffea81256c:	940002cd 	bl	ffffffffea8130a0 <_printf_engine>
ffffffffea812570:	2a0003f4 	mov	w20, w0
    arch_spin_unlock(lock);
ffffffffea812574:	aa1503e0 	mov	x0, x21
ffffffffea812578:	97ffc0da 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea81257c:	17ffffe8 	b	ffffffffea81251c <_dvprintf+0x84>

ffffffffea812580 <_panic>:
{
ffffffffea812580:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
ffffffffea812584:	90000288 	adrp	x8, ffffffffea862000 <__ctor_list>
ffffffffea812588:	910003fd 	mov	x29, sp
ffffffffea81258c:	f9402908 	ldr	x8, [x8, #80]
ffffffffea812590:	f9000bf3 	str	x19, [sp, #16]
ffffffffea812594:	aa0103f3 	mov	x19, x1
ffffffffea812598:	a9070fa2 	stp	x2, x3, [x29, #112]
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea81259c:	aa0003e1 	mov	x1, x0
{
ffffffffea8125a0:	a90817a4 	stp	x4, x5, [x29, #128]
ffffffffea8125a4:	a9091fa6 	stp	x6, x7, [x29, #144]
ffffffffea8125a8:	f9400100 	ldr	x0, [x8]
ffffffffea8125ac:	f90037a0 	str	x0, [x29, #104]
ffffffffea8125b0:	d2800000 	mov	x0, #0x0                   	// #0
	dprintf(ALWAYS, "panic (caller %p): ", caller);
ffffffffea8125b4:	d0000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8125b8:	91180000 	add	x0, x0, #0x600
ffffffffea8125bc:	97ffff69 	bl	ffffffffea812360 <_dprintf>
	va_start(ap, fmt);
ffffffffea8125c0:	b90067bf 	str	wzr, [x29, #100]
ffffffffea8125c4:	910283a0 	add	x0, x29, #0xa0
ffffffffea8125c8:	a90483a0 	stp	x0, x0, [x29, #72]
ffffffffea8125cc:	9101c3a1 	add	x1, x29, #0x70
ffffffffea8125d0:	128005e0 	mov	w0, #0xffffffd0            	// #-48
ffffffffea8125d4:	f9002fa1 	str	x1, [x29, #88]
	_dvprintf(fmt, ap);
ffffffffea8125d8:	910083a1 	add	x1, x29, #0x20
	va_start(ap, fmt);
ffffffffea8125dc:	b90063a0 	str	w0, [x29, #96]
	_dvprintf(fmt, ap);
ffffffffea8125e0:	aa1303e0 	mov	x0, x19
ffffffffea8125e4:	a9448fa2 	ldp	x2, x3, [x29, #72]
ffffffffea8125e8:	a9020fa2 	stp	x2, x3, [x29, #32]
ffffffffea8125ec:	a9458fa2 	ldp	x2, x3, [x29, #88]
ffffffffea8125f0:	a9030fa2 	stp	x2, x3, [x29, #48]
ffffffffea8125f4:	97ffffa9 	bl	ffffffffea812498 <_dvprintf>
	platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
ffffffffea8125f8:	52800121 	mov	w1, #0x9                   	// #9
ffffffffea8125fc:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea812600:	97ffd574 	bl	ffffffffea807bd0 <platform_halt>
ffffffffea812604:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812608 <__debug_stdio_vfprintf>:
{
ffffffffea812608:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81260c:	aa0103e0 	mov	x0, x1
ffffffffea812610:	910003fd 	mov	x29, sp
	return _dvprintf(fmt, ap);
ffffffffea812614:	a9401444 	ldp	x4, x5, [x2]
ffffffffea812618:	910043a1 	add	x1, x29, #0x10
ffffffffea81261c:	a9410c42 	ldp	x2, x3, [x2, #16]
ffffffffea812620:	a90117a4 	stp	x4, x5, [x29, #16]
ffffffffea812624:	a9020fa2 	stp	x2, x3, [x29, #32]
ffffffffea812628:	97ffff9c 	bl	ffffffffea812498 <_dvprintf>
}
ffffffffea81262c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812630:	d65f03c0 	ret
ffffffffea812634:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812638 <heap_insert_free_chunk>:
static ssize_t heap_grow(size_t len);

// try to insert this free chunk into the free list, consuming the chunk by merging it with
// nearby ones if possible. Returns base of whatever chunk it became in the list.
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
{
ffffffffea812638:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea81263c:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea812640:	910003fd 	mov	x29, sp
ffffffffea812644:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea812648:	aa0003f3 	mov	x19, x0
ffffffffea81264c:	f90013f5 	str	x21, [sp, #32]
ffffffffea812650:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812654:	913d2295 	add	x21, x20, #0xf48
ffffffffea812658:	910082a0 	add	x0, x21, #0x20
ffffffffea81265c:	97ffcc8b 	bl	ffffffffea805888 <mutex_acquire_timeout>
	struct free_heap_chunk *next_chunk;
	struct free_heap_chunk *last_chunk;

	mutex_acquire(&theheap.lock);

	theheap.remaining += chunk->len;
ffffffffea812660:	f9400a63 	ldr	x3, [x19, #16]

	// walk through the list, finding the node to insert before
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea812664:	910162a1 	add	x1, x21, #0x58
	theheap.remaining += chunk->len;
ffffffffea812668:	f9400aa2 	ldr	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea81266c:	f94032a0 	ldr	x0, [x21, #96]
	theheap.remaining += chunk->len;
ffffffffea812670:	8b030042 	add	x2, x2, x3
ffffffffea812674:	f9000aa2 	str	x2, [x21, #16]
	list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
ffffffffea812678:	eb01001f 	cmp	x0, x1
ffffffffea81267c:	540000a1 	b.ne	ffffffffea812690 <heap_insert_free_chunk+0x58>  // b.any
ffffffffea812680:	14000022 	b	ffffffffea812708 <heap_insert_free_chunk+0xd0>
ffffffffea812684:	f9400400 	ldr	x0, [x0, #8]
ffffffffea812688:	eb01001f 	cmp	x0, x1
ffffffffea81268c:	540003e0 	b.eq	ffffffffea812708 <heap_insert_free_chunk+0xd0>  // b.none
		if (chunk < next_chunk) {
ffffffffea812690:	eb00027f 	cmp	x19, x0
ffffffffea812694:	54ffff82 	b.cs	ffffffffea812684 <heap_insert_free_chunk+0x4c>  // b.hs, b.nlast
	item->prev = list->prev;
ffffffffea812698:	f9400001 	ldr	x1, [x0]
	// walked off the end of the list, add it at the tail
	list_add_tail(&theheap.free_list, &chunk->node);

	// try to merge with the previous chunk
try_merge:
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea81269c:	913d2282 	add	x2, x20, #0xf48
	item->next = list;
ffffffffea8126a0:	a9000261 	stp	x1, x0, [x19]
ffffffffea8126a4:	91016042 	add	x2, x2, #0x58
	list->prev->next = item;
ffffffffea8126a8:	f9400001 	ldr	x1, [x0]
ffffffffea8126ac:	f9000433 	str	x19, [x1, #8]
	list->prev = item;
ffffffffea8126b0:	f9000013 	str	x19, [x0]
ffffffffea8126b4:	f9400261 	ldr	x1, [x19]
ffffffffea8126b8:	f100003f 	cmp	x1, #0x0
ffffffffea8126bc:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea8126c0:	540000c0 	b.eq	ffffffffea8126d8 <heap_insert_free_chunk+0xa0>  // b.none
	if (last_chunk) {
		if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
ffffffffea8126c4:	f9400822 	ldr	x2, [x1, #16]
ffffffffea8126c8:	8b020024 	add	x4, x1, x2
ffffffffea8126cc:	eb04027f 	cmp	x19, x4
ffffffffea8126d0:	54000360 	b.eq	ffffffffea81273c <heap_insert_free_chunk+0x104>  // b.none
			chunk = last_chunk;
		}
	}

	// try to merge with the next chunk
	if (next_chunk) {
ffffffffea8126d4:	b40000a0 	cbz	x0, ffffffffea8126e8 <heap_insert_free_chunk+0xb0>
		if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
ffffffffea8126d8:	f9400a61 	ldr	x1, [x19, #16]
ffffffffea8126dc:	8b010262 	add	x2, x19, x1
ffffffffea8126e0:	eb02001f 	cmp	x0, x2
ffffffffea8126e4:	54000400 	b.eq	ffffffffea812764 <heap_insert_free_chunk+0x12c>  // b.none
			// remove them from the list
			list_delete(&next_chunk->node);
		}
	}

	mutex_release(&theheap.lock);
ffffffffea8126e8:	913d2280 	add	x0, x20, #0xf48
ffffffffea8126ec:	91008000 	add	x0, x0, #0x20
ffffffffea8126f0:	97ffcc92 	bl	ffffffffea805938 <mutex_release>

	return chunk;
}
ffffffffea8126f4:	aa1303e0 	mov	x0, x19
ffffffffea8126f8:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8126fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812700:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812704:	d65f03c0 	ret
	item->prev = list->prev;
ffffffffea812708:	913d2281 	add	x1, x20, #0xf48
ffffffffea81270c:	aa0103e2 	mov	x2, x1
ffffffffea812710:	f8458c44 	ldr	x4, [x2, #88]!
	item->next = list;
ffffffffea812714:	a9000a64 	stp	x4, x2, [x19]
	list->prev->next = item;
ffffffffea812718:	f9402c24 	ldr	x4, [x1, #88]
ffffffffea81271c:	f9000493 	str	x19, [x4, #8]
	list->prev = item;
ffffffffea812720:	f9002c33 	str	x19, [x1, #88]
	last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
ffffffffea812724:	f9400261 	ldr	x1, [x19]
ffffffffea812728:	f100003f 	cmp	x1, #0x0
ffffffffea81272c:	fa421024 	ccmp	x1, x2, #0x4, ne  // ne = any
ffffffffea812730:	54fffca1 	b.ne	ffffffffea8126c4 <heap_insert_free_chunk+0x8c>  // b.any
	if (next_chunk) {
ffffffffea812734:	b5fffd20 	cbnz	x0, ffffffffea8126d8 <heap_insert_free_chunk+0xa0>
ffffffffea812738:	17ffffec 	b	ffffffffea8126e8 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea81273c:	f9400664 	ldr	x4, [x19, #8]
			last_chunk->len += chunk->len;
ffffffffea812740:	8b020063 	add	x3, x3, x2
ffffffffea812744:	f9000823 	str	x3, [x1, #16]
ffffffffea812748:	f9000081 	str	x1, [x4]
	item->prev->next = item->next;
ffffffffea81274c:	f9400262 	ldr	x2, [x19]
ffffffffea812750:	f9000444 	str	x4, [x2, #8]
	item->prev = item->next = 0;
ffffffffea812754:	a9007e7f 	stp	xzr, xzr, [x19]
ffffffffea812758:	aa0103f3 	mov	x19, x1
	if (next_chunk) {
ffffffffea81275c:	b5fffbe0 	cbnz	x0, ffffffffea8126d8 <heap_insert_free_chunk+0xa0>
ffffffffea812760:	17ffffe2 	b	ffffffffea8126e8 <heap_insert_free_chunk+0xb0>
	item->next->prev = item->prev;
ffffffffea812764:	a9400c04 	ldp	x4, x3, [x0]
			chunk->len += next_chunk->len;
ffffffffea812768:	f9400802 	ldr	x2, [x0, #16]
ffffffffea81276c:	8b010041 	add	x1, x2, x1
ffffffffea812770:	f9000a61 	str	x1, [x19, #16]
ffffffffea812774:	f9000064 	str	x4, [x3]
	item->prev->next = item->next;
ffffffffea812778:	f9400001 	ldr	x1, [x0]
ffffffffea81277c:	f9000423 	str	x3, [x1, #8]
	item->prev = item->next = 0;
ffffffffea812780:	a9007c1f 	stp	xzr, xzr, [x0]
	mutex_release(&theheap.lock);
ffffffffea812784:	913d2280 	add	x0, x20, #0xf48
ffffffffea812788:	91008000 	add	x0, x0, #0x20
ffffffffea81278c:	97ffcc6b 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea812790:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812794:	aa1303e0 	mov	x0, x19
ffffffffea812798:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea81279c:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8127a0:	d65f03c0 	ret
ffffffffea8127a4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8127a8 <heap_free_delayed_list>:

	return chunk;
}

static void heap_free_delayed_list(void)
{
ffffffffea8127a8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea8127ac:	910003fd 	mov	x29, sp
ffffffffea8127b0:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8127b4:	90000294 	adrp	x20, ffffffffea862000 <__ctor_list>
	list->prev = list->next = list;
ffffffffea8127b8:	910123b3 	add	x19, x29, #0x48
ffffffffea8127bc:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8127c0:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea8127c4:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8127c8:	f9400001 	ldr	x1, [x0]
ffffffffea8127cc:	f9002fa1 	str	x1, [x29, #88]
ffffffffea8127d0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8127d4:	a904cfb3 	stp	x19, x19, [x29, #72]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea8127d8:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea8127dc:	373806e0 	tbnz	w0, #7, ffffffffea8128b8 <heap_free_delayed_list+0x110>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea8127e0:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea8127e4:	90000316 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8127e8:	913d22d7 	add	x23, x22, #0xf48
ffffffffea8127ec:	9101e2f8 	add	x24, x23, #0x78
	if (list->next != list) {
ffffffffea8127f0:	9101a2f7 	add	x23, x23, #0x68
ffffffffea8127f4:	aa1803e0 	mov	x0, x24
ffffffffea8127f8:	97ffc032 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea8127fc:	f94006e1 	ldr	x1, [x23, #8]
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
ffffffffea812800:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea812804:	eb17003f 	cmp	x1, x23
ffffffffea812808:	54000720 	b.eq	ffffffffea8128ec <heap_free_delayed_list+0x144>  // b.none
ffffffffea81280c:	913d22c0 	add	x0, x22, #0xf48
ffffffffea812810:	9101a004 	add	x4, x0, #0x68
ffffffffea812814:	d503201f 	nop
	item->next->prev = item->prev;
ffffffffea812818:	a9400823 	ldp	x3, x2, [x1]
ffffffffea81281c:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea812820:	f9400023 	ldr	x3, [x1]
ffffffffea812824:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea812828:	f900043f 	str	xzr, [x1, #8]
	item->next = list->next;
ffffffffea81282c:	f9402ba2 	ldr	x2, [x29, #80]
ffffffffea812830:	a9000833 	stp	x19, x2, [x1]
	list->next->prev = item;
ffffffffea812834:	f9402ba2 	ldr	x2, [x29, #80]
ffffffffea812838:	f9000041 	str	x1, [x2]
	list->next = item;
ffffffffea81283c:	f9002ba1 	str	x1, [x29, #80]
	if (list->next != list) {
ffffffffea812840:	f9403801 	ldr	x1, [x0, #112]
ffffffffea812844:	eb04003f 	cmp	x1, x4
ffffffffea812848:	54fffe81 	b.ne	ffffffffea812818 <heap_free_delayed_list+0x70>  // b.any
    arch_spin_unlock(lock);
ffffffffea81284c:	9101e000 	add	x0, x0, #0x78
ffffffffea812850:	97ffc024 	bl	ffffffffea8028e0 <arch_spin_unlock>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
ffffffffea812854:	34000195 	cbz	w21, ffffffffea812884 <heap_free_delayed_list+0xdc>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812858:	d50342ff 	msr	daifclr, #0x2
ffffffffea81285c:	f9402ba1 	ldr	x1, [x29, #80]
ffffffffea812860:	eb13003f 	cmp	x1, x19
ffffffffea812864:	54000160 	b.eq	ffffffffea812890 <heap_free_delayed_list+0xe8>  // b.none
	item->next->prev = item->prev;
ffffffffea812868:	a9400823 	ldp	x3, x2, [x1]
	}
	spin_unlock_irqrestore(&theheap.delayed_free_lock, state);

	while ((chunk = list_remove_head_type(&list, struct free_heap_chunk, node))) {
		LTRACEF("freeing chunk %p\n", chunk);
		heap_insert_free_chunk(chunk);
ffffffffea81286c:	aa0103e0 	mov	x0, x1
ffffffffea812870:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea812874:	f9400023 	ldr	x3, [x1]
ffffffffea812878:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea81287c:	a9007c3f 	stp	xzr, xzr, [x1]
ffffffffea812880:	97ffff6e 	bl	ffffffffea812638 <heap_insert_free_chunk>
	if (list->next != list) {
ffffffffea812884:	f9402ba1 	ldr	x1, [x29, #80]
ffffffffea812888:	eb13003f 	cmp	x1, x19
ffffffffea81288c:	54fffee1 	b.ne	ffffffffea812868 <heap_free_delayed_list+0xc0>  // b.any
	}
}
ffffffffea812890:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea812894:	f9402fa1 	ldr	x1, [x29, #88]
ffffffffea812898:	f9400280 	ldr	x0, [x20]
ffffffffea81289c:	ca000020 	eor	x0, x1, x0
ffffffffea8128a0:	b50002e0 	cbnz	x0, ffffffffea8128fc <heap_free_delayed_list+0x154>
ffffffffea8128a4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8128a8:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea8128ac:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea8128b0:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea8128b4:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea8128b8:	90000316 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea8128bc:	913d22d7 	add	x23, x22, #0xf48
ffffffffea8128c0:	9101e2f8 	add	x24, x23, #0x78
ffffffffea8128c4:	9101a2f7 	add	x23, x23, #0x68
ffffffffea8128c8:	aa1803e0 	mov	x0, x24
ffffffffea8128cc:	97ffbffd 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea8128d0:	f94006e1 	ldr	x1, [x23, #8]
    spin_lock_saved_state_t state = 0;
ffffffffea8128d4:	52800015 	mov	w21, #0x0                   	// #0
ffffffffea8128d8:	eb17003f 	cmp	x1, x23
ffffffffea8128dc:	54fff981 	b.ne	ffffffffea81280c <heap_free_delayed_list+0x64>  // b.any
    arch_spin_unlock(lock);
ffffffffea8128e0:	aa1803e0 	mov	x0, x24
ffffffffea8128e4:	97ffbfff 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8128e8:	17ffffe7 	b	ffffffffea812884 <heap_free_delayed_list+0xdc>
ffffffffea8128ec:	aa1803e0 	mov	x0, x24
ffffffffea8128f0:	97ffbffc 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea8128f4:	d50342ff 	msr	daifclr, #0x2
ffffffffea8128f8:	17ffffd9 	b	ffffffffea81285c <heap_free_delayed_list+0xb4>
ffffffffea8128fc:	9400050b 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea812900 <heap_alloc>:

void *heap_alloc(size_t size, unsigned int alignment)
{
ffffffffea812900:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
ffffffffea812904:	910003fd 	mov	x29, sp
ffffffffea812908:	a901d7f4 	stp	x20, x21, [sp, #24]
	return (list->next == list) ? true : false;
ffffffffea81290c:	90000315 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812910:	913d22a2 	add	x2, x21, #0xf48
ffffffffea812914:	f9001bf7 	str	x23, [sp, #48]
ffffffffea812918:	2a0103f7 	mov	w23, w1
#endif

	LTRACEF("size %zd, align %d\n", size, alignment);

	// deal with the pending free list
	if (unlikely(!list_is_empty(&theheap.delayed_free_list))) {
ffffffffea81291c:	9101a043 	add	x3, x2, #0x68
ffffffffea812920:	f9403841 	ldr	x1, [x2, #112]
ffffffffea812924:	eb03003f 	cmp	x1, x3
ffffffffea812928:	540014a1 	b.ne	ffffffffea812bbc <heap_alloc+0x2bc>  // b.any
		heap_free_delayed_list();
	}

	// alignment must be power of 2
	if (alignment & (alignment - 1))
ffffffffea81292c:	510006e1 	sub	w1, w23, #0x1
ffffffffea812930:	6a17003f 	tst	w1, w23
ffffffffea812934:	54000a21 	b.ne	ffffffffea812a78 <heap_alloc+0x178>  // b.any
		return NULL;

	// we always put a size field + base pointer + magic in front of the allocation
	size += sizeof(struct alloc_struct_begin);
ffffffffea812938:	91004000 	add	x0, x0, #0x10
ffffffffea81293c:	f9000bb3 	str	x19, [x29, #16]
	// in the spot
	if (size < sizeof(struct free_heap_chunk))
		size = sizeof(struct free_heap_chunk);

	// round up size to a multiple of native pointer size
	size = ROUNDUP(size, sizeof(void *));
ffffffffea812940:	d2800313 	mov	x19, #0x18                  	// #24
ffffffffea812944:	eb13001f 	cmp	x0, x19
ffffffffea812948:	9a932013 	csel	x19, x0, x19, cs  // cs = hs, nlast
ffffffffea81294c:	f90017b6 	str	x22, [x29, #40]
ffffffffea812950:	91001e73 	add	x19, x19, #0x7
ffffffffea812954:	927df273 	and	x19, x19, #0xfffffffffffffff8

	// deal with nonzero alignments
	if (alignment > 0) {
ffffffffea812958:	35001237 	cbnz	w23, ffffffffea812b9c <heap_alloc+0x29c>
	mutex_release(&theheap.lock);

#if WITH_KERNEL_VM
	/* try to grow the heap if we can */
	if (ptr == NULL && retry_count == 0) {
		size_t growby = MAX(HEAP_GROW_SIZE, ROUNDUP(size, PAGE_SIZE));
ffffffffea81295c:	913ffe62 	add	x2, x19, #0xfff
ffffffffea812960:	d2a00020 	mov	x0, #0x10000               	// #65536
ffffffffea812964:	9274cc42 	and	x2, x2, #0xfffffffffffff000
ffffffffea812968:	913d22b4 	add	x20, x21, #0xf48
ffffffffea81296c:	eb00005f 	cmp	x2, x0
ffffffffea812970:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea812974:	9a802042 	csel	x2, x2, x0, cs  // cs = hs, nlast
ffffffffea812978:	91008280 	add	x0, x20, #0x20
}

static ssize_t heap_grow(size_t size)
{
#if WITH_KERNEL_VM
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea81297c:	913ffc56 	add	x22, x2, #0xfff
ffffffffea812980:	97ffcbc2 	bl	ffffffffea805888 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812984:	f9403280 	ldr	x0, [x20, #96]
ffffffffea812988:	91016282 	add	x2, x20, #0x58

	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea81298c:	d34cfed4 	lsr	x20, x22, #12
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812990:	eb02001f 	cmp	x0, x2
ffffffffea812994:	54000160 	b.eq	ffffffffea8129c0 <heap_alloc+0xc0>  // b.none
		if (chunk->len >= size) {
ffffffffea812998:	f9400801 	ldr	x1, [x0, #16]
ffffffffea81299c:	eb13003f 	cmp	x1, x19
ffffffffea8129a0:	540000a3 	b.cc	ffffffffea8129b4 <heap_alloc+0xb4>  // b.lo, b.ul, b.last
ffffffffea8129a4:	1400003b 	b	ffffffffea812a90 <heap_alloc+0x190>
ffffffffea8129a8:	f9400801 	ldr	x1, [x0, #16]
ffffffffea8129ac:	eb01027f 	cmp	x19, x1
ffffffffea8129b0:	54000709 	b.ls	ffffffffea812a90 <heap_alloc+0x190>  // b.plast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea8129b4:	f9400400 	ldr	x0, [x0, #8]
ffffffffea8129b8:	eb02001f 	cmp	x0, x2
ffffffffea8129bc:	54ffff61 	b.ne	ffffffffea8129a8 <heap_alloc+0xa8>  // b.any
	mutex_release(&theheap.lock);
ffffffffea8129c0:	913d22a0 	add	x0, x21, #0xf48
	size = ROUNDUP(size, PAGE_SIZE);
ffffffffea8129c4:	9274ced6 	and	x22, x22, #0xfffffffffffff000
	mutex_release(&theheap.lock);
ffffffffea8129c8:	91008000 	add	x0, x0, #0x20
ffffffffea8129cc:	97ffcbdb 	bl	ffffffffea805938 <mutex_release>
	void *ptr = pmm_alloc_kpages(size / PAGE_SIZE, NULL);
ffffffffea8129d0:	2a1403e0 	mov	w0, w20
ffffffffea8129d4:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8129d8:	97fffa8e 	bl	ffffffffea811410 <pmm_alloc_kpages>
ffffffffea8129dc:	aa0003f4 	mov	x20, x0
	if (!ptr) {
ffffffffea8129e0:	b4000fe0 	cbz	x0, ffffffffea812bdc <heap_alloc+0x2dc>
	chunk->len = len;
ffffffffea8129e4:	f9000816 	str	x22, [x0, #16]
		return ERR_NO_MEMORY;
	}

	LTRACEF("growing heap by 0x%zx bytes, new ptr %p\n", size, ptr);

	heap_insert_free_chunk(heap_create_free_chunk(ptr, size, true));
ffffffffea8129e8:	97ffff14 	bl	ffffffffea812638 <heap_insert_free_chunk>

	/* change the heap start and end variables */
	if ((uintptr_t)ptr < (uintptr_t)theheap.base)
ffffffffea8129ec:	f947a6a1 	ldr	x1, [x21, #3912]
ffffffffea8129f0:	eb14003f 	cmp	x1, x20
ffffffffea8129f4:	54000069 	b.ls	ffffffffea812a00 <heap_alloc+0x100>  // b.plast
		theheap.base = ptr;
ffffffffea8129f8:	aa1403e1 	mov	x1, x20
ffffffffea8129fc:	f907a6b4 	str	x20, [x21, #3912]

	uintptr_t endptr = (uintptr_t)ptr + size;
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea812a00:	913d22a2 	add	x2, x21, #0xf48
	uintptr_t endptr = (uintptr_t)ptr + size;
ffffffffea812a04:	8b160294 	add	x20, x20, x22
	if (endptr > (uintptr_t)theheap.base + theheap.len) {
ffffffffea812a08:	f9400440 	ldr	x0, [x2, #8]
ffffffffea812a0c:	8b000020 	add	x0, x1, x0
ffffffffea812a10:	eb00029f 	cmp	x20, x0
ffffffffea812a14:	54000ce8 	b.hi	ffffffffea812bb0 <heap_alloc+0x2b0>  // b.pmore
		if (err >= 0) {
ffffffffea812a18:	b7f80db6 	tbnz	x22, #63, ffffffffea812bcc <heap_alloc+0x2cc>
ffffffffea812a1c:	913d22b4 	add	x20, x21, #0xf48
ffffffffea812a20:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea812a24:	91008280 	add	x0, x20, #0x20
ffffffffea812a28:	97ffcb98 	bl	ffffffffea805888 <mutex_acquire_timeout>
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812a2c:	91016282 	add	x2, x20, #0x58
ffffffffea812a30:	f9403280 	ldr	x0, [x20, #96]
ffffffffea812a34:	eb02001f 	cmp	x0, x2
ffffffffea812a38:	54000160 	b.eq	ffffffffea812a64 <heap_alloc+0x164>  // b.none
		if (chunk->len >= size) {
ffffffffea812a3c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea812a40:	eb01027f 	cmp	x19, x1
ffffffffea812a44:	540000a8 	b.hi	ffffffffea812a58 <heap_alloc+0x158>  // b.pmore
ffffffffea812a48:	14000012 	b	ffffffffea812a90 <heap_alloc+0x190>
ffffffffea812a4c:	f9400801 	ldr	x1, [x0, #16]
ffffffffea812a50:	eb13003f 	cmp	x1, x19
ffffffffea812a54:	540001e2 	b.cs	ffffffffea812a90 <heap_alloc+0x190>  // b.hs, b.nlast
	list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
ffffffffea812a58:	f9400400 	ldr	x0, [x0, #8]
ffffffffea812a5c:	eb02001f 	cmp	x0, x2
ffffffffea812a60:	54ffff61 	b.ne	ffffffffea812a4c <heap_alloc+0x14c>  // b.any
	mutex_release(&theheap.lock);
ffffffffea812a64:	913d22a0 	add	x0, x21, #0xf48
ffffffffea812a68:	91008000 	add	x0, x0, #0x20
ffffffffea812a6c:	97ffcbb3 	bl	ffffffffea805938 <mutex_release>
ffffffffea812a70:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea812a74:	f94017b6 	ldr	x22, [x29, #40]
		return NULL;
ffffffffea812a78:	d2800014 	mov	x20, #0x0                   	// #0
}
ffffffffea812a7c:	aa1403e0 	mov	x0, x20
ffffffffea812a80:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea812a84:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea812a88:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea812a8c:	d65f03c0 	ret
			struct list_node *next_node = list_next(&theheap.free_list, &chunk->node);
ffffffffea812a90:	a9400806 	ldp	x6, x2, [x0]
	if (item->next != list)
ffffffffea812a94:	913d22a3 	add	x3, x21, #0xf48
ffffffffea812a98:	91016064 	add	x4, x3, #0x58
ffffffffea812a9c:	91006265 	add	x5, x19, #0x18
ffffffffea812aa0:	eb04005f 	cmp	x2, x4
ffffffffea812aa4:	54000560 	b.eq	ffffffffea812b50 <heap_alloc+0x250>  // b.none
	item->next->prev = item->prev;
ffffffffea812aa8:	f9000046 	str	x6, [x2]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea812aac:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea812ab0:	f9400003 	ldr	x3, [x0]
ffffffffea812ab4:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea812ab8:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea812abc:	54000569 	b.ls	ffffffffea812b68 <heap_alloc+0x268>  // b.plast
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea812ac0:	8b130003 	add	x3, x0, x19
	item->prev = list->prev;
ffffffffea812ac4:	f9400044 	ldr	x4, [x2]
ffffffffea812ac8:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea812acc:	f9000861 	str	x1, [x3, #16]
				chunk->len -= chunk->len - size;
ffffffffea812ad0:	f9000813 	str	x19, [x0, #16]
ffffffffea812ad4:	f8336804 	str	x4, [x0, x19]
	list->prev->next = item;
ffffffffea812ad8:	f9400041 	ldr	x1, [x2]
	item->next = list;
ffffffffea812adc:	f9000462 	str	x2, [x3, #8]
	list->prev->next = item;
ffffffffea812ae0:	f9000423 	str	x3, [x1, #8]
	list->prev = item;
ffffffffea812ae4:	f9000043 	str	x3, [x2]
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea812ae8:	2a1703e2 	mov	w2, w23
			ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
ffffffffea812aec:	91004014 	add	x20, x0, #0x10
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea812af0:	d1000441 	sub	x1, x2, #0x1
			theheap.remaining -= size;
ffffffffea812af4:	913d22a3 	add	x3, x21, #0xf48
				ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
ffffffffea812af8:	cb0203e2 	neg	x2, x2
ffffffffea812afc:	8b140021 	add	x1, x1, x20
ffffffffea812b00:	710002ff 	cmp	w23, #0x0
ffffffffea812b04:	8a020021 	and	x1, x1, x2
ffffffffea812b08:	9a810294 	csel	x20, x20, x1, eq  // eq = none
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea812b0c:	a9410861 	ldp	x1, x2, [x3, #16]
			as->size = size;
ffffffffea812b10:	a93f4e80 	stp	x0, x19, [x20, #-16]
			theheap.remaining -= size;
ffffffffea812b14:	cb130033 	sub	x19, x1, x19
ffffffffea812b18:	f9000873 	str	x19, [x3, #16]
			if (theheap.remaining < theheap.low_watermark) {
ffffffffea812b1c:	eb02027f 	cmp	x19, x2
ffffffffea812b20:	54000042 	b.cs	ffffffffea812b28 <heap_alloc+0x228>  // b.hs, b.nlast
				theheap.low_watermark = theheap.remaining;
ffffffffea812b24:	f9000c73 	str	x19, [x3, #24]
	mutex_release(&theheap.lock);
ffffffffea812b28:	913d22a0 	add	x0, x21, #0xf48
ffffffffea812b2c:	91008000 	add	x0, x0, #0x20
ffffffffea812b30:	97ffcb82 	bl	ffffffffea805938 <mutex_release>
ffffffffea812b34:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea812b38:	f94017b6 	ldr	x22, [x29, #40]
}
ffffffffea812b3c:	aa1403e0 	mov	x0, x20
ffffffffea812b40:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea812b44:	a941d7f4 	ldp	x20, x21, [sp, #24]
ffffffffea812b48:	a8c57bfd 	ldp	x29, x30, [sp], #80
ffffffffea812b4c:	d65f03c0 	ret
	item->next->prev = item->prev;
ffffffffea812b50:	f9002c66 	str	x6, [x3, #88]
			if (chunk->len > size + sizeof(struct free_heap_chunk)) {
ffffffffea812b54:	eb05003f 	cmp	x1, x5
	item->prev->next = item->next;
ffffffffea812b58:	f9400004 	ldr	x4, [x0]
ffffffffea812b5c:	f9000482 	str	x2, [x4, #8]
	item->prev = item->next = 0;
ffffffffea812b60:	a9007c1f 	stp	xzr, xzr, [x0]
ffffffffea812b64:	54000068 	b.hi	ffffffffea812b70 <heap_alloc+0x270>  // b.pmore
ffffffffea812b68:	f9400813 	ldr	x19, [x0, #16]
ffffffffea812b6c:	17ffffdf 	b	ffffffffea812ae8 <heap_alloc+0x1e8>
				struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
ffffffffea812b70:	8b130004 	add	x4, x0, x19
	item->prev = list->prev;
ffffffffea812b74:	f9402c65 	ldr	x5, [x3, #88]
ffffffffea812b78:	cb130021 	sub	x1, x1, x19
	chunk->len = len;
ffffffffea812b7c:	f9000881 	str	x1, [x4, #16]
				chunk->len -= chunk->len - size;
ffffffffea812b80:	f9000813 	str	x19, [x0, #16]
ffffffffea812b84:	f8336805 	str	x5, [x0, x19]
	item->next = list;
ffffffffea812b88:	f9000482 	str	x2, [x4, #8]
	list->prev->next = item;
ffffffffea812b8c:	f9402c61 	ldr	x1, [x3, #88]
ffffffffea812b90:	f9000424 	str	x4, [x1, #8]
	list->prev = item;
ffffffffea812b94:	f9002c64 	str	x4, [x3, #88]
ffffffffea812b98:	17ffffd4 	b	ffffffffea812ae8 <heap_alloc+0x1e8>
ffffffffea812b9c:	710042ff 	cmp	w23, #0x10
ffffffffea812ba0:	52800200 	mov	w0, #0x10                  	// #16
ffffffffea812ba4:	1a8022f7 	csel	w23, w23, w0, cs  // cs = hs, nlast
		size += alignment;
ffffffffea812ba8:	8b374273 	add	x19, x19, w23, uxtw
ffffffffea812bac:	17ffff6c 	b	ffffffffea81295c <heap_alloc+0x5c>
		theheap.len = (uintptr_t)endptr - (uintptr_t)theheap.base;
ffffffffea812bb0:	cb010294 	sub	x20, x20, x1
ffffffffea812bb4:	f9000454 	str	x20, [x2, #8]
ffffffffea812bb8:	17ffff98 	b	ffffffffea812a18 <heap_alloc+0x118>
ffffffffea812bbc:	f90027a0 	str	x0, [x29, #72]
		heap_free_delayed_list();
ffffffffea812bc0:	97fffefa 	bl	ffffffffea8127a8 <heap_free_delayed_list>
ffffffffea812bc4:	f94027a0 	ldr	x0, [x29, #72]
ffffffffea812bc8:	17ffff59 	b	ffffffffea81292c <heap_alloc+0x2c>
ffffffffea812bcc:	f9400bb3 	ldr	x19, [x29, #16]
		return NULL;
ffffffffea812bd0:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea812bd4:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea812bd8:	17ffffa9 	b	ffffffffea812a7c <heap_alloc+0x17c>
		TRACEF("failed to grow kernel heap by 0x%zx bytes\n", size);
ffffffffea812bdc:	aa1603e3 	mov	x3, x22
ffffffffea812be0:	d0000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea812be4:	d0000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea812be8:	528036c2 	mov	w2, #0x1b6                 	// #438
ffffffffea812bec:	91186021 	add	x1, x1, #0x618
ffffffffea812bf0:	9118a000 	add	x0, x0, #0x628
ffffffffea812bf4:	94000419 	bl	ffffffffea813c58 <_printf>
ffffffffea812bf8:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea812bfc:	f94017b6 	ldr	x22, [x29, #40]
ffffffffea812c00:	17ffffcf 	b	ffffffffea812b3c <heap_alloc+0x23c>
ffffffffea812c04:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812c08 <heap_free>:
	if (ptr == 0)
ffffffffea812c08:	b40000a0 	cbz	x0, ffffffffea812c1c <heap_free+0x14>
	chunk->len = len;
ffffffffea812c0c:	a97f0801 	ldp	x1, x2, [x0, #-16]
ffffffffea812c10:	f9000822 	str	x2, [x1, #16]
	heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size, true));
ffffffffea812c14:	aa0103e0 	mov	x0, x1
ffffffffea812c18:	17fffe88 	b	ffffffffea812638 <heap_insert_free_chunk>
}
ffffffffea812c1c:	d65f03c0 	ret

ffffffffea812c20 <heap_delayed_free>:
{
ffffffffea812c20:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea812c24:	910003fd 	mov	x29, sp
ffffffffea812c28:	a90153f3 	stp	x19, x20, [sp, #16]
	chunk->len = len;
ffffffffea812c2c:	a97f0013 	ldp	x19, x0, [x0, #-16]
{
ffffffffea812c30:	f90013f5 	str	x21, [sp, #32]
	chunk->len = len;
ffffffffea812c34:	f9000a60 	str	x0, [x19, #16]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea812c38:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea812c3c:	37380280 	tbnz	w0, #7, ffffffffea812c8c <heap_delayed_free+0x6c>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea812c40:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea812c44:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812c48:	913d2294 	add	x20, x20, #0xf48
ffffffffea812c4c:	9101e295 	add	x21, x20, #0x78
ffffffffea812c50:	aa1503e0 	mov	x0, x21
ffffffffea812c54:	97ffbf1b 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea812c58:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea812c5c:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea812c60:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea812c64:	aa1503e0 	mov	x0, x21
	list->next->prev = item;
ffffffffea812c68:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea812c6c:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea812c70:	f9003a93 	str	x19, [x20, #112]
ffffffffea812c74:	97ffbf1b 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea812c78:	d50342ff 	msr	daifclr, #0x2
}
ffffffffea812c7c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812c80:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812c84:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812c88:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea812c8c:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812c90:	913d2294 	add	x20, x20, #0xf48
ffffffffea812c94:	9101e295 	add	x21, x20, #0x78
ffffffffea812c98:	aa1503e0 	mov	x0, x21
ffffffffea812c9c:	97ffbf09 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea812ca0:	f9403a80 	ldr	x0, [x20, #112]
	item->prev = list;
ffffffffea812ca4:	9101a281 	add	x1, x20, #0x68
	item->next = list->next;
ffffffffea812ca8:	a9000261 	stp	x1, x0, [x19]
    arch_spin_unlock(lock);
ffffffffea812cac:	aa1503e0 	mov	x0, x21
ffffffffea812cb0:	f94013f5 	ldr	x21, [sp, #32]
	list->next->prev = item;
ffffffffea812cb4:	f9403a81 	ldr	x1, [x20, #112]
ffffffffea812cb8:	f9000033 	str	x19, [x1]
	list->next = item;
ffffffffea812cbc:	f9003a93 	str	x19, [x20, #112]
ffffffffea812cc0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812cc4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea812cc8:	17ffbf06 	b	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea812ccc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812cd0 <heap_init>:
	return ERR_NO_MEMORY;
#endif
}

void heap_init(void)
{
ffffffffea812cd0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea812cd4:	910003fd 	mov	x29, sp
ffffffffea812cd8:	a90153f3 	stp	x19, x20, [sp, #16]
	LTRACE_ENTRY;

	// create a mutex
	mutex_init(&theheap.lock);
ffffffffea812cdc:	90000314 	adrp	x20, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea812ce0:	913d2293 	add	x19, x20, #0xf48
{
ffffffffea812ce4:	f90013f5 	str	x21, [sp, #32]
	mutex_init(&theheap.lock);
ffffffffea812ce8:	91008260 	add	x0, x19, #0x20
ffffffffea812cec:	aa1e03f5 	mov	x21, x30
ffffffffea812cf0:	97ffcada 	bl	ffffffffea805858 <mutex_init>
	list->prev = list->next = list;
ffffffffea812cf4:	91016261 	add	x1, x19, #0x58
ffffffffea812cf8:	9101a260 	add	x0, x19, #0x68
ffffffffea812cfc:	a9058661 	stp	x1, x1, [x19, #88]
	list_initialize(&theheap.delayed_free_list);
	spin_lock_init(&theheap.delayed_free_lock);

	// set the heap range
#if WITH_KERNEL_VM
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea812d00:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea812d04:	a9068260 	stp	x0, x0, [x19, #104]
ffffffffea812d08:	52800200 	mov	w0, #0x10                  	// #16
    *lock = SPIN_LOCK_INITIAL_VALUE;
ffffffffea812d0c:	f9003e7f 	str	xzr, [x19, #120]
ffffffffea812d10:	97fff9c0 	bl	ffffffffea811410 <pmm_alloc_kpages>
	theheap.len = HEAP_GROW_SIZE;
ffffffffea812d14:	d2a00022 	mov	x2, #0x10000               	// #65536
	theheap.base = pmm_alloc_kpages(HEAP_GROW_SIZE / PAGE_SIZE, NULL);
ffffffffea812d18:	f907a680 	str	x0, [x20, #3912]
	theheap.len = HEAP_GROW_SIZE;
ffffffffea812d1c:	f9000662 	str	x2, [x19, #8]

	if (theheap.base == 0) {
ffffffffea812d20:	b40000e0 	cbz	x0, ffffffffea812d3c <heap_init+0x6c>
#else
	theheap.base = (void *)HEAP_START;
	theheap.len = HEAP_LEN;
#endif
	theheap.remaining = 0; // will get set by heap_insert_free_chunk()
	theheap.low_watermark = theheap.len;
ffffffffea812d24:	a9010a7f 	stp	xzr, x2, [x19, #16]
	LTRACEF("base %p size %zd bytes\n", theheap.base, theheap.len);

	// create an initial free chunk
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
}
ffffffffea812d28:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea812d2c:	f94013f5 	ldr	x21, [sp, #32]
	chunk->len = len;
ffffffffea812d30:	f9000802 	str	x2, [x0, #16]
}
ffffffffea812d34:	a8c37bfd 	ldp	x29, x30, [sp], #48
	heap_insert_free_chunk(heap_create_free_chunk(theheap.base, theheap.len, false));
ffffffffea812d38:	17fffe40 	b	ffffffffea812638 <heap_insert_free_chunk>
		panic("HEAP: error allocating initial heap size\n");
ffffffffea812d3c:	d0000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea812d40:	aa1503e0 	mov	x0, x21
ffffffffea812d44:	91198021 	add	x1, x1, #0x660
ffffffffea812d48:	97fffe0e 	bl	ffffffffea812580 <_panic>
ffffffffea812d4c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812d50 <strtoul>:
	}

	return value;
}

unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812d50:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
	int neg = 0;
	unsigned long ret = 0;

	if (base < 0 || base == 1 || base > 36) {
ffffffffea812d54:	7100045f 	cmp	w2, #0x1
unsigned long strtoul(const char *nptr, char **endptr, int base) {
ffffffffea812d58:	910003fd 	mov	x29, sp
ffffffffea812d5c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea812d60:	aa0003f3 	mov	x19, x0
ffffffffea812d64:	f90013f5 	str	x21, [sp, #32]
	if (base < 0 || base == 1 || base > 36) {
ffffffffea812d68:	1a9f17f5 	cset	w21, eq  // eq = none
ffffffffea812d6c:	7100905f 	cmp	w2, #0x24
ffffffffea812d70:	1a9f97e0 	cset	w0, hi  // hi = pmore
ffffffffea812d74:	2a0002b5 	orr	w21, w21, w0
ffffffffea812d78:	34000155 	cbz	w21, ffffffffea812da0 <strtoul+0x50>
		errno = EINVAL;
ffffffffea812d7c:	9400006f 	bl	ffffffffea812f38 <__geterrno>
	if (neg && ret != ULONG_MAX) {
		ret = -ret;
	}

	return ret;
}
ffffffffea812d80:	f9400bf3 	ldr	x19, [sp, #16]
		errno = EINVAL;
ffffffffea812d84:	528002c2 	mov	w2, #0x16                  	// #22
ffffffffea812d88:	b9000002 	str	w2, [x0]
		return 0;
ffffffffea812d8c:	d2800001 	mov	x1, #0x0                   	// #0
}
ffffffffea812d90:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812d94:	aa0103e0 	mov	x0, x1
ffffffffea812d98:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea812d9c:	d65f03c0 	ret
ffffffffea812da0:	f9000fb4 	str	x20, [x29, #24]
ffffffffea812da4:	2a0203f4 	mov	w20, w2
ffffffffea812da8:	a902dfb6 	stp	x22, x23, [x29, #40]
ffffffffea812dac:	aa0103f7 	mov	x23, x1
ffffffffea812db0:	f9001fb8 	str	x24, [x29, #56]
ffffffffea812db4:	14000002 	b	ffffffffea812dbc <strtoul+0x6c>
		nptr++;
ffffffffea812db8:	91000673 	add	x19, x19, #0x1
	while (isspace(*nptr)) {
ffffffffea812dbc:	39400260 	ldrb	w0, [x19]
ffffffffea812dc0:	94000056 	bl	ffffffffea812f18 <isspace>
ffffffffea812dc4:	35ffffa0 	cbnz	w0, ffffffffea812db8 <strtoul+0x68>
	if (*nptr == '+') {
ffffffffea812dc8:	39400260 	ldrb	w0, [x19]
ffffffffea812dcc:	7100ac1f 	cmp	w0, #0x2b
ffffffffea812dd0:	54000800 	b.eq	ffffffffea812ed0 <strtoul+0x180>  // b.none
	} else if (*nptr == '-') {
ffffffffea812dd4:	7100b41f 	cmp	w0, #0x2d
ffffffffea812dd8:	54000740 	b.eq	ffffffffea812ec0 <strtoul+0x170>  // b.none
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812ddc:	721b7a9f 	tst	w20, #0xffffffef
ffffffffea812de0:	54000640 	b.eq	ffffffffea812ea8 <strtoul+0x158>  // b.none
		if (c >= 'A' && c <= 'Z') {
ffffffffea812de4:	51010402 	sub	w2, w0, #0x41
		new_ret = ret * base;
ffffffffea812de8:	93407e98 	sxtw	x24, w20
		if (c >= 'A' && c <= 'Z') {
ffffffffea812dec:	12001c42 	and	w2, w2, #0xff
		base = 10;
ffffffffea812df0:	d2800001 	mov	x1, #0x0                   	// #0
			errno = ERANGE;
ffffffffea812df4:	52800456 	mov	w22, #0x22                  	// #34
		if (c >= 'A' && c <= 'Z') {
ffffffffea812df8:	7100645f 	cmp	w2, #0x19
ffffffffea812dfc:	540002a8 	b.hi	ffffffffea812e50 <strtoul+0x100>  // b.pmore
			v = c - 'A' + 10;
ffffffffea812e00:	5100dc00 	sub	w0, w0, #0x37
		if (v < 0 || v >= base) {
ffffffffea812e04:	6b00029f 	cmp	w20, w0
ffffffffea812e08:	54000389 	b.ls	ffffffffea812e78 <strtoul+0x128>  // b.plast
		new_ret = ret * base;
ffffffffea812e0c:	9b017f02 	mul	x2, x24, x1
		if (new_ret / base != ret ||
ffffffffea812e10:	9ad80843 	udiv	x3, x2, x24
ffffffffea812e14:	eb01007f 	cmp	x3, x1
ffffffffea812e18:	540000c1 	b.ne	ffffffffea812e30 <strtoul+0xe0>  // b.any
		    new_ret + v < new_ret ||
ffffffffea812e1c:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea812e20:	eb02001f 	cmp	x0, x2
ffffffffea812e24:	ba412824 	ccmn	x1, #0x1, #0x4, cs  // cs = hs, nlast
ffffffffea812e28:	aa0003e1 	mov	x1, x0
ffffffffea812e2c:	54000081 	b.ne	ffffffffea812e3c <strtoul+0xec>  // b.any
			errno = ERANGE;
ffffffffea812e30:	94000042 	bl	ffffffffea812f38 <__geterrno>
ffffffffea812e34:	b9000016 	str	w22, [x0]
			ret = ULONG_MAX;
ffffffffea812e38:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea812e3c:	38401e60 	ldrb	w0, [x19, #1]!
		if (c >= 'A' && c <= 'Z') {
ffffffffea812e40:	51010402 	sub	w2, w0, #0x41
ffffffffea812e44:	12001c42 	and	w2, w2, #0xff
ffffffffea812e48:	7100645f 	cmp	w2, #0x19
ffffffffea812e4c:	54fffda9 	b.ls	ffffffffea812e00 <strtoul+0xb0>  // b.plast
		} else if (c >= 'a' && c <= 'z') {
ffffffffea812e50:	51018402 	sub	w2, w0, #0x61
ffffffffea812e54:	12001c42 	and	w2, w2, #0xff
ffffffffea812e58:	7100645f 	cmp	w2, #0x19
ffffffffea812e5c:	54000068 	b.hi	ffffffffea812e68 <strtoul+0x118>  // b.pmore
			v = c - 'a' + 10;
ffffffffea812e60:	51015c00 	sub	w0, w0, #0x57
ffffffffea812e64:	17ffffe8 	b	ffffffffea812e04 <strtoul+0xb4>
		} else if (c >= '0' && c <= '9') {
ffffffffea812e68:	5100c000 	sub	w0, w0, #0x30
ffffffffea812e6c:	12001c02 	and	w2, w0, #0xff
ffffffffea812e70:	7100245f 	cmp	w2, #0x9
ffffffffea812e74:	54fffc89 	b.ls	ffffffffea812e04 <strtoul+0xb4>  // b.plast
	if (neg && ret != ULONG_MAX) {
ffffffffea812e78:	710002bf 	cmp	w21, #0x0
ffffffffea812e7c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea812e80:	f9401fb8 	ldr	x24, [x29, #56]
		ret = -ret;
ffffffffea812e84:	ba411824 	ccmn	x1, #0x1, #0x4, ne  // ne = any
			*endptr = (char *) nptr;
ffffffffea812e88:	f90002f3 	str	x19, [x23]
		ret = -ret;
ffffffffea812e8c:	da810421 	cneg	x1, x1, ne  // ne = any
ffffffffea812e90:	a942dfb6 	ldp	x22, x23, [x29, #40]
}
ffffffffea812e94:	aa0103e0 	mov	x0, x1
ffffffffea812e98:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea812e9c:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea812ea0:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea812ea4:	d65f03c0 	ret
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812ea8:	7100c01f 	cmp	w0, #0x30
ffffffffea812eac:	540001c0 	b.eq	ffffffffea812ee4 <strtoul+0x194>  // b.none
		base = 10;
ffffffffea812eb0:	7100029f 	cmp	w20, #0x0
ffffffffea812eb4:	52800141 	mov	w1, #0xa                   	// #10
ffffffffea812eb8:	1a811294 	csel	w20, w20, w1, ne  // ne = any
ffffffffea812ebc:	17ffffca 	b	ffffffffea812de4 <strtoul+0x94>
ffffffffea812ec0:	39400660 	ldrb	w0, [x19, #1]
		nptr++;
ffffffffea812ec4:	52800035 	mov	w21, #0x1                   	// #1
ffffffffea812ec8:	91000673 	add	x19, x19, #0x1
ffffffffea812ecc:	17ffffc4 	b	ffffffffea812ddc <strtoul+0x8c>
ffffffffea812ed0:	39400660 	ldrb	w0, [x19, #1]
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812ed4:	721b7a9f 	tst	w20, #0xffffffef
		nptr++;
ffffffffea812ed8:	91000673 	add	x19, x19, #0x1
	if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
ffffffffea812edc:	54fff841 	b.ne	ffffffffea812de4 <strtoul+0x94>  // b.any
ffffffffea812ee0:	17fffff2 	b	ffffffffea812ea8 <strtoul+0x158>
ffffffffea812ee4:	39400661 	ldrb	w1, [x19, #1]
ffffffffea812ee8:	7101e03f 	cmp	w1, #0x78
ffffffffea812eec:	540000c0 	b.eq	ffffffffea812f04 <strtoul+0x1b4>  // b.none
	} else if (base == 0 && nptr[0] == '0') {
ffffffffea812ef0:	35fff7b4 	cbnz	w20, ffffffffea812de4 <strtoul+0x94>
		nptr++;
ffffffffea812ef4:	91000673 	add	x19, x19, #0x1
ffffffffea812ef8:	2a0103e0 	mov	w0, w1
		base = 8;
ffffffffea812efc:	52800114 	mov	w20, #0x8                   	// #8
		nptr++;
ffffffffea812f00:	17ffffb9 	b	ffffffffea812de4 <strtoul+0x94>
ffffffffea812f04:	39400a60 	ldrb	w0, [x19, #2]
		base = 16;
ffffffffea812f08:	52800214 	mov	w20, #0x10                  	// #16
		nptr += 2;
ffffffffea812f0c:	91000a73 	add	x19, x19, #0x2
ffffffffea812f10:	17ffffb5 	b	ffffffffea812de4 <strtoul+0x94>
ffffffffea812f14:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812f18 <isspace>:
	return (c == ' ' || c == '\t');
}

int isspace(int c)
{
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea812f18:	7100801f 	cmp	w0, #0x20
ffffffffea812f1c:	540000a0 	b.eq	ffffffffea812f30 <isspace+0x18>  // b.none
ffffffffea812f20:	51002400 	sub	w0, w0, #0x9
ffffffffea812f24:	7100101f 	cmp	w0, #0x4
ffffffffea812f28:	1a9f87e0 	cset	w0, ls  // ls = plast
}
ffffffffea812f2c:	d65f03c0 	ret
	return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
ffffffffea812f30:	52800020 	mov	w0, #0x1                   	// #1
}
ffffffffea812f34:	d65f03c0 	ret

ffffffffea812f38 <__geterrno>:
/* TODO: pull from kernel TLS or some other thread local storage */
static int _errno;

int *__geterrno(void)
{
    return &_errno;
ffffffffea812f38:	90000300 	adrp	x0, ffffffffea872000 <idle_threads+0xeb0>
}
ffffffffea812f3c:	913f2000 	add	x0, x0, #0xfc8
ffffffffea812f40:	d65f03c0 	ret
ffffffffea812f44:	00000000 	.inst	0x00000000 ; undefined

ffffffffea812f48 <_vsnprintf_output>:
static int _vsnprintf_output(const char *str, size_t len, void *state)
{
	struct _output_args *args = state;

	size_t count = 0;
	while (count < len && *str) {
ffffffffea812f48:	b40002c1 	cbz	x1, ffffffffea812fa0 <_vsnprintf_output+0x58>
ffffffffea812f4c:	39400003 	ldrb	w3, [x0]
ffffffffea812f50:	34000283 	cbz	w3, ffffffffea812fa0 <_vsnprintf_output+0x58>
	size_t count = 0;
ffffffffea812f54:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea812f58:	14000003 	b	ffffffffea812f64 <_vsnprintf_output+0x1c>
	while (count < len && *str) {
ffffffffea812f5c:	38636804 	ldrb	w4, [x0, x3]
ffffffffea812f60:	340001c4 	cbz	w4, ffffffffea812f98 <_vsnprintf_output+0x50>
		if (args->pos < args->len) {
ffffffffea812f64:	a9409045 	ldp	x5, x4, [x2, #8]
			args->outstr[args->pos++] = *str;
ffffffffea812f68:	91000486 	add	x6, x4, #0x1
		if (args->pos < args->len) {
ffffffffea812f6c:	eb05009f 	cmp	x4, x5
ffffffffea812f70:	540000a2 	b.cs	ffffffffea812f84 <_vsnprintf_output+0x3c>  // b.hs, b.nlast
			args->outstr[args->pos++] = *str;
ffffffffea812f74:	f9000846 	str	x6, [x2, #16]
ffffffffea812f78:	f9400045 	ldr	x5, [x2]
ffffffffea812f7c:	38636806 	ldrb	w6, [x0, x3]
ffffffffea812f80:	382468a6 	strb	w6, [x5, x4]
		}

		str++;
		count++;
ffffffffea812f84:	91000463 	add	x3, x3, #0x1
	while (count < len && *str) {
ffffffffea812f88:	eb03003f 	cmp	x1, x3
ffffffffea812f8c:	54fffe81 	b.ne	ffffffffea812f5c <_vsnprintf_output+0x14>  // b.any
ffffffffea812f90:	2a0103e0 	mov	w0, w1
	}

	return count;
}
ffffffffea812f94:	d65f03c0 	ret
ffffffffea812f98:	2a0303e0 	mov	w0, w3
ffffffffea812f9c:	d65f03c0 	ret
	while (count < len && *str) {
ffffffffea812fa0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea812fa4:	d65f03c0 	ret

ffffffffea812fa8 <longlong_to_string.constprop.0>:
	int negative = 0;
ffffffffea812fa8:	52800009 	mov	w9, #0x0                   	// #0
	if ((flag & SIGNEDFLAG) && (long long)n < 0) {
ffffffffea812fac:	36500042 	tbz	w2, #10, ffffffffea812fb4 <longlong_to_string.constprop.0+0xc>
ffffffffea812fb0:	b7f80481 	tbnz	x1, #63, ffffffffea813040 <longlong_to_string.constprop.0+0x98>
	buf[--pos] = 0;
ffffffffea812fb4:	39007c1f 	strb	wzr, [x0, #31]
	while (n >= 10) {
ffffffffea812fb8:	f100243f 	cmp	x1, #0x9
ffffffffea812fbc:	540004e9 	b.ls	ffffffffea813058 <longlong_to_string.constprop.0+0xb0>  // b.plast
		int digit = n % 10;
ffffffffea812fc0:	b202e7e8 	mov	x8, #0xcccccccccccccccc    	// #-3689348814741910324
	buf[--pos] = 0;
ffffffffea812fc4:	d28003e7 	mov	x7, #0x1f                  	// #31
		int digit = n % 10;
ffffffffea812fc8:	f29999a8 	movk	x8, #0xcccd
ffffffffea812fcc:	14000002 	b	ffffffffea812fd4 <longlong_to_string.constprop.0+0x2c>
		buf[--pos] = digit + '0';
ffffffffea812fd0:	aa0603e7 	mov	x7, x6
		int digit = n % 10;
ffffffffea812fd4:	9bc87c25 	umulh	x5, x1, x8
		buf[--pos] = digit + '0';
ffffffffea812fd8:	d10004e6 	sub	x6, x7, #0x1
		int digit = n % 10;
ffffffffea812fdc:	d343fca4 	lsr	x4, x5, #3
ffffffffea812fe0:	8b040884 	add	x4, x4, x4, lsl #2
ffffffffea812fe4:	cb040424 	sub	x4, x1, x4, lsl #1
		n /= 10;
ffffffffea812fe8:	d343fca1 	lsr	x1, x5, #3
		buf[--pos] = digit + '0';
ffffffffea812fec:	1100c084 	add	w4, w4, #0x30
ffffffffea812ff0:	38266804 	strb	w4, [x0, x6]
	while (n >= 10) {
ffffffffea812ff4:	f100243f 	cmp	x1, #0x9
ffffffffea812ff8:	54fffec8 	b.hi	ffffffffea812fd0 <longlong_to_string.constprop.0+0x28>  // b.pmore
ffffffffea812ffc:	d10008e7 	sub	x7, x7, #0x2
	buf[--pos] = n + '0';
ffffffffea813000:	1100c021 	add	w1, w1, #0x30
ffffffffea813004:	38276801 	strb	w1, [x0, x7]
ffffffffea813008:	8b070000 	add	x0, x0, x7
	if (negative)
ffffffffea81300c:	35000149 	cbnz	w9, ffffffffea813034 <longlong_to_string.constprop.0+0x8c>
	else if ((flag & SHOWSIGNFLAG))
ffffffffea813010:	374800c2 	tbnz	w2, #9, ffffffffea813028 <longlong_to_string.constprop.0+0x80>
		*signchar = ' ';
ffffffffea813014:	f273005f 	tst	x2, #0x2000
ffffffffea813018:	52800401 	mov	w1, #0x20                  	// #32
ffffffffea81301c:	1a9f1021 	csel	w1, w1, wzr, ne  // ne = any
ffffffffea813020:	39000061 	strb	w1, [x3]
}
ffffffffea813024:	d65f03c0 	ret
		*signchar = '+';
ffffffffea813028:	52800561 	mov	w1, #0x2b                  	// #43
ffffffffea81302c:	39000061 	strb	w1, [x3]
}
ffffffffea813030:	d65f03c0 	ret
		*signchar = '-';
ffffffffea813034:	528005a1 	mov	w1, #0x2d                  	// #45
ffffffffea813038:	39000061 	strb	w1, [x3]
}
ffffffffea81303c:	d65f03c0 	ret
	buf[--pos] = 0;
ffffffffea813040:	39007c1f 	strb	wzr, [x0, #31]
		n = -n;
ffffffffea813044:	cb0103e1 	neg	x1, x1
		negative = 1;
ffffffffea813048:	52800029 	mov	w9, #0x1                   	// #1
	while (n >= 10) {
ffffffffea81304c:	f100243f 	cmp	x1, #0x9
ffffffffea813050:	54fffb88 	b.hi	ffffffffea812fc0 <longlong_to_string.constprop.0+0x18>  // b.pmore
ffffffffea813054:	d503201f 	nop
ffffffffea813058:	d28003c7 	mov	x7, #0x1e                  	// #30
ffffffffea81305c:	17ffffe9 	b	ffffffffea813000 <longlong_to_string.constprop.0+0x58>

ffffffffea813060 <longlong_to_hexstring.constprop.1>:
	const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
ffffffffea813060:	7218005f 	tst	w2, #0x100
ffffffffea813064:	b0000023 	adrp	x3, ffffffffea818000 <zero_uuid+0x8>
ffffffffea813068:	b0000024 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea81306c:	911d4063 	add	x3, x3, #0x750
ffffffffea813070:	911d8084 	add	x4, x4, #0x760
ffffffffea813074:	91007802 	add	x2, x0, #0x1e
ffffffffea813078:	9a831084 	csel	x4, x4, x3, ne  // ne = any
	buf[--pos] = 0;
ffffffffea81307c:	39007c1f 	strb	wzr, [x0, #31]
		unsigned int digit = u % 16;
ffffffffea813080:	12000c23 	and	w3, w1, #0xf
		buf[--pos] = table[digit];
ffffffffea813084:	aa0203e0 	mov	x0, x2
		u /= 16;
ffffffffea813088:	d344fc21 	lsr	x1, x1, #4
		buf[--pos] = table[digit];
ffffffffea81308c:	38634883 	ldrb	w3, [x4, w3, uxtw]
ffffffffea813090:	381ff443 	strb	w3, [x2], #-1
	} while (u != 0);
ffffffffea813094:	b5ffff61 	cbnz	x1, ffffffffea813080 <longlong_to_hexstring.constprop.1+0x20>
}
ffffffffea813098:	d65f03c0 	ret
ffffffffea81309c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8130a0 <_printf_engine>:
		str[wlen] = '\0';
	return wlen;
}

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
ffffffffea8130a0:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
ffffffffea8130a4:	910003fd 	mov	x29, sp
ffffffffea8130a8:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea8130ac:	f0000279 	adrp	x25, ffffffffea862000 <__ctor_list>
ffffffffea8130b0:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8130b4:	aa0103f5 	mov	x21, x1
ffffffffea8130b8:	f9402b24 	ldr	x4, [x25, #80]
		/* grab the next format character */
		c = *fmt++;
		if (c == 0)
			break;

		switch (c) {
ffffffffea8130bc:	b000003a 	adrp	x26, ffffffffea818000 <zero_uuid+0x8>
{
ffffffffea8130c0:	a90573fb 	stp	x27, x28, [sp, #80]
				s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
				goto _output_string;
			}
#endif
			default:
				OUTPUT_CHAR('%');
ffffffffea8130c4:	910283b6 	add	x22, x29, #0xa0
{
ffffffffea8130c8:	f9400081 	ldr	x1, [x4]
ffffffffea8130cc:	f90067a1 	str	x1, [x29, #200]
ffffffffea8130d0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8130d4:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8130d8:	a940047b 	ldp	x27, x1, [x3]
ffffffffea8130dc:	aa0003f4 	mov	x20, x0
ffffffffea8130e0:	f90037a1 	str	x1, [x29, #104]
ffffffffea8130e4:	aa0203e0 	mov	x0, x2
ffffffffea8130e8:	b9401861 	ldr	w1, [x3, #24]
	size_t chars_written = 0;
ffffffffea8130ec:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea8130f0:	b90087a1 	str	w1, [x29, #132]
		switch (c) {
ffffffffea8130f4:	911a3341 	add	x1, x26, #0x68c
ffffffffea8130f8:	f90047a1 	str	x1, [x29, #136]
				s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
ffffffffea8130fc:	9102a3a1 	add	x1, x29, #0xa8
ffffffffea813100:	f9003ba1 	str	x1, [x29, #112]
		while ((c = *fmt++) != 0) {
ffffffffea813104:	9100041c 	add	x28, x0, #0x1
ffffffffea813108:	39400001 	ldrb	w1, [x0]
		signchar = '\0';
ffffffffea81310c:	39027fbf 	strb	wzr, [x29, #159]
		while ((c = *fmt++) != 0) {
ffffffffea813110:	34001be1 	cbz	w1, ffffffffea81348c <_printf_engine+0x3ec>
			if (c == '%')
ffffffffea813114:	7100943f 	cmp	w1, #0x25
ffffffffea813118:	54000081 	b.ne	ffffffffea813128 <_printf_engine+0x88>  // b.any
ffffffffea81311c:	14000014 	b	ffffffffea81316c <_printf_engine+0xcc>
ffffffffea813120:	7100945f 	cmp	w2, #0x25
ffffffffea813124:	54000260 	b.eq	ffffffffea813170 <_printf_engine+0xd0>  // b.none
ffffffffea813128:	cb000381 	sub	x1, x28, x0
		while ((c = *fmt++) != 0) {
ffffffffea81312c:	38401782 	ldrb	w2, [x28], #1
ffffffffea813130:	35ffff82 	cbnz	w2, ffffffffea813120 <_printf_engine+0x80>
		OUTPUT_STRING(s, string_len);
ffffffffea813134:	aa1503e2 	mov	x2, x21
ffffffffea813138:	d63f0280 	blr	x20
ffffffffea81313c:	36f828a0 	tbz	w0, #31, ffffffffea813650 <_printf_engine+0x5b0>
#undef OUTPUT_STRING
#undef OUTPUT_CHAR

exit:
	return (err < 0) ? err : (int)chars_written;
}
ffffffffea813140:	f9402b39 	ldr	x25, [x25, #80]
ffffffffea813144:	f94067a2 	ldr	x2, [x29, #200]
ffffffffea813148:	f9400321 	ldr	x1, [x25]
ffffffffea81314c:	ca010041 	eor	x1, x2, x1
ffffffffea813150:	b5003ee1 	cbnz	x1, ffffffffea81392c <_printf_engine+0x88c>
ffffffffea813154:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813158:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea81315c:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea813160:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea813164:	a8cd7bfd 	ldp	x29, x30, [sp], #208
ffffffffea813168:	d65f03c0 	ret
		string_len = 0;
ffffffffea81316c:	d2800001 	mov	x1, #0x0                   	// #0
		OUTPUT_STRING(s, string_len);
ffffffffea813170:	aa1503e2 	mov	x2, x21
ffffffffea813174:	d63f0280 	blr	x20
ffffffffea813178:	37fffe40 	tbnz	w0, #31, ffffffffea813140 <_printf_engine+0xa0>
ffffffffea81317c:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea813180:	a90363b7 	stp	x23, x24, [x29, #48]
		format_num = 0;
ffffffffea813184:	5280001a 	mov	w26, #0x0                   	// #0
		flags = 0;
ffffffffea813188:	52800018 	mov	w24, #0x0                   	// #0
		c = *fmt++;
ffffffffea81318c:	38401797 	ldrb	w23, [x28], #1
		if (c == 0)
ffffffffea813190:	34001ab7 	cbz	w23, ffffffffea8134e4 <_printf_engine+0x444>
		switch (c) {
ffffffffea813194:	510082e0 	sub	w0, w23, #0x20
ffffffffea813198:	7101681f 	cmp	w0, #0x5a
ffffffffea81319c:	54000229 	b.ls	ffffffffea8131e0 <_printf_engine+0x140>  // b.plast
				OUTPUT_CHAR('%');
ffffffffea8131a0:	528004a0 	mov	w0, #0x25                  	// #37
ffffffffea8131a4:	390283a0 	strb	w0, [x29, #160]
ffffffffea8131a8:	aa1503e2 	mov	x2, x21
ffffffffea8131ac:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8131b0:	aa1603e0 	mov	x0, x22
ffffffffea8131b4:	d63f0280 	blr	x20
ffffffffea8131b8:	2a0003f8 	mov	w24, w0
ffffffffea8131bc:	37f81fa0 	tbnz	w0, #31, ffffffffea8135b0 <_printf_engine+0x510>
				OUTPUT_CHAR(c);
ffffffffea8131c0:	390283b7 	strb	w23, [x29, #160]
ffffffffea8131c4:	aa1503e2 	mov	x2, x21
ffffffffea8131c8:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8131cc:	aa1603e0 	mov	x0, x22
ffffffffea8131d0:	d63f0280 	blr	x20
ffffffffea8131d4:	36f81600 	tbz	w0, #31, ffffffffea813494 <_printf_engine+0x3f4>
ffffffffea8131d8:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8131dc:	17ffffd9 	b	ffffffffea813140 <_printf_engine+0xa0>
		switch (c) {
ffffffffea8131e0:	f94047a1 	ldr	x1, [x29, #136]
ffffffffea8131e4:	78605820 	ldrh	w0, [x1, w0, uxtw #1]
ffffffffea8131e8:	10000061 	adr	x1, ffffffffea8131f4 <_printf_engine+0x154>
ffffffffea8131ec:	8b20a820 	add	x0, x1, w0, sxth #2
ffffffffea8131f0:	d61f0000 	br	x0
				flags |= CAPSFLAG;
ffffffffea8131f4:	32180318 	orr	w24, w24, #0x100
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea8131f8:	360806f8 	tbz	w24, #1, ffffffffea8132d4 <_printf_engine+0x234>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea8131fc:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813200:	37f817e0 	tbnz	w0, #31, ffffffffea8134fc <_printf_engine+0x45c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea813204:	91003f61 	add	x1, x27, #0xf
ffffffffea813208:	aa1b03e0 	mov	x0, x27
ffffffffea81320c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813210:	f9400001 	ldr	x1, [x0]
				s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
ffffffffea813214:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea813218:	2a1803e2 	mov	w2, w24
ffffffffea81321c:	97ffff91 	bl	ffffffffea813060 <longlong_to_hexstring.constprop.1>
ffffffffea813220:	aa0003f7 	mov	x23, x0
				if (flags & ALTFLAG) {
ffffffffea813224:	36380298 	tbz	w24, #7, ffffffffea813274 <_printf_engine+0x1d4>
					OUTPUT_CHAR('0');
ffffffffea813228:	52800600 	mov	w0, #0x30                  	// #48
ffffffffea81322c:	390283a0 	strb	w0, [x29, #160]
ffffffffea813230:	aa1503e2 	mov	x2, x21
ffffffffea813234:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea813238:	aa1603e0 	mov	x0, x22
ffffffffea81323c:	d63f0280 	blr	x20
ffffffffea813240:	37fffcc0 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea813244:	f278031f 	tst	x24, #0x100
ffffffffea813248:	52800b01 	mov	w1, #0x58                  	// #88
					OUTPUT_CHAR('0');
ffffffffea81324c:	8b20c273 	add	x19, x19, w0, sxtw
					OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
ffffffffea813250:	52800f00 	mov	w0, #0x78                  	// #120
ffffffffea813254:	1a810000 	csel	w0, w0, w1, eq  // eq = none
ffffffffea813258:	390283a0 	strb	w0, [x29, #160]
ffffffffea81325c:	aa1503e2 	mov	x2, x21
ffffffffea813260:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea813264:	aa1603e0 	mov	x0, x22
ffffffffea813268:	d63f0280 	blr	x20
ffffffffea81326c:	37fffb60 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
ffffffffea813270:	8b20c273 	add	x19, x19, w0, sxtw
		if (flags & LEFTFORMATFLAG) {
ffffffffea813274:	36580ab8 	tbz	w24, #11, ffffffffea8133c8 <_printf_engine+0x328>
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea813278:	aa1503e2 	mov	x2, x21
ffffffffea81327c:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea813280:	aa1703e0 	mov	x0, x23
ffffffffea813284:	d63f0280 	blr	x20
ffffffffea813288:	37fffa80 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
			uint written = err;
ffffffffea81328c:	2a0003f7 	mov	w23, w0
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea813290:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea813294:	6b00035f 	cmp	w26, w0
ffffffffea813298:	54000ee9 	b.ls	ffffffffea813474 <_printf_engine+0x3d4>  // b.plast
				OUTPUT_CHAR(' ');
ffffffffea81329c:	52800418 	mov	w24, #0x20                  	// #32
ffffffffea8132a0:	14000005 	b	ffffffffea8132b4 <_printf_engine+0x214>
			for (; format_num > written; format_num--)
ffffffffea8132a4:	5100075a 	sub	w26, w26, #0x1
				OUTPUT_CHAR(' ');
ffffffffea8132a8:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > written; format_num--)
ffffffffea8132ac:	6b1a02ff 	cmp	w23, w26
ffffffffea8132b0:	54000e20 	b.eq	ffffffffea813474 <_printf_engine+0x3d4>  // b.none
				OUTPUT_CHAR(' ');
ffffffffea8132b4:	390283b8 	strb	w24, [x29, #160]
ffffffffea8132b8:	aa1503e2 	mov	x2, x21
ffffffffea8132bc:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8132c0:	aa1603e0 	mov	x0, x22
ffffffffea8132c4:	d63f0280 	blr	x20
ffffffffea8132c8:	36fffee0 	tbz	w0, #31, ffffffffea8132a4 <_printf_engine+0x204>
ffffffffea8132cc:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8132d0:	17ffff9c 	b	ffffffffea813140 <_printf_engine+0xa0>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea8132d4:	3707f958 	tbnz	w24, #0, ffffffffea8131fc <_printf_engine+0x15c>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8132d8:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8132dc:	361810b8 	tbz	w24, #3, ffffffffea8134f0 <_printf_engine+0x450>
ffffffffea8132e0:	37f83860 	tbnz	w0, #31, ffffffffea8139ec <_printf_engine+0x94c>
ffffffffea8132e4:	aa1b03e0 	mov	x0, x27
ffffffffea8132e8:	91002f61 	add	x1, x27, #0xb
ffffffffea8132ec:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea8132f0:	39400001 	ldrb	w1, [x0]
ffffffffea8132f4:	17ffffc8 	b	ffffffffea813214 <_printf_engine+0x174>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea8132f8:	36080d38 	tbz	w24, #1, ffffffffea81349c <_printf_engine+0x3fc>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea8132fc:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813300:	37f83560 	tbnz	w0, #31, ffffffffea8139ac <_printf_engine+0x90c>
ffffffffea813304:	aa1b03e0 	mov	x0, x27
ffffffffea813308:	91003f61 	add	x1, x27, #0xf
ffffffffea81330c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813310:	f9400001 	ldr	x1, [x0]
ffffffffea813314:	14000027 	b	ffffffffea8133b0 <_printf_engine+0x310>
				flags |= ALTFLAG;
ffffffffea813318:	32190318 	orr	w24, w24, #0x80
				goto next_format;
ffffffffea81331c:	17ffff9c 	b	ffffffffea81318c <_printf_engine+0xec>
				flags |= SIZETFLAG;
ffffffffea813320:	321c0318 	orr	w24, w24, #0x10
				goto next_format;
ffffffffea813324:	17ffff9a 	b	ffffffffea81318c <_printf_engine+0xec>
					flags |= HALFHALFFLAG;
ffffffffea813328:	321d0300 	orr	w0, w24, #0x8
ffffffffea81332c:	f27e031f 	tst	x24, #0x4
ffffffffea813330:	1a981018 	csel	w24, w0, w24, ne  // ne = any
				flags |= HALFFLAG;
ffffffffea813334:	321e0318 	orr	w24, w24, #0x4
				goto next_format;
ffffffffea813338:	17ffff95 	b	ffffffffea81318c <_printf_engine+0xec>
				flags |= INTMAXFLAG;
ffffffffea81333c:	321b0318 	orr	w24, w24, #0x20
				goto next_format;
ffffffffea813340:	17ffff93 	b	ffffffffea81318c <_printf_engine+0xec>
					flags |= LONGLONGFLAG;
ffffffffea813344:	321f0300 	orr	w0, w24, #0x2
ffffffffea813348:	f240031f 	tst	x24, #0x1
ffffffffea81334c:	1a981018 	csel	w24, w0, w24, ne  // ne = any
				flags |= LONGFLAG;
ffffffffea813350:	32000318 	orr	w24, w24, #0x1
				goto next_format;
ffffffffea813354:	17ffff8e 	b	ffffffffea81318c <_printf_engine+0xec>
				flags |= LONGFLAG | ALTFLAG;
ffffffffea813358:	52801020 	mov	w0, #0x81                  	// #129
ffffffffea81335c:	2a000318 	orr	w24, w24, w0
				n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
ffffffffea813360:	360ffbb8 	tbz	w24, #1, ffffffffea8132d4 <_printf_engine+0x234>
ffffffffea813364:	17ffffa6 	b	ffffffffea8131fc <_printf_engine+0x15c>
				flags |= PTRDIFFFLAG;
ffffffffea813368:	321a0318 	orr	w24, w24, #0x40
				goto next_format;
ffffffffea81336c:	17ffff88 	b	ffffffffea81318c <_printf_engine+0xec>
				if (c == '0' && format_num == 0)
ffffffffea813370:	7100c2ff 	cmp	w23, #0x30
				format_num *= 10;
ffffffffea813374:	0b1a0b40 	add	w0, w26, w26, lsl #2
					flags |= LEADZEROFLAG;
ffffffffea813378:	7a400b40 	ccmp	w26, #0x0, #0x0, eq  // eq = none
ffffffffea81337c:	32140301 	orr	w1, w24, #0x1000
				format_num += c - '0';
ffffffffea813380:	5100c2e5 	sub	w5, w23, #0x30
					flags |= LEADZEROFLAG;
ffffffffea813384:	1a980038 	csel	w24, w1, w24, eq  // eq = none
				format_num += c - '0';
ffffffffea813388:	0b0004ba 	add	w26, w5, w0, lsl #1
				goto next_format;
ffffffffea81338c:	17ffff80 	b	ffffffffea81318c <_printf_engine+0xec>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813390:	36080998 	tbz	w24, #1, ffffffffea8134c0 <_printf_engine+0x420>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea813394:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813398:	37f82660 	tbnz	w0, #31, ffffffffea813864 <_printf_engine+0x7c4>
ffffffffea81339c:	aa1b03e0 	mov	x0, x27
ffffffffea8133a0:	91003f61 	add	x1, x27, #0xf
ffffffffea8133a4:	927df03b 	and	x27, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8133a8:	f9400001 	ldr	x1, [x0]
				flags |= SIGNEDFLAG;
ffffffffea8133ac:	32160318 	orr	w24, w24, #0x400
				s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
ffffffffea8133b0:	f9403ba0 	ldr	x0, [x29, #112]
ffffffffea8133b4:	91027fa3 	add	x3, x29, #0x9f
ffffffffea8133b8:	2a1803e2 	mov	w2, w24
ffffffffea8133bc:	97fffefb 	bl	ffffffffea812fa8 <longlong_to_string.constprop.0>
ffffffffea8133c0:	aa0003f7 	mov	x23, x0
		if (flags & LEFTFORMATFLAG) {
ffffffffea8133c4:	375ff5b8 	tbnz	w24, #11, ffffffffea813278 <_printf_engine+0x1d8>
			string_len = strlen(s);
ffffffffea8133c8:	aa1703e0 	mov	x0, x23
ffffffffea8133cc:	9400039d 	bl	ffffffffea814240 <strlen>
ffffffffea8133d0:	f9003fa0 	str	x0, [x29, #120]
ffffffffea8133d4:	12140301 	and	w1, w24, #0x1000
			if (signchar != '\0' && format_num > 0)
ffffffffea8133d8:	39427fa0 	ldrb	w0, [x29, #159]
ffffffffea8133dc:	b90083a1 	str	w1, [x29, #128]
ffffffffea8133e0:	35000f00 	cbnz	w0, ffffffffea8135c0 <_printf_engine+0x520>
			for (; format_num > string_len; format_num--)
ffffffffea8133e4:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8133e8:	eb3a401f 	cmp	x0, w26, uxtw
ffffffffea8133ec:	54001142 	b.cs	ffffffffea813614 <_printf_engine+0x574>  // b.hs, b.nlast
ffffffffea8133f0:	b94083a0 	ldr	w0, [x29, #128]
ffffffffea8133f4:	52800401 	mov	w1, #0x20                  	// #32
ffffffffea8133f8:	7100001f 	cmp	w0, #0x0
ffffffffea8133fc:	52800600 	mov	w0, #0x30                  	// #48
ffffffffea813400:	1a811000 	csel	w0, w0, w1, ne  // ne = any
ffffffffea813404:	12001c18 	and	w24, w0, #0xff
ffffffffea813408:	14000006 	b	ffffffffea813420 <_printf_engine+0x380>
				OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
ffffffffea81340c:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea813410:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea813414:	5100075a 	sub	w26, w26, #0x1
ffffffffea813418:	eb3a401f 	cmp	x0, w26, uxtw
ffffffffea81341c:	54000fc2 	b.cs	ffffffffea813614 <_printf_engine+0x574>  // b.hs, b.nlast
				OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
ffffffffea813420:	390283b8 	strb	w24, [x29, #160]
ffffffffea813424:	aa1503e2 	mov	x2, x21
ffffffffea813428:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea81342c:	aa1603e0 	mov	x0, x22
ffffffffea813430:	d63f0280 	blr	x20
ffffffffea813434:	36fffec0 	tbz	w0, #31, ffffffffea81340c <_printf_engine+0x36c>
ffffffffea813438:	17ffff68 	b	ffffffffea8131d8 <_printf_engine+0x138>
				flags |= BLANKPOSFLAG;
ffffffffea81343c:	32130318 	orr	w24, w24, #0x2000
				goto next_format;
ffffffffea813440:	17ffff53 	b	ffffffffea81318c <_printf_engine+0xec>
				flags |= SHOWSIGNFLAG;
ffffffffea813444:	32170318 	orr	w24, w24, #0x200
				goto next_format;
ffffffffea813448:	17ffff51 	b	ffffffffea81318c <_printf_engine+0xec>
				flags |= LEFTFORMATFLAG;
ffffffffea81344c:	32150318 	orr	w24, w24, #0x800
				goto next_format;
ffffffffea813450:	17ffff4f 	b	ffffffffea81318c <_printf_engine+0xec>
				OUTPUT_CHAR('%');
ffffffffea813454:	528004a0 	mov	w0, #0x25                  	// #37
				uc = va_arg(ap, unsigned int);
ffffffffea813458:	390283a0 	strb	w0, [x29, #160]
				OUTPUT_CHAR(uc);
ffffffffea81345c:	aa1503e2 	mov	x2, x21
ffffffffea813460:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea813464:	aa1603e0 	mov	x0, x22
ffffffffea813468:	d63f0280 	blr	x20
ffffffffea81346c:	37ffeb60 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
				OUTPUT_CHAR(c);
ffffffffea813470:	8b20c273 	add	x19, x19, w0, sxtw
{
ffffffffea813474:	aa1c03e0 	mov	x0, x28
		signchar = '\0';
ffffffffea813478:	39027fbf 	strb	wzr, [x29, #159]
{
ffffffffea81347c:	a94363b7 	ldp	x23, x24, [x29, #48]
		while ((c = *fmt++) != 0) {
ffffffffea813480:	9100041c 	add	x28, x0, #0x1
ffffffffea813484:	39400001 	ldrb	w1, [x0]
ffffffffea813488:	35ffe461 	cbnz	w1, ffffffffea813114 <_printf_engine+0x74>
		string_len = 0;
ffffffffea81348c:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea813490:	17ffff29 	b	ffffffffea813134 <_printf_engine+0x94>
				OUTPUT_CHAR('%');
ffffffffea813494:	8b38c273 	add	x19, x19, w24, sxtw
ffffffffea813498:	17fffff6 	b	ffffffffea813470 <_printf_engine+0x3d0>
				    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
ffffffffea81349c:	3707f318 	tbnz	w24, #0, ffffffffea8132fc <_printf_engine+0x25c>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8134a0:	36180e58 	tbz	w24, #3, ffffffffea813668 <_printf_engine+0x5c8>
ffffffffea8134a4:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8134a8:	37f82c20 	tbnz	w0, #31, ffffffffea813a2c <_printf_engine+0x98c>
ffffffffea8134ac:	aa1b03e0 	mov	x0, x27
ffffffffea8134b0:	91002f61 	add	x1, x27, #0xb
ffffffffea8134b4:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea8134b8:	39400001 	ldrb	w1, [x0]
ffffffffea8134bc:	17ffffbd 	b	ffffffffea8133b0 <_printf_engine+0x310>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8134c0:	3707f6b8 	tbnz	w24, #0, ffffffffea813394 <_printf_engine+0x2f4>
ffffffffea8134c4:	36180e38 	tbz	w24, #3, ffffffffea813688 <_printf_engine+0x5e8>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea8134c8:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8134cc:	37f82c40 	tbnz	w0, #31, ffffffffea813a54 <_printf_engine+0x9b4>
ffffffffea8134d0:	aa1b03e0 	mov	x0, x27
ffffffffea8134d4:	91002f61 	add	x1, x27, #0xb
ffffffffea8134d8:	927df03b 	and	x27, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8134dc:	39800001 	ldrsb	x1, [x0]
ffffffffea8134e0:	17ffffb3 	b	ffffffffea8133ac <_printf_engine+0x30c>
ffffffffea8134e4:	a94363b7 	ldp	x23, x24, [x29, #48]
	return (err < 0) ? err : (int)chars_written;
ffffffffea8134e8:	2a1303e0 	mov	w0, w19
ffffffffea8134ec:	17ffff15 	b	ffffffffea813140 <_printf_engine+0xa0>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8134f0:	37100558 	tbnz	w24, #2, ffffffffea813598 <_printf_engine+0x4f8>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea8134f4:	36200db8 	tbz	w24, #4, ffffffffea8136a8 <_printf_engine+0x608>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8134f8:	36ffe860 	tbz	w0, #31, ffffffffea813204 <_printf_engine+0x164>
ffffffffea8134fc:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813500:	11002001 	add	w1, w0, #0x8
ffffffffea813504:	7100003f 	cmp	w1, #0x0
ffffffffea813508:	5400152d 	b.le	ffffffffea8137ac <_printf_engine+0x70c>
ffffffffea81350c:	91003f62 	add	x2, x27, #0xf
ffffffffea813510:	aa1b03e0 	mov	x0, x27
ffffffffea813514:	b90087a1 	str	w1, [x29, #132]
ffffffffea813518:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea81351c:	17ffff3d 	b	ffffffffea813210 <_printf_engine+0x170>
				uc = va_arg(ap, unsigned int);
ffffffffea813520:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813524:	37f82080 	tbnz	w0, #31, ffffffffea813934 <_printf_engine+0x894>
ffffffffea813528:	aa1b03e0 	mov	x0, x27
ffffffffea81352c:	91002f61 	add	x1, x27, #0xb
ffffffffea813530:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813534:	b9400000 	ldr	w0, [x0]
ffffffffea813538:	17ffffc8 	b	ffffffffea813458 <_printf_engine+0x3b8>
				s = va_arg(ap, const char *);
ffffffffea81353c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813540:	37f81c60 	tbnz	w0, #31, ffffffffea8138cc <_printf_engine+0x82c>
ffffffffea813544:	91003f61 	add	x1, x27, #0xf
ffffffffea813548:	aa1b03e0 	mov	x0, x27
ffffffffea81354c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813550:	f9400017 	ldr	x23, [x0]
					s = "<null>";
ffffffffea813554:	b0000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea813558:	911d2000 	add	x0, x0, #0x748
				flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
ffffffffea81355c:	12137b18 	and	w24, w24, #0xffffefff
					s = "<null>";
ffffffffea813560:	f10002ff 	cmp	x23, #0x0
ffffffffea813564:	9a970017 	csel	x23, x0, x23, eq  // eq = none
				goto _output_string;
ffffffffea813568:	17ffff43 	b	ffffffffea813274 <_printf_engine+0x1d4>
				ptr = va_arg(ap, void *);
ffffffffea81356c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813570:	37f81f60 	tbnz	w0, #31, ffffffffea81395c <_printf_engine+0x8bc>
ffffffffea813574:	91003f61 	add	x1, x27, #0xf
ffffffffea813578:	aa1b03e0 	mov	x0, x27
ffffffffea81357c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813580:	f9400000 	ldr	x0, [x0]
				if (flags & LONGLONGFLAG)
ffffffffea813584:	370801b8 	tbnz	w24, #1, ffffffffea8135b8 <_printf_engine+0x518>
				else if (flags & LONGFLAG)
ffffffffea813588:	37000198 	tbnz	w24, #0, ffffffffea8135b8 <_printf_engine+0x518>
				else if (flags & HALFHALFFLAG)
ffffffffea81358c:	36180698 	tbz	w24, #3, ffffffffea81365c <_printf_engine+0x5bc>
					*(signed char *)ptr = chars_written;
ffffffffea813590:	39000013 	strb	w19, [x0]
ffffffffea813594:	17ffffb8 	b	ffffffffea813474 <_printf_engine+0x3d4>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea813598:	37f81860 	tbnz	w0, #31, ffffffffea8138a4 <_printf_engine+0x804>
ffffffffea81359c:	aa1b03e0 	mov	x0, x27
ffffffffea8135a0:	91002f61 	add	x1, x27, #0xb
ffffffffea8135a4:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea8135a8:	79400001 	ldrh	w1, [x0]
ffffffffea8135ac:	17ffff1a 	b	ffffffffea813214 <_printf_engine+0x174>
ffffffffea8135b0:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea8135b4:	17fffee3 	b	ffffffffea813140 <_printf_engine+0xa0>
					*(size_t *)ptr = chars_written;
ffffffffea8135b8:	f9000013 	str	x19, [x0]
ffffffffea8135bc:	17ffffae 	b	ffffffffea813474 <_printf_engine+0x3d4>
			if (signchar != '\0' && format_num > 0)
ffffffffea8135c0:	3400043a 	cbz	w26, ffffffffea813644 <_printf_engine+0x5a4>
				format_num--;
ffffffffea8135c4:	5100075a 	sub	w26, w26, #0x1
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea8135c8:	34001aa1 	cbz	w1, ffffffffea81391c <_printf_engine+0x87c>
				OUTPUT_CHAR(signchar);
ffffffffea8135cc:	390283a0 	strb	w0, [x29, #160]
ffffffffea8135d0:	aa1503e2 	mov	x2, x21
ffffffffea8135d4:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea8135d8:	aa1603e0 	mov	x0, x22
ffffffffea8135dc:	d63f0280 	blr	x20
ffffffffea8135e0:	37ffdfc0 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
ffffffffea8135e4:	8b20c273 	add	x19, x19, w0, sxtw
			for (; format_num > string_len; format_num--)
ffffffffea8135e8:	f9403fa0 	ldr	x0, [x29, #120]
ffffffffea8135ec:	eb3a401f 	cmp	x0, w26, uxtw
ffffffffea8135f0:	54fff003 	b.cc	ffffffffea8133f0 <_printf_engine+0x350>  // b.lo, b.ul, b.last
ffffffffea8135f4:	d503201f 	nop
			OUTPUT_STRING(s, SIZE_MAX);
ffffffffea8135f8:	aa1503e2 	mov	x2, x21
ffffffffea8135fc:	92800001 	mov	x1, #0xffffffffffffffff    	// #-1
ffffffffea813600:	aa1703e0 	mov	x0, x23
ffffffffea813604:	d63f0280 	blr	x20
ffffffffea813608:	36fff340 	tbz	w0, #31, ffffffffea813470 <_printf_engine+0x3d0>
ffffffffea81360c:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea813610:	17fffecc 	b	ffffffffea813140 <_printf_engine+0xa0>
			if (!(flags & LEADZEROFLAG) && signchar != '\0')
ffffffffea813614:	b94083a0 	ldr	w0, [x29, #128]
ffffffffea813618:	35ffff00 	cbnz	w0, ffffffffea8135f8 <_printf_engine+0x558>
ffffffffea81361c:	39427fa0 	ldrb	w0, [x29, #159]
ffffffffea813620:	34fffec0 	cbz	w0, ffffffffea8135f8 <_printf_engine+0x558>
				OUTPUT_CHAR(signchar);
ffffffffea813624:	390283a0 	strb	w0, [x29, #160]
ffffffffea813628:	aa1503e2 	mov	x2, x21
ffffffffea81362c:	d2800021 	mov	x1, #0x1                   	// #1
ffffffffea813630:	aa1603e0 	mov	x0, x22
ffffffffea813634:	d63f0280 	blr	x20
ffffffffea813638:	37ffdd00 	tbnz	w0, #31, ffffffffea8131d8 <_printf_engine+0x138>
ffffffffea81363c:	8b20c273 	add	x19, x19, w0, sxtw
ffffffffea813640:	17ffffee 	b	ffffffffea8135f8 <_printf_engine+0x558>
			if (flags & LEADZEROFLAG && signchar != '\0')
ffffffffea813644:	b94083a1 	ldr	w1, [x29, #128]
ffffffffea813648:	35fffc21 	cbnz	w1, ffffffffea8135cc <_printf_engine+0x52c>
ffffffffea81364c:	17fffff6 	b	ffffffffea813624 <_printf_engine+0x584>
		OUTPUT_STRING(s, string_len);
ffffffffea813650:	8b20c273 	add	x19, x19, w0, sxtw
	return (err < 0) ? err : (int)chars_written;
ffffffffea813654:	2a1303e0 	mov	w0, w19
ffffffffea813658:	17fffeba 	b	ffffffffea813140 <_printf_engine+0xa0>
				else if (flags & HALFFLAG)
ffffffffea81365c:	361004d8 	tbz	w24, #2, ffffffffea8136f4 <_printf_engine+0x654>
					*(short *)ptr = chars_written;
ffffffffea813660:	79000013 	strh	w19, [x0]
ffffffffea813664:	17ffff84 	b	ffffffffea813474 <_printf_engine+0x3d4>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea813668:	36100318 	tbz	w24, #2, ffffffffea8136c8 <_printf_engine+0x628>
ffffffffea81366c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813670:	37f80a80 	tbnz	w0, #31, ffffffffea8137c0 <_printf_engine+0x720>
ffffffffea813674:	aa1b03e0 	mov	x0, x27
ffffffffea813678:	91002f61 	add	x1, x27, #0xb
ffffffffea81367c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
ffffffffea813680:	79400001 	ldrh	w1, [x0]
ffffffffea813684:	17ffff4b 	b	ffffffffea8133b0 <_printf_engine+0x310>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813688:	361003d8 	tbz	w24, #2, ffffffffea813700 <_printf_engine+0x660>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea81368c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813690:	37f804e0 	tbnz	w0, #31, ffffffffea81372c <_printf_engine+0x68c>
ffffffffea813694:	aa1b03e0 	mov	x0, x27
ffffffffea813698:	91002f61 	add	x1, x27, #0xb
ffffffffea81369c:	927df03b 	and	x27, x1, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea8136a0:	79800001 	ldrsh	x1, [x0]
ffffffffea8136a4:	17ffff42 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea8136a8:	372ff298 	tbnz	w24, #5, ffffffffea8134f8 <_printf_engine+0x458>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8136ac:	3737f278 	tbnz	w24, #6, ffffffffea8134f8 <_printf_engine+0x458>
				    va_arg(ap, unsigned int);
ffffffffea8136b0:	37f80520 	tbnz	w0, #31, ffffffffea813754 <_printf_engine+0x6b4>
ffffffffea8136b4:	aa1b03e0 	mov	x0, x27
ffffffffea8136b8:	91002f61 	add	x1, x27, #0xb
ffffffffea8136bc:	927df03b 	and	x27, x1, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8136c0:	b9400001 	ldr	w1, [x0]
ffffffffea8136c4:	17fffed4 	b	ffffffffea813214 <_printf_engine+0x174>
				    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
ffffffffea8136c8:	3727e1b8 	tbnz	w24, #4, ffffffffea8132fc <_printf_engine+0x25c>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea8136cc:	372fe198 	tbnz	w24, #5, ffffffffea8132fc <_printf_engine+0x25c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8136d0:	b94087a2 	ldr	w2, [x29, #132]
ffffffffea8136d4:	36301ff8 	tbz	w24, #6, ffffffffea813ad0 <_printf_engine+0xa30>
ffffffffea8136d8:	37f81ea2 	tbnz	w2, #31, ffffffffea813aac <_printf_engine+0xa0c>
ffffffffea8136dc:	91003f60 	add	x0, x27, #0xf
ffffffffea8136e0:	927df000 	and	x0, x0, #0xfffffffffffffff8
ffffffffea8136e4:	f9400361 	ldr	x1, [x27]
ffffffffea8136e8:	aa0003fb 	mov	x27, x0
ffffffffea8136ec:	b90087a2 	str	w2, [x29, #132]
ffffffffea8136f0:	17ffff30 	b	ffffffffea8133b0 <_printf_engine+0x310>
				else if (flags & SIZETFLAG)
ffffffffea8136f4:	3727f638 	tbnz	w24, #4, ffffffffea8135b8 <_printf_engine+0x518>
					*(int *)ptr = chars_written;
ffffffffea8136f8:	b9000013 	str	w19, [x0]
ffffffffea8136fc:	17ffff5e 	b	ffffffffea813474 <_printf_engine+0x3d4>
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813700:	3727e4b8 	tbnz	w24, #4, ffffffffea813394 <_printf_engine+0x2f4>
ffffffffea813704:	372fe498 	tbnz	w24, #5, ffffffffea813394 <_printf_engine+0x2f4>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea813708:	b94087a2 	ldr	w2, [x29, #132]
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81370c:	36300818 	tbz	w24, #6, ffffffffea81380c <_printf_engine+0x76c>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea813710:	37f806c2 	tbnz	w2, #31, ffffffffea8137e8 <_printf_engine+0x748>
ffffffffea813714:	91003f60 	add	x0, x27, #0xf
ffffffffea813718:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81371c:	f9400361 	ldr	x1, [x27]
ffffffffea813720:	aa0003fb 	mov	x27, x0
ffffffffea813724:	b90087a2 	str	w2, [x29, #132]
ffffffffea813728:	17ffff21 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea81372c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813730:	11002001 	add	w1, w0, #0x8
ffffffffea813734:	7100003f 	cmp	w1, #0x0
ffffffffea813738:	5400022d 	b.le	ffffffffea81377c <_printf_engine+0x6dc>
ffffffffea81373c:	aa1b03e0 	mov	x0, x27
ffffffffea813740:	91002f62 	add	x2, x27, #0xb
ffffffffea813744:	b90087a1 	str	w1, [x29, #132]
ffffffffea813748:	927df05b 	and	x27, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81374c:	79800001 	ldrsh	x1, [x0]
ffffffffea813750:	17ffff17 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    va_arg(ap, unsigned int);
ffffffffea813754:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813758:	11002001 	add	w1, w0, #0x8
ffffffffea81375c:	7100003f 	cmp	w1, #0x0
ffffffffea813760:	540001ad 	b.le	ffffffffea813794 <_printf_engine+0x6f4>
ffffffffea813764:	aa1b03e0 	mov	x0, x27
ffffffffea813768:	91002f62 	add	x2, x27, #0xb
ffffffffea81376c:	b90087a1 	str	w1, [x29, #132]
ffffffffea813770:	927df05b 	and	x27, x2, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea813774:	b9400001 	ldr	w1, [x0]
ffffffffea813778:	17fffea7 	b	ffffffffea813214 <_printf_engine+0x174>
				    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
ffffffffea81377c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813780:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813784:	b90087a1 	str	w1, [x29, #132]
ffffffffea813788:	8b20c040 	add	x0, x2, w0, sxtw
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81378c:	79800001 	ldrsh	x1, [x0]
ffffffffea813790:	17ffff07 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    va_arg(ap, unsigned int);
ffffffffea813794:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813798:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea81379c:	b90087a1 	str	w1, [x29, #132]
ffffffffea8137a0:	8b20c040 	add	x0, x2, w0, sxtw
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea8137a4:	b9400001 	ldr	w1, [x0]
ffffffffea8137a8:	17fffe9b 	b	ffffffffea813214 <_printf_engine+0x174>
ffffffffea8137ac:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8137b0:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8137b4:	b90087a1 	str	w1, [x29, #132]
ffffffffea8137b8:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea8137bc:	17fffe95 	b	ffffffffea813210 <_printf_engine+0x170>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8137c0:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8137c4:	11002001 	add	w1, w0, #0x8
ffffffffea8137c8:	7100003f 	cmp	w1, #0x0
ffffffffea8137cc:	540002ed 	b.le	ffffffffea813828 <_printf_engine+0x788>
ffffffffea8137d0:	aa1b03e0 	mov	x0, x27
ffffffffea8137d4:	91002f62 	add	x2, x27, #0xb
ffffffffea8137d8:	b90087a1 	str	w1, [x29, #132]
ffffffffea8137dc:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea8137e0:	79400001 	ldrh	w1, [x0]
ffffffffea8137e4:	17fffef3 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    (flags & PTRDIFFFLAG) ? va_arg(ap, ptrdiff_t) :
ffffffffea8137e8:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8137ec:	11002002 	add	w2, w0, #0x8
ffffffffea8137f0:	7100005f 	cmp	w2, #0x0
ffffffffea8137f4:	54fff90c 	b.gt	ffffffffea813714 <_printf_engine+0x674>
ffffffffea8137f8:	b94087a1 	ldr	w1, [x29, #132]
ffffffffea8137fc:	aa1b03e0 	mov	x0, x27
ffffffffea813800:	f94037a3 	ldr	x3, [x29, #104]
ffffffffea813804:	8b21c07b 	add	x27, x3, w1, sxtw
ffffffffea813808:	17ffffc5 	b	ffffffffea81371c <_printf_engine+0x67c>
				    va_arg(ap, int);
ffffffffea81380c:	37f801a2 	tbnz	w2, #31, ffffffffea813840 <_printf_engine+0x7a0>
ffffffffea813810:	91002f60 	add	x0, x27, #0xb
ffffffffea813814:	927df000 	and	x0, x0, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813818:	b9800361 	ldrsw	x1, [x27]
ffffffffea81381c:	aa0003fb 	mov	x27, x0
ffffffffea813820:	b90087a2 	str	w2, [x29, #132]
ffffffffea813824:	17fffee2 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea813828:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea81382c:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813830:	b90087a1 	str	w1, [x29, #132]
ffffffffea813834:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813838:	79400001 	ldrh	w1, [x0]
ffffffffea81383c:	17fffedd 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    va_arg(ap, int);
ffffffffea813840:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813844:	11002002 	add	w2, w0, #0x8
ffffffffea813848:	7100005f 	cmp	w2, #0x0
ffffffffea81384c:	54fffe2c 	b.gt	ffffffffea813810 <_printf_engine+0x770>
ffffffffea813850:	b94087a1 	ldr	w1, [x29, #132]
ffffffffea813854:	aa1b03e0 	mov	x0, x27
ffffffffea813858:	f94037a3 	ldr	x3, [x29, #104]
ffffffffea81385c:	8b21c07b 	add	x27, x3, w1, sxtw
ffffffffea813860:	17ffffee 	b	ffffffffea813818 <_printf_engine+0x778>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea813864:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813868:	11002001 	add	w1, w0, #0x8
ffffffffea81386c:	7100003f 	cmp	w1, #0x0
ffffffffea813870:	540000ed 	b.le	ffffffffea81388c <_printf_engine+0x7ec>
ffffffffea813874:	aa1b03e0 	mov	x0, x27
ffffffffea813878:	b90087a1 	str	w1, [x29, #132]
ffffffffea81387c:	91003f62 	add	x2, x27, #0xf
ffffffffea813880:	927df05b 	and	x27, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813884:	f9400001 	ldr	x1, [x0]
ffffffffea813888:	17fffec9 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
ffffffffea81388c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813890:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813894:	b90087a1 	str	w1, [x29, #132]
ffffffffea813898:	8b20c040 	add	x0, x2, w0, sxtw
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea81389c:	f9400001 	ldr	x1, [x0]
ffffffffea8138a0:	17fffec3 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8138a4:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8138a8:	11002001 	add	w1, w0, #0x8
ffffffffea8138ac:	7100003f 	cmp	w1, #0x0
ffffffffea8138b0:	5400020d 	b.le	ffffffffea8138f0 <_printf_engine+0x850>
ffffffffea8138b4:	aa1b03e0 	mov	x0, x27
ffffffffea8138b8:	91002f62 	add	x2, x27, #0xb
ffffffffea8138bc:	b90087a1 	str	w1, [x29, #132]
ffffffffea8138c0:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea8138c4:	79400001 	ldrh	w1, [x0]
ffffffffea8138c8:	17fffe53 	b	ffffffffea813214 <_printf_engine+0x174>
				s = va_arg(ap, const char *);
ffffffffea8138cc:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8138d0:	11002001 	add	w1, w0, #0x8
ffffffffea8138d4:	7100003f 	cmp	w1, #0x0
ffffffffea8138d8:	5400018d 	b.le	ffffffffea813908 <_printf_engine+0x868>
ffffffffea8138dc:	91003f62 	add	x2, x27, #0xf
ffffffffea8138e0:	aa1b03e0 	mov	x0, x27
ffffffffea8138e4:	b90087a1 	str	w1, [x29, #132]
ffffffffea8138e8:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea8138ec:	17ffff19 	b	ffffffffea813550 <_printf_engine+0x4b0>
				    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
ffffffffea8138f0:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8138f4:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8138f8:	b90087a1 	str	w1, [x29, #132]
ffffffffea8138fc:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813900:	79400001 	ldrh	w1, [x0]
ffffffffea813904:	17fffe44 	b	ffffffffea813214 <_printf_engine+0x174>
				s = va_arg(ap, const char *);
ffffffffea813908:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea81390c:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813910:	b90087a1 	str	w1, [x29, #132]
ffffffffea813914:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813918:	17ffff0e 	b	ffffffffea813550 <_printf_engine+0x4b0>
			for (; format_num > string_len; format_num--)
ffffffffea81391c:	f9403fa1 	ldr	x1, [x29, #120]
ffffffffea813920:	eb3a403f 	cmp	x1, w26, uxtw
ffffffffea813924:	54ffd663 	b.cc	ffffffffea8133f0 <_printf_engine+0x350>  // b.lo, b.ul, b.last
ffffffffea813928:	17ffff3e 	b	ffffffffea813620 <_printf_engine+0x580>
ffffffffea81392c:	a90363b7 	stp	x23, x24, [x29, #48]
}
ffffffffea813930:	940000fe 	bl	ffffffffea813d28 <__stack_chk_fail>
				uc = va_arg(ap, unsigned int);
ffffffffea813934:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813938:	11002001 	add	w1, w0, #0x8
ffffffffea81393c:	7100003f 	cmp	w1, #0x0
ffffffffea813940:	5400020d 	b.le	ffffffffea813980 <_printf_engine+0x8e0>
ffffffffea813944:	aa1b03e0 	mov	x0, x27
ffffffffea813948:	91002f62 	add	x2, x27, #0xb
ffffffffea81394c:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea813950:	b90087a1 	str	w1, [x29, #132]
ffffffffea813954:	b9400000 	ldr	w0, [x0]
ffffffffea813958:	17fffec0 	b	ffffffffea813458 <_printf_engine+0x3b8>
				ptr = va_arg(ap, void *);
ffffffffea81395c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813960:	11002001 	add	w1, w0, #0x8
ffffffffea813964:	7100003f 	cmp	w1, #0x0
ffffffffea813968:	5400018d 	b.le	ffffffffea813998 <_printf_engine+0x8f8>
ffffffffea81396c:	91003f62 	add	x2, x27, #0xf
ffffffffea813970:	aa1b03e0 	mov	x0, x27
ffffffffea813974:	b90087a1 	str	w1, [x29, #132]
ffffffffea813978:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea81397c:	17ffff01 	b	ffffffffea813580 <_printf_engine+0x4e0>
				uc = va_arg(ap, unsigned int);
ffffffffea813980:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813984:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813988:	b90087a1 	str	w1, [x29, #132]
ffffffffea81398c:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813990:	b9400000 	ldr	w0, [x0]
ffffffffea813994:	17fffeb1 	b	ffffffffea813458 <_printf_engine+0x3b8>
				ptr = va_arg(ap, void *);
ffffffffea813998:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea81399c:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8139a0:	b90087a1 	str	w1, [x29, #132]
ffffffffea8139a4:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea8139a8:	17fffef6 	b	ffffffffea813580 <_printf_engine+0x4e0>
				    (flags & INTMAXFLAG) ? va_arg(ap, uintmax_t) :
ffffffffea8139ac:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8139b0:	11002001 	add	w1, w0, #0x8
ffffffffea8139b4:	7100003f 	cmp	w1, #0x0
ffffffffea8139b8:	540000ed 	b.le	ffffffffea8139d4 <_printf_engine+0x934>
ffffffffea8139bc:	aa1b03e0 	mov	x0, x27
ffffffffea8139c0:	b90087a1 	str	w1, [x29, #132]
ffffffffea8139c4:	91003f62 	add	x2, x27, #0xf
ffffffffea8139c8:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea8139cc:	f9400001 	ldr	x1, [x0]
ffffffffea8139d0:	17fffe78 	b	ffffffffea8133b0 <_printf_engine+0x310>
ffffffffea8139d4:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8139d8:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea8139dc:	b90087a1 	str	w1, [x29, #132]
ffffffffea8139e0:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea8139e4:	f9400001 	ldr	x1, [x0]
ffffffffea8139e8:	17fffe72 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea8139ec:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea8139f0:	11002001 	add	w1, w0, #0x8
ffffffffea8139f4:	7100003f 	cmp	w1, #0x0
ffffffffea8139f8:	540000ed 	b.le	ffffffffea813a14 <_printf_engine+0x974>
ffffffffea8139fc:	aa1b03e0 	mov	x0, x27
ffffffffea813a00:	91002f62 	add	x2, x27, #0xb
ffffffffea813a04:	b90087a1 	str	w1, [x29, #132]
ffffffffea813a08:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea813a0c:	39400001 	ldrb	w1, [x0]
ffffffffea813a10:	17fffe01 	b	ffffffffea813214 <_printf_engine+0x174>
ffffffffea813a14:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813a18:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813a1c:	b90087a1 	str	w1, [x29, #132]
ffffffffea813a20:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813a24:	39400001 	ldrb	w1, [x0]
ffffffffea813a28:	17fffdfb 	b	ffffffffea813214 <_printf_engine+0x174>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea813a2c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813a30:	11002001 	add	w1, w0, #0x8
ffffffffea813a34:	7100003f 	cmp	w1, #0x0
ffffffffea813a38:	5400022d 	b.le	ffffffffea813a7c <_printf_engine+0x9dc>
ffffffffea813a3c:	aa1b03e0 	mov	x0, x27
ffffffffea813a40:	91002f62 	add	x2, x27, #0xb
ffffffffea813a44:	b90087a1 	str	w1, [x29, #132]
ffffffffea813a48:	927df05b 	and	x27, x2, #0xfffffffffffffff8
ffffffffea813a4c:	39400001 	ldrb	w1, [x0]
ffffffffea813a50:	17fffe58 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea813a54:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813a58:	11002001 	add	w1, w0, #0x8
ffffffffea813a5c:	7100003f 	cmp	w1, #0x0
ffffffffea813a60:	540001ad 	b.le	ffffffffea813a94 <_printf_engine+0x9f4>
ffffffffea813a64:	aa1b03e0 	mov	x0, x27
ffffffffea813a68:	91002f62 	add	x2, x27, #0xb
ffffffffea813a6c:	b90087a1 	str	w1, [x29, #132]
ffffffffea813a70:	927df05b 	and	x27, x2, #0xfffffffffffffff8
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813a74:	39800001 	ldrsb	x1, [x0]
ffffffffea813a78:	17fffe4d 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
ffffffffea813a7c:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813a80:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813a84:	b90087a1 	str	w1, [x29, #132]
ffffffffea813a88:	8b20c040 	add	x0, x2, w0, sxtw
ffffffffea813a8c:	39400001 	ldrb	w1, [x0]
ffffffffea813a90:	17fffe48 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
ffffffffea813a94:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813a98:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813a9c:	b90087a1 	str	w1, [x29, #132]
ffffffffea813aa0:	8b20c040 	add	x0, x2, w0, sxtw
				n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
ffffffffea813aa4:	39800001 	ldrsb	x1, [x0]
ffffffffea813aa8:	17fffe41 	b	ffffffffea8133ac <_printf_engine+0x30c>
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea813aac:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813ab0:	11002002 	add	w2, w0, #0x8
ffffffffea813ab4:	7100005f 	cmp	w2, #0x0
ffffffffea813ab8:	54ffe12c 	b.gt	ffffffffea8136dc <_printf_engine+0x63c>
ffffffffea813abc:	b94087a1 	ldr	w1, [x29, #132]
ffffffffea813ac0:	aa1b03e0 	mov	x0, x27
ffffffffea813ac4:	f94037a3 	ldr	x3, [x29, #104]
ffffffffea813ac8:	8b21c07b 	add	x27, x3, w1, sxtw
ffffffffea813acc:	17ffff06 	b	ffffffffea8136e4 <_printf_engine+0x644>
				    va_arg(ap, unsigned int);
ffffffffea813ad0:	37f800e2 	tbnz	w2, #31, ffffffffea813aec <_printf_engine+0xa4c>
ffffffffea813ad4:	91002f60 	add	x0, x27, #0xb
ffffffffea813ad8:	927df000 	and	x0, x0, #0xfffffffffffffff8
				    (flags & PTRDIFFFLAG) ? (uintptr_t)va_arg(ap, ptrdiff_t) :
ffffffffea813adc:	b9400361 	ldr	w1, [x27]
ffffffffea813ae0:	aa0003fb 	mov	x27, x0
ffffffffea813ae4:	b90087a2 	str	w2, [x29, #132]
ffffffffea813ae8:	17fffe32 	b	ffffffffea8133b0 <_printf_engine+0x310>
				    va_arg(ap, unsigned int);
ffffffffea813aec:	b94087a0 	ldr	w0, [x29, #132]
ffffffffea813af0:	11002002 	add	w2, w0, #0x8
ffffffffea813af4:	7100005f 	cmp	w2, #0x0
ffffffffea813af8:	54fffeec 	b.gt	ffffffffea813ad4 <_printf_engine+0xa34>
ffffffffea813afc:	b94087a1 	ldr	w1, [x29, #132]
ffffffffea813b00:	aa1b03e0 	mov	x0, x27
ffffffffea813b04:	f94037a3 	ldr	x3, [x29, #104]
ffffffffea813b08:	8b21c07b 	add	x27, x3, w1, sxtw
ffffffffea813b0c:	17fffff4 	b	ffffffffea813adc <_printf_engine+0xa3c>

ffffffffea813b10 <vsnprintf>:
{
ffffffffea813b10:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
ffffffffea813b14:	910003fd 	mov	x29, sp
ffffffffea813b18:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea813b1c:	f0000273 	adrp	x19, ffffffffea862000 <__ctor_list>
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813b20:	a9401464 	ldp	x4, x5, [x3]
	args.outstr = str;
ffffffffea813b24:	f9002ba0 	str	x0, [x29, #80]
{
ffffffffea813b28:	f9402a66 	ldr	x6, [x19, #80]
ffffffffea813b2c:	aa0003f4 	mov	x20, x0
ffffffffea813b30:	f90013f5 	str	x21, [sp, #32]
ffffffffea813b34:	aa0103f5 	mov	x21, x1
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813b38:	a9410460 	ldp	x0, x1, [x3, #16]
{
ffffffffea813b3c:	f94000c3 	ldr	x3, [x6]
ffffffffea813b40:	f90037a3 	str	x3, [x29, #104]
ffffffffea813b44:	d2800003 	mov	x3, #0x0                   	// #0
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813b48:	9100c3a3 	add	x3, x29, #0x30
ffffffffea813b4c:	a90317a4 	stp	x4, x5, [x29, #48]
ffffffffea813b50:	a90407a0 	stp	x0, x1, [x29, #64]
ffffffffea813b54:	910143a1 	add	x1, x29, #0x50
	args.pos = 0;
ffffffffea813b58:	f90033bf 	str	xzr, [x29, #96]
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813b5c:	f0ffffe0 	adrp	x0, ffffffffea812000 <register_print_callback+0x70>
	args.len = len;
ffffffffea813b60:	f9002fb5 	str	x21, [x29, #88]
	wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
ffffffffea813b64:	913d2000 	add	x0, x0, #0xf48
ffffffffea813b68:	97fffd4e 	bl	ffffffffea8130a0 <_printf_engine>
	if (args.pos >= len)
ffffffffea813b6c:	f94033a1 	ldr	x1, [x29, #96]
ffffffffea813b70:	eb15003f 	cmp	x1, x21
ffffffffea813b74:	54000162 	b.cs	ffffffffea813ba0 <vsnprintf+0x90>  // b.hs, b.nlast
		str[wlen] = '\0';
ffffffffea813b78:	3820ca9f 	strb	wzr, [x20, w0, sxtw]
}
ffffffffea813b7c:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea813b80:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813b84:	f9400261 	ldr	x1, [x19]
ffffffffea813b88:	ca010041 	eor	x1, x2, x1
ffffffffea813b8c:	b5000101 	cbnz	x1, ffffffffea813bac <vsnprintf+0x9c>
ffffffffea813b90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813b94:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea813b98:	a8c77bfd 	ldp	x29, x30, [sp], #112
ffffffffea813b9c:	d65f03c0 	ret
		str[len-1] = '\0';
ffffffffea813ba0:	8b150294 	add	x20, x20, x21
ffffffffea813ba4:	381ff29f 	sturb	wzr, [x20, #-1]
ffffffffea813ba8:	17fffff5 	b	ffffffffea813b7c <vsnprintf+0x6c>
}
ffffffffea813bac:	9400005f 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea813bb0 <snprintf>:
{
ffffffffea813bb0:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
ffffffffea813bb4:	910003fd 	mov	x29, sp
	va_start(ap, fmt);
ffffffffea813bb8:	910283a8 	add	x8, x29, #0xa0
ffffffffea813bbc:	9101c3a9 	add	x9, x29, #0x70
{
ffffffffea813bc0:	f9000bf3 	str	x19, [sp, #16]
ffffffffea813bc4:	f0000273 	adrp	x19, ffffffffea862000 <__ctor_list>
	va_start(ap, fmt);
ffffffffea813bc8:	a904a3a8 	stp	x8, x8, [x29, #72]
ffffffffea813bcc:	128004e8 	mov	w8, #0xffffffd8            	// #-40
ffffffffea813bd0:	f9002fa9 	str	x9, [x29, #88]
ffffffffea813bd4:	b90063a8 	str	w8, [x29, #96]
ffffffffea813bd8:	b90067bf 	str	wzr, [x29, #100]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea813bdc:	a944afaa 	ldp	x10, x11, [x29, #72]
{
ffffffffea813be0:	a90793a3 	stp	x3, x4, [x29, #120]
	err = vsnprintf(str, len, fmt, ap);
ffffffffea813be4:	a945a7a8 	ldp	x8, x9, [x29, #88]
{
ffffffffea813be8:	a9089ba5 	stp	x5, x6, [x29, #136]
ffffffffea813bec:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea813bf0:	f9004fa7 	str	x7, [x29, #152]
ffffffffea813bf4:	f9400263 	ldr	x3, [x19]
ffffffffea813bf8:	f90037a3 	str	x3, [x29, #104]
ffffffffea813bfc:	d2800003 	mov	x3, #0x0                   	// #0
	err = vsnprintf(str, len, fmt, ap);
ffffffffea813c00:	a9022faa 	stp	x10, x11, [x29, #32]
ffffffffea813c04:	a90327a8 	stp	x8, x9, [x29, #48]
ffffffffea813c08:	910083a3 	add	x3, x29, #0x20
ffffffffea813c0c:	97ffffc1 	bl	ffffffffea813b10 <vsnprintf>
}
ffffffffea813c10:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea813c14:	f9400261 	ldr	x1, [x19]
ffffffffea813c18:	ca010041 	eor	x1, x2, x1
ffffffffea813c1c:	b5000081 	cbnz	x1, ffffffffea813c2c <snprintf+0x7c>
ffffffffea813c20:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813c24:	a8ca7bfd 	ldp	x29, x30, [sp], #160
ffffffffea813c28:	d65f03c0 	ret
ffffffffea813c2c:	9400003f 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea813c30 <rand>:
	randseed ^= enp;
}

int rand(void)
{
	return (randseed = randseed * 1664525 + 1013904223);
ffffffffea813c30:	f0000021 	adrp	x1, ffffffffea81a000 <__stdio_FILEs+0x60>
ffffffffea813c34:	528cc1a3 	mov	w3, #0x660d                	// #26125
ffffffffea813c38:	529e6be2 	mov	w2, #0xf35f                	// #62303
ffffffffea813c3c:	72a00323 	movk	w3, #0x19, lsl #16
ffffffffea813c40:	b9402820 	ldr	w0, [x1, #40]
ffffffffea813c44:	72a78dc2 	movk	w2, #0x3c6e, lsl #16
ffffffffea813c48:	1b030800 	madd	w0, w0, w3, w2
ffffffffea813c4c:	b9002820 	str	w0, [x1, #40]
}
ffffffffea813c50:	d65f03c0 	ret
ffffffffea813c54:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813c58 <_printf>:
	va_end(ap);
	return err;
}

int _printf(const char *fmt, ...)
{
ffffffffea813c58:	a9b37bfd 	stp	x29, x30, [sp, #-208]!
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813c5c:	f0000268 	adrp	x8, ffffffffea862000 <__ctor_list>
{
ffffffffea813c60:	910003fd 	mov	x29, sp
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813c64:	f9405d08 	ldr	x8, [x8, #184]
	va_list ap;
	int err;

	va_start(ap, fmt);
ffffffffea813c68:	910343a9 	add	x9, x29, #0xd0
ffffffffea813c6c:	910243aa 	add	x10, x29, #0x90
ffffffffea813c70:	a904a7a9 	stp	x9, x9, [x29, #72]
ffffffffea813c74:	128006e9 	mov	w9, #0xffffffc8            	// #-56
ffffffffea813c78:	f9002faa 	str	x10, [x29, #88]
{
ffffffffea813c7c:	f9004fa1 	str	x1, [x29, #152]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813c80:	aa0003e1 	mov	x1, x0
	va_start(ap, fmt);
ffffffffea813c84:	b90067bf 	str	wzr, [x29, #100]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813c88:	f9401500 	ldr	x0, [x8, #40]
ffffffffea813c8c:	f940250c 	ldr	x12, [x8, #72]
	va_start(ap, fmt);
ffffffffea813c90:	b90063a9 	str	w9, [x29, #96]
{
ffffffffea813c94:	f9000bf3 	str	x19, [sp, #16]
ffffffffea813c98:	f0000273 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea813c9c:	a944afaa 	ldp	x10, x11, [x29, #72]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813ca0:	a9022faa 	stp	x10, x11, [x29, #32]
ffffffffea813ca4:	a945a7a8 	ldp	x8, x9, [x29, #88]
ffffffffea813ca8:	a90327a8 	stp	x8, x9, [x29, #48]
{
ffffffffea813cac:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea813cb0:	a90a0fa2 	stp	x2, x3, [x29, #160]
ffffffffea813cb4:	a90b17a4 	stp	x4, x5, [x29, #176]
ffffffffea813cb8:	a90c1fa6 	stp	x6, x7, [x29, #192]
ffffffffea813cbc:	a906afaa 	stp	x10, x11, [x29, #104]
ffffffffea813cc0:	f9400262 	ldr	x2, [x19]
ffffffffea813cc4:	f90047a2 	str	x2, [x29, #136]
ffffffffea813cc8:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813ccc:	a907a7a8 	stp	x8, x9, [x29, #120]
	return fp->vfprintf(fp->ctx, fmt, ap);
ffffffffea813cd0:	910083a2 	add	x2, x29, #0x20
ffffffffea813cd4:	d63f0180 	blr	x12
	err = vfprintf(stdout, fmt, ap);
	va_end(ap);

	return err;
}
ffffffffea813cd8:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea813cdc:	f9400261 	ldr	x1, [x19]
ffffffffea813ce0:	ca010041 	eor	x1, x2, x1
ffffffffea813ce4:	b5000081 	cbnz	x1, ffffffffea813cf4 <_printf+0x9c>
ffffffffea813ce8:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813cec:	a8cd7bfd 	ldp	x29, x30, [sp], #208
ffffffffea813cf0:	d65f03c0 	ret
ffffffffea813cf4:	9400000d 	bl	ffffffffea813d28 <__stack_chk_fail>

ffffffffea813cf8 <__guard_setup>:

#include <rand.h>

unsigned int __stack_chk_guard = 0xaff;

static void __attribute__((constructor)) __guard_setup (void){
ffffffffea813cf8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813cfc:	910003fd 	mov	x29, sp
ffffffffea813d00:	f9000bf3 	str	x19, [sp, #16]
        /* 
         * included for future use. rand.h must be seeded and -fstack_protector must be disabled in
         * stack contexts preceeding this call.
         */
  	if ( __stack_chk_guard == 0U )
ffffffffea813d04:	f0000033 	adrp	x19, ffffffffea81a000 <__stdio_FILEs+0x60>
ffffffffea813d08:	b9402e60 	ldr	w0, [x19, #44]
ffffffffea813d0c:	35000060 	cbnz	w0, ffffffffea813d18 <__guard_setup+0x20>
  		__stack_chk_guard = rand();
ffffffffea813d10:	97ffffc8 	bl	ffffffffea813c30 <rand>
ffffffffea813d14:	b9002e60 	str	w0, [x19, #44]
}
ffffffffea813d18:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea813d1c:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813d20:	d65f03c0 	ret
ffffffffea813d24:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813d28 <__stack_chk_fail>:
		while (*_px == *_px) { }				\
	} while (1);

void __attribute__((noreturn)) __stack_chk_fail(void);
void __attribute__((noreturn)) __stack_chk_fail(void)
{
ffffffffea813d28:	f0000260 	adrp	x0, ffffffffea862000 <__ctor_list>
ffffffffea813d2c:	d10043ff 	sub	sp, sp, #0x10
	TRUSTY_LIBC_BREAK()
ffffffffea813d30:	52800602 	mov	w2, #0x30                  	// #48
{
ffffffffea813d34:	f9402800 	ldr	x0, [x0, #80]
ffffffffea813d38:	f9400001 	ldr	x1, [x0]
ffffffffea813d3c:	f90007e1 	str	x1, [sp, #8]
ffffffffea813d40:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea813d44:	d503201f 	nop
	TRUSTY_LIBC_BREAK()
ffffffffea813d48:	b90007e2 	str	w2, [sp, #4]
ffffffffea813d4c:	d503201f 	nop
ffffffffea813d50:	b94007e1 	ldr	w1, [sp, #4]
ffffffffea813d54:	b94007e0 	ldr	w0, [sp, #4]
ffffffffea813d58:	6b00003f 	cmp	w1, w0
ffffffffea813d5c:	54ffffa0 	b.eq	ffffffffea813d50 <__stack_chk_fail+0x28>  // b.none
ffffffffea813d60:	17fffffa 	b	ffffffffea813d48 <__stack_chk_fail+0x20>
ffffffffea813d64:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813d68 <malloc>:
#include <string.h>
#include <lib/heap.h>

void *malloc(size_t size)
{
	return heap_alloc(size, 0);
ffffffffea813d68:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813d6c:	17fffae5 	b	ffffffffea812900 <heap_alloc>

ffffffffea813d70 <memalign>:
}

void *memalign(size_t boundary, size_t size)
{
ffffffffea813d70:	aa0103e2 	mov	x2, x1
	return heap_alloc(size, boundary);
ffffffffea813d74:	2a0003e1 	mov	w1, w0
ffffffffea813d78:	aa0203e0 	mov	x0, x2
ffffffffea813d7c:	17fffae1 	b	ffffffffea812900 <heap_alloc>

ffffffffea813d80 <calloc>:
}

void *calloc(size_t count, size_t size)
{
ffffffffea813d80:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea813d84:	910003fd 	mov	x29, sp
ffffffffea813d88:	a90153f3 	stp	x19, x20, [sp, #16]
	void *ptr;
	size_t realsize = count * size;
ffffffffea813d8c:	9b017c14 	mul	x20, x0, x1

	ptr = heap_alloc(realsize, 0);
ffffffffea813d90:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813d94:	aa1403e0 	mov	x0, x20
ffffffffea813d98:	97fffada 	bl	ffffffffea812900 <heap_alloc>
ffffffffea813d9c:	aa0003f3 	mov	x19, x0
	if (!ptr)
ffffffffea813da0:	b4000080 	cbz	x0, ffffffffea813db0 <calloc+0x30>
		return NULL;

	memset(ptr, 0, realsize);
ffffffffea813da4:	aa1403e2 	mov	x2, x20
ffffffffea813da8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea813dac:	940000c3 	bl	ffffffffea8140b8 <memset>
	return ptr;
}
ffffffffea813db0:	aa1303e0 	mov	x0, x19
ffffffffea813db4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea813db8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea813dbc:	d65f03c0 	ret

ffffffffea813dc0 <free>:
	return p;
}

void free(void *ptr)
{
	return heap_free(ptr);
ffffffffea813dc0:	17fffb92 	b	ffffffffea812c08 <heap_free>
ffffffffea813dc4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813dc8 <memcpy>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea813dc8:	f100005f 	cmp	x2, #0x0
ffffffffea813dcc:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea813dd0:	540006e0 	b.eq	ffffffffea813eac <memcpy+0xe4>  // b.none
		return dest;

	if (((long)d | (long)s) & lmask) {
ffffffffea813dd4:	aa010003 	orr	x3, x0, x1
ffffffffea813dd8:	aa0003e4 	mov	x4, x0
ffffffffea813ddc:	f240087f 	tst	x3, #0x7
ffffffffea813de0:	540002e0 	b.eq	ffffffffea813e3c <memcpy+0x74>  // b.none
		// src and/or dest do not align on word boundary
		if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea813de4:	ca010003 	eor	x3, x0, x1
ffffffffea813de8:	f240087f 	tst	x3, #0x7
ffffffffea813dec:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea813df0:	54000608 	b.hi	ffffffffea813eb0 <memcpy+0xe8>  // b.pmore
			len = count; // copy the rest of the buffer with the byte mover
ffffffffea813df4:	2a0203e3 	mov	w3, w2
		else
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

		count -= len;
ffffffffea813df8:	cb22c042 	sub	x2, x2, w2, sxtw
		for (; len > 0; len--)
ffffffffea813dfc:	7100007f 	cmp	w3, #0x0
ffffffffea813e00:	540001ed 	b.le	ffffffffea813e3c <memcpy+0x74>
ffffffffea813e04:	51000466 	sub	w6, w3, #0x1
{
ffffffffea813e08:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813e0c:	aa0603e5 	mov	x5, x6
ffffffffea813e10:	910004c6 	add	x6, x6, #0x1
ffffffffea813e14:	d503201f 	nop
			*d++ = *s++;
ffffffffea813e18:	38636824 	ldrb	w4, [x1, x3]
ffffffffea813e1c:	38236804 	strb	w4, [x0, x3]
ffffffffea813e20:	91000463 	add	x3, x3, #0x1
		for (; len > 0; len--)
ffffffffea813e24:	eb06007f 	cmp	x3, x6
ffffffffea813e28:	54ffff81 	b.ne	ffffffffea813e18 <memcpy+0x50>  // b.any
ffffffffea813e2c:	93407ca3 	sxtw	x3, w5
ffffffffea813e30:	91000463 	add	x3, x3, #0x1
ffffffffea813e34:	8b030004 	add	x4, x0, x3
ffffffffea813e38:	8b030021 	add	x1, x1, x3
	}
	for (len = count / lsize; len > 0; len--) {
ffffffffea813e3c:	d343fc43 	lsr	x3, x2, #3
ffffffffea813e40:	7100007f 	cmp	w3, #0x0
ffffffffea813e44:	540001ed 	b.le	ffffffffea813e80 <memcpy+0xb8>
ffffffffea813e48:	51000466 	sub	w6, w3, #0x1
ffffffffea813e4c:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813e50:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea813e54:	910020e7 	add	x7, x7, #0x8
		*(word *)d = *(word *)s;
ffffffffea813e58:	f8636825 	ldr	x5, [x1, x3]
ffffffffea813e5c:	f8236885 	str	x5, [x4, x3]
ffffffffea813e60:	91002063 	add	x3, x3, #0x8
	for (len = count / lsize; len > 0; len--) {
ffffffffea813e64:	eb07007f 	cmp	x3, x7
ffffffffea813e68:	54ffff81 	b.ne	ffffffffea813e58 <memcpy+0x90>  // b.any
ffffffffea813e6c:	93407cc3 	sxtw	x3, w6
ffffffffea813e70:	91000463 	add	x3, x3, #0x1
ffffffffea813e74:	d37df063 	lsl	x3, x3, #3
ffffffffea813e78:	8b030084 	add	x4, x4, x3
ffffffffea813e7c:	8b030021 	add	x1, x1, x3
		d += lsize;
		s += lsize;
	}
	for (len = count & lmask; len > 0; len--)
ffffffffea813e80:	72000842 	ands	w2, w2, #0x7
ffffffffea813e84:	54000140 	b.eq	ffffffffea813eac <memcpy+0xe4>  // b.none
ffffffffea813e88:	51000443 	sub	w3, w2, #0x1
ffffffffea813e8c:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813e90:	91000463 	add	x3, x3, #0x1
ffffffffea813e94:	d503201f 	nop
		*d++ = *s++;
ffffffffea813e98:	38626825 	ldrb	w5, [x1, x2]
ffffffffea813e9c:	38226885 	strb	w5, [x4, x2]
ffffffffea813ea0:	91000442 	add	x2, x2, #0x1
	for (len = count & lmask; len > 0; len--)
ffffffffea813ea4:	eb03005f 	cmp	x2, x3
ffffffffea813ea8:	54ffff81 	b.ne	ffffffffea813e98 <memcpy+0xd0>  // b.any

	return dest;
}
ffffffffea813eac:	d65f03c0 	ret
			len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea813eb0:	12000804 	and	w4, w0, #0x7
ffffffffea813eb4:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea813eb8:	4b040063 	sub	w3, w3, w4
		count -= len;
ffffffffea813ebc:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea813ec0:	17ffffd1 	b	ffffffffea813e04 <memcpy+0x3c>
ffffffffea813ec4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea813ec8 <memmove>:
{
	char *d = (char *)dest;
	const char *s = (const char *)src;
	int len;

	if (count == 0 || dest == src)
ffffffffea813ec8:	f100005f 	cmp	x2, #0x0
ffffffffea813ecc:	fa411004 	ccmp	x0, x1, #0x4, ne  // ne = any
ffffffffea813ed0:	54000720 	b.eq	ffffffffea813fb4 <memmove+0xec>  // b.none
		return dest;

	if ((long)d < (long)s) {
ffffffffea813ed4:	eb01001f 	cmp	x0, x1
ffffffffea813ed8:	5400070a 	b.ge	ffffffffea813fb8 <memmove+0xf0>  // b.tcont
		if (((long)d | (long)s) & lmask) {
ffffffffea813edc:	aa010003 	orr	x3, x0, x1
ffffffffea813ee0:	aa0003e4 	mov	x4, x0
ffffffffea813ee4:	f240087f 	tst	x3, #0x7
ffffffffea813ee8:	540002e0 	b.eq	ffffffffea813f44 <memmove+0x7c>  // b.none
			// src and/or dest do not align on word boundary
			if ((((long)d ^ (long)s) & lmask) || (count < lsize))
ffffffffea813eec:	ca010003 	eor	x3, x0, x1
ffffffffea813ef0:	f240087f 	tst	x3, #0x7
ffffffffea813ef4:	fa470840 	ccmp	x2, #0x7, #0x0, eq  // eq = none
ffffffffea813ef8:	54000d48 	b.hi	ffffffffea8140a0 <memmove+0x1d8>  // b.pmore
				len = count; // copy the rest of the buffer with the byte mover
ffffffffea813efc:	2a0203e3 	mov	w3, w2
			else
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary

			count -= len;
ffffffffea813f00:	cb22c042 	sub	x2, x2, w2, sxtw
			for (; len > 0; len--)
ffffffffea813f04:	7100007f 	cmp	w3, #0x0
ffffffffea813f08:	540001ed 	b.le	ffffffffea813f44 <memmove+0x7c>
ffffffffea813f0c:	51000466 	sub	w6, w3, #0x1
{
ffffffffea813f10:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813f14:	aa0603e5 	mov	x5, x6
ffffffffea813f18:	910004c6 	add	x6, x6, #0x1
ffffffffea813f1c:	d503201f 	nop
				*d++ = *s++;
ffffffffea813f20:	38636824 	ldrb	w4, [x1, x3]
ffffffffea813f24:	38236804 	strb	w4, [x0, x3]
ffffffffea813f28:	91000463 	add	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea813f2c:	eb06007f 	cmp	x3, x6
ffffffffea813f30:	54ffff81 	b.ne	ffffffffea813f20 <memmove+0x58>  // b.any
ffffffffea813f34:	93407ca3 	sxtw	x3, w5
ffffffffea813f38:	91000463 	add	x3, x3, #0x1
ffffffffea813f3c:	8b030004 	add	x4, x0, x3
ffffffffea813f40:	8b030021 	add	x1, x1, x3
		}
		for (len = count / lsize; len > 0; len--) {
ffffffffea813f44:	d343fc43 	lsr	x3, x2, #3
ffffffffea813f48:	7100007f 	cmp	w3, #0x0
ffffffffea813f4c:	540001ed 	b.le	ffffffffea813f88 <memmove+0xc0>
ffffffffea813f50:	51000466 	sub	w6, w3, #0x1
ffffffffea813f54:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea813f58:	d37d7cc7 	ubfiz	x7, x6, #3, #32
ffffffffea813f5c:	910020e7 	add	x7, x7, #0x8
			*(word *)d = *(word *)s;
ffffffffea813f60:	f8636825 	ldr	x5, [x1, x3]
ffffffffea813f64:	f8236885 	str	x5, [x4, x3]
ffffffffea813f68:	91002063 	add	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea813f6c:	eb07007f 	cmp	x3, x7
ffffffffea813f70:	54ffff81 	b.ne	ffffffffea813f60 <memmove+0x98>  // b.any
ffffffffea813f74:	93407cc3 	sxtw	x3, w6
ffffffffea813f78:	91000463 	add	x3, x3, #0x1
ffffffffea813f7c:	d37df063 	lsl	x3, x3, #3
ffffffffea813f80:	8b030084 	add	x4, x4, x3
ffffffffea813f84:	8b030021 	add	x1, x1, x3
			d += lsize;
			s += lsize;
		}
		for (len = count & lmask; len > 0; len--)
ffffffffea813f88:	72000842 	ands	w2, w2, #0x7
ffffffffea813f8c:	54000140 	b.eq	ffffffffea813fb4 <memmove+0xec>  // b.none
ffffffffea813f90:	51000445 	sub	w5, w2, #0x1
ffffffffea813f94:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea813f98:	910004a5 	add	x5, x5, #0x1
ffffffffea813f9c:	d503201f 	nop
			*d++ = *s++;
ffffffffea813fa0:	38626823 	ldrb	w3, [x1, x2]
ffffffffea813fa4:	38226883 	strb	w3, [x4, x2]
ffffffffea813fa8:	91000442 	add	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea813fac:	eb05005f 	cmp	x2, x5
ffffffffea813fb0:	54ffff81 	b.ne	ffffffffea813fa0 <memmove+0xd8>  // b.any
		for (len = count & lmask; len > 0; len--)
			*--d = *--s;
	}

	return dest;
}
ffffffffea813fb4:	d65f03c0 	ret
		d += count;
ffffffffea813fb8:	8b020004 	add	x4, x0, x2
		s += count;
ffffffffea813fbc:	8b020021 	add	x1, x1, x2
		if (((long)d | (long)s) & lmask) {
ffffffffea813fc0:	aa010083 	orr	x3, x4, x1
ffffffffea813fc4:	f240087f 	tst	x3, #0x7
ffffffffea813fc8:	540002e0 	b.eq	ffffffffea814024 <memmove+0x15c>  // b.none
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea813fcc:	ca010083 	eor	x3, x4, x1
				len = count;
ffffffffea813fd0:	12000885 	and	w5, w4, #0x7
			if ((((long)d ^ (long)s) & lmask) || (count <= lsize))
ffffffffea813fd4:	f240087f 	tst	x3, #0x7
				len = count;
ffffffffea813fd8:	fa480840 	ccmp	x2, #0x8, #0x0, eq  // eq = none
ffffffffea813fdc:	1a859045 	csel	w5, w2, w5, ls  // ls = plast
			for (; len > 0; len--)
ffffffffea813fe0:	710000bf 	cmp	w5, #0x0
			count -= len;
ffffffffea813fe4:	cb25c042 	sub	x2, x2, w5, sxtw
			for (; len > 0; len--)
ffffffffea813fe8:	540001ed 	b.le	ffffffffea814024 <memmove+0x15c>
ffffffffea813fec:	510004a3 	sub	w3, w5, #0x1
ffffffffea813ff0:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
ffffffffea813ff4:	cb0300e7 	sub	x7, x7, x3
ffffffffea813ff8:	92800003 	mov	x3, #0xffffffffffffffff    	// #-1
ffffffffea813ffc:	d503201f 	nop
				*--d = *--s;
ffffffffea814000:	38636826 	ldrb	w6, [x1, x3]
ffffffffea814004:	38236886 	strb	w6, [x4, x3]
ffffffffea814008:	d1000463 	sub	x3, x3, #0x1
			for (; len > 0; len--)
ffffffffea81400c:	eb07007f 	cmp	x3, x7
ffffffffea814010:	54ffff81 	b.ne	ffffffffea814000 <memmove+0x138>  // b.any
ffffffffea814014:	4b0503e5 	neg	w5, w5
ffffffffea814018:	93407ca5 	sxtw	x5, w5
ffffffffea81401c:	8b050084 	add	x4, x4, x5
ffffffffea814020:	8b050021 	add	x1, x1, x5
		for (len = count / lsize; len > 0; len--) {
ffffffffea814024:	d343fc43 	lsr	x3, x2, #3
ffffffffea814028:	7100007f 	cmp	w3, #0x0
ffffffffea81402c:	5400022d 	b.le	ffffffffea814070 <memmove+0x1a8>
ffffffffea814030:	51000467 	sub	w7, w3, #0x1
ffffffffea814034:	928000e3 	mov	x3, #0xfffffffffffffff8    	// #-8
ffffffffea814038:	aa0703e6 	mov	x6, x7
ffffffffea81403c:	cb070fe7 	neg	x7, x7, lsl #3
ffffffffea814040:	d10040e7 	sub	x7, x7, #0x10
ffffffffea814044:	d503201f 	nop
			*(word *)d = *(word *)s;
ffffffffea814048:	f8636825 	ldr	x5, [x1, x3]
ffffffffea81404c:	f8236885 	str	x5, [x4, x3]
ffffffffea814050:	d1002063 	sub	x3, x3, #0x8
		for (len = count / lsize; len > 0; len--) {
ffffffffea814054:	eb07007f 	cmp	x3, x7
ffffffffea814058:	54ffff81 	b.ne	ffffffffea814048 <memmove+0x180>  // b.any
ffffffffea81405c:	93407cc3 	sxtw	x3, w6
ffffffffea814060:	aa2303e3 	mvn	x3, x3
ffffffffea814064:	d37df063 	lsl	x3, x3, #3
ffffffffea814068:	8b030084 	add	x4, x4, x3
ffffffffea81406c:	8b030021 	add	x1, x1, x3
		for (len = count & lmask; len > 0; len--)
ffffffffea814070:	72000842 	ands	w2, w2, #0x7
ffffffffea814074:	54fffa00 	b.eq	ffffffffea813fb4 <memmove+0xec>  // b.none
ffffffffea814078:	51000442 	sub	w2, w2, #0x1
ffffffffea81407c:	92800025 	mov	x5, #0xfffffffffffffffe    	// #-2
ffffffffea814080:	cb0200a5 	sub	x5, x5, x2
ffffffffea814084:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
			*--d = *--s;
ffffffffea814088:	38626823 	ldrb	w3, [x1, x2]
ffffffffea81408c:	38226883 	strb	w3, [x4, x2]
ffffffffea814090:	d1000442 	sub	x2, x2, #0x1
		for (len = count & lmask; len > 0; len--)
ffffffffea814094:	eb05005f 	cmp	x2, x5
ffffffffea814098:	54ffff81 	b.ne	ffffffffea814088 <memmove+0x1c0>  // b.any
}
ffffffffea81409c:	d65f03c0 	ret
				len = lsize - ((long)d & lmask); // move the ptrs up to a word boundary
ffffffffea8140a0:	12000804 	and	w4, w0, #0x7
ffffffffea8140a4:	52800103 	mov	w3, #0x8                   	// #8
ffffffffea8140a8:	4b040063 	sub	w3, w3, w4
			count -= len;
ffffffffea8140ac:	cb23c042 	sub	x2, x2, w3, sxtw
ffffffffea8140b0:	17ffff97 	b	ffffffffea813f0c <memmove+0x44>
ffffffffea8140b4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8140b8 <memset>:

void *
memset(void *s, int c, size_t count)
{
	char *xs = (char *) s;
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea8140b8:	cb0003e5 	neg	x5, x0
	char *xs = (char *) s;
ffffffffea8140bc:	aa0003e3 	mov	x3, x0
	size_t len = (-(size_t)s) & (sizeof(size_t)-1);
ffffffffea8140c0:	924008a5 	and	x5, x5, #0x7
	size_t cc = c & 0xff;

	if ( count > len ) {
ffffffffea8140c4:	eb0200bf 	cmp	x5, x2
ffffffffea8140c8:	54000282 	b.cs	ffffffffea814118 <memset+0x60>  // b.hs, b.nlast
	size_t cc = c & 0xff;
ffffffffea8140cc:	92401c24 	and	x4, x1, #0xff
		count -= len;
ffffffffea8140d0:	cb050042 	sub	x2, x2, x5
		cc |= cc << 8;
ffffffffea8140d4:	aa042084 	orr	x4, x4, x4, lsl #8
		cc |= cc << 16;
ffffffffea8140d8:	aa044084 	orr	x4, x4, x4, lsl #16
		if (sizeof(size_t) == 8)
			cc |= (uint64_t)cc << 32; // should be optimized out on 32 bit machines
ffffffffea8140dc:	aa048084 	orr	x4, x4, x4, lsl #32

		// write to non-aligned memory byte-wise
		for ( ; len > 0; len-- )
ffffffffea8140e0:	b40000e5 	cbz	x5, ffffffffea8140fc <memset+0x44>
ffffffffea8140e4:	12001c26 	and	w6, w1, #0xff
ffffffffea8140e8:	8b050005 	add	x5, x0, x5
ffffffffea8140ec:	d503201f 	nop
			*xs++ = c;
ffffffffea8140f0:	38001466 	strb	w6, [x3], #1
		for ( ; len > 0; len-- )
ffffffffea8140f4:	eb0300bf 	cmp	x5, x3
ffffffffea8140f8:	54ffffc1 	b.ne	ffffffffea8140f0 <memset+0x38>  // b.any

		// write to aligned memory dword-wise
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea8140fc:	d343fc45 	lsr	x5, x2, #3
ffffffffea814100:	b40000a5 	cbz	x5, ffffffffea814114 <memset+0x5c>
ffffffffea814104:	8b050c65 	add	x5, x3, x5, lsl #3
			*((size_t *)xs) = (size_t)cc;
ffffffffea814108:	f8008464 	str	x4, [x3], #8
		for ( len = count/sizeof(size_t); len > 0; len-- ) {
ffffffffea81410c:	eb0300bf 	cmp	x5, x3
ffffffffea814110:	54ffffc1 	b.ne	ffffffffea814108 <memset+0x50>  // b.any
			xs += sizeof(size_t);
		}

		count &= sizeof(size_t)-1;
ffffffffea814114:	92400842 	and	x2, x2, #0x7
	}

	// write remaining bytes
	for ( ; count > 0; count-- )
ffffffffea814118:	b40000e2 	cbz	x2, ffffffffea814134 <memset+0x7c>
ffffffffea81411c:	12001c21 	and	w1, w1, #0xff
ffffffffea814120:	8b020062 	add	x2, x3, x2
ffffffffea814124:	d503201f 	nop
		*xs++ = c;
ffffffffea814128:	38001461 	strb	w1, [x3], #1
	for ( ; count > 0; count-- )
ffffffffea81412c:	eb03005f 	cmp	x2, x3
ffffffffea814130:	54ffffc1 	b.ne	ffffffffea814128 <memset+0x70>  // b.any

	return s;
}
ffffffffea814134:	d65f03c0 	ret

ffffffffea814138 <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
ffffffffea814138:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea81413c:	14000002 	b	ffffffffea814144 <strcmp+0xc>
	signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea814140:	34000124 	cbz	w4, ffffffffea814164 <strcmp+0x2c>
ffffffffea814144:	38636804 	ldrb	w4, [x0, x3]
ffffffffea814148:	38636822 	ldrb	w2, [x1, x3]
ffffffffea81414c:	91000463 	add	x3, x3, #0x1
ffffffffea814150:	4b020082 	sub	w2, w4, w2
ffffffffea814154:	13001c42 	sxtb	w2, w2
ffffffffea814158:	34ffff42 	cbz	w2, ffffffffea814140 <strcmp+0x8>
ffffffffea81415c:	2a0203e0 	mov	w0, w2
			break;
	}

	return __res;
}
ffffffffea814160:	d65f03c0 	ret
ffffffffea814164:	52800000 	mov	w0, #0x0                   	// #0
ffffffffea814168:	d65f03c0 	ret
ffffffffea81416c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814170 <strdup>:
#include <stdlib.h>
#include <string.h>

char *
strdup(const char *str)
{
ffffffffea814170:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea814174:	910003fd 	mov	x29, sp
ffffffffea814178:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea81417c:	f90013f5 	str	x21, [sp, #32]
ffffffffea814180:	aa0003f5 	mov	x21, x0
	size_t len;
	char *copy;

	len = strlen(str) + 1;
ffffffffea814184:	9400002f 	bl	ffffffffea814240 <strlen>
ffffffffea814188:	91000414 	add	x20, x0, #0x1
	copy = malloc(len);
ffffffffea81418c:	aa1403e0 	mov	x0, x20
ffffffffea814190:	97fffef6 	bl	ffffffffea813d68 <malloc>
ffffffffea814194:	aa0003f3 	mov	x19, x0
	if (copy == NULL)
ffffffffea814198:	b4000080 	cbz	x0, ffffffffea8141a8 <strdup+0x38>
		return NULL;
	memcpy(copy, str, len);
ffffffffea81419c:	aa1403e2 	mov	x2, x20
ffffffffea8141a0:	aa1503e1 	mov	x1, x21
ffffffffea8141a4:	97ffff09 	bl	ffffffffea813dc8 <memcpy>
	return copy;
}
ffffffffea8141a8:	aa1303e0 	mov	x0, x19
ffffffffea8141ac:	f94013f5 	ldr	x21, [sp, #32]
ffffffffea8141b0:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8141b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea8141b8:	d65f03c0 	ret
ffffffffea8141bc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8141c0 <strlcpy>:
size_t
strlcpy(char *dst, char const *src, size_t s)
{
	size_t i= 0;

	if (!s) {
ffffffffea8141c0:	b4000362 	cbz	x2, ffffffffea81422c <strlcpy+0x6c>
{
ffffffffea8141c4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
		return strlen(src);
	}

	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8141c8:	f1000442 	subs	x2, x2, #0x1
{
ffffffffea8141cc:	910003fd 	mov	x29, sp
ffffffffea8141d0:	f9000bf3 	str	x19, [sp, #16]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8141d4:	54000300 	b.eq	ffffffffea814234 <strlcpy+0x74>  // b.none
ffffffffea8141d8:	aa0103e3 	mov	x3, x1
ffffffffea8141dc:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea8141e0:	aa0003e5 	mov	x5, x0
ffffffffea8141e4:	38401464 	ldrb	w4, [x3], #1
ffffffffea8141e8:	35000084 	cbnz	w4, ffffffffea8141f8 <strlcpy+0x38>
ffffffffea8141ec:	14000009 	b	ffffffffea814210 <strlcpy+0x50>
ffffffffea8141f0:	38401464 	ldrb	w4, [x3], #1
ffffffffea8141f4:	340000e4 	cbz	w4, ffffffffea814210 <strlcpy+0x50>
		dst[i]= src[i];
ffffffffea8141f8:	38336804 	strb	w4, [x0, x19]
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea8141fc:	91000673 	add	x19, x19, #0x1
ffffffffea814200:	aa0303e1 	mov	x1, x3
ffffffffea814204:	8b130005 	add	x5, x0, x19
ffffffffea814208:	eb02027f 	cmp	x19, x2
ffffffffea81420c:	54ffff21 	b.ne	ffffffffea8141f0 <strlcpy+0x30>  // b.any
	}

	dst[i]= 0;
ffffffffea814210:	390000bf 	strb	wzr, [x5]

	return i + strlen(src+i);
ffffffffea814214:	aa0103e0 	mov	x0, x1
ffffffffea814218:	9400000a 	bl	ffffffffea814240 <strlen>
}
ffffffffea81421c:	8b130000 	add	x0, x0, x19
ffffffffea814220:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea814224:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea814228:	d65f03c0 	ret
		return strlen(src);
ffffffffea81422c:	aa0103e0 	mov	x0, x1
ffffffffea814230:	14000004 	b	ffffffffea814240 <strlen>
	for (i= 0; ((i< s-1) && src[i]); i++) {
ffffffffea814234:	aa0003e5 	mov	x5, x0
ffffffffea814238:	d2800013 	mov	x19, #0x0                   	// #0
ffffffffea81423c:	17fffff5 	b	ffffffffea814210 <strlcpy+0x50>

ffffffffea814240 <strlen>:
#include <string.h>
#include <sys/types.h>

size_t
strlen(char const *s)
{
ffffffffea814240:	aa0003e2 	mov	x2, x0
	size_t i;

	i= 0;
	while (s[i]) {
ffffffffea814244:	39400000 	ldrb	w0, [x0]
ffffffffea814248:	340000c0 	cbz	w0, ffffffffea814260 <strlen+0x20>
	i= 0;
ffffffffea81424c:	d2800000 	mov	x0, #0x0                   	// #0
		i+= 1;
ffffffffea814250:	91000400 	add	x0, x0, #0x1
	while (s[i]) {
ffffffffea814254:	38606841 	ldrb	w1, [x2, x0]
ffffffffea814258:	35ffffc1 	cbnz	w1, ffffffffea814250 <strlen+0x10>
	}

	return i;
}
ffffffffea81425c:	d65f03c0 	ret
	i= 0;
ffffffffea814260:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea814264:	d65f03c0 	ret

ffffffffea814268 <strncpy>:
char *
strncpy(char *dest, char const *src, size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
ffffffffea814268:	d2800003 	mov	x3, #0x0                   	// #0
ffffffffea81426c:	14000005 	b	ffffffffea814280 <strncpy+0x18>
ffffffffea814270:	38636824 	ldrb	w4, [x1, x3]
ffffffffea814274:	38236804 	strb	w4, [x0, x3]
ffffffffea814278:	91000463 	add	x3, x3, #0x1
ffffffffea81427c:	34000064 	cbz	w4, ffffffffea814288 <strncpy+0x20>
ffffffffea814280:	eb02007f 	cmp	x3, x2
ffffffffea814284:	54ffff61 	b.ne	ffffffffea814270 <strncpy+0x8>  // b.any
		;

	return tmp;
}
ffffffffea814288:	d65f03c0 	ret
ffffffffea81428c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814290 <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
	signed char __res = 0;

	while (count > 0) {
ffffffffea814290:	b4000242 	cbz	x2, ffffffffea8142d8 <strncmp+0x48>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
ffffffffea814294:	39400004 	ldrb	w4, [x0]
ffffffffea814298:	39400023 	ldrb	w3, [x1]
ffffffffea81429c:	4b030083 	sub	w3, w4, w3
ffffffffea8142a0:	13001c63 	sxtb	w3, w3
ffffffffea8142a4:	350001e3 	cbnz	w3, ffffffffea8142e0 <strncmp+0x50>
ffffffffea8142a8:	34000184 	cbz	w4, ffffffffea8142d8 <strncmp+0x48>
ffffffffea8142ac:	d2800024 	mov	x4, #0x1                   	// #1
ffffffffea8142b0:	14000008 	b	ffffffffea8142d0 <strncmp+0x40>
ffffffffea8142b4:	38646805 	ldrb	w5, [x0, x4]
ffffffffea8142b8:	38646823 	ldrb	w3, [x1, x4]
ffffffffea8142bc:	91000484 	add	x4, x4, #0x1
ffffffffea8142c0:	4b0300a3 	sub	w3, w5, w3
ffffffffea8142c4:	13001c63 	sxtb	w3, w3
ffffffffea8142c8:	350000c3 	cbnz	w3, ffffffffea8142e0 <strncmp+0x50>
ffffffffea8142cc:	34000065 	cbz	w5, ffffffffea8142d8 <strncmp+0x48>
	while (count > 0) {
ffffffffea8142d0:	eb04005f 	cmp	x2, x4
ffffffffea8142d4:	54ffff01 	b.ne	ffffffffea8142b4 <strncmp+0x24>  // b.any
ffffffffea8142d8:	52800000 	mov	w0, #0x0                   	// #0
			break;
		count--;
	}

	return __res;
}
ffffffffea8142dc:	d65f03c0 	ret
ffffffffea8142e0:	2a0303e0 	mov	w0, w3
ffffffffea8142e4:	d65f03c0 	ret

ffffffffea8142e8 <strnlen>:
#include <string.h>
#include <sys/types.h>

size_t
strnlen(char const *s, size_t count)
{
ffffffffea8142e8:	aa0003e3 	mov	x3, x0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea8142ec:	b4000181 	cbz	x1, ffffffffea81431c <strnlen+0x34>
ffffffffea8142f0:	39400002 	ldrb	w2, [x0]
ffffffffea8142f4:	34000142 	cbz	w2, ffffffffea81431c <strnlen+0x34>
ffffffffea8142f8:	8b010001 	add	x1, x0, x1
ffffffffea8142fc:	14000003 	b	ffffffffea814308 <strnlen+0x20>
ffffffffea814300:	39400002 	ldrb	w2, [x0]
ffffffffea814304:	34000082 	cbz	w2, ffffffffea814314 <strnlen+0x2c>
ffffffffea814308:	91000400 	add	x0, x0, #0x1
ffffffffea81430c:	eb01001f 	cmp	x0, x1
ffffffffea814310:	54ffff81 	b.ne	ffffffffea814300 <strnlen+0x18>  // b.any
ffffffffea814314:	cb030000 	sub	x0, x0, x3
		;
	return sc - s;
}
ffffffffea814318:	d65f03c0 	ret
	for (sc = s; count-- && *sc != '\0'; ++sc)
ffffffffea81431c:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea814320:	d65f03c0 	ret
ffffffffea814324:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814328 <arm64_syscall>:
 * r0-r1/x0    = return value (r0 only if 32-bit retval)
 * r12/x12     = syscall number, expected to be trashed.
 * syscalls run with interrupts enabled
 */
FUNCTION (arm64_syscall)
	push	x0, x30
ffffffffea814328:	a9bf7be0 	stp	x0, x30, [sp, #-16]!
	ldr	w12, [x0, #(12 << 3)]
ffffffffea81432c:	b940600c 	ldr	w12, [x0, #96]

	msr	daifclr, #DAIF_MASK_IAF
ffffffffea814330:	d50347ff 	msr	daifclr, #0x7

	ldr	x14, =nr_syscalls
ffffffffea814334:	580001ee 	ldr	x14, ffffffffea814370 <arm64_syscall+0x48>
	ldr	x14, [x14]
ffffffffea814338:	f94001ce 	ldr	x14, [x14]
	cmp	x12, x14
ffffffffea81433c:	eb0e019f 	cmp	x12, x14
	b.hs	.Lundefined
ffffffffea814340:	54000082 	b.cs	ffffffffea814350 <arm64_syscall+0x28>  // b.hs, b.nlast
	ldr	x14, =syscall_table
ffffffffea814344:	580001ae 	ldr	x14, ffffffffea814378 <arm64_syscall+0x50>
	ldr	x14, [x14, x12, lsl#3]
ffffffffea814348:	f86c79ce 	ldr	x14, [x14, x12, lsl #3]
	cbnz	x14, .Ldefined
ffffffffea81434c:	b500004e 	cbnz	x14, ffffffffea814354 <arm64_syscall+0x2c>
.Lundefined:
	ldr	x14,=sys_undefined
ffffffffea814350:	5800018e 	ldr	x14, ffffffffea814380 <arm64_syscall+0x58>
.Ldefined:
	ldp	x2, x3, [x0, #16]
ffffffffea814354:	a9410c02 	ldp	x2, x3, [x0, #16]
	ldp	x0, x1, [x0]
ffffffffea814358:	a9400400 	ldp	x0, x1, [x0]
	blr	x14
ffffffffea81435c:	d63f01c0 	blr	x14

	msr	daifset, #DAIF_MASK_IAF
ffffffffea814360:	d50347df 	msr	daifset, #0x7

	pop	x1, x30
ffffffffea814364:	a8c17be1 	ldp	x1, x30, [sp], #16

	str	x0, [x1, 0]
ffffffffea814368:	f9000020 	str	x0, [x1]

	ret
ffffffffea81436c:	d65f03c0 	ret
ffffffffea814370:	ea81a030 	.word	0xea81a030
ffffffffea814374:	ffffffff 	.word	0xffffffff
ffffffffea814378:	ea81a038 	.word	0xea81a038
ffffffffea81437c:	ffffffff 	.word	0xffffffff
ffffffffea814380:	ea814388 	.word	0xea814388
ffffffffea814384:	ffffffff 	.word	0xffffffff

ffffffffea814388 <sys_undefined>:

long sys_undefined(int num)
{
	dprintf(SPEW, "%p invalid syscall %d requested\n", get_current_thread(), num);
	return ERR_NOT_SUPPORTED;
}
ffffffffea814388:	928002e0 	mov	x0, #0xffffffffffffffe8    	// #-24
ffffffffea81438c:	d65f03c0 	ret

ffffffffea814390 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea814390:	b40000c2 	cbz	x2, ffffffffea8143a8 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	w9, [x1], #1
ffffffffea814394:	38401429 	ldrb	w9, [x1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	sttrb	w9, [x0]
ffffffffea814398:	38000809 	sttrb	w9, [x0]

	add	x0, x0, #1
ffffffffea81439c:	91000400 	add	x0, x0, #0x1
	subs	x2, x2, #1
ffffffffea8143a0:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_to_user_loop
ffffffffea8143a4:	54ffff88 	b.hi	ffffffffea814394 <arch_copy_to_user+0x4>  // b.pmore
.Larch_copy_to_user_done:
	mov	x0, #0
ffffffffea8143a8:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea8143ac:	d65f03c0 	ret

ffffffffea8143b0 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cbz	x2, .Larch_copy_to_user_done
ffffffffea8143b0:	b4ffffc2 	cbz	x2, ffffffffea8143a8 <arch_copy_to_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea8143b4:	38400829 	ldtrb	w9, [x1]

	add	x1, x1, #1
ffffffffea8143b8:	91000421 	add	x1, x1, #0x1
	strb	w9, [x0], #1
ffffffffea8143bc:	38001409 	strb	w9, [x0], #1
	subs	x2, x2, #1
ffffffffea8143c0:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_loop
ffffffffea8143c4:	54ffff88 	b.hi	ffffffffea8143b4 <arch_copy_from_user+0x4>  // b.pmore
.Larch_copy_from_user_done:
	mov	x0, #0
ffffffffea8143c8:	d2800000 	mov	x0, #0x0                   	// #0
	ret
ffffffffea8143cc:	d65f03c0 	ret

ffffffffea8143d0 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	x10, x1
ffffffffea8143d0:	aa0103ea 	mov	x10, x1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldtrb	w9, [x1]
ffffffffea8143d4:	38400829 	ldtrb	w9, [x1]

	cmp	w9, #0
ffffffffea8143d8:	7100013f 	cmp	w9, #0x0
	cinc	x1, x1, ne
ffffffffea8143dc:	9a810421 	cinc	x1, x1, ne  // ne = any

	cbz	x2, .Larch_strlcpy_from_user_dst_full
ffffffffea8143e0:	b4000082 	cbz	x2, ffffffffea8143f0 <arch_strlcpy_from_user+0x20>
	subs	x2, x2, #1
ffffffffea8143e4:	f1000442 	subs	x2, x2, #0x1
	csel	w11, w9, wzr, hi
ffffffffea8143e8:	1a9f812b 	csel	w11, w9, wzr, hi  // hi = pmore
	strb	w11, [x0], #1
ffffffffea8143ec:	3800140b 	strb	w11, [x0], #1
.Larch_strlcpy_from_user_dst_full:
	cbnz	w9, .Larch_strlcpy_from_user_loop
ffffffffea8143f0:	35ffff29 	cbnz	w9, ffffffffea8143d4 <arch_strlcpy_from_user+0x4>

	sub	x0, x1, x10
ffffffffea8143f4:	cb0a0020 	sub	x0, x1, x10
	ret
ffffffffea8143f8:	d65f03c0 	ret

.Larch_strlcpy_from_user_fault:
	cbz	x2, .Larch_copy_to_user_fault
ffffffffea8143fc:	b4000082 	cbz	x2, ffffffffea81440c <arch_strlcpy_from_user+0x3c>
.Larch_copy_from_user_fault:
	strb	wzr, [x0], #1
ffffffffea814400:	3800141f 	strb	wzr, [x0], #1
	subs	x2, x2, #1
ffffffffea814404:	f1000442 	subs	x2, x2, #0x1
	b.hi	.Larch_copy_from_user_fault
ffffffffea814408:	54ffffc8 	b.hi	ffffffffea814400 <arch_strlcpy_from_user+0x30>  // b.pmore
.Larch_copy_to_user_fault:
	mov	x0, #ERR_FAULT
ffffffffea81440c:	928004e0 	mov	x0, #0xffffffffffffffd8    	// #-40
	ret
ffffffffea814410:	d65f03c0 	ret
ffffffffea814414:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814418 <uthread_find_va_space_ns>:
{
}


static vaddr_t uthread_find_va_space_ns(uthread_t *ut, size_t size, u_int align)
{
ffffffffea814418:	aa0003e9 	mov	x9, x0
	vaddr_t start, end;
	uthread_map_t *mp;

	/* get first suitable address */
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea81441c:	4b0203e2 	neg	w2, w2
ffffffffea814420:	d2a04003 	mov	x3, #0x2000000             	// #33554432
ffffffffea814424:	cb010063 	sub	x3, x3, x1
	end = start + size;

	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea814428:	91006007 	add	x7, x0, #0x18
	start = ROUNDDOWN(MAX_USR_VA - size, align);
ffffffffea81442c:	8a020060 	and	x0, x3, x2
	if (list->prev != list) {
ffffffffea814430:	f9400d24 	ldr	x4, [x9, #24]
	end = start + size;
ffffffffea814434:	8b000028 	add	x8, x1, x0
	mp = list_peek_tail_type (&ut->map_list, uthread_map_t, node);
ffffffffea814438:	f100009f 	cmp	x4, #0x0
ffffffffea81443c:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea814440:	540000c1 	b.ne	ffffffffea814458 <uthread_find_va_space_ns+0x40>  // b.any

		/* get prev list item */
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
	}

	if (start < ut->start_stack || start > end) {
ffffffffea814444:	f9400121 	ldr	x1, [x9]
ffffffffea814448:	eb00003f 	cmp	x1, x0
		return (vaddr_t) NULL;
ffffffffea81444c:	fa489002 	ccmp	x0, x8, #0x2, ls  // ls = plast
ffffffffea814450:	9a9f9000 	csel	x0, x0, xzr, ls  // ls = plast
	}
	return start;
}
ffffffffea814454:	d65f03c0 	ret
	while (mp) {
ffffffffea814458:	f1006086 	subs	x6, x4, #0x18
ffffffffea81445c:	54ffff40 	b.eq	ffffffffea814444 <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea814460:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea814464:	8b050065 	add	x5, x3, x5
ffffffffea814468:	eb05001f 	cmp	x0, x5
ffffffffea81446c:	54000243 	b.cc	ffffffffea8144b4 <uthread_find_va_space_ns+0x9c>  // b.lo, b.ul, b.last
ffffffffea814470:	14000015 	b	ffffffffea8144c4 <uthread_find_va_space_ns+0xac>
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea814474:	cb010063 	sub	x3, x3, x1
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea814478:	f9400cc4 	ldr	x4, [x6, #24]
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea81447c:	8a020063 	and	x3, x3, x2
ffffffffea814480:	eb03001f 	cmp	x0, x3
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea814484:	d1006086 	sub	x6, x4, #0x18
		start = MIN(start, ROUNDDOWN((mp->vaddr - size), align));
ffffffffea814488:	9a839000 	csel	x0, x0, x3, ls  // ls = plast
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea81448c:	f100009f 	cmp	x4, #0x0
		end = start + size;
ffffffffea814490:	8b000028 	add	x8, x1, x0
		mp = list_prev_type(&ut->map_list, &mp->node, uthread_map_t, node);
ffffffffea814494:	fa4410e4 	ccmp	x7, x4, #0x4, ne  // ne = any
ffffffffea814498:	54fffd60 	b.eq	ffffffffea814444 <uthread_find_va_space_ns+0x2c>  // b.none
	while (mp) {
ffffffffea81449c:	f100609f 	cmp	x4, #0x18
ffffffffea8144a0:	54fffd20 	b.eq	ffffffffea814444 <uthread_find_va_space_ns+0x2c>  // b.none
		if (start >= mp->vaddr + mp->size) { /* found gap */
ffffffffea8144a4:	a97e9483 	ldp	x3, x5, [x4, #-24]
ffffffffea8144a8:	8b050065 	add	x5, x3, x5
ffffffffea8144ac:	eb0000bf 	cmp	x5, x0
ffffffffea8144b0:	540000a9 	b.ls	ffffffffea8144c4 <uthread_find_va_space_ns+0xac>  // b.plast
		if (!(mp->flags & UTM_NS_MEM)) {
ffffffffea8144b4:	b85f8084 	ldur	w4, [x4, #-8]
ffffffffea8144b8:	3737fde4 	tbnz	w4, #6, ffffffffea814474 <uthread_find_va_space_ns+0x5c>
		return (vaddr_t) NULL;
ffffffffea8144bc:	d2800000 	mov	x0, #0x0                   	// #0
}
ffffffffea8144c0:	d65f03c0 	ret
			if (start >= ut->ns_va_bottom) {
ffffffffea8144c4:	f9403121 	ldr	x1, [x9, #96]
ffffffffea8144c8:	eb00003f 	cmp	x1, x0
ffffffffea8144cc:	54fffbc9 	b.ls	ffffffffea814444 <uthread_find_va_space_ns+0x2c>  // b.plast
			if (ROUNDDOWN(start, UT_MAP_ALIGN_1MB) < mp->vaddr + mp->size) {
ffffffffea8144d0:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea8144d4:	eb05003f 	cmp	x1, x5
ffffffffea8144d8:	54fffb62 	b.cs	ffffffffea814444 <uthread_find_va_space_ns+0x2c>  // b.hs, b.nlast
		return (vaddr_t) NULL;
ffffffffea8144dc:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8144e0:	17fffff8 	b	ffffffffea8144c0 <uthread_find_va_space_ns+0xa8>
ffffffffea8144e4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8144e8 <uthread_find_va_space_sec>:
static vaddr_t uthread_find_va_space_sec(uthread_t *ut, size_t size, u_int align)
{
	vaddr_t start, end;
	uthread_map_t *mp;

	start = ROUNDUP(ut->start_stack, align);
ffffffffea8144e8:	f9400004 	ldr	x4, [x0]
ffffffffea8144ec:	51000448 	sub	w8, w2, #0x1
	end = start + size;

	/* find first fit */
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8144f0:	f9401006 	ldr	x6, [x0, #32]
	start = ROUNDUP(ut->start_stack, align);
ffffffffea8144f4:	4b0203e2 	neg	w2, w2
ffffffffea8144f8:	8b040104 	add	x4, x8, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8144fc:	d10060c5 	sub	x5, x6, #0x18
	start = ROUNDUP(ut->start_stack, align);
ffffffffea814500:	8a020084 	and	x4, x4, x2
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814504:	eb05001f 	cmp	x0, x5
	end = start + size;
ffffffffea814508:	8b010083 	add	x3, x4, x1
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81450c:	54000260 	b.eq	ffffffffea814558 <uthread_find_va_space_sec+0x70>  // b.none
		if (end <= mp->vaddr) {
ffffffffea814510:	f85e80c6 	ldur	x6, [x6, #-24]
ffffffffea814514:	eb06007f 	cmp	x3, x6
ffffffffea814518:	540000a8 	b.hi	ffffffffea81452c <uthread_find_va_space_sec+0x44>  // b.pmore
ffffffffea81451c:	1400000f 	b	ffffffffea814558 <uthread_find_va_space_sec+0x70>
ffffffffea814520:	f85e80e6 	ldur	x6, [x7, #-24]
ffffffffea814524:	eb0300df 	cmp	x6, x3
ffffffffea814528:	54000182 	b.cs	ffffffffea814558 <uthread_find_va_space_sec+0x70>  // b.hs, b.nlast
			break;
		}
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea81452c:	f94004a3 	ldr	x3, [x5, #8]
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814530:	f94010a7 	ldr	x7, [x5, #32]
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea814534:	8b030103 	add	x3, x8, x3
ffffffffea814538:	8b060063 	add	x3, x3, x6
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81453c:	d10060e5 	sub	x5, x7, #0x18
		start = MAX(start, ROUNDUP((mp->vaddr + mp->size), align));
ffffffffea814540:	8a020063 	and	x3, x3, x2
ffffffffea814544:	eb03009f 	cmp	x4, x3
ffffffffea814548:	9a832084 	csel	x4, x4, x3, cs  // cs = hs, nlast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81454c:	eb05001f 	cmp	x0, x5
		end = start + size;
ffffffffea814550:	8b040023 	add	x3, x1, x4
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814554:	54fffe61 	b.ne	ffffffffea814520 <uthread_find_va_space_sec+0x38>  // b.any
	}

	if (end > ut->ns_va_bottom || start > end) {
ffffffffea814558:	f9403000 	ldr	x0, [x0, #96]
ffffffffea81455c:	eb03001f 	cmp	x0, x3
		return (vaddr_t) NULL;
ffffffffea814560:	fa442060 	ccmp	x3, x4, #0x0, cs  // cs = hs, nlast
	}
	return start;
}
ffffffffea814564:	9a9f2080 	csel	x0, x4, xzr, cs  // cs = hs, nlast
ffffffffea814568:	d65f03c0 	ret
ffffffffea81456c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814570 <uthread_free_maps>:
}

static void uthread_free_maps(uthread_t *ut)
{
	uthread_map_t *mp, *tmp;
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea814570:	f9401001 	ldr	x1, [x0, #32]
ffffffffea814574:	d1006021 	sub	x1, x1, #0x18
ffffffffea814578:	f9401022 	ldr	x2, [x1, #32]
ffffffffea81457c:	eb01001f 	cmp	x0, x1
ffffffffea814580:	540002a0 	b.eq	ffffffffea8145d4 <uthread_free_maps+0x64>  // b.none
{
ffffffffea814584:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea814588:	910003fd 	mov	x29, sp
ffffffffea81458c:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814590:	aa0003f4 	mov	x20, x0
ffffffffea814594:	d1006053 	sub	x19, x2, #0x18
	item->next->prev = item->prev;
ffffffffea814598:	f9400c23 	ldr	x3, [x1, #24]
			uthread_map_t, node) {
		list_delete(&mp->node);
		free(mp);
ffffffffea81459c:	aa0103e0 	mov	x0, x1
ffffffffea8145a0:	f9000043 	str	x3, [x2]
	item->prev->next = item->next;
ffffffffea8145a4:	f9400c23 	ldr	x3, [x1, #24]
ffffffffea8145a8:	f9000462 	str	x2, [x3, #8]
	item->prev = item->next = 0;
ffffffffea8145ac:	a901fc3f 	stp	xzr, xzr, [x1, #24]
ffffffffea8145b0:	97fffe04 	bl	ffffffffea813dc0 <free>
	list_for_every_entry_safe(&ut->map_list, mp, tmp,
ffffffffea8145b4:	f9401262 	ldr	x2, [x19, #32]
ffffffffea8145b8:	aa1303e1 	mov	x1, x19
ffffffffea8145bc:	eb13029f 	cmp	x20, x19
ffffffffea8145c0:	d1006053 	sub	x19, x2, #0x18
ffffffffea8145c4:	54fffea1 	b.ne	ffffffffea814598 <uthread_free_maps+0x28>  // b.any
	}
}
ffffffffea8145c8:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea8145cc:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8145d0:	d65f03c0 	ret
ffffffffea8145d4:	d65f03c0 	ret

ffffffffea8145d8 <uthread_map_alloc>:
{
ffffffffea8145d8:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea8145dc:	f2402c9f 	tst	x4, #0xfff
{
ffffffffea8145e0:	910003fd 	mov	x29, sp
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea8145e4:	54000f01 	b.ne	ffffffffea8147c4 <uthread_map_alloc+0x1ec>  // b.any
ffffffffea8145e8:	f9000fb4 	str	x20, [x29, #24]
ffffffffea8145ec:	aa0003f4 	mov	x20, x0
ffffffffea8145f0:	a902dfb6 	stp	x22, x23, [x29, #40]
	if (vaddr + size <= vaddr) {
ffffffffea8145f4:	8b020080 	add	x0, x4, x2
ffffffffea8145f8:	aa0403f6 	mov	x22, x4
ffffffffea8145fc:	aa0203f7 	mov	x23, x2
ffffffffea814600:	eb02001f 	cmp	x0, x2
ffffffffea814604:	54000fc9 	b.ls	ffffffffea8147fc <uthread_map_alloc+0x224>  // b.plast
ffffffffea814608:	f9000bb3 	str	x19, [x29, #16]
ffffffffea81460c:	f90013b5 	str	x21, [x29, #32]
ffffffffea814610:	aa0103f5 	mov	x21, x1
ffffffffea814614:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea814618:	aa0303f9 	mov	x25, x3
ffffffffea81461c:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea814620:	2a0503f8 	mov	w24, w5
ffffffffea814624:	2a0603fa 	mov	w26, w6
	if (flags & UTM_PHYS_CONTIG) {
ffffffffea814628:	372807d8 	tbnz	w24, #5, ffffffffea814720 <uthread_map_alloc+0x148>
ffffffffea81462c:	d34cac9b 	ubfx	x27, x4, #12, #32
ffffffffea814630:	91001760 	add	x0, x27, #0x5
ffffffffea814634:	d37df000 	lsl	x0, x0, #3
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea814638:	97fffdcc 	bl	ffffffffea813d68 <malloc>
ffffffffea81463c:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea814640:	b40007a0 	cbz	x0, ffffffffea814734 <uthread_map_alloc+0x15c>
	mp->size = size;
ffffffffea814644:	a9005a77 	stp	x23, x22, [x19]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea814648:	d37df362 	lsl	x2, x27, #3
	mp->align = align;
ffffffffea81464c:	29026a78 	stp	w24, w26, [x19, #16]
	memcpy(mp->pfn_list, pfn_list, npages*sizeof(paddr_t));
ffffffffea814650:	aa1903e1 	mov	x1, x25
ffffffffea814654:	9100a000 	add	x0, x0, #0x28
ffffffffea814658:	97fffddc 	bl	ffffffffea813dc8 <memcpy>
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea81465c:	b9401260 	ldr	w0, [x19, #16]
	new_ns = ut->ns_va_bottom;
ffffffffea814660:	f9403284 	ldr	x4, [x20, #96]
	if ((mp->flags & UTM_NS_MEM) && (mp->vaddr < ut->ns_va_bottom)) {
ffffffffea814664:	363000a0 	tbz	w0, #6, ffffffffea814678 <uthread_map_alloc+0xa0>
ffffffffea814668:	f9400260 	ldr	x0, [x19]
		new_ns = ROUNDDOWN(mp->vaddr, UT_MAP_ALIGN_1MB);
ffffffffea81466c:	926cac01 	and	x1, x0, #0xfffffffffff00000
ffffffffea814670:	eb04001f 	cmp	x0, x4
ffffffffea814674:	9a843024 	csel	x4, x1, x4, cc  // cc = lo, ul, last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea814678:	f9401281 	ldr	x1, [x20, #32]
ffffffffea81467c:	d1006022 	sub	x2, x1, #0x18
ffffffffea814680:	eb02029f 	cmp	x20, x2
ffffffffea814684:	540002a0 	b.eq	ffffffffea8146d8 <uthread_map_alloc+0x100>  // b.none
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea814688:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea81468c:	f9400263 	ldr	x3, [x19]
ffffffffea814690:	eb03001f 	cmp	x0, x3
ffffffffea814694:	540007e8 	b.hi	ffffffffea814790 <uthread_map_alloc+0x1b8>  // b.pmore
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea814698:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea81469c:	8b010000 	add	x0, x0, x1
ffffffffea8146a0:	eb03001f 	cmp	x0, x3
ffffffffea8146a4:	54000129 	b.ls	ffffffffea8146c8 <uthread_map_alloc+0xf0>  // b.plast
ffffffffea8146a8:	14000036 	b	ffffffffea814780 <uthread_map_alloc+0x1a8>
		if (mp_lst->vaddr > mp->vaddr) {
ffffffffea8146ac:	f85e8020 	ldur	x0, [x1, #-24]
ffffffffea8146b0:	eb00007f 	cmp	x3, x0
ffffffffea8146b4:	540006e3 	b.cc	ffffffffea814790 <uthread_map_alloc+0x1b8>  // b.lo, b.ul, b.last
			if (mp->vaddr < (mp_lst->vaddr + mp_lst->size)) {
ffffffffea8146b8:	f85f0021 	ldur	x1, [x1, #-16]
ffffffffea8146bc:	8b010000 	add	x0, x0, x1
ffffffffea8146c0:	eb00007f 	cmp	x3, x0
ffffffffea8146c4:	540005e3 	b.cc	ffffffffea814780 <uthread_map_alloc+0x1a8>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp_lst, uthread_map_t, node) {
ffffffffea8146c8:	f9401041 	ldr	x1, [x2, #32]
ffffffffea8146cc:	d1006022 	sub	x2, x1, #0x18
ffffffffea8146d0:	eb02029f 	cmp	x20, x2
ffffffffea8146d4:	54fffec1 	b.ne	ffffffffea8146ac <uthread_map_alloc+0xd4>  // b.any
	item->prev = list->prev;
ffffffffea8146d8:	aa1403e1 	mov	x1, x20
	list_add_tail(&ut->map_list, &mp->node);
ffffffffea8146dc:	91006260 	add	x0, x19, #0x18
ffffffffea8146e0:	f8418c22 	ldr	x2, [x1, #24]!
	item->next = list;
ffffffffea8146e4:	a9018662 	stp	x2, x1, [x19, #24]
	ut->ns_va_bottom = new_ns;
ffffffffea8146e8:	f9003284 	str	x4, [x20, #96]
	list->prev->next = item;
ffffffffea8146ec:	f9000440 	str	x0, [x2, #8]
	list->prev = item;
ffffffffea8146f0:	f9000e80 	str	x0, [x20, #24]
	return NO_ERROR;
ffffffffea8146f4:	52800000 	mov	w0, #0x0                   	// #0
	if (mpp) {
ffffffffea8146f8:	b4000355 	cbz	x21, ffffffffea814760 <uthread_map_alloc+0x188>
ffffffffea8146fc:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea814700:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = mp;
ffffffffea814704:	f90002b3 	str	x19, [x21]
ffffffffea814708:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea81470c:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea814710:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea814714:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea814718:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea81471c:	d65f03c0 	ret
ffffffffea814720:	d2800600 	mov	x0, #0x30                  	// #48
ffffffffea814724:	d280003b 	mov	x27, #0x1                   	// #1
	mp = malloc(sizeof(uthread_map_t) + (npages * sizeof(mp->pfn_list[0])));
ffffffffea814728:	97fffd90 	bl	ffffffffea813d68 <malloc>
ffffffffea81472c:	aa0003f3 	mov	x19, x0
	if (!mp) {
ffffffffea814730:	b5fff8a0 	cbnz	x0, ffffffffea814644 <uthread_map_alloc+0x6c>
		err = ERR_NO_MEMORY;
ffffffffea814734:	12800080 	mov	w0, #0xfffffffb            	// #-5
	if (mpp) {
ffffffffea814738:	b4000155 	cbz	x21, ffffffffea814760 <uthread_map_alloc+0x188>
ffffffffea81473c:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea814740:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea814744:	a944efba 	ldp	x26, x27, [x29, #72]
		*mpp = NULL;
ffffffffea814748:	f90002bf 	str	xzr, [x21]
ffffffffea81474c:	f94013b5 	ldr	x21, [x29, #32]
}
ffffffffea814750:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea814754:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea814758:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea81475c:	d65f03c0 	ret
ffffffffea814760:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea814764:	f9400fb4 	ldr	x20, [x29, #24]
ffffffffea814768:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea81476c:	a942dfb6 	ldp	x22, x23, [x29, #40]
ffffffffea814770:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea814774:	a944efba 	ldp	x26, x27, [x29, #72]
ffffffffea814778:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea81477c:	d65f03c0 	ret
	free(mp);
ffffffffea814780:	aa1303e0 	mov	x0, x19
ffffffffea814784:	97fffd8f 	bl	ffffffffea813dc0 <free>
ffffffffea814788:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea81478c:	17ffffeb 	b	ffffffffea814738 <uthread_map_alloc+0x160>
			if((mp->vaddr + mp->size) > mp_lst->vaddr) {
ffffffffea814790:	f9400661 	ldr	x1, [x19, #8]
ffffffffea814794:	8b010063 	add	x3, x3, x1
ffffffffea814798:	eb00007f 	cmp	x3, x0
ffffffffea81479c:	54ffff28 	b.hi	ffffffffea814780 <uthread_map_alloc+0x1a8>  // b.pmore
	item->prev = list->prev;
ffffffffea8147a0:	aa0203e1 	mov	x1, x2
			list_add_before(&mp_lst->node, &mp->node);
ffffffffea8147a4:	91006260 	add	x0, x19, #0x18
ffffffffea8147a8:	f8418c23 	ldr	x3, [x1, #24]!
	item->next = list;
ffffffffea8147ac:	a9018663 	stp	x3, x1, [x19, #24]
	list->prev->next = item;
ffffffffea8147b0:	f9400c41 	ldr	x1, [x2, #24]
			ut->ns_va_bottom = new_ns;
ffffffffea8147b4:	f9003284 	str	x4, [x20, #96]
ffffffffea8147b8:	f9000420 	str	x0, [x1, #8]
	list->prev = item;
ffffffffea8147bc:	f9000c40 	str	x0, [x2, #24]
ffffffffea8147c0:	17ffffcd 	b	ffffffffea8146f4 <uthread_map_alloc+0x11c>
	ASSERT(!(size & (PAGE_SIZE - 1)));
ffffffffea8147c4:	90000024 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8147c8:	90000022 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8147cc:	d0000001 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8147d0:	a90153b3 	stp	x19, x20, [x29, #16]
ffffffffea8147d4:	a9025bb5 	stp	x21, x22, [x29, #32]
ffffffffea8147d8:	911fa084 	add	x4, x4, #0x7e8
ffffffffea8147dc:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8147e0:	52801463 	mov	w3, #0xa3                  	// #163
ffffffffea8147e4:	a9046bb9 	stp	x25, x26, [x29, #64]
ffffffffea8147e8:	91202042 	add	x2, x2, #0x808
ffffffffea8147ec:	91314021 	add	x1, x1, #0xc50
ffffffffea8147f0:	aa1e03e0 	mov	x0, x30
ffffffffea8147f4:	f9002bbb 	str	x27, [x29, #80]
ffffffffea8147f8:	97fff762 	bl	ffffffffea812580 <_panic>
		return ERR_INVALID_ARGS;
ffffffffea8147fc:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea814800:	17ffffd4 	b	ffffffffea814750 <uthread_map_alloc+0x178>
ffffffffea814804:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814808 <uthread_init>:
	list->prev = list->next = list;
ffffffffea814808:	d00002e1 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea81480c:	913f4020 	add	x0, x1, #0xfd0
ffffffffea814810:	f907e820 	str	x0, [x1, #4048]
ffffffffea814814:	f9000400 	str	x0, [x0, #8]
#endif

static void uthread_init(uint level)
{
	list_initialize(&uthread_list);
	arch_uthread_init();
ffffffffea814818:	1400025a 	b	ffffffffea815180 <arch_uthread_init>
ffffffffea81481c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814820 <uthread_start>:
	if (!ut || !ut->thread) {
ffffffffea814820:	b4000080 	cbz	x0, ffffffffea814830 <uthread_start+0x10>
ffffffffea814824:	f9403c00 	ldr	x0, [x0, #120]
ffffffffea814828:	b4000040 	cbz	x0, ffffffffea814830 <uthread_start+0x10>
	return thread_resume(ut->thread);
ffffffffea81482c:	17ffc68f 	b	ffffffffea806268 <thread_resume>
}
ffffffffea814830:	128000e0 	mov	w0, #0xfffffff8            	// #-8
ffffffffea814834:	d65f03c0 	ret

ffffffffea814838 <uthread_exit>:
{
ffffffffea814838:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea81483c:	910003fd 	mov	x29, sp
ffffffffea814840:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814844:	2a0003f4 	mov	w20, w0
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea814848:	d538d080 	mrs	x0, tpidr_el1
#define THREAD_UNLOCK(state) spin_unlock_irqrestore(&thread_lock, state)

/* thread local storage */
static inline __ALWAYS_INLINE uintptr_t tls_get(uint entry)
{
	return get_current_thread()->tls[entry];
ffffffffea81484c:	f9415813 	ldr	x19, [x0, #688]
	if (ut) {
ffffffffea814850:	b4000173 	cbz	x19, ffffffffea81487c <uthread_exit+0x44>
		uthread_free_maps(ut);
ffffffffea814854:	aa1303e0 	mov	x0, x19
ffffffffea814858:	97ffff46 	bl	ffffffffea814570 <uthread_free_maps>
		free(ut->stack);
ffffffffea81485c:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea814860:	97fffd58 	bl	ffffffffea813dc0 <free>
		arch_uthread_free(ut);
ffffffffea814864:	aa1303e0 	mov	x0, x19
ffffffffea814868:	94000280 	bl	ffffffffea815268 <arch_uthread_free>
		free(ut);
ffffffffea81486c:	aa1303e0 	mov	x0, x19
ffffffffea814870:	97fffd54 	bl	ffffffffea813dc0 <free>
	thread_exit(retcode);
ffffffffea814874:	2a1403e0 	mov	w0, w20
ffffffffea814878:	97ffc9ae 	bl	ffffffffea806f30 <thread_exit>
ffffffffea81487c:	d538d083 	mrs	x3, tpidr_el1
		TRACEF("WARNING: unexpected call on kernel thread %s!",
ffffffffea814880:	90000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814884:	90000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814888:	910ae063 	add	x3, x3, #0x2b8
ffffffffea81488c:	52802f42 	mov	w2, #0x17a                 	// #378
ffffffffea814890:	911dc021 	add	x1, x1, #0x770
ffffffffea814894:	911ec000 	add	x0, x0, #0x7b0
ffffffffea814898:	97fffcf0 	bl	ffffffffea813c58 <_printf>
ffffffffea81489c:	17fffff6 	b	ffffffffea814874 <uthread_exit+0x3c>

ffffffffea8148a0 <uthread_context_switch>:
	arch_uthread_context_switch(old_ut, new_ut);
ffffffffea8148a0:	f9415800 	ldr	x0, [x0, #688]
ffffffffea8148a4:	f9415821 	ldr	x1, [x1, #688]
ffffffffea8148a8:	14000248 	b	ffffffffea8151c8 <arch_uthread_context_switch>
ffffffffea8148ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8148b0 <uthread_map>:
{
ffffffffea8148b0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
ffffffffea8148b4:	910003fd 	mov	x29, sp
ffffffffea8148b8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8148bc:	d0000273 	adrp	x19, ffffffffea862000 <__ctor_list>
ffffffffea8148c0:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea8148c4:	aa0003f4 	mov	x20, x0
	mutex_acquire(&ut->mmap_lock);
ffffffffea8148c8:	9100a017 	add	x23, x0, #0x28
{
ffffffffea8148cc:	f9402a60 	ldr	x0, [x19, #80]
ffffffffea8148d0:	aa0103f8 	mov	x24, x1
ffffffffea8148d4:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea8148d8:	f9400001 	ldr	x1, [x0]
ffffffffea8148dc:	f9002fa1 	str	x1, [x29, #88]
ffffffffea8148e0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8148e4:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea8148e8:	aa0303f5 	mov	x21, x3
ffffffffea8148ec:	aa0203f9 	mov	x25, x2
ffffffffea8148f0:	2a0403f6 	mov	w22, w4
ffffffffea8148f4:	2a0503fa 	mov	w26, w5
ffffffffea8148f8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8148fc:	aa1703e0 	mov	x0, x23
ffffffffea814900:	97ffc3e2 	bl	ffffffffea805888 <mutex_acquire_timeout>
	uthread_map_t *mp = NULL;
ffffffffea814904:	f9002bbf 	str	xzr, [x29, #80]
	if (!ut || !pfn_list || !vaddrp) {
ffffffffea814908:	f100033f 	cmp	x25, #0x0
ffffffffea81490c:	fa401b04 	ccmp	x24, #0x0, #0x4, ne  // ne = any
ffffffffea814910:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
ffffffffea814914:	540005a0 	b.eq	ffffffffea8149c8 <uthread_map+0x118>  // b.none
	if((size & (PAGE_SIZE - 1))) {
ffffffffea814918:	f2402ebf 	tst	x21, #0xfff
ffffffffea81491c:	540005a1 	b.ne	ffffffffea8149d0 <uthread_map+0x120>  // b.any
	if(!(flags & UTM_FIXED)) {
ffffffffea814920:	364003b6 	tbz	w22, #8, ffffffffea814994 <uthread_map+0xe4>
ffffffffea814924:	f9400302 	ldr	x2, [x24]
	err = uthread_map_alloc(ut, &mp, *vaddrp, pfn_list, size, flags, align);
ffffffffea814928:	aa1503e4 	mov	x4, x21
ffffffffea81492c:	2a1a03e6 	mov	w6, w26
ffffffffea814930:	2a1603e5 	mov	w5, w22
ffffffffea814934:	aa1903e3 	mov	x3, x25
ffffffffea814938:	910143a1 	add	x1, x29, #0x50
ffffffffea81493c:	aa1403e0 	mov	x0, x20
ffffffffea814940:	97ffff26 	bl	ffffffffea8145d8 <uthread_map_alloc>
ffffffffea814944:	2a0003f5 	mov	w21, w0
	if(err) {
ffffffffea814948:	350000a0 	cbnz	w0, ffffffffea81495c <uthread_map+0xac>
	err = arch_uthread_map(ut, mp);
ffffffffea81494c:	f9402ba1 	ldr	x1, [x29, #80]
ffffffffea814950:	aa1403e0 	mov	x0, x20
ffffffffea814954:	94000269 	bl	ffffffffea8152f8 <arch_uthread_map>
ffffffffea814958:	2a0003f5 	mov	w21, w0
	mutex_release(&ut->mmap_lock);
ffffffffea81495c:	aa1703e0 	mov	x0, x23
ffffffffea814960:	97ffc3f6 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea814964:	f9402a73 	ldr	x19, [x19, #80]
ffffffffea814968:	2a1503e0 	mov	w0, w21
ffffffffea81496c:	f9402fa2 	ldr	x2, [x29, #88]
ffffffffea814970:	f9400261 	ldr	x1, [x19]
ffffffffea814974:	ca010041 	eor	x1, x2, x1
ffffffffea814978:	b5000301 	cbnz	x1, ffffffffea8149d8 <uthread_map+0x128>
ffffffffea81497c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814980:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814984:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea814988:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea81498c:	a8c67bfd 	ldp	x29, x30, [sp], #96
ffffffffea814990:	d65f03c0 	ret
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea814994:	2a1a03e2 	mov	w2, w26
ffffffffea814998:	aa1503e1 	mov	x1, x21
ffffffffea81499c:	aa1403e0 	mov	x0, x20
	if (flags & UTM_NS_MEM) {
ffffffffea8149a0:	373000f6 	tbnz	w22, #6, ffffffffea8149bc <uthread_map+0x10c>
		return uthread_find_va_space_sec(ut, size, align);
ffffffffea8149a4:	97fffed1 	bl	ffffffffea8144e8 <uthread_find_va_space_sec>
ffffffffea8149a8:	aa0003e2 	mov	x2, x0
		*vaddrp = uthread_find_va_space(ut, size, flags, align);
ffffffffea8149ac:	f9000302 	str	x2, [x24]
		if (!(*vaddrp)) {
ffffffffea8149b0:	b5fffbc2 	cbnz	x2, ffffffffea814928 <uthread_map+0x78>
			err = ERR_NO_MEMORY;
ffffffffea8149b4:	12800095 	mov	w21, #0xfffffffb            	// #-5
ffffffffea8149b8:	17ffffe9 	b	ffffffffea81495c <uthread_map+0xac>
		return uthread_find_va_space_ns(ut, size, align);
ffffffffea8149bc:	97fffe97 	bl	ffffffffea814418 <uthread_find_va_space_ns>
ffffffffea8149c0:	aa0003e2 	mov	x2, x0
ffffffffea8149c4:	17fffffa 	b	ffffffffea8149ac <uthread_map+0xfc>
		err = ERR_INVALID_ARGS;
ffffffffea8149c8:	128000f5 	mov	w21, #0xfffffff8            	// #-8
ffffffffea8149cc:	17ffffe4 	b	ffffffffea81495c <uthread_map+0xac>
		err = ERR_NOT_VALID;
ffffffffea8149d0:	128000d5 	mov	w21, #0xfffffff9            	// #-7
ffffffffea8149d4:	17ffffe2 	b	ffffffffea81495c <uthread_map+0xac>
}
ffffffffea8149d8:	97fffcd4 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea8149dc:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8149e0 <uthread_create>:
{
ffffffffea8149e0:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
ffffffffea8149e4:	910003fd 	mov	x29, sp
ffffffffea8149e8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8149ec:	d0000274 	adrp	x20, ffffffffea862000 <__ctor_list>
ffffffffea8149f0:	a9046bf9 	stp	x25, x26, [sp, #64]
ffffffffea8149f4:	aa0003f9 	mov	x25, x0
ffffffffea8149f8:	f9402a80 	ldr	x0, [x20, #80]
ffffffffea8149fc:	2a0203fa 	mov	w26, w2
ffffffffea814a00:	a90573fb 	stp	x27, x28, [sp, #80]
ffffffffea814a04:	aa0103fc 	mov	x28, x1
ffffffffea814a08:	f9400001 	ldr	x1, [x0]
ffffffffea814a0c:	f90047a1 	str	x1, [x29, #136]
ffffffffea814a10:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea814a14:	a90363f7 	stp	x23, x24, [sp, #48]
ffffffffea814a18:	aa0503fb 	mov	x27, x5
ffffffffea814a1c:	aa0303f8 	mov	x24, x3
ffffffffea814a20:	aa0403f7 	mov	x23, x4
	ut = (uthread_t *)calloc(1, sizeof(uthread_t));
ffffffffea814a24:	d2801501 	mov	x1, #0xa8                  	// #168
ffffffffea814a28:	d2800020 	mov	x0, #0x1                   	// #1
ffffffffea814a2c:	97fffcd5 	bl	ffffffffea813d80 <calloc>
ffffffffea814a30:	aa0003f3 	mov	x19, x0
	if (!ut) {
ffffffffea814a34:	b40009a0 	cbz	x0, ffffffffea814b68 <uthread_create+0x188>
ffffffffea814a38:	a9025bb5 	stp	x21, x22, [x29, #32]
	list_initialize(&ut->map_list);
ffffffffea814a3c:	91006000 	add	x0, x0, #0x18
ffffffffea814a40:	a9018260 	stp	x0, x0, [x19, #24]
	mutex_init(&ut->mmap_lock);
ffffffffea814a44:	9100a260 	add	x0, x19, #0x28
ffffffffea814a48:	97ffc384 	bl	ffffffffea805858 <mutex_init>
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea814a4c:	d53b4220 	mrs	x0, daif
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
ffffffffea814a50:	37380a40 	tbnz	w0, #7, ffffffffea814b98 <uthread_create+0x1b8>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea814a54:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea814a58:	d00002f5 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814a5c:	913f82a2 	add	x2, x21, #0xfe0
	next_utid++;
ffffffffea814a60:	d00002f6 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814a64:	aa0203e0 	mov	x0, x2
ffffffffea814a68:	f90037a2 	str	x2, [x29, #104]
ffffffffea814a6c:	97ffb795 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea814a70:	b94fcec1 	ldr	w1, [x22, #4044]
    arch_spin_unlock(lock);
ffffffffea814a74:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea814a78:	11000421 	add	w1, w1, #0x1
ffffffffea814a7c:	b90fcec1 	str	w1, [x22, #4044]
ffffffffea814a80:	aa0203e0 	mov	x0, x2
ffffffffea814a84:	97ffb797 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea814a88:	d50342ff 	msr	daifclr, #0x2
	ut->id = uthread_alloc_utid();
ffffffffea814a8c:	b94fcec0 	ldr	w0, [x22, #4044]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea814a90:	aa1703e1 	mov	x1, x23
	ut->entry = entry;
ffffffffea814a94:	f900067c 	str	x28, [x19, #8]
	ut->id = uthread_alloc_utid();
ffffffffea814a98:	b9006a60 	str	w0, [x19, #104]
	ut->ns_va_bottom = MAX_USR_VA;
ffffffffea814a9c:	d2a04000 	mov	x0, #0x2000000             	// #33554432
ffffffffea814aa0:	f9003260 	str	x0, [x19, #96]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea814aa4:	d2820000 	mov	x0, #0x1000                	// #4096
	ut->private_data = private_data;
ffffffffea814aa8:	f9004a7b 	str	x27, [x19, #144]
	ut->stack = memalign(PAGE_SIZE, stack_size);
ffffffffea814aac:	97fffcb1 	bl	ffffffffea813d70 <memalign>
ffffffffea814ab0:	f9000a60 	str	x0, [x19, #16]
	if(!ut->stack) {
ffffffffea814ab4:	b4000ae0 	cbz	x0, ffffffffea814c10 <uthread_create+0x230>
	stack_bot = start_stack - stack_size;
ffffffffea814ab8:	cb170301 	sub	x1, x24, x23
ffffffffea814abc:	f9003fa1 	str	x1, [x29, #120]
ffffffffea814ac0:	97fff2fc 	bl	ffffffffea8116b0 <kvaddr_to_paddr>
ffffffffea814ac4:	910243a2 	add	x2, x29, #0x90
	return uthread_map(ut, vaddrp, &paddr, size, flags, align);
ffffffffea814ac8:	52820005 	mov	w5, #0x1000                	// #4096
ffffffffea814acc:	52802664 	mov	w4, #0x133                 	// #307
ffffffffea814ad0:	aa1703e3 	mov	x3, x23
ffffffffea814ad4:	9101e3a1 	add	x1, x29, #0x78
ffffffffea814ad8:	f81f0c40 	str	x0, [x2, #-16]!
ffffffffea814adc:	aa1303e0 	mov	x0, x19
ffffffffea814ae0:	97ffff74 	bl	ffffffffea8148b0 <uthread_map>
	if (err) {
ffffffffea814ae4:	35000920 	cbnz	w0, ffffffffea814c08 <uthread_create+0x228>
	ut->thread = thread_create(name,
ffffffffea814ae8:	d0000261 	adrp	x1, ffffffffea862000 <__ctor_list>
	ut->start_stack = start_stack;
ffffffffea814aec:	f9000278 	str	x24, [x19]
	ut->thread = thread_create(name,
ffffffffea814af0:	d2820004 	mov	x4, #0x1000                	// #4096
ffffffffea814af4:	2a1a03e3 	mov	w3, w26
ffffffffea814af8:	f9405021 	ldr	x1, [x1, #160]
ffffffffea814afc:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea814b00:	aa1903e0 	mov	x0, x25
ffffffffea814b04:	97ffc579 	bl	ffffffffea8060e8 <thread_create>
ffffffffea814b08:	f9003e60 	str	x0, [x19, #120]
	if (!ut->thread) {
ffffffffea814b0c:	b40007a0 	cbz	x0, ffffffffea814c00 <uthread_create+0x220>
	err = arch_uthread_create(ut);
ffffffffea814b10:	aa1303e0 	mov	x0, x19
ffffffffea814b14:	940001cf 	bl	ffffffffea815250 <arch_uthread_create>
	if (err) {
ffffffffea814b18:	35000740 	cbnz	w0, ffffffffea814c00 <uthread_create+0x220>
	ut->thread->tls[TLS_ENTRY_UTHREAD] = (uintptr_t) ut;
ffffffffea814b1c:	f9403e60 	ldr	x0, [x19, #120]
ffffffffea814b20:	f9015813 	str	x19, [x0, #688]
    __asm__ volatile("mrs %0, daif" : "=r"(state));
ffffffffea814b24:	d53b4220 	mrs	x0, daif
ffffffffea814b28:	91020276 	add	x22, x19, #0x80
ffffffffea814b2c:	37380500 	tbnz	w0, #7, ffffffffea814bcc <uthread_create+0x1ec>
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea814b30:	d50342df 	msr	daifset, #0x2
    arch_spin_lock(lock);
ffffffffea814b34:	913f82b5 	add	x21, x21, #0xfe0
ffffffffea814b38:	aa1503e0 	mov	x0, x21
ffffffffea814b3c:	97ffb761 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea814b40:	d00002e1 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814b44:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea814b48:	aa1503e0 	mov	x0, x21
ffffffffea814b4c:	f9400422 	ldr	x2, [x1, #8]
ffffffffea814b50:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea814b54:	f9000056 	str	x22, [x2]
	list->next = item;
ffffffffea814b58:	f9000436 	str	x22, [x1, #8]
ffffffffea814b5c:	97ffb761 	bl	ffffffffea8028e0 <arch_spin_unlock>
    __asm__ volatile("msr daifclr, #2" ::: "memory");
ffffffffea814b60:	d50342ff 	msr	daifclr, #0x2
ffffffffea814b64:	a9425bb5 	ldp	x21, x22, [x29, #32]
}
ffffffffea814b68:	aa1303e0 	mov	x0, x19
ffffffffea814b6c:	f9402a94 	ldr	x20, [x20, #80]
ffffffffea814b70:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea814b74:	f9400281 	ldr	x1, [x20]
ffffffffea814b78:	ca010041 	eor	x1, x2, x1
ffffffffea814b7c:	b5000541 	cbnz	x1, ffffffffea814c24 <uthread_create+0x244>
ffffffffea814b80:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814b84:	a94363f7 	ldp	x23, x24, [sp, #48]
ffffffffea814b88:	a9446bf9 	ldp	x25, x26, [sp, #64]
ffffffffea814b8c:	a94573fb 	ldp	x27, x28, [sp, #80]
ffffffffea814b90:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea814b94:	d65f03c0 	ret
    arch_spin_lock(lock);
ffffffffea814b98:	d00002f5 	adrp	x21, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814b9c:	913f82a2 	add	x2, x21, #0xfe0
	next_utid++;
ffffffffea814ba0:	d00002f6 	adrp	x22, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814ba4:	aa0203e0 	mov	x0, x2
ffffffffea814ba8:	f90037a2 	str	x2, [x29, #104]
ffffffffea814bac:	97ffb745 	bl	ffffffffea8028c0 <arch_spin_lock>
ffffffffea814bb0:	b94fcec1 	ldr	w1, [x22, #4044]
    arch_spin_unlock(lock);
ffffffffea814bb4:	f94037a2 	ldr	x2, [x29, #104]
ffffffffea814bb8:	11000421 	add	w1, w1, #0x1
ffffffffea814bbc:	b90fcec1 	str	w1, [x22, #4044]
ffffffffea814bc0:	aa0203e0 	mov	x0, x2
ffffffffea814bc4:	97ffb747 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea814bc8:	17ffffb1 	b	ffffffffea814a8c <uthread_create+0xac>
    arch_spin_lock(lock);
ffffffffea814bcc:	913f82b5 	add	x21, x21, #0xfe0
ffffffffea814bd0:	aa1503e0 	mov	x0, x21
ffffffffea814bd4:	97ffb73b 	bl	ffffffffea8028c0 <arch_spin_lock>
	item->next = list->next;
ffffffffea814bd8:	d00002e1 	adrp	x1, ffffffffea872000 <idle_threads+0xeb0>
ffffffffea814bdc:	913f4021 	add	x1, x1, #0xfd0
    arch_spin_unlock(lock);
ffffffffea814be0:	aa1503e0 	mov	x0, x21
ffffffffea814be4:	f9400422 	ldr	x2, [x1, #8]
ffffffffea814be8:	a9080a61 	stp	x1, x2, [x19, #128]
	list->next->prev = item;
ffffffffea814bec:	f9000056 	str	x22, [x2]
	list->next = item;
ffffffffea814bf0:	f9000436 	str	x22, [x1, #8]
ffffffffea814bf4:	97ffb73b 	bl	ffffffffea8028e0 <arch_spin_unlock>
ffffffffea814bf8:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea814bfc:	17ffffdb 	b	ffffffffea814b68 <uthread_create+0x188>
	uthread_free_maps(ut);
ffffffffea814c00:	aa1303e0 	mov	x0, x19
ffffffffea814c04:	97fffe5b 	bl	ffffffffea814570 <uthread_free_maps>
	free(ut->stack);
ffffffffea814c08:	f9400a60 	ldr	x0, [x19, #16]
ffffffffea814c0c:	97fffc6d 	bl	ffffffffea813dc0 <free>
	free(ut);
ffffffffea814c10:	aa1303e0 	mov	x0, x19
	return NULL;
ffffffffea814c14:	d2800013 	mov	x19, #0x0                   	// #0
	free(ut);
ffffffffea814c18:	97fffc6a 	bl	ffffffffea813dc0 <free>
ffffffffea814c1c:	a9425bb5 	ldp	x21, x22, [x29, #32]
ffffffffea814c20:	17ffffd2 	b	ffffffffea814b68 <uthread_create+0x188>
ffffffffea814c24:	a9025bb5 	stp	x21, x22, [x29, #32]
}
ffffffffea814c28:	97fffc40 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea814c2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814c30 <uthread_pmm_alloc_and_map>:
{
ffffffffea814c30:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
	uint32_t alloc_size = ROUNDUP(size, PAGE_SIZE);
ffffffffea814c34:	113ffc42 	add	w2, w2, #0xfff
{
ffffffffea814c38:	910003fd 	mov	x29, sp
ffffffffea814c3c:	a902dff6 	stp	x22, x23, [sp, #40]
ffffffffea814c40:	d0000276 	adrp	x22, ffffffffea862000 <__ctor_list>
	uint32_t alloc_size = ROUNDUP(size, PAGE_SIZE);
ffffffffea814c44:	12144c57 	and	w23, w2, #0xfffff000
{
ffffffffea814c48:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814c4c:	f9402ac2 	ldr	x2, [x22, #80]
	struct list_node page_list = LIST_INITIAL_VALUE(page_list);
ffffffffea814c50:	9101e3b4 	add	x20, x29, #0x78
{
ffffffffea814c54:	f90037a0 	str	x0, [x29, #104]
ffffffffea814c58:	f9400040 	ldr	x0, [x2]
ffffffffea814c5c:	f90047a0 	str	x0, [x29, #136]
ffffffffea814c60:	d2800000 	mov	x0, #0x0                   	// #0
	struct list_node page_list = LIST_INITIAL_VALUE(page_list);
ffffffffea814c64:	a907d3b4 	stp	x20, x20, [x29, #120]
	if (vaddr == NULL)
ffffffffea814c68:	b4000d41 	cbz	x1, ffffffffea814e10 <uthread_pmm_alloc_and_map+0x1e0>
ffffffffea814c6c:	f9001fb8 	str	x24, [x29, #56]
ffffffffea814c70:	aa0103f8 	mov	x24, x1
ffffffffea814c74:	a90573bb 	stp	x27, x28, [x29, #80]
ffffffffea814c78:	530c7ef3 	lsr	w19, w23, #12
ffffffffea814c7c:	2a0303fc 	mov	w28, w3
ffffffffea814c80:	2a0403fb 	mov	w27, w4
	*vaddr = NULL;
ffffffffea814c84:	f900031f 	str	xzr, [x24]
	allocated = pmm_alloc_pages(count, &page_list);
ffffffffea814c88:	2a1303e0 	mov	w0, w19
ffffffffea814c8c:	aa1403e1 	mov	x1, x20
ffffffffea814c90:	97fff0ea 	bl	ffffffffea811038 <pmm_alloc_pages>
	if (allocated != count) {
ffffffffea814c94:	6b00027f 	cmp	w19, w0
ffffffffea814c98:	540002e0 	b.eq	ffffffffea814cf4 <uthread_pmm_alloc_and_map+0xc4>  // b.none
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea814c9c:	90000024 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814ca0:	90000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814ca4:	2a1303e3 	mov	w3, w19
ffffffffea814ca8:	2a0003e2 	mov	w2, w0
ffffffffea814cac:	911e0021 	add	x1, x1, #0x780
ffffffffea814cb0:	9120a080 	add	x0, x4, #0x828
	status_t sts = -1;
ffffffffea814cb4:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: Failed to allocate enough pages (allocated %d, needed %d)\n",
ffffffffea814cb8:	97fff5aa 	bl	ffffffffea812360 <_dprintf>
	pmm_free(&page_list);
ffffffffea814cbc:	aa1403e0 	mov	x0, x20
ffffffffea814cc0:	97fff180 	bl	ffffffffea8112c0 <pmm_free>
	return sts;
ffffffffea814cc4:	f9401fb8 	ldr	x24, [x29, #56]
ffffffffea814cc8:	a94573bb 	ldp	x27, x28, [x29, #80]
}
ffffffffea814ccc:	2a1303e0 	mov	w0, w19
ffffffffea814cd0:	f9402ad6 	ldr	x22, [x22, #80]
ffffffffea814cd4:	f94047a2 	ldr	x2, [x29, #136]
ffffffffea814cd8:	f94002c1 	ldr	x1, [x22]
ffffffffea814cdc:	ca010041 	eor	x1, x2, x1
ffffffffea814ce0:	b50009c1 	cbnz	x1, ffffffffea814e18 <uthread_pmm_alloc_and_map+0x1e8>
ffffffffea814ce4:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814ce8:	a942dff6 	ldp	x22, x23, [sp, #40]
ffffffffea814cec:	a8c97bfd 	ldp	x29, x30, [sp], #144
ffffffffea814cf0:	d65f03c0 	ret
	pfn_list = malloc(count * sizeof(*pfn_list));
ffffffffea814cf4:	d37d4e73 	ubfiz	x19, x19, #3, #20
ffffffffea814cf8:	f90023b9 	str	x25, [x29, #64]
ffffffffea814cfc:	aa1303e0 	mov	x0, x19
ffffffffea814d00:	97fffc1a 	bl	ffffffffea813d68 <malloc>
ffffffffea814d04:	aa0003f9 	mov	x25, x0
	if (pfn_list == NULL) {
ffffffffea814d08:	b4000720 	cbz	x0, ffffffffea814dec <uthread_pmm_alloc_and_map+0x1bc>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea814d0c:	f94043b3 	ldr	x19, [x29, #128]
ffffffffea814d10:	eb14027f 	cmp	x19, x20
ffffffffea814d14:	540001e0 	b.eq	ffffffffea814d50 <uthread_pmm_alloc_and_map+0x120>  // b.none
ffffffffea814d18:	f90013b5 	str	x21, [x29, #32]
ffffffffea814d1c:	f90027ba 	str	x26, [x29, #72]
	i = 0;
ffffffffea814d20:	5280001a 	mov	w26, #0x0                   	// #0
ffffffffea814d24:	d503201f 	nop
		pfn_list[i] = page_to_address(page);
ffffffffea814d28:	2a1a03f5 	mov	w21, w26
ffffffffea814d2c:	aa1303e0 	mov	x0, x19
ffffffffea814d30:	97fff04a 	bl	ffffffffea810e58 <page_to_address>
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea814d34:	f9400673 	ldr	x19, [x19, #8]
		pfn_list[i] = page_to_address(page);
ffffffffea814d38:	1100075a 	add	w26, w26, #0x1
ffffffffea814d3c:	f8357b20 	str	x0, [x25, x21, lsl #3]
	list_for_every_entry(&page_list, page, vm_page_t, node) {
ffffffffea814d40:	eb14027f 	cmp	x19, x20
ffffffffea814d44:	54ffff21 	b.ne	ffffffffea814d28 <uthread_pmm_alloc_and_map+0xf8>  // b.any
ffffffffea814d48:	f94013b5 	ldr	x21, [x29, #32]
ffffffffea814d4c:	f94027ba 	ldr	x26, [x29, #72]
	if (flags & MMAP_FLAG_DEVICE_MEM)
ffffffffea814d50:	360801dc 	tbz	w28, #1, ffffffffea814d88 <uthread_pmm_alloc_and_map+0x158>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea814d54:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea814d58:	2a1b03e5 	mov	w5, w27
ffffffffea814d5c:	52804064 	mov	w4, #0x203                 	// #515
ffffffffea814d60:	aa1703e3 	mov	x3, x23
ffffffffea814d64:	aa1903e2 	mov	x2, x25
ffffffffea814d68:	aa1803e1 	mov	x1, x24
ffffffffea814d6c:	97fffed1 	bl	ffffffffea8148b0 <uthread_map>
ffffffffea814d70:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea814d74:	35000280 	cbnz	w0, ffffffffea814dc4 <uthread_pmm_alloc_and_map+0x194>
		arch_clean_cache_range(*vaddr, alloc_size);
ffffffffea814d78:	f9400300 	ldr	x0, [x24]
ffffffffea814d7c:	aa1703e1 	mov	x1, x23
ffffffffea814d80:	97ffb6da 	bl	ffffffffea8028e8 <arch_clean_cache_range>
ffffffffea814d84:	1400000a 	b	ffffffffea814dac <uthread_pmm_alloc_and_map+0x17c>
	sts = uthread_map(ut, vaddr, pfn_list, alloc_size,
ffffffffea814d88:	f94037a0 	ldr	x0, [x29, #104]
ffffffffea814d8c:	2a1b03e5 	mov	w5, w27
ffffffffea814d90:	52800064 	mov	w4, #0x3                   	// #3
ffffffffea814d94:	aa1703e3 	mov	x3, x23
ffffffffea814d98:	aa1903e2 	mov	x2, x25
ffffffffea814d9c:	aa1803e1 	mov	x1, x24
ffffffffea814da0:	97fffec4 	bl	ffffffffea8148b0 <uthread_map>
ffffffffea814da4:	2a0003f3 	mov	w19, w0
	if (sts) {
ffffffffea814da8:	350000e0 	cbnz	w0, ffffffffea814dc4 <uthread_pmm_alloc_and_map+0x194>
	free(pfn_list);
ffffffffea814dac:	aa1903e0 	mov	x0, x25
	return 0;
ffffffffea814db0:	52800013 	mov	w19, #0x0                   	// #0
	free(pfn_list);
ffffffffea814db4:	97fffc03 	bl	ffffffffea813dc0 <free>
	return 0;
ffffffffea814db8:	a943e7b8 	ldp	x24, x25, [x29, #56]
ffffffffea814dbc:	a94573bb 	ldp	x27, x28, [x29, #80]
ffffffffea814dc0:	17ffffc3 	b	ffffffffea814ccc <uthread_pmm_alloc_and_map+0x9c>
		dprintf(ALWAYS, "%s: Mapping failed with Error: %x\n",
ffffffffea814dc4:	2a1303e2 	mov	w2, w19
ffffffffea814dc8:	90000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814dcc:	911e0021 	add	x1, x1, #0x780
ffffffffea814dd0:	90000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814dd4:	91228000 	add	x0, x0, #0x8a0
ffffffffea814dd8:	97fff562 	bl	ffffffffea812360 <_dprintf>
	free(pfn_list);
ffffffffea814ddc:	aa1903e0 	mov	x0, x25
ffffffffea814de0:	97fffbf8 	bl	ffffffffea813dc0 <free>
ffffffffea814de4:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea814de8:	17ffffb5 	b	ffffffffea814cbc <uthread_pmm_alloc_and_map+0x8c>
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea814dec:	aa1303e2 	mov	x2, x19
ffffffffea814df0:	90000021 	adrp	x1, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814df4:	90000020 	adrp	x0, ffffffffea818000 <zero_uuid+0x8>
ffffffffea814df8:	911e0021 	add	x1, x1, #0x780
ffffffffea814dfc:	9121a000 	add	x0, x0, #0x868
	status_t sts = -1;
ffffffffea814e00:	12800013 	mov	w19, #0xffffffff            	// #-1
		dprintf(ALWAYS, "%s: malloc failed. Unable to allocate pfn (size %lu)\n",
ffffffffea814e04:	97fff557 	bl	ffffffffea812360 <_dprintf>
		goto err_free_pages;
ffffffffea814e08:	f94023b9 	ldr	x25, [x29, #64]
ffffffffea814e0c:	17ffffac 	b	ffffffffea814cbc <uthread_pmm_alloc_and_map+0x8c>
		return ERR_INVALID_ARGS;
ffffffffea814e10:	128000f3 	mov	w19, #0xfffffff8            	// #-8
ffffffffea814e14:	17ffffae 	b	ffffffffea814ccc <uthread_pmm_alloc_and_map+0x9c>
ffffffffea814e18:	f90013b5 	str	x21, [x29, #32]
ffffffffea814e1c:	a903e7b8 	stp	x24, x25, [x29, #56]
ffffffffea814e20:	a904efba 	stp	x26, x27, [x29, #72]
ffffffffea814e24:	f9002fbc 	str	x28, [x29, #88]
}
ffffffffea814e28:	97fffbc0 	bl	ffffffffea813d28 <__stack_chk_fail>
ffffffffea814e2c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814e30 <uthread_unmap>:
{
ffffffffea814e30:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
ffffffffea814e34:	910003fd 	mov	x29, sp
ffffffffea814e38:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea814e3c:	9100a016 	add	x22, x0, #0x28
{
ffffffffea814e40:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814e44:	aa0003f5 	mov	x21, x0
ffffffffea814e48:	aa0103f4 	mov	x20, x1
ffffffffea814e4c:	aa0203f3 	mov	x19, x2
ffffffffea814e50:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea814e54:	aa1603e0 	mov	x0, x22
ffffffffea814e58:	f9001bf7 	str	x23, [sp, #48]
ffffffffea814e5c:	97ffc28b 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (!ut || !vaddr) {
ffffffffea814e60:	f10002bf 	cmp	x21, #0x0
ffffffffea814e64:	fa401a84 	ccmp	x20, #0x0, #0x4, ne  // ne = any
ffffffffea814e68:	54000b20 	b.eq	ffffffffea814fcc <uthread_unmap+0x19c>  // b.none
	if (vaddr + size < vaddr) {
ffffffffea814e6c:	8b130282 	add	x2, x20, x19
ffffffffea814e70:	eb02029f 	cmp	x20, x2
ffffffffea814e74:	54000228 	b.hi	ffffffffea814eb8 <uthread_unmap+0x88>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814e78:	f94012b3 	ldr	x19, [x21, #32]
ffffffffea814e7c:	d1006273 	sub	x19, x19, #0x18
ffffffffea814e80:	eb1302bf 	cmp	x21, x19
ffffffffea814e84:	540001a0 	b.eq	ffffffffea814eb8 <uthread_unmap+0x88>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea814e88:	f9400260 	ldr	x0, [x19]
ffffffffea814e8c:	eb00029f 	cmp	x20, x0
ffffffffea814e90:	540000c3 	b.cc	ffffffffea814ea8 <uthread_unmap+0x78>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea814e94:	f9400661 	ldr	x1, [x19, #8]
ffffffffea814e98:	8b010000 	add	x0, x0, x1
ffffffffea814e9c:	eb00029f 	cmp	x20, x0
ffffffffea814ea0:	fa403042 	ccmp	x2, x0, #0x2, cc  // cc = lo, ul, last
ffffffffea814ea4:	540001c9 	b.ls	ffffffffea814edc <uthread_unmap+0xac>  // b.plast
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea814ea8:	f9401273 	ldr	x19, [x19, #32]
ffffffffea814eac:	d1006273 	sub	x19, x19, #0x18
ffffffffea814eb0:	eb1302bf 	cmp	x21, x19
ffffffffea814eb4:	54fffea1 	b.ne	ffffffffea814e88 <uthread_unmap+0x58>  // b.any
		err = ERR_NOT_FOUND;
ffffffffea814eb8:	12800037 	mov	w23, #0xfffffffe            	// #-2
	mutex_release(&ut->mmap_lock);
ffffffffea814ebc:	aa1603e0 	mov	x0, x22
ffffffffea814ec0:	97ffc29e 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea814ec4:	2a1703e0 	mov	w0, w23
ffffffffea814ec8:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea814ecc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814ed0:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814ed4:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea814ed8:	d65f03c0 	ret
	err = arch_uthread_unmap(ut, mp);
ffffffffea814edc:	aa1303e1 	mov	x1, x19
ffffffffea814ee0:	aa1503e0 	mov	x0, x21
ffffffffea814ee4:	94000197 	bl	ffffffffea815540 <arch_uthread_unmap>
ffffffffea814ee8:	2a0003f7 	mov	w23, w0
	if (err) {
ffffffffea814eec:	35fffe80 	cbnz	w0, ffffffffea814ebc <uthread_unmap+0x8c>
	if (mp->flags & MMAP_FLAG_DEVICE_MEM) {
ffffffffea814ef0:	b9401262 	ldr	w2, [x19, #16]
ffffffffea814ef4:	36080242 	tbz	w2, #1, ffffffffea814f3c <uthread_unmap+0x10c>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814ef8:	f9400660 	ldr	x0, [x19, #8]
ffffffffea814efc:	eb4033ff 	negs	xzr, x0, lsr #12
ffffffffea814f00:	540001e0 	b.eq	ffffffffea814f3c <uthread_unmap+0x10c>  // b.none
ffffffffea814f04:	52800014 	mov	w20, #0x0                   	// #0
ffffffffea814f08:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea814f0c:	d503201f 	nop
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814f10:	8b000e60 	add	x0, x19, x0, lsl #3
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814f14:	11000694 	add	w20, w20, #0x1
			vm_page_t *page = address_to_page(mp->pfn_list[i]);
ffffffffea814f18:	f9401400 	ldr	x0, [x0, #40]
ffffffffea814f1c:	97ffefeb 	bl	ffffffffea810ec8 <address_to_page>
			if (page) {
ffffffffea814f20:	b4000040 	cbz	x0, ffffffffea814f28 <uthread_unmap+0xf8>
				pmm_free_page(page);
ffffffffea814f24:	97fff123 	bl	ffffffffea8113b0 <pmm_free_page>
		for (i = 0; i < (mp->size / PAGE_SIZE); i++) {
ffffffffea814f28:	f9400661 	ldr	x1, [x19, #8]
ffffffffea814f2c:	2a1403e0 	mov	w0, w20
ffffffffea814f30:	eb41301f 	cmp	x0, x1, lsr #12
ffffffffea814f34:	54fffee3 	b.cc	ffffffffea814f10 <uthread_unmap+0xe0>  // b.lo, b.ul, b.last
ffffffffea814f38:	b9401262 	ldr	w2, [x19, #16]
ffffffffea814f3c:	a9418660 	ldp	x0, x1, [x19, #24]
	if (mp->flags & UTM_NS_MEM) {
ffffffffea814f40:	36300142 	tbz	w2, #6, ffffffffea814f68 <uthread_unmap+0x138>
		item = list_prev_type(&ut->map_list, &mp->node,
ffffffffea814f44:	910062a2 	add	x2, x21, #0x18
ffffffffea814f48:	f100001f 	cmp	x0, #0x0
ffffffffea814f4c:	fa401044 	ccmp	x2, x0, #0x4, ne  // ne = any
ffffffffea814f50:	54000281 	b.ne	ffffffffea814fa0 <uthread_unmap+0x170>  // b.any
			item = list_next_type(&ut->map_list, &mp->node,
ffffffffea814f54:	f100003f 	cmp	x1, #0x0
ffffffffea814f58:	fa411044 	ccmp	x2, x1, #0x4, ne  // ne = any
ffffffffea814f5c:	540002c1 	b.ne	ffffffffea814fb4 <uthread_unmap+0x184>  // b.any
				ut->ns_va_bottom = MAX_USR_VA;
ffffffffea814f60:	d2a04002 	mov	x2, #0x2000000             	// #33554432
ffffffffea814f64:	f90032a2 	str	x2, [x21, #96]
	item->next->prev = item->prev;
ffffffffea814f68:	f9000020 	str	x0, [x1]
	free(mp);
ffffffffea814f6c:	aa1303e0 	mov	x0, x19
	item->prev->next = item->next;
ffffffffea814f70:	f9400e62 	ldr	x2, [x19, #24]
ffffffffea814f74:	f9000441 	str	x1, [x2, #8]
	item->prev = item->next = 0;
ffffffffea814f78:	a901fe7f 	stp	xzr, xzr, [x19, #24]
ffffffffea814f7c:	97fffb91 	bl	ffffffffea813dc0 <free>
	mutex_release(&ut->mmap_lock);
ffffffffea814f80:	aa1603e0 	mov	x0, x22
ffffffffea814f84:	97ffc26d 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea814f88:	2a1703e0 	mov	w0, w23
ffffffffea814f8c:	f9401bf7 	ldr	x23, [sp, #48]
ffffffffea814f90:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea814f94:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea814f98:	a8c47bfd 	ldp	x29, x30, [sp], #64
ffffffffea814f9c:	d65f03c0 	ret
		if (!item || (item->flags & UTM_NS_MEM) == 0) {
ffffffffea814fa0:	f100601f 	cmp	x0, #0x18
ffffffffea814fa4:	54fffd80 	b.eq	ffffffffea814f54 <uthread_unmap+0x124>  // b.none
ffffffffea814fa8:	b85f8003 	ldur	w3, [x0, #-8]
ffffffffea814fac:	3637fd43 	tbz	w3, #6, ffffffffea814f54 <uthread_unmap+0x124>
ffffffffea814fb0:	17ffffee 	b	ffffffffea814f68 <uthread_unmap+0x138>
			if (item) {
ffffffffea814fb4:	f100603f 	cmp	x1, #0x18
ffffffffea814fb8:	54fffd40 	b.eq	ffffffffea814f60 <uthread_unmap+0x130>  // b.none
				ut->ns_va_bottom = ROUNDDOWN(item->vaddr,
ffffffffea814fbc:	f85e8022 	ldur	x2, [x1, #-24]
ffffffffea814fc0:	926cac42 	and	x2, x2, #0xfffffffffff00000
ffffffffea814fc4:	f90032a2 	str	x2, [x21, #96]
ffffffffea814fc8:	17ffffe8 	b	ffffffffea814f68 <uthread_unmap+0x138>
		err = ERR_INVALID_ARGS;
ffffffffea814fcc:	128000f7 	mov	w23, #0xfffffff8            	// #-8
ffffffffea814fd0:	17ffffbb 	b	ffffffffea814ebc <uthread_unmap+0x8c>
ffffffffea814fd4:	00000000 	.inst	0x00000000 ; undefined

ffffffffea814fd8 <uthread_is_valid_range>:
{
ffffffffea814fd8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea814fdc:	910003fd 	mov	x29, sp
ffffffffea814fe0:	a9025bf5 	stp	x21, x22, [sp, #32]
	mutex_acquire(&ut->mmap_lock);
ffffffffea814fe4:	9100a016 	add	x22, x0, #0x28
{
ffffffffea814fe8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea814fec:	aa0003f5 	mov	x21, x0
ffffffffea814ff0:	aa0103f4 	mov	x20, x1
ffffffffea814ff4:	aa0203f3 	mov	x19, x2
ffffffffea814ff8:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea814ffc:	aa1603e0 	mov	x0, x22
ffffffffea815000:	97ffc222 	bl	ffffffffea805888 <mutex_acquire_timeout>
	if (vaddr + size < vaddr) {
ffffffffea815004:	8b130282 	add	x2, x20, x19
ffffffffea815008:	eb02029f 	cmp	x20, x2
ffffffffea81500c:	54000288 	b.hi	ffffffffea81505c <uthread_is_valid_range+0x84>  // b.pmore
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea815010:	f94012a1 	ldr	x1, [x21, #32]
ffffffffea815014:	d1006021 	sub	x1, x1, #0x18
ffffffffea815018:	eb0102bf 	cmp	x21, x1
ffffffffea81501c:	54000200 	b.eq	ffffffffea81505c <uthread_is_valid_range+0x84>  // b.none
		if ((mp->vaddr <= vaddr) &&
ffffffffea815020:	f9400020 	ldr	x0, [x1]
ffffffffea815024:	eb00029f 	cmp	x20, x0
ffffffffea815028:	54000123 	b.cc	ffffffffea81504c <uthread_is_valid_range+0x74>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea81502c:	f9400423 	ldr	x3, [x1, #8]
ffffffffea815030:	8b030000 	add	x0, x0, x3
ffffffffea815034:	eb00005f 	cmp	x2, x0
ffffffffea815038:	1a9f87e3 	cset	w3, ls  // ls = plast
		if ((mp->vaddr <= vaddr) &&
ffffffffea81503c:	eb00029f 	cmp	x20, x0
ffffffffea815040:	1a9f27f3 	cset	w19, cc  // cc = lo, ul, last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea815044:	6a130073 	ands	w19, w3, w19
ffffffffea815048:	540000c1 	b.ne	ffffffffea815060 <uthread_is_valid_range+0x88>  // b.any
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea81504c:	f9401021 	ldr	x1, [x1, #32]
ffffffffea815050:	d1006021 	sub	x1, x1, #0x18
ffffffffea815054:	eb0102bf 	cmp	x21, x1
ffffffffea815058:	54fffe41 	b.ne	ffffffffea815020 <uthread_is_valid_range+0x48>  // b.any
ffffffffea81505c:	52800013 	mov	w19, #0x0                   	// #0
	mutex_release(&ut->mmap_lock);
ffffffffea815060:	aa1603e0 	mov	x0, x22
ffffffffea815064:	97ffc235 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea815068:	2a1303e0 	mov	w0, w19
ffffffffea81506c:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815070:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea815074:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea815078:	d65f03c0 	ret
ffffffffea81507c:	00000000 	.inst	0x00000000 ; undefined

ffffffffea815080 <uthread_virt_to_phys>:
{
ffffffffea815080:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffffffffea815084:	910003fd 	mov	x29, sp
ffffffffea815088:	a9025bf5 	stp	x21, x22, [sp, #32]
ffffffffea81508c:	aa0003f5 	mov	x21, x0
	mutex_acquire(&ut->mmap_lock);
ffffffffea815090:	9100a016 	add	x22, x0, #0x28
{
ffffffffea815094:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea815098:	aa1603e0 	mov	x0, x22
ffffffffea81509c:	aa0103f3 	mov	x19, x1
ffffffffea8150a0:	aa0203f4 	mov	x20, x2
ffffffffea8150a4:	12800001 	mov	w1, #0xffffffff            	// #-1
ffffffffea8150a8:	97ffc1f8 	bl	ffffffffea805888 <mutex_acquire_timeout>
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8150ac:	f94012a0 	ldr	x0, [x21, #32]
ffffffffea8150b0:	d1006000 	sub	x0, x0, #0x18
ffffffffea8150b4:	eb0002bf 	cmp	x21, x0
ffffffffea8150b8:	540001a0 	b.eq	ffffffffea8150ec <uthread_virt_to_phys+0x6c>  // b.none
ffffffffea8150bc:	d503201f 	nop
		if ((mp->vaddr <= vaddr) &&
ffffffffea8150c0:	f9400001 	ldr	x1, [x0]
ffffffffea8150c4:	eb01027f 	cmp	x19, x1
ffffffffea8150c8:	540000a3 	b.cc	ffffffffea8150dc <uthread_virt_to_phys+0x5c>  // b.lo, b.ul, b.last
		    (vaddr < mp->vaddr + mp->size) &&
ffffffffea8150cc:	f9400403 	ldr	x3, [x0, #8]
ffffffffea8150d0:	8b030023 	add	x3, x1, x3
		if ((mp->vaddr <= vaddr) &&
ffffffffea8150d4:	eb03027f 	cmp	x19, x3
ffffffffea8150d8:	540001a3 	b.cc	ffffffffea81510c <uthread_virt_to_phys+0x8c>  // b.lo, b.ul, b.last
	list_for_every_entry(&ut->map_list, mp, uthread_map_t, node) {
ffffffffea8150dc:	f9401000 	ldr	x0, [x0, #32]
ffffffffea8150e0:	d1006000 	sub	x0, x0, #0x18
ffffffffea8150e4:	eb0002bf 	cmp	x21, x0
ffffffffea8150e8:	54fffec1 	b.ne	ffffffffea8150c0 <uthread_virt_to_phys+0x40>  // b.any
		err = ERR_INVALID_ARGS;
ffffffffea8150ec:	128000f5 	mov	w21, #0xfffffff8            	// #-8
	mutex_release(&ut->mmap_lock);
ffffffffea8150f0:	aa1603e0 	mov	x0, x22
ffffffffea8150f4:	97ffc211 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea8150f8:	2a1503e0 	mov	w0, w21
ffffffffea8150fc:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815100:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea815104:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea815108:	d65f03c0 	ret
	if (mp->flags & UTM_PHYS_CONTIG) {
ffffffffea81510c:	b9401002 	ldr	w2, [x0, #16]
ffffffffea815110:	37280202 	tbnz	w2, #5, ffffffffea815150 <uthread_virt_to_phys+0xd0>
		uint32_t pg = (vaddr - mp->vaddr) / PAGE_SIZE;
ffffffffea815114:	cb010261 	sub	x1, x19, x1
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea815118:	92402e73 	and	x19, x19, #0xfff
	err = NO_ERROR;
ffffffffea81511c:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[pg] + offset;
ffffffffea815120:	d34cac21 	ubfx	x1, x1, #12, #32
ffffffffea815124:	8b010c00 	add	x0, x0, x1, lsl #3
ffffffffea815128:	f9401400 	ldr	x0, [x0, #40]
ffffffffea81512c:	8b130013 	add	x19, x0, x19
ffffffffea815130:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea815134:	aa1603e0 	mov	x0, x22
ffffffffea815138:	97ffc200 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea81513c:	2a1503e0 	mov	w0, w21
ffffffffea815140:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815144:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea815148:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81514c:	d65f03c0 	ret
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea815150:	f9401400 	ldr	x0, [x0, #40]
	err = NO_ERROR;
ffffffffea815154:	52800015 	mov	w21, #0x0                   	// #0
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea815158:	cb010001 	sub	x1, x0, x1
	mutex_release(&ut->mmap_lock);
ffffffffea81515c:	aa1603e0 	mov	x0, x22
		*paddr = mp->pfn_list[0] + (vaddr - mp->vaddr);
ffffffffea815160:	8b130033 	add	x19, x1, x19
ffffffffea815164:	f9000293 	str	x19, [x20]
	mutex_release(&ut->mmap_lock);
ffffffffea815168:	97ffc1f4 	bl	ffffffffea805938 <mutex_release>
}
ffffffffea81516c:	2a1503e0 	mov	w0, w21
ffffffffea815170:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815174:	a9425bf5 	ldp	x21, x22, [sp, #32]
ffffffffea815178:	a8c37bfd 	ldp	x29, x30, [sp], #48
ffffffffea81517c:	d65f03c0 	ret

ffffffffea815180 <arch_uthread_init>:

#define USER_PAGE_MASK	(USER_PAGE_SIZE - 1)

void arch_uthread_init(void)
{
}
ffffffffea815180:	d65f03c0 	ret
ffffffffea815184:	00000000 	.inst	0x00000000 ; undefined

ffffffffea815188 <arch_uthread_startup>:
    return (struct thread *)ARM64_READ_SYSREG(tpidr_el1);
ffffffffea815188:	d538d080 	mrs	x0, tpidr_el1

void arch_uthread_startup(void)
{
	struct uthread *ut = (struct uthread *) tls_get(TLS_ENTRY_UTHREAD);
ffffffffea81518c:	f9415800 	ldr	x0, [x0, #688]
	register uint64_t sp_usr asm("x2") = ROUNDDOWN(ut->start_stack, 8);
ffffffffea815190:	a9400c02 	ldp	x2, x3, [x0]
ffffffffea815194:	927df042 	and	x2, x2, #0xfffffffffffffff8
    __asm__ volatile("msr daifset, #2" ::: "memory");
ffffffffea815198:	d50342df 	msr	daifset, #0x2
	register uint64_t entry asm("x3") = ut->entry;

	arch_disable_ints();
	__asm__ volatile(
ffffffffea81519c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea8151a0:	d2800001 	mov	x1, #0x0                   	// #0
ffffffffea8151a4:	aa0203ed 	mov	x13, x2
ffffffffea8151a8:	aa0303ee 	mov	x14, x3
ffffffffea8151ac:	d2800209 	mov	x9, #0x10                  	// #16
ffffffffea8151b0:	d5184009 	msr	spsr_el1, x9
ffffffffea8151b4:	d5184023 	msr	elr_el1, x3
ffffffffea8151b8:	d69f03e0 	eret
ffffffffea8151bc:	d503379f 	dsb	nsh
ffffffffea8151c0:	d5033fdf 	isb
		"isb\n"
		:
		: [stack]"r" (sp_usr), [entry]"r" (entry)
		: "x0", "x1", "memory"
	);
}
ffffffffea8151c4:	d65f03c0 	ret

ffffffffea8151c8 <arch_uthread_context_switch>:

void arch_uthread_context_switch(struct uthread *old_ut, struct uthread *new_ut)
{
	paddr_t pgd;

	if (old_ut && !new_ut) {
ffffffffea8151c8:	f100001f 	cmp	x0, #0x0
ffffffffea8151cc:	fa401820 	ccmp	x1, #0x0, #0x0, ne  // ne = any
ffffffffea8151d0:	540000e1 	b.ne	ffffffffea8151ec <arch_uthread_context_switch+0x24>  // b.any
		ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_KERNEL);
ffffffffea8151d4:	d286b4e0 	mov	x0, #0x35a7                	// #13735
ffffffffea8151d8:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea8151dc:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea8151e0:	d5182040 	msr	tcr_el1, x0
ffffffffea8151e4:	d5033fdf 	isb
ffffffffea8151e8:	d65f03c0 	ret
	}

	if (new_ut) {
ffffffffea8151ec:	b4000301 	cbz	x1, ffffffffea81524c <arch_uthread_context_switch+0x84>
{
ffffffffea8151f0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
ffffffffea8151f4:	910003fd 	mov	x29, sp
ffffffffea8151f8:	a90153f3 	stp	x19, x20, [sp, #16]
ffffffffea8151fc:	aa0003f4 	mov	x20, x0
ffffffffea815200:	f9403820 	ldr	x0, [x1, #112]
ffffffffea815204:	aa0103f3 	mov	x19, x1
ffffffffea815208:	97fff12a 	bl	ffffffffea8116b0 <kvaddr_to_paddr>
		pgd = vaddr_to_paddr(new_ut->page_table);
		ARM64_WRITE_SYSREG(ttbr0_el1, (paddr_t)new_ut->arch.asid << 48 | pgd);
ffffffffea81520c:	b9409a61 	ldr	w1, [x19, #152]
ffffffffea815210:	aa01c000 	orr	x0, x0, x1, lsl #48
ffffffffea815214:	d5182000 	msr	ttbr0_el1, x0
ffffffffea815218:	d5033fdf 	isb
		if (!old_ut)
ffffffffea81521c:	b4000094 	cbz	x20, ffffffffea81522c <arch_uthread_context_switch+0x64>
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
	}
}
ffffffffea815220:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815224:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea815228:	d65f03c0 	ret
			ARM64_WRITE_SYSREG(tcr_el1, MMU_TCR_FLAGS_USER);
ffffffffea81522c:	d286a4e0 	mov	x0, #0x3527                	// #13607
ffffffffea815230:	f2b6a460 	movk	x0, #0xb523, lsl #16
ffffffffea815234:	f2c00040 	movk	x0, #0x2, lsl #32
ffffffffea815238:	d5182040 	msr	tcr_el1, x0
ffffffffea81523c:	d5033fdf 	isb
}
ffffffffea815240:	a94153f3 	ldp	x19, x20, [sp, #16]
ffffffffea815244:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea815248:	d65f03c0 	ret
ffffffffea81524c:	d65f03c0 	ret

ffffffffea815250 <arch_uthread_create>:

status_t arch_uthread_create(struct uthread *ut)
{
ffffffffea815250:	aa0003e1 	mov	x1, x0

	ut->arch.asid = ut->id;
	ut->arch.uthread = ut;

	return err;
}
ffffffffea815254:	52800000 	mov	w0, #0x0                   	// #0
	ut->arch.asid = ut->id;
ffffffffea815258:	b9406822 	ldr	w2, [x1, #104]
ffffffffea81525c:	b9009822 	str	w2, [x1, #152]
	ut->arch.uthread = ut;
ffffffffea815260:	f9005021 	str	x1, [x1, #160]
}
ffffffffea815264:	d65f03c0 	ret

ffffffffea815268 <arch_uthread_free>:

void arch_uthread_free(struct uthread *ut)
{
ffffffffea815268:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea81526c:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea815270:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea815274:	52800323 	mov	w3, #0x19                  	// #25
{
ffffffffea815278:	910003fd 	mov	x29, sp
ffffffffea81527c:	f9000bf3 	str	x19, [sp, #16]
ffffffffea815280:	aa0003f3 	mov	x19, x0
	arm64_mmu_unmap(0, 1UL << MMU_USER_SIZE_SHIFT,
ffffffffea815284:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea815288:	d2a04001 	mov	x1, #0x2000000             	// #33554432
ffffffffea81528c:	d2800000 	mov	x0, #0x0                   	// #0
ffffffffea815290:	b9409a67 	ldr	w7, [x19, #152]
ffffffffea815294:	f9403a66 	ldr	x6, [x19, #112]
ffffffffea815298:	97ffba1a 	bl	ffffffffea803b00 <arm64_mmu_unmap>
	                0, MMU_USER_SIZE_SHIFT,
	                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
	                ut->page_table, ut->arch.asid);

	free(ut->page_table);
ffffffffea81529c:	f9403a60 	ldr	x0, [x19, #112]
}
ffffffffea8152a0:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8152a4:	a8c27bfd 	ldp	x29, x30, [sp], #32
	free(ut->page_table);
ffffffffea8152a8:	17fffac6 	b	ffffffffea813dc0 <free>
ffffffffea8152ac:	00000000 	.inst	0x00000000 ; undefined

ffffffffea8152b0 <arm64_uthread_allocate_page_table>:

status_t arm64_uthread_allocate_page_table(struct uthread *ut)
{
ffffffffea8152b0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
	size_t page_table_size;

	page_table_size = MMU_USER_PAGE_TABLE_ENTRIES_TOP * sizeof(pte_t);

	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea8152b4:	d2801001 	mov	x1, #0x80                  	// #128
{
ffffffffea8152b8:	910003fd 	mov	x29, sp
ffffffffea8152bc:	f9000bf3 	str	x19, [sp, #16]
ffffffffea8152c0:	aa0003f3 	mov	x19, x0
	ut->page_table = memalign(page_table_size, page_table_size);
ffffffffea8152c4:	aa0103e0 	mov	x0, x1
ffffffffea8152c8:	97fffaaa 	bl	ffffffffea813d70 <memalign>
ffffffffea8152cc:	f9003a60 	str	x0, [x19, #112]
	if (!ut->page_table) {
ffffffffea8152d0:	b4000100 	cbz	x0, ffffffffea8152f0 <arm64_uthread_allocate_page_table+0x40>
		return ERR_NO_MEMORY;
	}
	memset(ut->page_table, 0, page_table_size);
ffffffffea8152d4:	d2801002 	mov	x2, #0x80                  	// #128
ffffffffea8152d8:	52800001 	mov	w1, #0x0                   	// #0
ffffffffea8152dc:	97fffb77 	bl	ffffffffea8140b8 <memset>

	LTRACEF("id %d, user page table %p, size %ld\n",
	        ut->id, ut->page_table, page_table_size);

	return NO_ERROR;
ffffffffea8152e0:	52800000 	mov	w0, #0x0                   	// #0
}
ffffffffea8152e4:	f9400bf3 	ldr	x19, [sp, #16]
ffffffffea8152e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
ffffffffea8152ec:	d65f03c0 	ret
		return ERR_NO_MEMORY;
ffffffffea8152f0:	12800080 	mov	w0, #0xfffffffb            	// #-5
ffffffffea8152f4:	17fffffc 	b	ffffffffea8152e4 <arm64_uthread_allocate_page_table+0x34>

ffffffffea8152f8 <arch_uthread_map>:

status_t arch_uthread_map(struct uthread *ut, struct uthread_map *mp)
{
ffffffffea8152f8:	d101c3ff 	sub	sp, sp, #0x70
ffffffffea8152fc:	a9017bfd 	stp	x29, x30, [sp, #16]
ffffffffea815300:	910043fd 	add	x29, sp, #0x10
ffffffffea815304:	f9001ff6 	str	x22, [sp, #56]
ffffffffea815308:	aa0103f6 	mov	x22, x1
	paddr_t pg, pte_attr;
	size_t entry_size;
	status_t err = NO_ERROR;

	if (!ut->page_table) {
ffffffffea81530c:	f9403801 	ldr	x1, [x0, #112]
{
ffffffffea815310:	a902d7f4 	stp	x20, x21, [sp, #40]
ffffffffea815314:	aa0003f5 	mov	x21, x0
ffffffffea815318:	f90033fb 	str	x27, [sp, #96]
ffffffffea81531c:	aa1e03f4 	mov	x20, x30
	if (!ut->page_table) {
ffffffffea815320:	b4000de1 	cbz	x1, ffffffffea8154dc <arch_uthread_map+0x1e4>
ffffffffea815324:	f9000bb3 	str	x19, [x29, #16]
ffffffffea815328:	f90027ba 	str	x26, [x29, #72]
		if (err) {
			return err;
		}
	}

	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea81532c:	f94006d3 	ldr	x19, [x22, #8]
ffffffffea815330:	f2402e7a 	ands	x26, x19, #0xfff
ffffffffea815334:	54000dc1 	b.ne	ffffffffea8154ec <arch_uthread_map+0x1f4>  // b.any

	pte_attr = MMU_PTE_ATTR_NON_GLOBAL | MMU_PTE_ATTR_AF;

	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea815338:	b94012c1 	ldr	w1, [x22, #16]

	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81533c:	d2801802 	mov	x2, #0xc0                  	// #192
ffffffffea815340:	f90023b9 	str	x25, [x29, #64]
ffffffffea815344:	d2800819 	mov	x25, #0x40                  	// #64
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea815348:	53017c20 	lsr	w0, w1, #1
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81534c:	f27f003f 	tst	x1, #0x2
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea815350:	121b0000 	and	w0, w0, #0x20
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea815354:	9a821339 	csel	x25, x25, x2, ne  // ne = any
	pte_attr |= (mp->flags & UTM_NS_MEM) ? MMU_PTE_ATTR_NON_SECURE : 0;
ffffffffea815358:	32160400 	orr	w0, w0, #0xc00
	pte_attr |= (mp->flags & UTM_W) ? MMU_PTE_ATTR_AP_P_RW_U_RW :
ffffffffea81535c:	aa000339 	orr	x25, x25, x0
	 * is not speculatively prefeched as an instruction,
	 * these mappings should always be tagged as execute-never.
	 *
	 * The code block below always asserts this
	 */
	if (mp->flags & UTM_IO) {
ffffffffea815360:	36380841 	tbz	w1, #7, ffffffffea815468 <arch_uthread_map+0x170>
		pte_attr |= MMU_PTE_ATTR_STRONGLY_ORDERED;
		/* Explictly check that IO mem is not tagged as executable */
		ASSERT(!(mp->flags & UTM_X));
ffffffffea815364:	37100da1 	tbnz	w1, #2, ffffffffea815518 <arch_uthread_map+0x220>

	/*
	 * Mark execute-never unless explicitly flagged as UTM_X.
	 * Mark NS memory as execute-never always.
	 */
	if ( !(mp->flags & UTM_X) || (mp->flags & UTM_NS_MEM) )
ffffffffea815368:	52800880 	mov	w0, #0x44                  	// #68
ffffffffea81536c:	0a000020 	and	w0, w1, w0
	    pte_attr |= (MMU_PTE_ATTR_UXN | MMU_PTE_ATTR_PXN);
ffffffffea815370:	7100101f 	cmp	w0, #0x4
ffffffffea815374:	b24b0720 	orr	x0, x25, #0x60000000000000
ffffffffea815378:	9a991019 	csel	x25, x0, x25, ne  // ne = any

	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea81537c:	37280a61 	tbnz	w1, #5, ffffffffea8154c8 <arch_uthread_map+0x1d0>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea815380:	f13ffe7f 	cmp	x19, #0xfff
ffffffffea815384:	540008e9 	b.ls	ffffffffea8154a0 <arch_uthread_map+0x1a8>  // b.plast
ffffffffea815388:	a90363b7 	stp	x23, x24, [x29, #48]
	entry_size = (mp->flags & UTM_PHYS_CONTIG) ? mp->size : USER_PAGE_SIZE;
ffffffffea81538c:	d2820013 	mov	x19, #0x1000                	// #4096
ffffffffea815390:	9100a2d8 	add	x24, x22, #0x28
ffffffffea815394:	d2800017 	mov	x23, #0x0                   	// #0
ffffffffea815398:	d2800014 	mov	x20, #0x0                   	// #0
ffffffffea81539c:	14000008 	b	ffffffffea8153bc <arch_uthread_map+0xc4>
	for (pg = 0; pg < (mp->size / entry_size); pg++) {
ffffffffea8153a0:	f94006c0 	ldr	x0, [x22, #8]
ffffffffea8153a4:	91000694 	add	x20, x20, #0x1
ffffffffea8153a8:	8b1302f7 	add	x23, x23, x19
ffffffffea8153ac:	91002318 	add	x24, x24, #0x8
ffffffffea8153b0:	9ad30800 	udiv	x0, x0, x19
ffffffffea8153b4:	eb14001f 	cmp	x0, x20
ffffffffea8153b8:	54000729 	b.ls	ffffffffea81549c <arch_uthread_map+0x1a4>  // b.plast
		err = arm64_mmu_map(mp->vaddr + pg * entry_size,
ffffffffea8153bc:	f9400301 	ldr	x1, [x24]
ffffffffea8153c0:	52800187 	mov	w7, #0xc                   	// #12
ffffffffea8153c4:	b9409aa2 	ldr	w2, [x21, #152]
ffffffffea8153c8:	528002a6 	mov	w6, #0x15                  	// #21
ffffffffea8153cc:	f9403aa3 	ldr	x3, [x21, #112]
ffffffffea8153d0:	52800325 	mov	w5, #0x19                  	// #25
ffffffffea8153d4:	f94002c0 	ldr	x0, [x22]
ffffffffea8153d8:	d2800004 	mov	x4, #0x0                   	// #0
ffffffffea8153dc:	f90003e3 	str	x3, [sp]
ffffffffea8153e0:	aa1903e3 	mov	x3, x25
ffffffffea8153e4:	b9000be2 	str	w2, [sp, #8]
ffffffffea8153e8:	8b0002e0 	add	x0, x23, x0
ffffffffea8153ec:	aa1303e2 	mov	x2, x19
ffffffffea8153f0:	97ffb996 	bl	ffffffffea803a48 <arm64_mmu_map>
ffffffffea8153f4:	2a0003fb 	mov	w27, w0
		                    mp->pfn_list[pg], entry_size, pte_attr,
		                    0, MMU_USER_SIZE_SHIFT, MMU_USER_TOP_SHIFT,
		                    MMU_USER_PAGE_SIZE_SHIFT,
		                    ut->page_table, ut->arch.asid);
		if (err) {
ffffffffea8153f8:	34fffd40 	cbz	w0, ffffffffea8153a0 <arch_uthread_map+0xa8>
	}

	return NO_ERROR;

err_undo_maps:
	for(u_int p = 0; p < pg; p++) {
ffffffffea8153fc:	52800017 	mov	w23, #0x0                   	// #0
ffffffffea815400:	b4000214 	cbz	x20, ffffffffea815440 <arch_uthread_map+0x148>
ffffffffea815404:	d503201f 	nop
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea815408:	f94002c0 	ldr	x0, [x22]
	for(u_int p = 0; p < pg; p++) {
ffffffffea81540c:	110006f7 	add	w23, w23, #0x1
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea815410:	b9409aa7 	ldr	w7, [x21, #152]
ffffffffea815414:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea815418:	f9403aa6 	ldr	x6, [x21, #112]
ffffffffea81541c:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea815420:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea815424:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea815428:	9b1a0260 	madd	x0, x19, x26, x0
ffffffffea81542c:	aa1303e1 	mov	x1, x19
	for(u_int p = 0; p < pg; p++) {
ffffffffea815430:	2a1703fa 	mov	w26, w23
		arm64_mmu_unmap(mp->vaddr + p * entry_size, entry_size,
ffffffffea815434:	97ffb9b3 	bl	ffffffffea803b00 <arm64_mmu_unmap>
	for(u_int p = 0; p < pg; p++) {
ffffffffea815438:	eb14035f 	cmp	x26, x20
ffffffffea81543c:	54fffe63 	b.cc	ffffffffea815408 <arch_uthread_map+0x110>  // b.lo, b.ul, b.last
ffffffffea815440:	f9400bb3 	ldr	x19, [x29, #16]
ffffffffea815444:	a94363b7 	ldp	x23, x24, [x29, #48]
ffffffffea815448:	a9446bb9 	ldp	x25, x26, [x29, #64]
		                MMU_USER_TOP_SHIFT, MMU_USER_PAGE_SIZE_SHIFT,
		                ut->page_table, ut->arch.asid);
	}

	return err;
}
ffffffffea81544c:	2a1b03e0 	mov	w0, w27
ffffffffea815450:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea815454:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea815458:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea81545c:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea815460:	9101c3ff 	add	sp, sp, #0x70
ffffffffea815464:	d65f03c0 	ret
	} else if (mp->flags & UTM_DEVICE) {
ffffffffea815468:	36480341 	tbz	w1, #9, ffffffffea8154d0 <arch_uthread_map+0x1d8>
		pte_attr |= MMU_PTE_ATTR_DEVICE;
ffffffffea81546c:	b27e0339 	orr	x25, x25, #0x4
		ASSERT(!(mp->flags & UTM_X));
ffffffffea815470:	3617f7c1 	tbz	w1, #2, ffffffffea815368 <arch_uthread_map+0x70>
ffffffffea815474:	f0000004 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea815478:	f0000002 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea81547c:	b0000001 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea815480:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea815484:	91246084 	add	x4, x4, #0x918
ffffffffea815488:	52801423 	mov	w3, #0xa1                  	// #161
ffffffffea81548c:	9123a042 	add	x2, x2, #0x8e8
ffffffffea815490:	91314021 	add	x1, x1, #0xc50
ffffffffea815494:	aa1403e0 	mov	x0, x20
ffffffffea815498:	97fff43a 	bl	ffffffffea812580 <_panic>
ffffffffea81549c:	a94363b7 	ldp	x23, x24, [x29, #48]
	return NO_ERROR;
ffffffffea8154a0:	5280001b 	mov	w27, #0x0                   	// #0
ffffffffea8154a4:	f9400bb3 	ldr	x19, [x29, #16]
}
ffffffffea8154a8:	2a1b03e0 	mov	w0, w27
ffffffffea8154ac:	a9446bb9 	ldp	x25, x26, [x29, #64]
ffffffffea8154b0:	a9417bfd 	ldp	x29, x30, [sp, #16]
ffffffffea8154b4:	a942d7f4 	ldp	x20, x21, [sp, #40]
ffffffffea8154b8:	f9401ff6 	ldr	x22, [sp, #56]
ffffffffea8154bc:	f94033fb 	ldr	x27, [sp, #96]
ffffffffea8154c0:	9101c3ff 	add	sp, sp, #0x70
ffffffffea8154c4:	d65f03c0 	ret
ffffffffea8154c8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8154cc:	17ffffb1 	b	ffffffffea815390 <arch_uthread_map+0x98>
		pte_attr |= MMU_PTE_ATTR_NORMAL_MEMORY;
ffffffffea8154d0:	d2806100 	mov	x0, #0x308                 	// #776
ffffffffea8154d4:	aa000339 	orr	x25, x25, x0
ffffffffea8154d8:	17ffffa4 	b	ffffffffea815368 <arch_uthread_map+0x70>
		err = arm64_uthread_allocate_page_table(ut);
ffffffffea8154dc:	97ffff75 	bl	ffffffffea8152b0 <arm64_uthread_allocate_page_table>
ffffffffea8154e0:	2a0003fb 	mov	w27, w0
		if (err) {
ffffffffea8154e4:	34fff200 	cbz	w0, ffffffffea815324 <arch_uthread_map+0x2c>
ffffffffea8154e8:	17ffffd9 	b	ffffffffea81544c <arch_uthread_map+0x154>
	ASSERT(!(mp->size & USER_PAGE_MASK));
ffffffffea8154ec:	f0000004 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8154f0:	f0000002 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea8154f4:	b0000001 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea8154f8:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea8154fc:	91232084 	add	x4, x4, #0x8c8
ffffffffea815500:	52801103 	mov	w3, #0x88                  	// #136
ffffffffea815504:	9123a042 	add	x2, x2, #0x8e8
ffffffffea815508:	91314021 	add	x1, x1, #0xc50
ffffffffea81550c:	aa1403e0 	mov	x0, x20
ffffffffea815510:	f90023b9 	str	x25, [x29, #64]
ffffffffea815514:	97fff41b 	bl	ffffffffea812580 <_panic>
		ASSERT(!(mp->flags & UTM_X));
ffffffffea815518:	f0000004 	adrp	x4, ffffffffea818000 <zero_uuid+0x8>
ffffffffea81551c:	f0000002 	adrp	x2, ffffffffea818000 <zero_uuid+0x8>
ffffffffea815520:	b0000001 	adrp	x1, ffffffffea816000 <__fault_handler_table_start>
ffffffffea815524:	a90363b7 	stp	x23, x24, [x29, #48]
ffffffffea815528:	91246084 	add	x4, x4, #0x918
ffffffffea81552c:	528013a3 	mov	w3, #0x9d                  	// #157
ffffffffea815530:	9123a042 	add	x2, x2, #0x8e8
ffffffffea815534:	91314021 	add	x1, x1, #0xc50
ffffffffea815538:	aa1403e0 	mov	x0, x20
ffffffffea81553c:	97fff411 	bl	ffffffffea812580 <_panic>

ffffffffea815540 <arch_uthread_unmap>:

status_t arch_uthread_unmap(struct uthread *ut, struct uthread_map *mp)
{
	return arm64_mmu_unmap(mp->vaddr, mp->size, 0, MMU_USER_SIZE_SHIFT,
ffffffffea815540:	b9409807 	ldr	w7, [x0, #152]
ffffffffea815544:	52800185 	mov	w5, #0xc                   	// #12
ffffffffea815548:	f9403806 	ldr	x6, [x0, #112]
ffffffffea81554c:	528002a4 	mov	w4, #0x15                  	// #21
ffffffffea815550:	a9400420 	ldp	x0, x1, [x1]
ffffffffea815554:	52800323 	mov	w3, #0x19                  	// #25
ffffffffea815558:	d2800002 	mov	x2, #0x0                   	// #0
ffffffffea81555c:	17ffb969 	b	ffffffffea803b00 <arm64_mmu_unmap>
